<?xml version="1.0" encoding="UTF-8"?>
<Symbol IsArchivable="no" IsPlaceable="no" MainGUID="2E2C73DA-3895-45DA-AD46-2D375D31F3AD" MigrationValue="Normal" Owner="1196638531" Signature="1196644685" Version="34">
<Ancestry SectVersion="1" SectionFlags="0" SubIdent="0" Template="no">
	<MainGUID>F938E33A-329D-4A36-BE3E-85E126820996</MainGUID>
	<MainGUID>103E8D2C-8230-42E1-9597-46F84CCE28C0</MainGUID>
	<MainGUID>6ACDA889-69B2-4EC5-936C-CB1DA7032A92</MainGUID>
</Ancestry>

<CalledMacros SectVersion="2" SectionFlags="0" SubIdent="0">
	<Macro>
		<MName><![CDATA["SizeCtrl_WMCC"]]></MName>
		<MainGUID>D3868793-9276-45DD-AADA-CEB1A1C2AFEC</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["Leaf_WMCC"]]></MName>
		<MainGUID>2E2C73DA-3895-45DA-AD46-2D375D31F3AD</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["Handle_WMCC"]]></MName>
		<MainGUID>4FDF529D-D957-495D-BD49-107836C4DD99</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["Profiles_WMCC"]]></MName>
		<MainGUID>E3B150F5-3A06-4C5A-85FA-D8C58B347069</MainGUID>
	</Macro>
</CalledMacros>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_3D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
!sphere 0.01 : lin_ 0,0,0, 0,1,0 : lin_ 0,0,0, 1,0,0 : lin_ 0,0,0, 0,0,1 : hotspot 0,0,0

resol iResolution
pen gs_pen_3D

sect_fill gs_fillLeaf, gs_penLeaf_bg, gs_penLeaf_fg, gs_leaf_pen_cont

!!!!!!**********************************************************************  Window Sashes Routines
!!!!!!**********************************************************************  Window Sashes Routines
!!!!!!**********************************************************************  Window Sashes Routines

!!!!!!**********************************************************************  Define Frame 

gosub OPTYPE_BASE + iOpeningType

if iOpeningType = DIVIDER_HORIZONTAL | iOpeningType = DIVIDER_VERTICAL then goto "endPos"

!!!!!!**********************************************************************  Define Glass Panels - MODELS
!!!!!!**********************************************************************  Define Glass Panels - MODELS
!!!!!!**********************************************************************  Define Glass Panels - MODELS

DelGlasTrans = 0

xform 	1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, -1, -zOffset

DelGlasTrans = DelGlasTrans + 1 
GlassLayers = vardim1(GlassThk)
if vardim2(GlassThk) = 5 then bExtendedGlassDefinition = 1 else bExtendedGlassDefinition = 0

if bExtendedGlassDefinition then 																							!extended Glasspanel definition, for panel doors
	mGlassTop		= mats[ GlassThk[vardim1(GlassThk)][GL_MATERIAL] ]
	mGlassBottom	= mats[ GlassThk[1][GL_MATERIAL] ]
	mGlassSide		= mats[ GlassThk[1][GL_MATERIAL] ]
else 
	mGlassTop		= mats[MAT_GLASS]
	mGlassBottom	= mats[MAT_GLASS]
	mGlassSide		= mats[MAT_GLASS]	
endif

if iDetLevel3D = DETLEVEL_3D_100 then
		material sMaterialS[MAT_GLASS]
		sect_fill fillType_glass, fillPenBg_glass, fillPenFg_glass, penCont_glass

		CPRISM_ mGlassTop, mGlassBottom, mGlassSide, 5, zGlassThk,															!Glazing
						OffsetGL + yGlazingBead,				OffsetGBot + yGlazingBead,	15,
			LeafBoxA -	OffsetGR - yGlazingBead,				OffsetGBot + yGlazingBead,	15,
			LeafBoxA -	OffsetGR - yGlazingBead,	LeafBoxB - 	OffsetGTop - yGlazingBead,	15,
						OffsetGL + yGlazingBead,	LeafBoxB - 	OffsetGTop - yGlazingBead,	15,
						OffsetGL + yGlazingBead,				OffsetGBot + yGlazingBead,	-1
endif

if	iDetLevel3D = DETLEVEL_3D_50 \
|	iDetLevel3D = DETLEVEL_3D_10 \
then
		material sMaterialS[MAT_GLASS]
		sect_fill fillType_glass, fillPenBg_glass, fillPenFg_glass, penCont_glass

		CPRISM_ mGlassTop, mGlassBottom, mGlassSide, 5, zGlassThk,															!Glazing
						OffsetGL,				OffsetGBot,	15,
			LeafBoxA -	OffsetGR,				OffsetGBot,	15,
			LeafBoxA -	OffsetGR,	LeafBoxB - 	OffsetGTop,	15,
						OffsetGL,	LeafBoxB - 	OffsetGTop,	15,
						OffsetGL,				OffsetGBot,	-1
endif

!!if	iDetLevel3D = DETLEVEL_3D_10 \
!!&	1 = 2 \
!!then
!!	for u=1 to GlassLayers
!!		if bExtendedGlassDefinition > EPS then 																				!extended Glasspanel definition
!!			glassOffset =  GlassThk[u][GL_OFFSET]
!!			MATERIAL mats[ GlassThk[u][GL_MATERIAL] ]
!!		else 
!!			glassOffset = 0
!!			material mats[MAT_GLASS]
!!		endif
!!	
!!		sect_fill fillType_glass, fillPenBg_glass, fillPenFg_glass, penCont_glass
!!
!!		PRISM_ 5, GlassThk[u][GL_THICKNESS],																				!Glazing
!!						OffsetGL + glassOffset,				OffsetGBot + glassOffset,	15,
!!			LeafBoxA -	OffsetGR - glassOffset,				OffsetGBot + glassOffset ,	15,
!!			LeafBoxA -	OffsetGR - glassOffset,	LeafBoxB -	OffsetGTop - glassOffset ,	15,
!!						OffsetGL + glassOffset,	LeafBoxB -	OffsetGTop - glassOffset ,	15,
!!						OffsetGL + glassOffset,				OffsetGBot + glassOffset ,	-1
!!		ADDz GlassThk[u][GL_THICKNESS]	: DelGlasTrans = DelGlasTrans+1
!!	
!!		if GlassThk[u][GL_AIRGAP] > EPS then
!!			if bExtendedGlassDefinition > EPS then glassOffset = max (GlassThk[u][GL_OFFSET], GlassThk[u+1][GL_OFFSET])
!!			MATERIAL mats[MAT_SEALANT]
!!			sect_fill fillType_sealant, fillPenBg_sealant, fillPenFg_sealant, penCont_sealant
!!	
!!			PRISM_ 10, GlassThk[u][GL_AIRGAP],																				!Spacer
!!							OffsetGL + glassOffset,							OffsetGBot + glassOffset,				15,
!!				LeafBoxA -	OffsetGR - glassOffset,							OffsetGBot + glassOffset,				15,
!!				LeafBoxA -	OffsetGR - glassOffset,				LeafBoxB -	OffsetGTop - glassOffset,				15,
!!							OffsetGL + glassOffset,				LeafBoxB -	OffsetGTop - glassOffset,				15,
!!							OffsetGL + glassOffset,							OffsetGBot + glassOffset,				-1,
!!		
!!							OffsetGL + glassOffset + zGum,				OffsetGBot + glassOffset + zGum,	15,
!!				LeafBoxA -	OffsetGR - glassOffset - zGum,				OffsetGBot + glassOffset + zGum,	15,
!!				LeafBoxA -	OffsetGR - glassOffset - zGum, LeafBoxB -	OffsetGTop - glassOffset - zGum,	15,
!!							OffsetGL + glassOffset + zGum,	LeafBoxB -	OffsetGTop - glassOffset - zGum,	15,
!!							OffsetGL + glassOffset + zGum,				OffsetGBot + glassOffset + zGum,	-1
!!		endif
!!		ADDz GlassThk[u][GL_AIRGAP]	: DelGlasTrans = DelGlasTrans+1
!!		next u
!!endif

DEL DelGlasTrans

!!!!!!**********************************************************************  Define Handles
!!!!!!**********************************************************************  Define Handles

!!!!!!**********************************************************************  OPENING LINES 
!!!!!!**********************************************************************  OPENING LINES 
!!!!!!**********************************************************************  OPENING LINES 

if or_bOplines3d then 
	PEN or_opLinePen
	zMax = gs_sash_thk + EPS
	zMin = zMin - EPS
!	!!print iDoorLeaf
!	
!	NotSliding = 1
!
!	if ABS(or_gs_opline_style_m-2)<EPS  and NotSliding then 
!		ADDx LeafBoxA
!		MULx -1	
!	endif

	if iOpeningType = OPTYPE_FIXED then
		or_iOpLineType3d = or_iOpLineType3dOut
		dx1 = OffsetGR	: dy1 = OffsetGBot				: dz1 = -zMax	: dx2 = LeafBoxA - OffsetGR	: dy2 = LeafBoxB - OffsetGTop	: dz2 = -zMax
		gosub "LineTypeDefiner"

		or_iOpLineType3d = or_iOpLineType3dIn
		dx1 = OffsetGR	: dy1 = OffsetGBot				: dz1 =  zMin	: dx2 = LeafBoxA - OffsetGR	: dy2 = LeafBoxB - OffsetGTop	: dz2 =  zMin
		gosub "LineTypeDefiner"
	endif

	if  iOpeningType = OPTYPE_SIDE_HUNG \
	|	iOpeningType = DOUBLE_FIRST_SASH & bBottomHung = 0 \
	|	iOpeningType = DOUBLE_SECOND_SASH \
	|	iOpeningType = OPTYPE_DOOR \
	|	iOpeningType = DOUBLE_DOOR_FIRST_SASH \
	|	iOpeningType = DOUBLE_DOOR_SECOND_SASH \
	|	iOpeningType = DOUBLE_ZT_DOOR_FIRST_SASH \
	|	iOpeningType = DOUBLE_ZT_DOOR_SECOND_SASH \
	|	iOpeningType = OPTYPE_COMBI_DOOR \
	|	iOpeningType = SLIDING_FOLDING_FIRST_SASH \
	|	iOpeningType = SLIDING_FOLDING_SECOND_SASH \

	|	iOpeningType = 	OPTYPE_WINDOW_DOOR \
	|	iOpeningType = 	OPTYPE_WINDOW_DOUBLE_DOOR \
	then
		or_iOpLineType3d = or_iOpLineType3dOut
		dx1 = OffsetGR	: dy1 = OffsetGBot				: dz1 = -zMax	: dx2 = LeafBoxA - OffsetGR	: dy2 = LeafBoxB / 2	: dz2 = -zMax
		gosub "LineTypeDefiner"
		dx1 = OffsetGR : dy1 = LeafBoxB - OffsetGTop	: dz1 = -zMax	: dx2 = LeafBoxA - OffsetGR : dy2 = LeafBoxB / 2	: dz2 = -zMax
		gosub "LineTypeDefiner"
	
		or_iOpLineType3d = or_iOpLineType3dIn
		dx1 = OffsetGR	: dy1 = OffsetGBot				: dz1 =  zMin	: dx2 = LeafBoxA - OffsetGR	: dy2 = LeafBoxB / 2	: dz2 =  zMin
		gosub "LineTypeDefiner"
		dx1 = OffsetGR : dy1 = LeafBoxB - OffsetGTop	: dz1 =  zMin	: dx2 = LeafBoxA - OffsetGR	: dy2 = LeafBoxB / 2	: dz2 =  zMin
		gosub "LineTypeDefiner"
	endif

	if  iOpeningType = OPTYPE_OUTWARDS \
	|	iOpeningType = DOUBLE_OUTWARDS_FIRST_SASH \
	|	iOpeningType = DOUBLE_OUTWARDS_SECOND_SASH \
	|	iOpeningType = OPTYPE_DOOR_OUTWARDS \
	|	iOpeningType = DOUBLE_DOOR_OUTWARDS_FIRST_SASH \
	|	iOpeningType = DOUBLE_DOOR_OUTWARDS_SECOND_SASH \
	|	iOpeningType = DOUBLE_ZT_DOOR_OUTWARDS_FIRST_SASH \
	|	iOpeningType = DOUBLE_ZT_DOOR_OUTWARDS_SECOND_SASH \
	|	iOpeningType = OPTYPE_COMBI_DOOR_OUTWARDS \

	|	iOpeningType = 	OPTYPE_WINDOW_DOOR_OUTWARDS	\
	|	iOpeningType = 	OPTYPE_WINDOW_DOUBLE_DOOR_OUTWARDS \
	then
		or_iOpLineType3d = or_iOpLineType3dIn
		dx1 = OffsetGR	: dy1 = OffsetGBot				: dz1 = -zMax	: dx2 = LeafBoxA - OffsetGR	: dy2 = LeafBoxB / 2				: dz2 = -zMax
		gosub "LineTypeDefiner"
		dx1 = OffsetGR : dy1 = LeafBoxB - OffsetGTop	: dz1 = -zMax	: dx2 = LeafBoxA - OffsetGR : dy2 = LeafBoxB / 2				: dz2 = -zMax
		gosub "LineTypeDefiner"

		or_iOpLineType3d = or_iOpLineType3dOut
		dx1 = OffsetGR : dy1 = OffsetGBot 				: dz1 =  zMin	: dx2 = LeafBoxA - OffsetGR	: dy2 = LeafBoxB / 2				: dz2 =  zMin
		gosub "LineTypeDefiner"
		dx1 = OffsetGR : dy1 = LeafBoxB - OffsetGTop	: dz1 =  zMin	: dx2 = LeafBoxA - OffsetGR : dy2 = LeafBoxB / 2				: dz2 =  zMin
		gosub "LineTypeDefiner"
	endif

	if  iOpeningType = OPTYPE_TILT_TURN \
	|	iOpeningType = DOUBLE_FIRST_SASH & bBottomHung = 1 \
	then
		or_iOpLineType3d = or_iOpLineType3dOut
		dx1 = OffsetGR	: dy1 = OffsetGBot 				: dz1 = -zMax	: dx2 = LeafBoxA - OffsetGR	: dy2 = LeafBoxB / 2				: dz2 = -zMax
		gosub "LineTypeDefiner"
		dx1 = OffsetGR	: dy1 = LeafBoxB - OffsetGTop	: dz1 = -zMax	: dx2 = LeafBoxA - OffsetGR	: dy2 = LeafBoxB / 2				: dz2 = -zMax
		gosub "LineTypeDefiner"
	
		or_iOpLineType3d = or_iOpLineType3dIn
		dx1 = OffsetGR : dy1 = OffsetGBot				: dz1 =  zMin	: dx2 = LeafBoxA - OffsetGR	: dy2 = LeafBoxB / 2				: dz2 =  zMin
		gosub "LineTypeDefiner"
		dx1 = OffsetGR : dy1 = LeafBoxB - OffsetGTop	: dz1 =  zMin	: dx2 = LeafBoxA - OffsetGR : dy2 = LeafBoxB / 2				: dz2 =  zMin
		gosub "LineTypeDefiner"

		or_iOpLineType3d = or_iOpLineType3dOut
		dx1 = OffsetGR				: dy1 = OffsetGBot	: dz1 = -zMax	: dx2 = LeafBoxA / 2		: dy2 = LeafBoxB					: dz2 = -zMax
		gosub "LineTypeDefiner"
		dx1 = LeafBoxA - OffsetGR	: dy1 = OffsetGBot	: dz1 = -zMax	: dx2 = LeafBoxA / 2		: dy2 = LeafBoxB					: dz2 = -zMax
		gosub "LineTypeDefiner"

		or_iOpLineType3d = or_iOpLineType3dIn
		dx1 = OffsetGR 				: dy1 = OffsetGBot	: dz1 =  zMin	: dx2 = LeafBoxA / 2 		: dy2 = LeafBoxB					: dz2 = zMin
		gosub "LineTypeDefiner"
		dx1 = LeafBoxA - OffsetGR	: dy1 = OffsetGBot	: dz1 =  zMin	: dx2 = LeafBoxA / 2		: dy2 = LeafBoxB					: dz2 = zMin
		gosub "LineTypeDefiner"
	endif

	if  iOpeningType = OPTYPE_BOTTOM_HUNG \
	|	iOpeningType = OPTYPE_UPPER_VENT \
	then
		or_iOpLineType3d = or_iOpLineType3dOut
		dx1 = OffsetGR				: dy1 = OffsetGBot	: dz1 = -zMax	: dx2 = LeafBoxA / 2		: dy2 = LeafBoxB - OffsetGTop		: dz2 = -zMax
		gosub "LineTypeDefiner"
		dx1 = LeafBoxA - OffsetGR	: dy1 = OffsetGBot  : dz1 = -zMax	: dx2 = LeafBoxA / 2		: dy2 = LeafBoxB - OffsetGTop		: dz2 = -zMax
		gosub "LineTypeDefiner"

		or_iOpLineType3d = or_iOpLineType3dIn
		dx1 = OffsetGR				: dy1 = OffsetGBot  : dz1 =  zMin	: dx2 = LeafBoxA / 2		: dy2 = LeafBoxB - OffsetGTop		: dz2 =  zMin
		gosub "LineTypeDefiner"
		dx1 = LeafBoxA - OffsetGR	: dy1 = OffsetGBot  : dz1 =  zMin	: dx2 = LeafBoxA / 2		: dy2 = LeafBoxB - OffsetGTop		: dz2 =  zMin
		gosub "LineTypeDefiner"
	endif

	if  iOpeningType = OPTYPE_TOP_HUNG then
		or_iOpLineType3d = or_iOpLineType3dIn
		dx1 = OffsetGR				: dy1 = LeafBoxB - OffsetGTop	: dz1 = -zMax	: dx2 = LeafBoxA / 2		: dy2 = OffsetGBot		: dz2 = -zMax
		gosub "LineTypeDefiner"
		dx1 = LeafBoxA - OffsetGR	: dy1 = LeafBoxB - OffsetGTop	: dz1 = -zMax	: dx2 = LeafBoxA / 2		: dy2 = OffsetGBot		: dz2 = -zMax
		gosub "LineTypeDefiner"

		or_iOpLineType3d = or_iOpLineType3dOut
		dx1 = OffsetGR				: dy1 = LeafBoxB - OffsetGTop	: dz1 =  zMin	: dx2 = LeafBoxA / 2		: dy2 = OffsetGBot		: dz2 =  zMin
		gosub "LineTypeDefiner"
		dx1 = LeafBoxA - OffsetGR	: dy1 = LeafBoxB - OffsetGTop	: dz1 = zMin	: dx2 = LeafBoxA / 2		: dy2 = OffsetGBot		: dz2 =  zMin
		gosub "LineTypeDefiner"
	endif

	if  iOpeningType = OPTYPE_HOR_PIVOT then
		or_iOpLineType3d = or_iOpLineType3dOut
		dx1 = OffsetGR				: dy1 = LeafBoxB / 2	: dz1 = -zMax	: dx2 = LeafBoxA / 2	: dy2 = LeafBoxB - OffsetGTop		: dz2 = -zMax
		gosub "LineTypeDefiner"
		dx1 = LeafBoxA - OffsetGR	: dy1 = LeafBoxB / 2	: dz1 = -zMax	: dx2 = LeafBoxA / 2	: dy2 = LeafBoxB - OffsetGTop		: dz2 = -zMax
		gosub "LineTypeDefiner"

		or_iOpLineType3d = or_iOpLineType3dIn
		dx1 = OffsetGR				: dy1 = LeafBoxB / 2	: dz1 = -zMax	: dx2 = LeafBoxA / 2	: dy2 = OffsetGBot					: dz2 = -zMax
		gosub "LineTypeDefiner"
		dx1 = LeafBoxA - OffsetGR	: dy1 = LeafBoxB / 2	: dz1 = -zMax	: dx2 = LeafBoxA / 2	: dy2 = OffsetGBot					: dz2 = -zMax
		gosub "LineTypeDefiner"


		or_iOpLineType3d = or_iOpLineType3dIn
		dx1 = OffsetGR				: dy1 = LeafBoxB / 2	: dz1 =  zMin	: dx2 = LeafBoxA / 2	: dy2 = LeafBoxB - OffsetGTop		: dz2 =  zMin
		gosub "LineTypeDefiner"
		dx1 = LeafBoxA - OffsetGR	: dy1 = LeafBoxB / 2	: dz1 =  zMin	: dx2 = LeafBoxA / 2	: dy2 = LeafBoxB - OffsetGTop		: dz2 =  zMin
		gosub "LineTypeDefiner"

		or_iOpLineType3d = or_iOpLineType3dOut
		dx1 = OffsetGR				: dy1 = LeafBoxB / 2	: dz1 =  zMin	: dx2 = LeafBoxA / 2	: dy2 = OffsetGBot					: dz2 =  zMin
		gosub "LineTypeDefiner"
		dx1 = LeafBoxA - OffsetGR	: dy1 = LeafBoxB / 2	: dz1 =  zMin	: dx2 = LeafBoxA / 2	: dy2 = OffsetGBot					: dz2 =  zMin
		gosub "LineTypeDefiner"
	endif

	if  iOpeningType = OPTYPE_PIVOT_DOOR then
		or_iOpLineType3d = or_iOpLineType3dOut
		dx1 = OffsetGR				: dy1 = LeafBoxB / 2	: dz1 =  zMin	: dx2 = LeafBoxA * 0.2	: dy2 = LeafBoxB - OffsetGTop		: dz2 =  zMin
		gosub "LineTypeDefiner"
		dx1 = LeafBoxA - OffsetGR	: dy1 = LeafBoxB / 2	: dz1 =  zMin	: dx2 = LeafBoxA * 0.2	: dy2 = LeafBoxB - OffsetGTop		: dz2 =  zMin
		gosub "LineTypeDefiner"

		or_iOpLineType3d = or_iOpLineType3dIn
		dx1 = OffsetGR				: dy1 = LeafBoxB / 2	: dz1 =  zMin	: dx2 = LeafBoxA * 0.2	: dy2 = OffsetGBot					: dz2 =  zMin
		gosub "LineTypeDefiner"
		dx1 = LeafBoxA - OffsetGR	: dy1 = LeafBoxB / 2	: dz1 =  zMin	: dx2 = LeafBoxA * 0.2	: dy2 = OffsetGBot					: dz2 =  zMin
		gosub "LineTypeDefiner"


		or_iOpLineType3d = or_iOpLineType3dIn
		dx1 = OffsetGR				: dy1 = LeafBoxB / 2	: dz1 =  -zMax	: dx2 = LeafBoxA * 0.2	: dy2 = LeafBoxB - OffsetGTop		: dz2 =  -zMax
		gosub "LineTypeDefiner"
		dx1 = LeafBoxA - OffsetGR	: dy1 = LeafBoxB / 2	: dz1 =  -zMax	: dx2 = LeafBoxA * 0.2	: dy2 = LeafBoxB - OffsetGTop		: dz2 =  -zMax
		gosub "LineTypeDefiner"

		or_iOpLineType3d = or_iOpLineType3dOut
		dx1 = OffsetGR				: dy1 = LeafBoxB / 2	: dz1 =  -zMax	: dx2 = LeafBoxA * 0.2	: dy2 = OffsetGBottom				: dz2 =  -zMax
		gosub "LineTypeDefiner"
		dx1 = LeafBoxA - OffsetGR	: dy1 = LeafBoxB / 2	: dz1 =  -zMax	: dx2 = LeafBoxA * 0.2	: dy2 = OffsetGBottom				: dz2 =  -zMax
		gosub "LineTypeDefiner"
	endif

	if  iOpeningType = OPTYPE_PIVOT_DOOR_OUTWARDS then
		or_iOpLineType3d = or_iOpLineType3dOut
		dx1 = OffsetGR				: dy1 = LeafBoxB / 2	: dz1 = -zMax	: dx2 = LeafBoxA * 0.8	: dy2 = LeafBoxB - OffsetGTop		: dz2 = -zMax
		gosub "LineTypeDefiner"
		dx1 = LeafBoxA - OffsetGR	: dy1 = LeafBoxB / 2	: dz1 = -zMax	: dx2 = LeafBoxA * 0.8	: dy2 = LeafBoxB - OffsetGTop		: dz2 = -zMax
		gosub "LineTypeDefiner"

		or_iOpLineType3d = or_iOpLineType3dIn
		dx1 = OffsetGR				: dy1 = LeafBoxB / 2	: dz1 = -zMax	: dx2 = LeafBoxA * 0.8	: dy2 = OffsetGBottom				: dz2 = -zMax
		gosub "LineTypeDefiner"
		dx1 = LeafBoxA - OffsetGR	: dy1 = LeafBoxB / 2	: dz1 = -zMax	: dx2 = LeafBoxA * 0.8	: dy2 = OffsetGBottom				: dz2 = -zMax
		gosub "LineTypeDefiner"


		or_iOpLineType3d = or_iOpLineType3dIn
		dx1 = OffsetGR				: dy1 = LeafBoxB / 2	: dz1 =  zMin	: dx2 = LeafBoxA * 0.8	: dy2 = LeafBoxB - OffsetGTop		: dz2 =  zMin
		gosub "LineTypeDefiner"
		dx1 = LeafBoxA - OffsetGR	: dy1 = LeafBoxB / 2	: dz1 =  zMin	: dx2 = LeafBoxA * 0.8	: dy2 = LeafBoxB - OffsetGTop		: dz2 =  zMin
		gosub "LineTypeDefiner"

		or_iOpLineType3d = or_iOpLineType3dOut
		dx1 = OffsetGR				: dy1 = LeafBoxB / 2	: dz1 =  zMin	: dx2 = LeafBoxA * 0.8	: dy2 = OffsetGBottom				: dz2 =  zMin
		gosub "LineTypeDefiner"
		dx1 = LeafBoxA - OffsetGR	: dy1 = LeafBoxB / 2	: dz1 =  zMin	: dx2 = LeafBoxA * 0.8	: dy2 = OffsetGBottom				: dz2 =  zMin
		gosub "LineTypeDefiner"
	endif

	if  iOpeningType = OPTYPE_SIDE_HUNG_SLIDING then
		or_iOpLineType3d = or_iOpLineType3dIn
		dx1 = xSlide - leafDLeft	: dy1 = OffsetGBot				: dz1 = -zMax	: dx2 = LeafBoxA - OffsetGR	: dy2 = LeafBoxB / 2	: dz2 = -zMax
		gosub "LineTypeDefiner"
		dx1 = xSlide - leafDLeft	: dy1 = LeafBoxB - OffsetGTop	: dz1 = -zMax	: dx2 = LeafBoxA - OffsetGR : dy2 = LeafBoxB / 2	: dz2 = -zMax
		gosub "LineTypeDefiner"
		dx1 = xSlide - leafDLeft	: dy1 = LeafBoxB - OffsetGTop	: dz1 = -zMax	: dx2 = xSlide - leafDLeft	: dy2 = OffsetGBot		: dz2 = -zMax
		gosub "LineTypeDefiner"
	
		or_iOpLineType3d = or_iOpLineType3dOut
		dx1 = xSlide - leafDLeft	: dy1 = OffsetGBot				: dz1 =  zMin	: dx2 = LeafBoxA - OffsetGR	: dy2 = LeafBoxB / 2	: dz2 =  zMin
		gosub "LineTypeDefiner"
		dx1 = xSlide - leafDLeft	: dy1 = LeafBoxB - OffsetGTop	: dz1 =  zMin	: dx2 = LeafBoxA - OffsetGR	: dy2 = LeafBoxB / 2	: dz2 =  zMin
		gosub "LineTypeDefiner"
		or_iOpLineType3d = or_iOpLineType3dIn
		dx1 = xSlide - leafDLeft	: dy1 = LeafBoxB - OffsetGTop	: dz1 =  zMin	: dx2 = xSlide - leafDLeft	: dy2 = OffsetGBot		: dz2 =  zMin
		gosub "LineTypeDefiner"
	endif

	if  iOpeningType = OPTYPE_TOP_HUNG_SLIDING then
		or_iOpLineType3d = or_iOpLineType3dIn
		dx1 = OffsetGR				: dy1 = LeafBoxB - ySlide		: dz1 = -zMax	: dx2 = LeafBoxA / 2		: dy2 = OffsetGBot  		: dz2 = -zMax
		gosub "LineTypeDefiner"
		dx1 = LeafBoxA - OffsetGR	: dy1 = LeafBoxB - ySlide		: dz1 = -zMax	: dx2 = LeafBoxA / 2		: dy2 = OffsetGBot  		: dz2 = -zMax
		gosub "LineTypeDefiner"
		or_iOpLineType3d = or_iOpLineType3dIn
		dx1 = LeafBoxA - OffsetGR	: dy1 = LeafBoxB - ySlide		: dz1 = -zMax	: dx2 = OffsetGR			: dy2 = LeafBoxB - ySlide		: dz2 = -zMax
		gosub "LineTypeDefiner"
		dx1 = LeafBoxA - OffsetGR	: dy1 = LeafBoxB - ySlide		: dz1 = zMin	: dx2 = OffsetGR			: dy2 = LeafBoxB - ySlide		: dz2 =  zMin
		gosub "LineTypeDefiner"

		or_iOpLineType3d = or_iOpLineType3dOut
		dx1 = OffsetGR				: dy1 = LeafBoxB - ySlide		: dz1 =  zMin	: dx2 = LeafBoxA / 2		: dy2 = OffsetGBot  		: dz2 =  zMin
		gosub "LineTypeDefiner"
		dx1 = LeafBoxA - OffsetGR	: dy1 = LeafBoxB - ySlide		: dz1 = zMin	: dx2 = LeafBoxA / 2		: dy2 = OffsetGBot  		: dz2 =  zMin
		gosub "LineTypeDefiner"
	endif

	if  iOpeningType = OPTYPE_TILT_SLIDE \
	|	iOpeningType = DOUBLE_SLIDING_FIRST_SASH \
	|	iOpeningType = DOUBLE_SLIDING_SECOND_SASH \
	then
		or_iOpLineType3d = or_iOpLineType3dOut
		dx1 = LeafBoxA * 4 / 5		: dy1 = LeafBoxB / 2				: dz1 = -zMax	: dx2 = LeafBoxA * 1 / 5	: dy2 = LeafBoxB / 2		: dz2 = -zMax
		gosub "LineTypeDefiner"

		or_iOpLineType3d = or_iOpLineType3dOut
		dx1 = LeafBoxA * 4 / 5		: dy1 = LeafBoxB/2 - LeafBoxA/10	: dz1 = -zMax	: dx2 = LeafBoxA * 4 / 5	: dy2 = LeafBoxB / 2		: dz2 = -zMax
		gosub "LineTypeDefiner"

		or_iOpLineType3d = or_iOpLineType3dOut
		dx1 = LeafBoxA * 3 / 10		: dy1 = LeafBoxB/2 - LeafBoxA/10	: dz1 = -zMax	: dx2 = LeafBoxA * 1 / 5	: dy2 = LeafBoxB / 2		: dz2 = -zMax
		gosub "LineTypeDefiner"

		or_iOpLineType3d = or_iOpLineType3dOut
		dx1 = LeafBoxA * 3 / 10		: dy1 = LeafBoxB/2 + LeafBoxA/10	: dz1 = -zMax	: dx2 = LeafBoxA * 1 / 5	: dy2 = LeafBoxB / 2		: dz2 = -zMax
		gosub "LineTypeDefiner"
	endif

	if	iOpeningType = OPTYPE_UP_SLIDING \
	then
		or_iOpLineType3d = or_iOpLineType3dOut
		dx1 = LeafBoxA / 2					: dy1 = LeafBoxB * 4 / 5	: dz1 = -zMax	: dx2 = LeafBoxA / 2	: dy2 = LeafBoxB * 1 / 5		: dz2 = -zMax
		gosub "LineTypeDefiner"

		or_iOpLineType3d = or_iOpLineType3dOut
		dx1 = LeafBoxA/2 - LeafBoxB/10		: dy1 = LeafBoxB * 7 / 10	: dz1 = -zMax	: dx2 = LeafBoxA / 2	: dy2 = LeafBoxB * 8 / 10		: dz2 = -zMax
		gosub "LineTypeDefiner"

		or_iOpLineType3d = or_iOpLineType3dOut
		dx1 = LeafBoxA/2 + LeafBoxB/10		: dy1 = LeafBoxB * 7 / 10	: dz1 = -zMax	: dx2 = LeafBoxA / 2	: dy2 = LeafBoxB * 8 / 10		: dz2 = -zMax
		gosub "LineTypeDefiner"
	endif

	if	iOpeningType = OPTYPE_RIGHT_SLIDING \
	then
		or_iOpLineType3d = or_iOpLineType3dOut
		dx1 = LeafBoxA * 4 / 5		: dy1 = LeafBoxB / 2				: dz1 = -zMax	: dx2 = LeafBoxA * 1 / 5	: dy2 = LeafBoxB / 2		: dz2 = -zMax
		gosub "LineTypeDefiner"

		or_iOpLineType3d = or_iOpLineType3dOut
		dx1 = LeafBoxA * 7 / 10		: dy1 = LeafBoxB/2 - LeafBoxA/10	: dz1 = -zMax	: dx2 = LeafBoxA * 4 / 5	: dy2 = LeafBoxB / 2		: dz2 = -zMax
		gosub "LineTypeDefiner"

		or_iOpLineType3d = or_iOpLineType3dOut
		dx1 = LeafBoxA * 7 / 10		: dy1 = LeafBoxB/2 + LeafBoxA/10	: dz1 = -zMax	: dx2 = LeafBoxA * 4 / 5	: dy2 = LeafBoxB / 2		: dz2 = -zMax
		gosub "LineTypeDefiner"
	endif
endif

!!del 1

!!!!!==========================================================================  Stretching contstraints
!!!!!==========================================================================  Stretching contstraints
!TODO not working
!!if	 GLOB_CONTEXT = 23 \
!!&	(GLOB_MODPAR_NAME = "A" \
!!|	 GLOB_MODPAR_NAME = "B") \
!!then								!Display allowed sizes when stretching
!!	if maxW > EPS & maxW > EPS then
!!		lin_ minW,	minH,	0,	xMin,	minH,	0
!!		lin_ xMin,	minH,	0,	maxW,	yMin,	0
!!		lin_ maxW,	yMin,	0,	maxW,	yMax,	0
!!		lin_ maxW,	yMax,	0,	xMax,	maxH,	0
!!		lin_ xMax,	maxH,	0,	minW,	maxH,	0
!!		lin_ minW,	maxH,	0,	minW,	minH,	0
!!
!!!		hotspot minW,	minH,	0
!!!		hotspot xMin,	minH,	0
!!!		hotspot maxW,	yMin,	0
!!!		hotspot maxW,	yMax,	0
!!!		hotspot xMax,	maxH,	0
!!!		hotspot minW,	maxH,	0
!!
!!		crossSize = 0.25
!!
!!		lin_ LeafBoxA - crossSize,	LeafBoxB,				0,	LeafBoxA  + crossSize,	LeafBoxB,				0
!!		lin_ LeafBoxA,				LeafBoxB - crossSize,	0,	LeafBoxA,				LeafBoxB + crossSize,	0
!!		add LeafBoxA, LeafBoxB, 0
!!			circle crossSize / 2
!!			circle crossSize / 4
!!		del 1
!!	endif
!!endif


!!!!!==========================================================================  END
!!!!!==========================================================================  END

"endPos":

END	minW, minH, maxW, maxH, 
	xWarnMin, yWarnMin, xWarnMax, yWarnMax,
	Zone~, iMullionPointer, xMullionPos, UnID

!!!!!==========================================================================  END
!!!!!==========================================================================  END


!!!!!!*********************************************************** LINE TYPES

"LineTypeDefiner":
	!!!dx1 = 0 : dy1 = 0 : dz1 = 0 : dx2 = 1 : dy2 = 0 : dz2 = 0.8 	

!Countinuous
	if or_iOpLineType3d < EPS then 
		LIN_ dx1, dy1, dz1, dx2, dy2, dz2 
	endif

!Dashed	
	if ABS(or_iOpLineType3d - 1) < EPS then 
		MainLineLength = 0.1
		MainGap = 0.05
		Length2D = SQR((dx2- dx1)**2 + (dy2-dy1)**2)
		Length3D = SQR((Length2D)**2 + (dz2-dz1)**2)
		
		LineNum = MAX(1, INT((Length3D + MainGap) / (MainLineLength + MainGap)))

		dxfull = ((dx2-dx1)/LineNum) * (Length3D + MainGap) / Length3D
		dyfull = ((dy2-dy1)/LineNum) * (Length3D + MainGap) / Length3D
		dzfull = ((dz2-dz1)/LineNum) * (Length3D + MainGap) / Length3D

		dxline = ((dx2-dx1)/LineNum) * (Length3D + MainGap) / Length3D * (MainLineLength/(MainLineLength + MainGap))
		dyline = ((dy2-dy1)/LineNum) * (Length3D + MainGap) / Length3D * (MainLineLength/(MainLineLength + MainGap))
		dzline = ((dz2-dz1)/LineNum) * (Length3D + MainGap) / Length3D * (MainLineLength/(MainLineLength + MainGap))

		ADD dx1, dy1, dz1
			for LNum = 1 to LineNum
				ADD (LNum-1)*dxfull, (LNum-1)*dyfull, (LNum-1)*dzfull
					LIN_ 0, 0, 0, dxline, dyline, dzline
				DEL 1
			next LNum
		DEL 1
	endif

!--------------From this not reviewed yet----------------
	if ABS(or_iOpLineType3d-2) <EPS then 
		MainLineLength = 0.1
		MainGap = 0.05
		MainPoint = 0.02

		Length2D = SQR((dx2-dx1)**2+(dy2-dy1)**2)
		Length3D = SQR((Length2D)**2+(dz2-dz1)**2)
		
		LineNum = MAX(1, INT(Length3D/(MainLineLength+2*MainGap+MainPoint)))
		
		dxfull = ((dx2-dx1)/LineNum)
		dyfull = ((dy2-dy1)/LineNum)
		dzfull = ((dz2-dz1)/LineNum)

		dxline = ((dx2-dx1)/LineNum)*(MainLineLength/(MainLineLength+2*MainGap+MainPoint))
		dyline = ((dy2-dy1)/LineNum)*(MainLineLength/(MainLineLength+2*MainGap+MainPoint))
		dzline = ((dz2-dz1)/LineNum)*(MainLineLength/(MainLineLength+2*MainGap+MainPoint))

		dxgap = ((dx2-dx1)/LineNum)*(MainGap/(MainLineLength+2*MainGap+MainPoint))
		dygap = ((dy2-dy1)/LineNum)*(MainGap/(MainLineLength+2*MainGap+MainPoint))
		dzgap = ((dz2-dz1)/LineNum)*(MainGap/(MainLineLength+2*MainGap+MainPoint))

		dxpoint = ((dx2-dx1)/LineNum)*(MainPoint/(MainLineLength+2*MainGap+MainPoint))
		dypoint = ((dy2-dy1)/LineNum)*(MainPoint/(MainLineLength+2*MainGap+MainPoint))
		dzpoint = ((dz2-dz1)/LineNum)*(MainPoint/(MainLineLength+2*MainGap+MainPoint))

		ADD dx1, dy1, dz1 + 0.018
			for LNum=1 to LineNum
				ADD (LNum-1)*dxfull, (LNum-1)*dyfull, (LNum-1)*dzfull
					LIN_ 0, 0, 0, dxline, dyline, dzline
					ADD dxline+dxgap, dyline+dygap, dzline+dzgap
						LIN_ 0, 0, 0, dxpoint, dypoint, dzpoint	
				DEL 2
			next LNum
		DEL 1
	endif
RETURN


10100:	!DIVIDER_VERTICAL, standing mullions
	!Recursive subroutine for divding frame for placing a number of sashes
	!The processing order of the child sashes is depth-first
	!All the data is put into one dimension arrays, the position in the array pointed by Zone~ is the order of the depth-first walkthrough
	!With exceptions for arrays for Mullions, because for n division/number of sash there is n+1 Mullion pos (the 0th and the n+1st being the two sides of window)

	!Some incoming variables:
	!LeafD1, LeafD2		: Leafbox difference besides mullion, first/second side, set up at the mullion definig subroutine
	!OuterD1, OuterD2	: Mullions' outer profile length difference due to parent profile width, calculated locally form LeafDs, used in mullion profile start/end offsets
	!InnerD1, InnerD1	: The same for inner (and all internal: thermal breaker, etc), longer profiles. InnerDiff should be usually smaller than outerdiff meaning longer profiles	

	!init vars
	iNumberOfZones = iNumbersOfZones[Zone~]											! Division number of THIS divider as an array
	iMullionOrientation = 40000 													! horizontal/standing
	iAllocatedMullionPointer = iMullionPointer + iNumberofZones + 1 				! array of the Mullion grows differently, faster
	xMullionPos[iMullionPointer + iNumberOfZones] = LeafBoxA						! last pos = unit width			???????????
	LeafDTemp	= LeafDLeft															! LeafBox width difference coming from frame/parent
	LeafDEnd	= LeafDRight														! For the last zone, difference from frame

	OuterD1		= LeafDLower	+ OuterOffset										! Difference btween LeafDs and profile widths, for calculating inside mullion length for outer profiles
	OuterD2		= LeafDUpper	+ OuterOffset										! OuterOffset being hopefully a system specific constant, set up in master, at the beginning
	InnerD1		= LeafDLower	+ InnerOffset										! For calculating inside mullion length for inner/inside (longer than outer) profiles
	InnerD2		= LeafDUpper	+ InnerOffset										! InnerOffset being hopefully a system specific constant

	if Zone~ > MAX_ALLOWED_ZONE_NUMBER then end MAX_ALLOWED_ZONE_NUMBER + 1			! Some safety against infinite calls

	addx - LeafBoxA / 2																!initial

!--------------------------------

		for i = iMullionPointer + 1 to iMullionPointer + iNumberOfZones

			if i < iMullionPointer + iNumberOfZones then												! mullion is not for the last Zone
				hotspot 0, 				LeafBoxB/3, -0.125, UnID, xMullionPos[i], 1 : UnID = UnID + 1
				hotspot xMullionPos[i],	LeafBoxB/3, -0.125, UnID, xMullionPos[i], 2 : UnID = UnID + 1
				hotspot -1, 			LeafBoxB/3, -0.125, UnID, xMullionPos[i], 3 : UnID = UnID + 1

				add xMullionPos[i], 0, zFrameOffset
					gs_frame_mat  = -iMullionColor[2]													! TODO ????
					iProfileT = PT_MULLION

					gosub 30012																			! Mullion; sets yProf1 , yProf2 (profile width from profile axis on 2 sides)

					LeafD1	= yProf1 - InnerOffset														! yProf1 is simple to measure while OuterOffset is system specific
					LeafD2	= yProf2 - InnerOffset
				del 1
			else
				LeafD1 = LeafDEnd
			endif

			Zone~ = Zone~ + 1
			add (xMullionPos[i-1] + xMullionPos[i]) / 2, 0, zFrameOffset

!if iSelectableProfiles [PROF_FRAME][Zone~] > EPS then bDrawFrame = 1 else bDrawFrame = 0 				! TODO only self-hack for some openings drawing own frames
				CALL "Leaf_WMCC" Parameters all \
					LeafBoxA				= xMullionPos[i] - xMullionPos[i-1], 
					LeafBoxB				= LeafBoxB,
					Zone~					= Zone~,
					xMullionPos				= xMullionPos,
					UnID 					= UnID,
					iOpeningType			= iOpeningTypes[Zone~],
					iMullionColor			= iMullionColor,
					gs_sash_mat 			= iZoneColor[Zone~],
					iDesignVariant			= iDesignVariant,
!					bDrawFrame				= iSelectableProfiles [PROF_FRAME][Zone~] > EPS,				! If frame drawn elsewhere
					leafDLeft				= LeafDTemp,
					leafDRight				= LeafD1,
					iMullionPointer			= iAllocatedMullionPointer \
						returned_parameters x1, y1, x2, y2, x3, y3, x4, y4, Zone~, iAllocatedMullionPointer, xMullionPos, UnID
			del 1

			LeafDTemp = LeafD2
		next i
	del 1
return


10101:	!DIVIDER_HORIZONTAL, laying mullions
	!init vars
	iNumberOfZones = iNumbersOfZones[Zone~]											! Division number of THIS divider as an array
	iMullionOrientation = 40001 													! vertical/laying
	iAllocatedMullionPointer = iMullionPointer + iNumberofZones + 1 				! array of the Mullions grows differently, faster
	xMullionPos [iMullionPointer + iNumberOfZones] = LeafBoxB - LeafBoxDiff2
	LeafDTemp 	= LeafDLower														! LeafBox width difference coming from frame/parent
	LeafDEnd	= LeafDUpper														! For the last zone, difference from frame

	OuterD1		= LeafDLeft		+ OuterOffset										! OuterOffset being a system specific constant, set up in master, at the beginning
	OuterD2		= LeafDRight	+ OuterOffset
	InnerD1		= LeafDLeft		+ InnerOffset										! InnerOffset being a system specific constant
	InnerD2		= LeafDRight	+ InnerOffset

	if Zone~ > MAX_ALLOWED_ZONE_NUMBER then end MAX_ALLOWED_ZONE_NUMBER + 1			! Some safety against infinite calls

	for i = iMullionPointer + 1 to iMullionPointer + iNumberOfZones
		if i < iMullionPointer + iNumberOfZones then
			hotspot LeafBoxA / 3, 0,				-0.0125, UnID, xMullionPos[i], 1 : UnID = UnID + 1
			hotspot LeafBoxA / 3, xMullionPos[i],	-0.0125, UnID, xMullionPos[i], 2 : UnID = UnID + 1
			hotspot LeafBoxA / 3, -1,				-0.0125, UnID, xMullionPos[i], 3 : UnID = UnID + 1

			add -LeafBoxA / 2, xMullionPos[i], zFrameOffset
				gs_frame_mat  = -iMullionColor[2]
				iProfileT = PT_MULLION
!print yprof1, LeafDLeft, innerd1, outerd1
					gosub 30012																						! Mullion; sets LeafD1, LeafD2
				LeafD1	= yProf1 - InnerOffset																		! yProf1 is simple to measure while OuterOffset is system specific
				LeafD2	= yProf2 - InnerOffset
			del 1
		else
				LeafD1 = LeafDEnd
		endif

		Zone~ = Zone~ + 1
		add 0, xMullionPos[i-1], zFrameOffset																		! TODO check
			CALL "Leaf_WMCC" Parameters all \
				LeafBoxA				= LeafBoxA,																	! TODO check diff2
				LeafBoxB				= xMullionPos[i] - xMullionPos[i-1],
				Zone~					= Zone~,
				xMullionPos				= xMullionPos,
				UnID					= UnID,
				iOpeningType			= iOpeningTypes[Zone~],
				iMullionColor			= iMullionColor,
				gs_sash_mat 			= iZoneColor[Zone~],
				iDesignVariant			= iDesignVariant,
				bDrawFrame				= iSelectableProfiles [PROF_FRAME][Zone~] > EPS,								! If frame drawn elsewhere
				leafDLower				= LeafDTemp,
				leafDUpper				= LeafD1,
				iMullionPointer			= iMullionPointer \
					returned_parameters x1, y1, x2, y2, x3, y3, x4, y4, Zone~, iMullionPointer, xMullionPos, UnID
		del 1
		LeafDTemp = LeafD2
	next i
return


103102:
	!DIVISION_COMMON
	!TODO to merge the two above
return
!
!"endPos":
!END Zone~, iMullionPointer, xMullionPos, UnID




]]>
</Script_3D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_2D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
!circle2 0,0, .01 : hotspot2 0,0 : line2 0,0, 0,1 : line2 0,0, 1,0

!!IF iDetLevel2D = DETLEVEL_2D_SCALE THEN	! Scale Sensitive
!!	iDetLevel2D = DETLEVEL_2D_10
!!	IF GLOB_SCALE > 20 + EPS THEN iDetLevel2D = DETLEVEL_2D_50
!!	IF GLOB_SCALE > 50 + EPS THEN iDetLevel2D = DETLEVEL_2D_100
!!ENDIF

IF GLOB_CONTEXT = 22 & iDetLevel2D = DETLEVEL_2D_10 THEN
	iDetLevel2D = DETLEVEL_2D_50
ENDIF

!!!!!!**********************************************************************  Window Sashes Routines
!!!!!!**********************************************************************  Window Sashes Routines
!!!!!!**********************************************************************  Window Sashes Routines

FILL	fFills[FILL_SASH]
PEN		pFills[FILL_SASH][FP_CONTPEN]

!print str(iSelectableProfiles[PROF_SASH][1], 10, 0)
!print str(iSelectableProfiles[PROF_FRAME][1], 10, 0)

gosub OPTYPE_BASE + iOpeningType 																			!10000 + 3 = 10003, for example, these subroutines draw all profiles

if iOpeningType = DIVIDER_HORIZONTAL | iOpeningType = DIVIDER_VERTICAL then goto "endPos"

!!!!!!**********************************************************************  Background Fill 

if	iOpeningTypes[Zone~] = OPTYPE_FIXED and Zone~ = 1 then gs_sash_thk = gs_frame_thk + zMoveLeaf + zFrameOffset
if	iDetLevel2D = DETLEVEL_2D_100 then yGlazingIODiff = 0

! Outer side
POLY2_B 5, FillStatus, pFills[FILL_SASH][FP_FGPEN], pFills[FILL_SASH][FP_BGPEN],
	0			+ OffsetGL + yGlazingBead,					 0,						 0,
	0			+ OffsetGL + yGlazingBead,					-zOffset,				 1, 
	LeafBoxA	- OffsetGR - yGlazingBead,					-zOffset,				 0,
	LeafBoxA	- OffsetGR - yGlazingBead,					 0,						 1,
	0			+ OffsetGL + yGlazingBead,					 0,						-1

! Inner side
POLY2_B 5, FillStatus, pFills[FILL_SASH][FP_FGPEN], pFills[FILL_SASH][FP_BGPEN],
	0			+ OffsetGL + yGlazingBead - yGlazingIODiff,	-zOffset - zGlassThk,	 0,
	0			+ OffsetGL + yGlazingBead - yGlazingIODiff,	-zMax,					 1, 
	LeafBoxA	- OffsetGR - yGlazingBead + yGlazingIODiff,	-zMax,					 0,
	LeafBoxA	- OffsetGR - yGlazingBead + yGlazingIODiff,	-zOffset - zGlassThk,	 1,
	0			+ OffsetGL + yGlazingBead - yGlazingIODiff,	-zOffset - zGlassThk,	-1

!!!!!!**********************************************************************  Define Glass Panels - MODELS
!!!!!!**********************************************************************  Define Glass Panels - MODELS
!!!!!!**********************************************************************  Define Glass Panels - MODELS

DelGlasTrans = 0
GlassLayers = vardim1(GlassThk)
if vardim2(GlassThk) = 5 then bExtendedGlassDefinition = 1 else bExtendedGlassDefinition = 0

MUL2 1,-1			: DelGlasTrans = DelGlasTrans+1
ADD2 0, zOffset 	: DelGlasTrans = DelGlasTrans+1

!if iOpeningTypes[Zone~] = OPTYPE_FIXED and Zone~ <> 1 then add2 0, zMoveLeaf

if	iOpeningType = 	DOUBLE_SLIDING_SECOND_SASH \
!|	iOpeningType = 	DOUBLE_SECOND_SASH \
|	iOpeningType = 	DOUBLE_DOOR_SECOND_SASH \
|	iOpeningType = 	DOUBLE_DOOR_OUTWARDS_SECOND_SASH \
|	iOpeningType = 	DOUBLE_ZT_DOOR_SECOND_SASH \
|	iOpeningType = 	DOUBLE_ZT_DOOR_OUTWARDS_SECOND_SASH \
|	iOpeningType = 	SLIDING_FOLDING_SECOND_SASH \
!|	iOpeningType = 	OPTYPE_PIVOT_DOOR \
!|	iOpeningType = 	OPTYPE_PIVOT_DOOR_OUTWARDS \
then xOffsetforMiddleprofile = 0																			!hack

if bExtendedGlassDefinition > EPS then 																		!extended Glasspanel definition
	PEN 	  pFills[ GlassThk[1][GL_FILL_TYPE] ][FP_CONTPEN]
	Fill 	  fFills[ GlassThk[1][GL_FILL_TYPE] ]
	Pen_FG 	= pFills[ GlassThk[1][GL_FILL_TYPE] ][FP_FGPEN]
	Pen_BG 	= pFills[ GlassThk[1][GL_FILL_TYPE] ][FP_BGPEN]
else 
	PEN 	  pFills[FILL_GLASS][FP_CONTPEN]
	Fill 	  fFills[FILL_GLASS]
	Pen_FG 	= pFills[FILL_GLASS][FP_FGPEN]
	Pen_BG 	= pFills[FILL_GLASS][FP_BGPEN]
endif


if	iDetLevel2D = DETLEVEL_2D_100 then
	POLY2_B 5,1+2, Pen_FG, Pen_BG,
						OffsetGL + yGlazingBead,							0,			1,
			LeafBoxA - 	OffsetGR - yGlazingBead - xOffsetforMiddleprofile,	0,			1,
			LeafBoxA - 	OffsetGR - yGlazingBead - xOffsetforMiddleprofile,	zGlassThk,	1,
						OffsetGL + yGlazingBead,							zGlassThk,	1,
						OffsetGL + yGlazingBead,							0,			-1
endif

if	iDetLevel2D = DETLEVEL_2D_50 \
|	iDetLevel2D = DETLEVEL_2D_10 \
then
	POLY2_B 5,1+2, Pen_FG, Pen_BG,
						OffsetGL,							0,			1,
			LeafBoxA - 	OffsetGR - xOffsetforMiddleprofile,	0,			1,
			LeafBoxA - 	OffsetGR - xOffsetforMiddleprofile,	zGlassThk,	1,
						OffsetGL,							zGlassThk,	1,
						OffsetGL,							0,			-1
endif

if	iDetLevel2D = DETLEVEL_2D_10 \
&	1 = 2 \																											! disabled for now
then
	for u=1 to GlassLayers
		if bExtendedGlassDefinition > EPS then 																		!extended Glasspanel definition
			glassOffset =  GlassThk[u][GL_OFFSET]
	
			PEN 	  pFills[ GlassThk[u][GL_FILL_TYPE] ][FP_CONTPEN]
			Fill 	  fFills[ GlassThk[u][GL_FILL_TYPE] ]
			Pen_FG 	= pFills[ GlassThk[u][GL_FILL_TYPE] ][FP_FGPEN]
			Pen_BG 	= pFills[ GlassThk[u][GL_FILL_TYPE] ][FP_BGPEN]
		else 
			glassOffset = 0
	
			PEN 	  pFills[FILL_GLASS][FP_CONTPEN]
			Fill 	  fFills[FILL_GLASS]
			Pen_FG 	= pFills[FILL_GLASS][FP_FGPEN]
			Pen_BG 	= pFills[FILL_GLASS][FP_BGPEN]
		endif

		POLY2_B 5,1+2, Pen_FG, Pen_BG,
						OffsetGL + glassOffset,	0,							1,
			LeafBoxA -	OffsetGR - glassOffset,	0,							1,
			LeafBoxA -	OffsetGR - glassOffset,	GlassThk[u][GL_THICKNESS],	1,
						OffsetGL + glassOffset,	GlassThk[u][GL_THICKNESS],	1,
						OffsetGL + glassOffset, 0,							-1
	
		ADD2 0, GlassThk[u][GL_THICKNESS]	: DelGlasTrans = DelGlasTrans+1
		if GlassThk[u][GL_AIRGAP] > EPS then 
			if bExtendedGlassDefinition > EPS then glassOffset = max (GlassThk[u][GL_OFFSET], GlassThk[u+1][GL_OFFSET])

			!Sealants between Glass layers, 2 sides	
			PEN		  pFills[FILL_SEALANT][FP_CONTPEN]
			Fill	  fFills[FILL_SEALANT]
			Pen_FG 	= pFills[FILL_SEALANT][FP_FGPEN]
			Pen_BG 	= pFills[FILL_SEALANT][FP_BGPEN]
	
			POLY2_B 5,1+2, Pen_FG, Pen_BG,
				OffsetGL + glassOffset,							0, 				1,
				OffsetGL + glassOffset + zGum,					0, 				1,
				OffsetGL + glassOffset + zGum,					GlassThk[u][2],	1,
				OffsetGL + glassOffset,							GlassThk[u][2],	1,
				OffsetGL + glassOffset,							0,				-1
	
			POLY2_B 5,1+2, Pen_FG, Pen_BG,
				LeafBoxA - OffsetGR - glassOffset,				0,				1,
				LeafBoxA - OffsetGR - glassOffset - zGum,		0,				1,
				LeafBoxA - OffsetGR - glassOffset - zGum,		GlassThk[u][2],	1,
				LeafBoxA - OffsetGR - glassOffset,				GlassThk[u][2],	1,
				LeafBoxA - OffsetGR - glassOffset,				0,				-1
	
		endif
		ADD2 0, GlassThk[u][2]	: DelGlasTrans = DelGlasTrans+1
	next u
endif

DEL DelGlasTrans

!!!!!!**********************************************************************  OPENING LINES 
!!!!!!**********************************************************************  OPENING LINES 
!!!!!!**********************************************************************  OPENING LINES 

line_type 	gs_swingLineType
pen 		gs_opLinePen

if or_bOplines2D then
	if 	bOpening = 1 then
			xLine = LeafBoxA - xHinge - xOffsetForMiddleProfile
	!		if	  iOpeningType = OPTYPE_PIVOT_DOOR then xLine = LeafBoxA * 0.8
	!		if	  iOpeningType = OPTYPE_PIVOT_DOOR_OUTWARDS then xLine = LeafBoxA - leafDLeft
	
			if gs_iSwingType = 1 then 						!arc
															!TODO depends also on LOD
				if iOpeningType = OPTYPE_SIDE_HUNG_SLIDING then
					mul2 1, (LeafBoxA - xSlide) / LeafBoxA
						arc2 xhinge, yhinge, xLine, -aOpeningS2D[1], 0
					del 1
				else
					if aOpeningS2D[1] < EPS then
						if iInwardsOpening > 0 then
							arc2 xhinge, yhinge, xLine, -90, 0
							line2 xhinge, yhinge, xhinge, yhinge - xLine
							if	  iOpeningType = OPTYPE_PIVOT_DOOR then 
								arc2 xhinge, yhinge, xhinge, 90, 180
								line2 xhinge, yhinge, xhinge, xhinge + yhinge
							endif
						else
							arc2 xhinge, yhinge, xLine, 0, 90
							line2 xhinge, yhinge, xhinge, yhinge + xLine
						endif
					else
						if iInwardsOpening > 0 then
							arc2 xhinge, yhinge, xLine, min(aOpeningS2D[1], atn(gs_sash_thk / LeafBoxA)), aOpeningS2D[1]
						else
							arc2 xhinge, yhinge, xLine, -aOpeningS2D[1], 0
						endif
					endif
				endif
			else
				line2 -xLine / 2, 0, xLine / 2, xLine
				line2  xLine / 2 ,0, xLine / 2, xLine
			endif
	endif
	
	if iOpeningType = OPTYPE_PIVOT_DOOR_OUTWARDS then
		aSmall = atn(gs_sash_thk / 2 / LeafBoxA)
		arc2 xhinge, yhinge, xhinge,			aSmall + 180,	max(aOpeningS2D[1] - aSmall, aSmall) + 180
		arc2 xhinge, yhinge, LeafBoxA - xhinge, aSmall,			max(aOpeningS2D[1] - aSmall, aSmall)
	
		if aOpeningS2D[1] < EPS then
			arc2 xhinge, yhinge, xhinge, 90, 180
			line2 xhinge, yhinge, xhinge, xhinge + yhinge
	
			arc2 xhinge, yhinge, LeafBoxA - xhinge, -90, 0
			line2 xhinge, yhinge, xhinge, + yhinge + xhinge - LeafBoxA
		endif
	endif
endif

!!!!!==========================================================================  END
!!!!!==========================================================================  END

"endPos":
END	minW, minH, maxW, maxH, 
	xWarnMin, yWarnMin, xWarnMax, yWarnMax,
	Zone~, iMullionPointer, xMullionPos, UnID

!!!!!==========================================================================  END
!!!!!==========================================================================  END

! ---------------------------------------------------------------------------
"slidingSymbol":
! ---------------------------------------------------------------------------
!!	if gs_iSlidingType = LINE_SHAPE_SLIDING_ARROW then
!		pen gs_opLinePen
!		line_type gs_swingLineType
!	
!		!if bLineShapeArrowNED then
!		!	line2 0, 0, 0, 0.12
!		!endif
!		if iOplineArrow > 0 then
!			line2 0, 0.10, 0.20, 0.10
!	
!			if bittest (iOplineArrow, 0) then
!				line2 0.00, 0.10, 0.05, 0.13
!				line2 0.00, 0.10, 0.05, 0.07
!			endif
!			if bittest (iOplineArrow, 1) then
!				line2 0.20, 0.10, 0.15, 0.13
!				line2 0.20, 0.10, 0.15, 0.07
!			endif
!		endif
!	
!		line_type 1
!!	endif
!return

10100:
	!DIVIDER_VERTICAL, standing/vertical mullions
	!Subroutine for divding frame for placing an arbitrary but finite number of sashes
	!The processing order of the child sashes is depth-first
	!All the data is put into one dimension arrays, the position in the array pointed by Zone~ is the order of the depth-first walkthrough
	!With exceptions for arrays for Mullions, because for n division/number of sash there is n+1 Mullion pos (the 0th and the n+1st being the two sides of window)

	!Some incoming variables:
	!LeafD1, LeafD2		: Leafbox difference besides mullion, first/second side, set up at the mullion definig subroutine
	!OuterD1, OuterD2	: Mullions' outer profile length difference due to parent profile width, calculated locally form LeafDs, used in mullion profile offsets
	!InnerD1, InnerD1	: The same for inner (and all internal: thermal breaker, etc), longer profiles. InnerDiff should be usually smaller than outerdiff meaning longer profiles	

	!init vars
	iNumberOfZones = iNumbersOfZones[Zone~]
	iMullionOrientation = 40000 													!horizontal division/standing mullions
	iAllocatedMullionPointer = iMullionPointer + iNumberofZones + 1 				!array of the Mullions grows differently, faster
	xMullionPos [iMullionPointer + iNumberOfZones] = LeafBoxA						!last pos = unit width
	LeafDTemp	= LeafDLeft															!LeafBox width difference coming from frame/parent
	LeafBoxEnd	= LeafDRight														!For the last zone, difference from frame

	OuterD1		= LeafDLower	+ OuterOffset										!OuterOffset being hopefully a system specific constant, set up in master, at the beginning
	OuterD2		= LeafDUpper	+ OuterOffset
	InnerD1		= LeafDLower	+ InnerOffset										!InnerOffset being hopefully a system specific constant
	InnerD2		= LeafDUpper	+ InnerOffset

	if Zone~ > MAX_ALLOWED_ZONE_NUMBER then end MAX_ALLOWED_ZONE_NUMBER + 1	!Some safety against infinite calls

	add2 - LeafBoxA / 2, 0 															!initial
		for i = iMullionPointer + 1 to iMullionPointer + iNumberOfZones
			if i < iMullionPointer + iNumberOfZones then
				hotspot2 0, 				-0.025, UnID, xMullionPos[i], 1 : UnID = UnID + 1
				hotspot2 xMullionPos[i], 	-0.025, UnID, xMullionPos[i], 2 : UnID = UnID + 1
				hotspot2 -1, 				-0.025, UnID, xMullionPos[i], 3 : UnID = UnID + 1

				add2 xMullionPos[i], zFrameOffset
					gs_frame_mat  = -iMullionColor[2]													!TODO
					iProfileT = PT_MULLION
						gosub 30012
					LeafD1	= yProf1 - InnerOffset
					LeafD2	= yProf2 - InnerOffset
				del 1
			else
				LeafD1 = LeafBoxEnd
			endif

			Zone~ = Zone~ + 1

			add2 (xMullionPos[i-1] + xMullionPos[i]) / 2, zFrameOffset
				CALL "Leaf_WMCC" Parameters all \
					LeafBoxA				= xMullionPos[i] - xMullionPos[i-1],
					LeafBoxB				= LeafBoxB,
					Zone~					= Zone~,
					xMullionPos				= xMullionPos,
					UnID 					= UnID,
					iOpeningType			= iOpeningTypes[Zone~],
					iMullionColor			= iMullionColor,
					iDesignVariant			= iDesignVariant,
					bDrawFrame				= iSelectableProfiles [PROF_FRAME][Zone~] > EPS,				!Frame drawn elsewhere, if, TO BE REMOVED?
					leafDLeft				= LeafDTemp,
					leafDRight				= LeafD1,
					iMullionPointer			= iAllocatedMullionPointer \
						returned_parameters x1, y1, x2, y2, x3, y3, x4, y4, Zone~, iAllocatedMullionPointer, xMullionPos, UnID
			del 1

			LeafDTemp = LeafD2
		next i
	del 1
return

10101:
!DIVIDER_HORIZONTAL, laying/horizontal mullions
!TODO include zFrameOffset
	!init vars
	iAllocatedMullionPointer = iMullionPointer + iNumberofZones + 1			!array of the Mullions grows differently, quicker
	xMullionPos [iMullionPointer + iNumberOfZones] = LeafBoxB
	iMullionType[iMullionPointer + 1] = iMullionType[2]						!Just for now, can be greater
	if Zone~ > MAX_ALLOWED_ZONE_NUMBER then end MAX_ALLOWED_ZONE_NUMBER + 1	!Some safety against infinite calls

if (iSelectableProfiles [PROF_FRAME][Zone~ + iZoneToDrawIn2D[1]] ) > EPS then bDrawFrame = 1 				!TODO only self-hack
!print leafboxa, Zone~, iZoneToDrawIn2D[1], bDrawFrame
	CALL "Leaf_WMCC" Parameters all \
		LeafBoxA				= LeafBoxA,
		LeafBoxB				= xMullionPos[iMullionPointer + 1] - xMullionPos[iMullionPointer],
		Zone~					= Zone~ + iZoneToDrawIn2D[1],												!TODO Upper or lower zone to draw,
		xMullionPos				= xMullionPos,
		UnID					= UnID,
		iOpeningType			= iOpeningTypes[Zone~ + iZoneToDrawIn2D[1]] ,
		iMullionColor			= iMullionColor,
		iDesignVariant			= iDesignVariant,
		bDrawFrame				= bDrawFrame,	
		leafDLower				= LeafDTemp,															!Do we need these?
		leafDUpper				= LeafD1,																!Frame drawn elsewhere TODO out
		iMullionPointer			= iMullionPointer returned_parameters x1, y1, x2, y2, x3, y3, x4, y4, Zone~, iMullionPointer, xMullionPos, UnID

	LeafDTemp = LeafD2
	Zone~ = Zone~ + 1
	for i = iMullionPointer + 1 to iMullionPointer + iNumberOfZones - 1 ! now 2 to 2
		Zone~ = Zone~ + 1																	!TODO This is erroneous works only with a fixed number of children
	next i
return




!			iAdditionalProfiles 	= iAdditionalProfiles,
!			yGap 					= yGap,
]]>
</Script_2D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_1D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!Avoiding infinite recursive calls
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
MAX_ALLOWED_ZONE_NUMBER	= 20 	!Limiting Zone~, the LeafMacro ends after reaching this, constant used elsewhere, too
iWatchdog = vardim1(Watchdog)
if iWatchdog > MAX_ALLOWED_ZONE_NUMBER then end MAX_ALLOWED_ZONE_NUMBER + 1
Watchdog[iWatchdog + 1]= 1
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! =============================================================================
! Safe init settings in case of uninitialized stuff
! =============================================================================

minW					= 0		! Size control to be used later only Minimal width
maxW					= 0
minH					= 0
maxH					= 0
xWarnMin				= 0		! Minimal width at the given height
xWarnMax				= 0
yWarnMin				= 0
yWarnMax				= 0

yProf					= 0
zOffset					= 0
!!zGlassThk				= 0
!!xOverLapRight			= 0
zO						= 0		! =zMoveLeaf FIXME to rename everywhere and TO BE REMOVED
xOffset					= 0
iAdditionalProfiles 	= 0
PN						= 1

xOffsetStart			= 0
xOffsetEnd				= 0

bOpening 				= 0

yprof1 					= 0.0
yprof2 					= 0.0
zMoveLeaf 				= 0.0	! When leaf is not in frame's plane, negative means inwards (doesn't move mullions, thesholds)
zFrameOffset			= 0.0	! If only frame is thicker, this moves everything (incuding mullions) inwards instead of (system specific) zMoveLeaf

Pen_FG					= 1
Pen_BG					= 1

isFrameMirrored			= 0		! Used if outwards frame is the same as inwards but built in opposite direction, inside out ("Mirrored")
bInverseCalculation 	= 0		! Sometimes profiles are put in place in a reverse way (inner/outer side changed)

calculatedArea			= 0.00	! Calculating glazed area for listing params
calculatedPerimeter		= 0.00	! Calculating glazing perimeter for listing params

!!iZoneToDrawIn2D[1]	= 1		! definition must be in 1st field of array; # is the zone number WITHIN (vertical) division

xThrOffs				= 0.00
_yMoveBottom			= 0.00

mulHandleZ				= 1.00	! Handle thinckess multiplier, if less than 1 handle will be thinner

iAdditionalProfiles 	= 0
yGap 					= 0.00

! For texture orientation
isTextMapVert			= 0
isCompositeProfileStart	= 1
isCompositeProfileEnd	= 1

aOpeningMax 			= 10

! =============================================================================
! Labels	
! =============================================================================

CALCULATE_WIDTHS		= 1000000

! ==================================================================
! Locale strings
! ==================================================================

DIM stDetlevel2D[6]
	stDetlevel2D[1] = `Scale Sensitive`
	stDetlevel2D[2] = `1:1`
	stDetlevel2D[3] = `1:20`
	stDetlevel2D[4] = `1:50`
	stDetlevel2D[5] = `1:100`
	stDetlevel2D[6] = `1:200`

DIM stDetlevel3D[4]
	stDetlevel3D[1] = `Scale Sensitive`
	stDetlevel3D[2] = `Detailed`
	stDetlevel3D[3] = `Simple`
	stDetlevel3D[4] = `Off`

!iDesignVariant
	DESVAR_CLASSIC		= 0
	DESVAR_FERRO		= 1000
	DESVAR_CUBIC		= 2000

!iDoorOption
	DOOR_OPT_PLINTH								= 1
	DOOR_OPT_MITER								= 2
	DOOR_OPT_PANEL_ONE_SIDED					= 3
	DOOR_OPT_PANEL_DOUBLE_SIDED					= 4

! iOpeningType:
	OPTYPE_BASE									= 10000

	OPTYPE_EMPTY								= -1	! Empty (no sash, no glass)
	OPTYPE_SOLID								= 0		! Solid panel in sash
	OPTYPE_FIXED								= 1		! Fixed Glass 									!
	OPTYPE_FIXED_SCREW							= 2		! Fixed Sash
	OPTYPE_SIDE_HUNG							= 3		! Side Hung 									!
	OPTYPE_SIDE_HUNG_M							= 4		! Side Hung Mirrored
	OPTYPE_TILT_TURN							= 5		! Tilt and Turn									!
	OPTYPE_TILT_TURN_M							= 6		! Tilt and Turn Mirrored
	OPTYPE_BOTTOM_HUNG							= 7		! Bottom Hung									!
	OPTYPE_TOP_HUNG								= 8		! Top Hung										!
	OPTYPE_HOR_PIVOT							= 9		! Horizontal Pivot Hung							!	
	OPTYPE_VER_PIVOT							= 10	! Vertical Pivotted								!
	OPTYPE_TILT_SLIDE							= 11	! Tilt and Slide
	OPTYPE_DOUBLE_TILT_SLIDE					= 12	! in place of OPTYPE_LEFT_SLIDING
	OPTYPE_RIGHT_SLIDING						= 13	! Right Sliding
	OPTYPE_UP_SLIDING							= 14	! Sliding Up
	OPTYPE_DOWN_SLIDING							= 15	! Sliding Down
	OPTYPE_VER_PIVOT_M							= 16	! Vertical Pivotted Mirrored
	OPTYPE_DOUBLE_SIDE_HUNG						= 18	! Double Sash									!
	OPTYPE_DOUBLE_TILT_TURN						= 19	! Double Tilt and Turn							!
	OPTYPE_DOUBLE_TILT_TURN_M					= 20	! Double Tilt and Turn Mirrored
	OPTYPE_SLIDING_HOR							= 21	! Sliding
	OPTYPE_SLIDING_HOR_M						= 22	! Sliding Mirrored
	OPTYPE_DOUBLE_SLIDING_HOR					= 23	! Double Sliding
	OPTYPE_DOUBLE_SLIDING_HOR_M					= 24	! Double Sliding Mirrored
	OPTYPE_SLIDING_VER							= 25	! Single Hung
	OPTYPE_DOUBLE_SLIDING_VER					= 26	! Double Hung
	OPTYPE_SLIDING_FIX							= 27	! Sliding Fix
	OPTYPE_SLIDING_FIX_M						= 28	! Sliding Fix Mirrored
	OPTYPE_TOP_SWING							= 31	! Top Swing
	OPTYPE_SIDE_SWING							= 32	! Side Swing
	OPTYPE_SIDE_SWING_M							= 33	! Side Swing mirrored
	OPTYPE_TOP_TURN								= 34	! Top Turn
	OPTYPE_FIXED_COMBI							= 35	! Fixed Glass Combi window
	OPTYPE_DOUBLE_TILT_FIXED					= 36	! Double Tilt and Turn							!
	OPTYPE_DOOR_WIN_SIDE_HUNG					= 37	! Door window side hung							!
	OPTYPE_DOUBLE_DOOR_WIN_SIDE_HUNG			= 38	! Double door window side hung					!
	OPTYPE_OUTWARDS								= 39	! Side hung, outwards opening					!
	OPTYPE_OUTWARDS_M							= 40	! Side hung, outwards opening, mirrored			!
	OPTYPE_OUTWARDS_DOUBLE						= 41	! Side hung, outwards opening, double			!
	OPTYPE_OUTWARDS_DOUBLE_M					= 42	! Side hung, outwards opening, double mirrored	!
	OPTYPE_TILT_TURN_AND_FIXED					= 43	! Tilt&turn + fixed
	OPTYPE_TOP_HUNG_SLIDING						= 44	! Top-hung sliding 								!
	OPTYPE_TOP_HUNG_SLIDING_FIXED				= 45	! Top-hung sliding and fixed					!
	OPTYPE_SIDE_HUNG_SLIDING					= 46	! Side-hung sliding 							!
	OPTYPE_FIXED_WITH_VENT						= 47	! Fixed window frame with vent					!
	OPTYPE_COMBINED_FIXED						= 48    ! Combined fixed window							!
	OPTYPE_COMPOSITE    						= 49    ! Composite with top hung inside glazed			!
	OPTYPE_UPPER_VENT							= 50    ! Upper vent									!
	OPTYPE_COMBINED_TOP_HUNG					= 51    ! Combined window with top hung sliding window	!
	OPTYPE_SLIDING_FOLDING						= 52    ! Sliding-folding, composite
	OPTYPE_COMBINED_FIXED_FIXED					= 53	! Fixed with fixed hung vent
	OPTYPE_COMBINED_FIXED_SIDE_HUNG				= 54	! Fixed with side hung vent
	OPTYPE_COMBINED_FIXED_TILT_TURN				= 55	! Fixed with tilt & turn hung vent
	OPTYPE_COMBINED_DOUBLE_SIDE_HUNG			= 56	! Double casement window with fixed Z-profile

	OPTYPE_DOOR									= 60	! Door window side hung
	OPTYPE_DOUBLE_DOOR							= 61	! Double door window side hung
	OPTYPE_DOUBLE_DOOR_Z_T						= 62	! Double door Z-T opening						!
	OPTYPE_COMBI_DOOR							= 63	! Combi door
	OPTYPE_DOOR_OUTWARDS						= 64	! Door window side hung, outwards opening
	OPTYPE_DOUBLE_DOOR_OUTWARDS					= 65	! Double door side hung, outwards opening		!
	OPTYPE_DOUBLE_DOOR_Z_T_OUTWARDS				= 66	! Double Z-T door, outwards opening
	OPTYPE_COMBI_DOOR_OUTWARDS					= 67	! Combi door, outwards opening
	OPTYPE_ALTERNATE_DOOR						= 68	! Alternate door
	OPTYPE_PIVOT_DOOR							= 69	! Pivot door									!
	OPTYPE_PIVOT_DOOR_OUTWARDS					= 70	! Pivot door, outwards opening
	OPTYPE_WINDOW_DOOR							= 71	! Window door, inwards opening
	OPTYPE_WINDOW_DOOR_DOUBLE					= 72	! Double window door, inwards opening
	OPTYPE_WINDOW_DOOR_OUTWARDS					= 73	! Window door, outwards opening
	OPTYPE_WINDOW_DOOR_OUTWARDS_DOUBLE			= 74	! Double window door, outwards opening
	OPTYPE_TILT_SLIDE							= 75	! Door window side hung


	OPTYPE_AUTO_DOOR_2_ZONES					= 80	! Auto sliding door, 2 zones (1 fix, 1 sliding)
	OPTYPE_AUTO_DOOR_4_ZONES					= 81	! Auto sliding door, 4 zones (2 fix, 2 sliding)

	DIVIDER_VERTICAL							= 100
	DIVIDER_HORIZONTAL							= 101
	DOUBLE_FIRST_SASH							= 102
	DOUBLE_SECOND_SASH							= 103
	DOUBLE_OUTWARDS_FIRST_SASH					= 104
	DOUBLE_OUTWARDS_SECOND_SASH					= 105
	DOUBLE_DOOR_FIRST_SASH						= 106
	DOUBLE_DOOR_SECOND_SASH						= 107
	DOUBLE_DOOR_OUTWARDS_FIRST_SASH				= 108
	DOUBLE_DOOR_OUTWARDS_SECOND_SASH			= 109
	DOUBLE_ZT_DOOR_SECOND_SASH					= 110
	DOUBLE_ZT_DOOR_OUTWARDS_SECOND_SASH			= 111
	DOUBLE_SLIDING_FIRST_SASH					= 112
	DOUBLE_SLIDING_SECOND_SASH					= 113
	SLIDING_FOLDING_FIRST_SASH					= 114
	SLIDING_FOLDING_SECOND_SASH					= 115


! Profile alternatives array definitions
	PROF_FRAME								=  1
	PROF_SASH								=  2
	PROF_GLAZING_BEAD						=  3
	PROF_MULLION							=  4
	PROF_THRESHOLD							=  5
	PROF_FRAME2 							=  6
	PROF_PLINTH								=  7
	PROF_Z									=  8	! ZT double door's middle profile
	PROF_I									=  9	! Double door/win passive leaf's additional profile at middle
	PROF_BOTTOM								= 10	! Bottom threshold related additional profiles
	PROF_C									= 11	! O type's sealants that are cut through by mid prof while I type for double doors/wins
	PROF_I_CAP								= 12	! Top cap of I profile, if present

!Threshold type
	THRESHOLD_BASE							= 50000
	THRESHOLD_DELTA							= 100
	
	THRESHOLD_WINDOW						=  1
	THRESHOLD_BRUSH							=  2
	THRESHOLD_AUTO_LATCH					=  3
	THRESHOLD_BOTTOM_RAIL_WITH_BRUSH		=  4
	THRESHOLD_BOTTOM_RAIL_WITH_LATCH		=  5
	THRESHOLD_TRANSOM_BRUSH					=  6
	THRESHOLD_TRANSOM_LATCH					=  7
	THRESHOLD_DOUBLE_WEATHER_STRIP			=  8
	THRESHOLD_DOUBLE_WEATHER_STRIP_HIPLUS	=  9
	THRESHOLD_PANEL_DOOR					= 10	! Panel door, only put here cos didn't fit elsewhere
	THRESHOLD_PANEL_DOOR_DOUBLE_SIDED		= 11	! Panel door, only put here cos didn't fit elsewhere
	THRESHOLD_PLINTH_DOUBLE_WEATHER_STRIP	= 12	! Double weather strip with miter instead of plinth


!Leaf/sash types
	SASH_BASE								= 0
	MITER_SASH_FIXED						= 60000
	MITER_SASH_TYPE_O						= 60001	!Simple O type sash: all profiles are the same with 45 deg cuts, like for 1 leaf side hung window
	MITER_SASH_TYPE_I						= 60002	!Simple O type sash with I profile: second sash of double sash windows
	MITER_SASH_TYPE_Z						= 60003	! Second sash of double sash windows with different profile in the middle
	!FIXME:
	MITER_SASH_PIVOT_HOR					= 60004
	MITER_SASH_PIVOT_VERT					= 60005
	MITER_SASH_DOUBLE_I						= 60006	! Like I, but additional profile is on both sides, for folding-sliding middle
MITER_SASH_TYPE_O_MIRRORED				= 60007	!same as MITER_SASH_TYPE_O but inside is out

	PLINTH_LEAF_FIXED						= 60010	! FIXME
	PLINTH_LEAF_TYPE_O						= 60011	! Simple O type door leaf: all profiles are the same with 45 deg cuts except the Bottom, like for 1 leaf side hung door
	PLINTH_LEAF_TYPE_I						= 60012	! Simple O type sash with I profile: second sash of double sash windows
	PLINTH_LEAF_TYPE_Z						= 60013	! Second sash of double sash windows with different profile in the middle
	!FIXME:
	PLINTH_LEAF_PIVOT_HOR					= 60014
	PLINTH_LEAF_PIVOT_VERT					= 60015
	PLINTH_LEAF_DOUBLE_I					= 60016	

!Frame types
	FRAME_WINDOW							= 61001
	FRAME_WINDOW_MIRRORED					= 61002	! Same as above but in/out stuff is exchanged; USES gs_frame_thk!!!
	FRAME_HOR_PIVOT_WINDOW					= 61003
	FRAME_VERT_PIVOT_WINDOW					= 61004

	FRAME_DOOR								= 61011
	FRAME_DOOR_MIRRORED						= 61012	! Same as above but in/out stuff is exchanged; USES gs_frame_thk!!!

	FRAME_HOR_PIVOT_DOOR					= 61014
	FRAME_VERT_PIVOT_DOOR					= 61015

!iMechanics					
	MECHA_FIXED								= 20000	! Fixed mechanics, maybe to be deleted later on
	MECHA_FRAME								= 20001	! Frame for all
	MECHA_OPEN								= 20002	! For all side &| bottom hung | pivot openings
	MECHA_DOUBLE							= 20003	! For all double openings
	MECHA_TOP_HUNG							= 20004	! 
	MECHA_TOP_SLIDE							= 20005	! 
	MECHA_SIDE_SLIDE						= 20006	! 
	MECHA_COMPOSITE							= 20007	! 
	MECHA_PIVOT_VERTICAL					= 20008	! 
	MECHA_TILT_SLIDE						= 20009	!
	MECHA_SLIDE								= 20010	! Sliding mecha

! TODO RENAME FROM HERE

!!	MECHA_PIVOT_HORIZONTAL					= 20009	! TODO RENAME FROM HERE
!!	MECHA_SLIDE_FOLD						= 20011	!

!Profile positions 
	PROFILE_COMMON		= 1		! General profile of leaf
	PROFILE_BOTTOM		= 2
	PROFILE_Z			= 3
	PROFILE_I			= 3		! Double door/win passive leaf's additional profile at middle
	PROFILE_BOTTOM_THR	= 4		! Bottom threshold related additional profiles
	PROFILE_C			= 5		! Sealant between frame and leaf that is missing at middle pos of double door/win passive leafs

!rArray positions
	HANDLE_POS			= 1
	SLIDE_OPENING_1		= 2
	SLIDE_OPENING_2		= 3		! To be removed
	DIVISION_RATIO		= 2
	MIN_POS_X			= 2		! Minimal position of, say, a handle
	MAX_POS_X			= 3

!iArray positions
	NR_OF_LEAFS			= 1
	ASYMMETRY			= 2

!iProfileT profile types for low detlevs
	PT_NONE				= 0		! The whole profile group shouldn't be drawn at low detlevs
	PT_FRAME			= 1
	PT_SASH				= 2
	PT_MULLION			= 3
	PT_ZT				= 4		! Z-T door
	PT_I				= 5		! Double door I profile

! Profile array indexes
	PAI_PRNUM		= 1
	PAI_MOVX		= 2
	PAI_MOVY		= 3
	PAI_ROT			= 4
	PAI_MIRRX		= 5
	PAI_MIRRY		= 6
	PAI_STARTOFFS	= 7
	PAI_ENDOFFS		= 8
	PAI_MAT			= 9
	PAI_STARTROT	= 10
	PAI_ENDROT		= 11
	PAI_FILL		= 12

DIM stDetlevel3D[4]
	stDetlevel3D[1]		= `Scale Sensitive`
	stDetlevel3D[2]		= `Detailed`
	stDetlevel3D[3]		= `Simple`
	stDetlevel3D[4]		= `Off`

! iDetLevel2D
	DETLEVEL_2D_MVO		= -2
	DETLEVEL_2D_SCALE	= -1
	DETLEVEL_2D_OFF		= 0
	DETLEVEL_2D_10		= 10
	DETLEVEL_2D_50		= 50
	DETLEVEL_2D_100		= 100
	DETLEVEL_2D_200		= 200

! iDetLevel3D
	DETLEVEL_3D_MVO		= -2
	DETLEVEL_3D_SCALE	= -1
	DETLEVEL_3D_OFF		= 0
	DETLEVEL_3D_10		= 10
	DETLEVEL_3D_50		= 50
	DETLEVEL_3D_100		= 100

! ==================================================================
! Materials 
! ==================================================================

! Fill/contour array column positions as seen in sect_attrs
	FP_BGPEN		= 1		! Background pen
	FP_FGPEN		= 2		! Foreground pen
	FP_CONTPEN		= 3		! Contour pen
	FP_FILL			= 4		! Fill type
	FP_LTYPE		= 5		! Contour linetype

! iType2D
	FILL_EMPTY		= 1		! Non section lines
	FILL_ALU		= 2		! Aluminium
	FILL_WOOD		= 3		! Timber
	FILL_PVC		= 4		! PVC
	FILL_STEEL		= 5 	! Steel
	FILL_FOAM		= 6		! Foam
	FILL_SEALANT	= 7		! Gum
	FILL_THERMAL	= 8		! Thermal blocker
	FILL_GLASS		= 9		! Glass
	FILL_SASH		= 10	! Sash
	FILL_FRAME		= 11	! Frame
	FILL_OPERATOR	= 12	! Operator (kilincs, vasalat) szín
	FILL_WALLHOLE	= 13	! Wallhole fill
	FILL_ORIGFRAME	= 14	! Original frame fill
	FILL_COVER		= 15	! Cover
	FILL_PVC		= 16	! PVC
	FILL_BRUSH		= 17	! Brush

! iType3D
	MAT_IN			= 1		! Inner side surface
	MAT_OUT			= 2		! Outer side surface
	MAT_ALU			= 3		! Aluminium
	MAT_STEEL		= 4 	! Steel surface
	MAT_SEALANT		= 5		! Sealant surface
	MAT_THERMAL		= 6		! Thermal blocker
	MAT_GLASSBACK 	= 7		! Glassback
	MAT_BRUSH		= 8		! Brush
	MAT_GLASS		= 9		! Glass surface
	MAT_OPERATOR	= 10	! Operator (handle, hinge) surfaces
	MAT_THRESHOLD	= 11	! Threshold
	MAT_SASH_IN		= 12	! Sash inner, if differs from frame, now UNUSED
	MAT_SASH_OUT	= 13	! Sash outer, if differs from frame, now UNUSED
	MAT_FOAM 		= 14	! Foam fillings

!Glazing position constants
	GL_THICKNESS	= 1
	GL_AIRGAP		= 2
	GL_OFFSET		= 3
	GL_MATERIAL		= 4
	GL_FILL_TYPE	= 5

! ==============================================================================
! Product Specific Data
! ==============================================================================

! =============================================================================
! Product/system specific data to be modified always when a new product is started
! =============================================================================
!!!!!Went to parameters
!!!!xMinimalHandleDistFromCorners	=  0.30		! Handle minimal pos from corners
!!!!
!!!!yGlazingBead					=  0.014	! Glazing bead width, difference between glass panel size and opening/visible size for glass (/2)
!!!!yGlazingBeadDiff				=  0.010	! Difference between glazing bead border and glass border (positive = glazing bead is the outer)
!!!!yGlazingIODiff					=  0.005	! Visible glazing side in/out difference, glazing bead to glazing perpendicular planes are not the same, positive means inner (glazing bead) is smaller
!!!!OuterOffset						=  0.019	! OuterD1 - LeafDLeft, mullion outer profile is shorter than LeafBoxSize by (2 times) this length				?? 0.0335
!!!!InnerOffset						=  0.0055	! InnerD1 - LeafDLeft, mullion inner profile is shorter than LeafBoxSize by (2 times) this length				?? 0.0085
!!!!FrameSashGap					=  0.0105	! Visible gap between sash and frame
!!!!zMoveLeaf						= -0.0231	! Leaf is outwards of the frame plane by this distance
!!!!gs_frame_thk					=  0.099
!!!!gs_sash_thk						=  0.0857
!!!!zOffset 						=  0.0246	! Glass panel offset regarding to leaf; positive inwards
!!!!zGum 							=  0.0083
!!!!xHinge 							= -0.0112	! Hinge position regarding to leaf coord system
!!!!yHinge 							= -0.0858	! yHinge is at the opposite dir of leaf, so expect larger negative values
!!!!yHandleOffset					=  0.0322	! handle axis dist from leaf profile INNER side (border of glazing)

if	iOpeningTypes[1] = OPTYPE_OUTWARDS \
|	iOpeningTypes[1] = OPTYPE_WINDOW_DOOR_OUTWARDS \
|	iOpeningTypes[1] = OPTYPE_WINDOW_DOOR_OUTWARDS_DOUBLE \
then
	zMoveLeaf						= -0.0131	! Leaf is outwards of the frame plane by this distance
	zOffset 						=  0.0246	! Glass panel offset regarding to leaf; positive inwards
	xHinge 							= -0.0051	! Hinge position regarding to leaf coord system
	yHinge 							=  0.0109	! yHinge is at the opposite dir of leaf, so expect larger negative values
endif

InOutOffset						= OuterOffset - InnerOffset

!!!!!!**********************************************************************  Define Glass Panels - PARAMETERS
!!!!!!**********************************************************************  Define Glass Panels - PARAMETERS 
!!!!!!**********************************************************************  Define Glass Panels - PARAMETERS

!Default glazing:

dim GlassThk[2][2]

GlassThk[1][GL_THICKNESS]	= 0.006
GlassThk[1][GL_AIRGAP]		= 0.015
GlassThk[2][GL_THICKNESS]	= 0.006
GlassThk[2][GL_AIRGAP]		= -1

if iDoorOption  = DOOR_OPT_PANEL_DOUBLE_SIDED then		!11
	zOffset 			= 0.0
	yGlazingBead		= 0.0

	!Extended parameter deFinitions
	dim GlassThk[5][5]

	GlassThk[1][GL_THICKNESS]	= 0.003
	GlassThk[1][GL_AIRGAP]		= 0
	GlassThk[1][GL_OFFSET]		= 0.0265															!Side offset: the actual glass is smaller than GlassBox by this amount
	GlassThk[1][GL_MATERIAL]	= MAT_SASH_OUT														!Material of the actual layer
	GlassThk[1][GL_FILL_TYPE]	= FILL_ALU															!Fill type of the actual layer

	GlassThk[2][GL_THICKNESS]	= 0.020
	GlassThk[2][GL_AIRGAP]		= 0
	GlassThk[2][GL_OFFSET]		= 0.0825
	GlassThk[2][GL_MATERIAL]	= MAT_FOAM
	GlassThk[2][GL_FILL_TYPE]	= FILL_FOAM

	GlassThk[3][GL_THICKNESS]	= 0.001
	GlassThk[3][GL_AIRGAP]		= 0
	GlassThk[3][GL_OFFSET]		= 0.0825
	GlassThk[3][GL_MATERIAL]	= MAT_ALU
	GlassThk[3][GL_FILL_TYPE]	= FILL_ALU

	GlassThk[4][GL_THICKNESS]	= 0.050
	GlassThk[4][GL_AIRGAP]		= 0
	GlassThk[4][GL_OFFSET]		= 0.0825
	GlassThk[4][GL_MATERIAL]	= MAT_FOAM
	GlassThk[4][GL_FILL_TYPE]	= FILL_FOAM

	GlassThk[5][GL_THICKNESS]	= 0.003
	GlassThk[5][GL_AIRGAP]		= -1																!Last glazing's airgap MUST BE -1
	GlassThk[5][GL_OFFSET]		= 0
	GlassThk[5][GL_MATERIAL]	= MAT_SASH_IN
	GlassThk[5][GL_FILL_TYPE]	= FILL_ALU

	if	iOpeningType  = OPTYPE_DOOR_OUTWARDS \ 
	|	iOpeningType  = DOUBLE_DOOR_OUTWARDS_FIRST_SASH \ 
	|	iOpeningType  = DOUBLE_DOOR_OUTWARDS_SECOND_SASH \ 
	|	iOpeningType  = DOUBLE_ZT_DOOR_OUTWARDS_SECOND_SASH \ 
	then 
		GlassThk[1][GL_OFFSET]	= 0
		GlassThk[5][GL_OFFSET]	= 0.0265
	endif
endif

! ==============================================================================
!
! Initializations not to be product specifically and thus modified later on
!
! ==============================================================================

dim ProfArr[][]							!!! Necessary for Profile Placement in 3D and 2D 
dim xMullionWidth[]						! doublage width
dim iSashProfiles[]						!Sash profiles
dim glassOffsets[]						!Offset data for glazing edges's distance from profile outermost edge
dim yProfs[][]							!Profile sizes

EPS					= 0.001
EPSILON				= 0.001
iSashType			= 0

xSash				= LeafBoxA			!TODO to be removed
ySash				= LeafBoxB

zMin				= 0

!iDoorLeaf			= iSashType			!Just for safety
FillStatus 			= 1
!UnID				= 1
Status				= 1+2+16+32

ProfilNum			= 0					!!! Defined Profile Number to place 
PathNum				= 0					!!! Defined Path Number for the profile placement
TubeStatus 			= 1+2+16+32 + 64	!!!! Default Tube Status
PlaceType 			= 2					!!!! Old Version Tube Placemen. if "2", then NEW one	
ShowHoles			= 1					!!!! If you want to hide the holes in the profiles switch it to 0
ShowArcs			= 0					!!!! Show Profile Arcs in 3D

OffsetBot 			= 0					!!! Offsets for Profiles one by one TO BE DEPRECATED
OffsetTop 			= 0
OffsetR 			= 0 
OffsetL 			= 0

xMul 				= 1					! Mirroring the opening of opening doors, should be used only for multizone windows, otherwise simply mirror of the window/door
bFirstSash			= 1

aCut1				= 0
aCut2				= 0

aThresholdCut1		= 0
aThresholdCut2		= 0

InnerD1						= 0				! Offset for smaller profile (Glazing bead side, usually inner)	-> InnerD1
InnerD2						= 0

xGlass1						= 0				!Offset for glazing bead/Sealant				
xGlass2						= 0 

OuterD1						= 0				!Offset for Larger profile (Usually outer)						-> OuterD1
OuterD2						= 0

xOffsetForMiddleProfile		= 0
iAdditionalProfiles 		= 0				!For simple modes, there are additional profiles

! ==============================================================================
!
! End of Master Script
!
! ==============================================================================

goto "endMasterSript"

! ==============================================================================
!
! SubRoutines
!
! ==============================================================================
	

! ==============================================================================
! Calculate VECTOR Angle Normal Angle
! ------------------------------------------------------------------------------

"VectorAngle":
	!!!  INCOMING: dx, dy
	!!!  RETURNING: 0 <= VectAng < 360
		
	VectAng = 90
	if ABS(dx) > EPS then 
		VectAng = ATN (dy/dx)
		if VectAng >0 and dx < EPS then VectAng = VectAng + 180
		if VectAng<=0 and dx < EPS then VectAng = VectAng + 180
	else
		if dy > EPS then 
			VectAng = 90 
		else
			VectAng = 270 
		endif
	endif

	if VectAng <  EPS then VectAng=VectAng + 360
	if VectAng >= 360 then VectAng=VectAng - 360
return

! ==============================================================================

"CleanStack":
	for _z=1 to nsp
		_temp = get(1)
	next _z
return

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Dummy/empty subroutine
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

0:
	!Dummy subroutine
	!WARNING: called frequently, don't use it for purposes
return

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Sash database
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

10000:	!OPTYPE_SOLID 

return

10001: !OPTYPE_FIXED
	if Zone~ > 1 then zMoveLeaf 	=  0.00

	bThreshold					=  0
	iFrameProfile				=  FRAME_WINDOW
	iSashType 					=  MITER_SASH_FIXED

	iMechanics					=  MECHA_FIXED

	yGlazingIODiff				= 0
	yGlazingBead 				= 0

	gosub 20001
return

10003:	!OPTYPE_SIDE_HUNG
	iInwardsOpening 			= 1
	bOpening 					= 1
	bBottomHung					= 0

	iFrameProfile				= FRAME_WINDOW
	iMechanics					= MECHA_OPEN

	iSashType 					= MITER_SASH_TYPE_O

	gosub 20001
return

10005: !OPTYPE_TILT_TURN
	iInwardsOpening 			= 1
	bOpening 					= 1
	bBottomHung					= 1

	iFrameProfile				= FRAME_WINDOW
	iMechanics					= MECHA_OPEN
	iSashType 					= MITER_SASH_TYPE_O

	aMax						= 20

	gosub 20001
return

10007: !OPTYPE_BOTTOM_HUNG
	iInwardsOpening 			= 1
	bOpening 					= 0
	bBottomHung					= 1

	aMax						= 20

	iFrameProfile				= FRAME_WINDOW
	iMechanics					= MECHA_OPEN
	iSashType 					= MITER_SASH_TYPE_O

	gosub 20001
return

10008: !OPTYPE_TOP_HUNG
	iInwardsOpening 			= 1
	bOpening 					= 0
	bBottomHung					= 1

	aMax						= 90

	iFrameProfile				= FRAME_WINDOW
	iMechanics					= MECHA_TOP_HUNG
	iSashType 					= MITER_SASH_TYPE_O

	gosub 20001
return

10009: !OPTYPE_HOR_PIVOT
	iInwardsOpening 			= 1
	bOpening 					= 0
	bBottomHung					= 1

	xHinge 						= LeafBoxB/2
	aMax						= 90

	iFrameProfile				= FRAME_WINDOW
	iMechanics					= MECHA_OPEN
	iSashType 					= MITER_SASH_TYPE_O

	gosub 20001
return


10011:	!OPTYPE_TILT_SLIDE
	iInwardsOpening 						= 1
	bOpening 								= 1
	iSashType 								= MITER_SASH_TYPE_O
	iFrameProfile							= FRAME_WINDOW			! 30001
	iMechanics								= MECHA_TILT_SLIDE		! 20009

	aOpeningMax 							= 10

	gosub MECHA_FRAME
return

10012: !OPTYPE_DOUBLE_TILT_SLIDE
	iInwardsOpening 			= 1

	iFirstSashType				= DOUBLE_SLIDING_FIRST_SASH
	iSecondSashType				= DOUBLE_SLIDING_SECOND_SASH

	xOverLapLeft				= -0.001				!overlap of the two sashes, positive values enlarge LeafBoxA
	xOverLapRight				= -0.004				!overlap of the two sashes TODO 1/2 instead of left/right

	aOpeningMax 							= 10

	gosub MECHA_DOUBLE
return

10013:	! OPTYPE_RIGHT_SLIDING
	isVerticalSliding						= 0
	isPositiveDirection						= 1

	iSashType 								= MITER_SASH_TYPE_O
	iFrameProfile							= FRAME_WINDOW			! 30001
	iMechanics								= MECHA_SLIDE			! 20010

	leafDRight = 0													!FIXME temporary
	zMoveLeaf	= -gs_frame_thk / 2									!FIXME temporary

	gosub MECHA_FRAME
return

10014:	! OPTYPE_UP_SLIDING
	isVerticalSliding						= 1
	isPositiveDirection						= 1

	iSashType 								= MITER_SASH_TYPE_O
	iFrameProfile							= FRAME_WINDOW			! 30001
	iMechanics								= MECHA_SLIDE			! 20010

	leafDUpper	= 0													!FIXME temporary
	zMoveLeaf	= -gs_frame_thk / 2									!FIXME temporary

	gosub MECHA_FRAME
return

!!10015:	! OPTYPE_DOWN_SLIDING
!!	iInwardsOpening 						= 1
!!	bOpening 								= 1
!!	iSashType 								= MITER_SASH_TYPE_O
!!	iFrameProfile							= FRAME_WINDOW			! 30001
!!	iMechanics								= MECHA_TILT_SLIDE		! 20009
!!
!!	aOpeningMax 							= 10
!!
!!	gosub MECHA_FRAME
!!return

10018: !OPTYPE_DOUBLE_SIDE_HUNG
	iInwardsOpening 			= 1
	bBottomHung					= 0

	iFrameProfile				= FRAME_WINDOW

	iFirstSashType				= DOUBLE_FIRST_SASH
	iSecondSashType				= DOUBLE_SECOND_SASH

	gosub MECHA_DOUBLE
return

10019: !OPTYPE_DOUBLE_TILT_TURN
	iInwardsOpening 			= 1
	bBottomHung					= 1

	iFrameProfile				= FRAME_WINDOW

	iFirstSashType				= DOUBLE_FIRST_SASH
	iSecondSashType				= DOUBLE_SECOND_SASH

	gosub MECHA_DOUBLE
return

10021:	!OPTYPE_SLIDING_HOR
	iFrameProfile		= FRAME_WINDOW

	Zone~				= 2
	iMullionPointer		= 1
	iZoneToDrawIn2D[1]	= 1

	iOpeningTypes[2]	= DIVIDER_VERTICAL
	iOpeningTypes[3]	= OPTYPE_RIGHT_SLIDING
	iOpeningTypes[4]	= OPTYPE_FIXED

	iSelectableProfiles[PROF_FRAME][2]		= iSelectableProfiles[PROF_FRAME][1]
	iSelectableProfiles[PROF_SASH][3] 		= 30007
	iSelectableProfiles[PROF_MULLION][2]	= 30006

	if GLOB_MODPAR_NAME = "iOpeningTypeS" then
		xMullionPos[1]	= 0
		xMullionPos[2]	= LeafBoxA / 2 + gs_sash_width / 2
		xMullionPos[3]	= LeafBoxA
		
		parameters	xMullionPos	= xMullionPos
	endif

	gosub 20007
return

10023:	!OPTYPE_DOUBLE_SLIDING_HOR
!TODO this is a DOOR
	iFrameProfile		= FRAME_WINDOW												! 30030

	Zone~				= 2
	iMullionPointer		= 1

	iOpeningTypes[2]						= DIVIDER_VERTICAL
	iNumbersOfZones[2]						= 3
	iOpeningTypes[3]						= OPTYPE_FIXED
	iOpeningTypes[4]						= OPTYPE_DOUBLE_TILT_SLIDE
	iOpeningTypes[5]						= OPTYPE_FIXED

	if GLOB_MODPAR_NAME = "iOpeningTypeS" then
		xMullionPos[1]	= 0
		xMullionPos[2]	= LeafBoxA / 4
		xMullionPos[3]	= LeafBoxA / 4 * 3
		xMullionPos[4]	= LeafBoxA

		xZoneWidth[4]	= LeafBoxA / 4
		
		parameters	xMullionPos	= xMullionPos,
					xZoneWidth	= xZoneWidth
	endif

	gosub MECHA_COMPOSITE
return

10025:	! OPTYPE_SLIDING_VER
	iFrameProfile		= FRAME_WINDOW

	Zone~				= 2
	iMullionPointer		= 1
	iZoneToDrawIn2D[1]	= 1

	iOpeningTypes[2]	= DIVIDER_HORIZONTAL
	iOpeningTypes[3]	= OPTYPE_UP_SLIDING
	iOpeningTypes[4]	= OPTYPE_FIXED

	iSelectableProfiles[PROF_FRAME][2]		= iSelectableProfiles[PROF_FRAME][1]
	iSelectableProfiles[PROF_SASH][3] 		= 30007
	iSelectableProfiles[PROF_MULLION][2]	= 30006

	if GLOB_MODPAR_NAME = "iOpeningTypeS" then
		xMullionPos[1]	= 0
		xMullionPos[2]	= LeafBoxB / 2 + gs_sash_width / 2
		xMullionPos[3]	= LeafBoxB
		
		parameters	xMullionPos	= xMullionPos
	endif

	gosub 20007
return

10026:	! OPTYPE_DOUBLE_SLIDING_VER
	iFrameProfile		= FRAME_WINDOW												! 30030

	Zone~				= 2
	iMullionPointer		= 1

	iOpeningTypes[2]	= DIVIDER_HORIZONTAL
	iNumbersOfZones[2]	= 2
	iOpeningTypes[3]	= OPTYPE_FIXED
	iOpeningTypes[4]	= OPTYPE_TILT_SLIDE

	gosub MECHA_COMPOSITE
return

10039: !OPTYPE_OUTWARDS
	iInwardsOpening 			= -1
	bOpening 					=  1
	bBottomHung					=  0

	iFrameProfile				= FRAME_WINDOW
	iSashType 					= MITER_SASH_TYPE_O
	iMechanics					= MECHA_OPEN

	gosub 20001
return

10041: !OPTYPE_OUTWARDS_DOUBLE
	iInwardsOpening 			= -1
	bOpening 					=  1
	bBottomHung					=  0

	iFrameProfile				= FRAME_WINDOW

	iFirstSashType				= DOUBLE_OUTWARDS_FIRST_SASH
	iSecondSashType				= DOUBLE_OUTWARDS_SECOND_SASH

	gosub 20003
return

10044: !OPTYPE_TOP_HUNG_SLIDING 
	iInwardsOpening 			= 1
	bOpening 					= 0
	bBottomHung					= 1

	ySlide						= max(0.200, LeafBoxB * .1)
	aMax						= 90

	iFrameProfile				= FRAME_WINDOW
	iSashType 					= MITER_SASH_TYPE_O
	iMechanics					= MECHA_TOP_SLIDE

	gosub 20001
return

10046: !OPTYPE_SIDE_HUNG_SLIDING
	iInwardsOpening 			= -1
	bOpening 					= 1
	bBottomHung					= 0

	xSlide						= max(0.200, LeafBoxB * .1)

	iFrameProfile				= FRAME_WINDOW
	iSashType 					= MITER_SASH_TYPE_O
	iMechanics					= MECHA_SIDE_SLIDE

	gosub 20001
return

10048:	!OPTYPE_COMBINED_FIXED
	iFrameProfile		= FRAME_WINDOW

!	iNumberofZones 		= 2
	Zone~				= 2
	iMullionPointer		= 1

	iOpeningTypes[2]	= DIVIDER_VERTICAL
	iOpeningTypes[3]	= OPTYPE_BOTTOM_HUNG
	iOpeningTypes[4]	= OPTYPE_FIXED

	gosub 20007
return

!15052:	!OPTYPE_SLIDING_FOLDING
!	gosub 20010
!return

10053:	!OPTYPE_COMBINED_FIXED_FIXED
	iFrameProfile		= FRAME_WINDOW

!	iNumberofZones 		= 2
	Zone~				= 2			! NOT 1 (makes infinite loop!!!)
	iMullionPointer		= 1

	iOpeningTypes[2]	= DIVIDER_VERTICAL
	iOpeningTypes[3]	= OPTYPE_FIXED
	iOpeningTypes[4]	= OPTYPE_FIXED

	gosub 20007
return


10054:	!OPTYPE_COMBINED_FIXED_SIDE_HUNG
	iFrameProfile		= FRAME_WINDOW

!	iNumberofZones 		= 2
	Zone~				= 2
	iMullionPointer		= 1

	iOpeningTypes[2]	= DIVIDER_VERTICAL
	iOpeningTypes[3]	= OPTYPE_SIDE_HUNG
	iOpeningTypes[4]	= OPTYPE_FIXED

	gosub 20007
return


10055:	!OPTYPE_COMBINED_FIXED_TILT_TURN
	iFrameProfile		= FRAME_WINDOW

	iDivideOrientation	= DIVIDER_VERTICAL
!	iNumberofZones 		= 2
	Zone~				= 2
	iMullionPointer		= 1

	iOpeningTypes[2]	= DIVIDER_VERTICAL
	iOpeningTypes[3]	= OPTYPE_TILT_TURN
	iOpeningTypes[4]	= OPTYPE_FIXED

	gosub 20007
return


10056:	!OPTYPE_COMBINED_DOUBLE_SIDE_HUNG
	iFrameProfile		= FRAME_WINDOW

	iDivideOrientation	= DIVIDER_VERTICAL
!	iNumberofZones 		= 2
	Zone~				= 2
	iMullionPointer		= 1

	iOpeningTypes[2]	= DIVIDER_VERTICAL
	iOpeningTypes[3]	= OPTYPE_SIDE_HUNG
	iOpeningTypes[4]	= OPTYPE_SIDE_HUNG

	gosub 20007
return

!----------------doors---------------------------------doors---------------------------doors------------------------
!----------------doors---------------------------------doors---------------------------doors------------------------
!----------------doors---------------------------------doors---------------------------doors------------------------

10060: ! OPTYPE_DOOR
	iInwardsOpening 			= 1
	bOpening 					= 1
	bBottomHung					= 0

	iFrameProfile				= FRAME_DOOR
	iMechanics					= MECHA_OPEN
	iSashType 					= PLINTH_LEAF_TYPE_O

	gosub 20001
return

10061: ! OPTYPE_DOUBLE_DOOR
	iFrameProfile				= FRAME_DOOR
	iMechanics					= MECHA_DOUBLE

	iFirstSashType				= DOUBLE_DOOR_FIRST_SASH
	iSecondSashType				= DOUBLE_DOOR_SECOND_SASH

	xOverLapLeft				= -0.003							!overlap of the two sashes
	xOverLapRight				= -0.003							!overlap of the two sashes

	gosub 20003
return

10062: ! OPTYPE_DOUBLE_DOOR_Z_T
	iFrameProfile				= FRAME_DOOR
	iMechanics					= 20002

	iFirstSashType				= DOUBLE_DOOR_FIRST_SASH
	iSecondSashType				= DOUBLE_ZT_DOOR_SECOND_SASH

	xOverLapLeft				= 0.0								!overlap of the two sashes
	xOverLapRight				=-0.0								!overlap of the two sashes

	gosub 20003
return

10064: ! OPTYPE_DOOR_OUTWARDS
	iInwardsOpening 			= -1
	bOpening 					=  1
	bBottomHung					=  0

	iFrameProfile				= FRAME_DOOR

	if iDoorOption = DOOR_OPT_PLINTH then
		iSashType 				= PLINTH_LEAF_TYPE_O
	else
		iSashType 		      	= MITER_SASH_TYPE_O
	endif

	iMechanics					= 20002

	gosub 20001
return

10065: ! OPTYPE_DOUBLE_DOOR_OUTWARDS
	iInwardsOpening 			= -1
	bBottomHung					=  0

	iFrameProfile				= FRAME_DOOR
	iMechanics					= 20002

	iFirstSashType				= DOUBLE_DOOR_OUTWARDS_FIRST_SASH
	iSecondSashType				= DOUBLE_DOOR_OUTWARDS_SECOND_SASH

	xOverLapLeft				= -0.003				!overlap of the two sashes
	xOverLapRight				= -0.003				!overlap of the two sashes

	gosub 20003
return

10066: ! OPTYPE_DOUBLE_DOOR_Z_T_OUTWARDS
	iInwardsOpening 			= -1
	bBottomHung					=  0

	iFrameProfile				= FRAME_DOOR
	iMechanics					= 20002

	iFirstSashType				= DOUBLE_DOOR_OUTWARDS_FIRST_SASH						!DOUBLE_ZT_DOOR_OUTWARDS_FIRST_SASH
	iSecondSashType				= DOUBLE_ZT_DOOR_OUTWARDS_SECOND_SASH

	xOverLapLeft				= 0.016					!overlap of the two sashes
	xOverLapRight				= 0.016					!overlap of the two sashes

	gosub 20003
return

10069: !OPTYPE_PIVOT_DOOR
	iInwardsOpening 			= 1
	bOpening 					= 1
	bDrawFrame 					= 1
	bBottomHung					= 0

	iFrameProfile				= FRAME_VERT_PIVOT_DOOR			! 30026
	iSashType 					= PLINTH_LEAF_PIVOT_VERT		! 30027
	iMechanics					= MECHA_OPEN

	xhinge = LeafBoxA * 0.2

	gosub 20001
return

10070: !OPTYPE_PIVOT_DOOR_OUTWARDS
	iInwardsOpening 			= -1
	bOpening 					= 0								!Has an own opening line
	bDrawFrame 					= 1
	bBottomHung					= 0

	iFrameProfile				= FRAME_VERT_PIVOT_DOOR			! 30026
	iSashType 					= PLINTH_LEAF_PIVOT_VERT		! 30027
	iMechanics					= MECHA_OPEN

	gosub 20001
return

10071:	!OPTYPE_WINDOW_DOOR
	iInwardsOpening 			= 1
	bOpening 					= 1
	iFrameProfile				= FRAME_DOOR
	iMechanics					= 20002

	bBottomHung					= 0

	iSashType 					= MITER_SASH_TYPE_O

	gosub 20001
return

10072:	!OPTYPE_WINDOW_DOOR_DOUBLE
	iInwardsOpening 			= 1
	iFrameProfile				= FRAME_DOOR

	iFirstSashType				= DOUBLE_FIRST_SASH
	iSecondSashType				= DOUBLE_SECOND_SASH

	xOverLapLeft				= -0.0035				!overlap of the two sashes, positive values enlarge LeafBoxA
	xOverLapRight				= -0.0035				!overlap of the two sashes

	bBottomHung					= 0

	gosub 20003
return

10073:	!OPTYPE_WINDOW_DOOR_OUTWARDS
	iInwardsOpening 			= -1
	bOpening 					=  1
	bBottomHung					=  0

	if iDesignVariant = DESVAR_CLASSIC \
	then 
		isFrameMirrored	= 0 
		zMoveLeaf = -0.0131 							! leaf coord sys is offset outwards by this value
		_m = sMaterialS[MAT_IN]
		sMaterialS[MAT_IN]	= sMaterialS[MAT_OUT]
		sMaterialS[MAT_OUT]	= _m
	else 
		isFrameMirrored =  1
		zMoveLeaf = 0.010 								! leaf coord sys is offset outwards by this value
	endif

	iFrameProfile				= FRAME_DOOR
	iMechanics					= 20002
	iSashType 					= MITER_SASH_TYPE_O

	gosub 20001
return

10074:	!OPTYPE_WINDOW_DOOR_OUTWARDS_DOUBLE
	iInwardsOpening 			= -1

	if iDesignVariant = DESVAR_CLASSIC \
	then 
		isFrameMirrored	= 0 
		zMoveLeaf = -0.0131 							! leaf coord sys is offset outwards by this value
		_m = sMaterialS[MAT_IN]
		sMaterialS[MAT_IN]	= sMaterialS[MAT_OUT]
		sMaterialS[MAT_OUT]	= _m
	else 
		isFrameMirrored =  1
		zMoveLeaf = 0.010 								! leaf coord sys is offset outwards by this value
	endif

	bBottomHung					=  0
	bOpening 					=  1

	iFrameProfile				= FRAME_DOOR

	iFirstSashType				= DOUBLE_OUTWARDS_FIRST_SASH
	iSecondSashType				= DOUBLE_OUTWARDS_SECOND_SASH

	xOverLapLeft				= -0.0035				!overlap of the two sashes, positive values enlarge LeafBoxA
	xOverLapRight				= -0.0035				!overlap of the two sashes
	if iDesignVariant <> DESVAR_CLASSIC then zMoveLeaf = 0.010 else zMoveLeaf = -0.0131 ! leaf coord sys is offset outwards by this value

	gosub 20003
return

10075:
	iFrameProfile		= FRAME_WINDOW												! 30030

	Zone~				= 2
	iMullionPointer		= 1

	iOpeningTypes[2]	= DIVIDER_VERTICAL
	iNumbersOfZones[2]	= 2
	iOpeningTypes[3]	= OPTYPE_FIXED
	iOpeningTypes[4]	= OPTYPE_TILT_SLIDE

	gosub MECHA_COMPOSITE
return

!------------------------------------------------------------------------------------
!-----double sashes/leafs------------------------------------------------------------
!------------------------------------------------------------------------------------

!-----double window leafs------------------------------------------------------------

10102: !DOUBLE_FIRST_SASH,
	!2 sash When called as a separate macro, first (normal) sash

	bOpening 					=  1
	iSashType 					= MITER_SASH_TYPE_O

	gosub 20002
return


10103: !DOUBLE_SECOND_SASH
	!2 sash When called as a separate macro, 2nd sash (made of different profiles)

	bOpening 					= 1
	bFirstSash					= 0
	xMul 						= -1				!Mirrored leaf
	bBottomHung					= 0 				!the first sash tilts only

	iSashType 					= MITER_SASH_TYPE_I

	gosub 20002
return


10104: !DOUBLE_OUTWARDS_FIRST_SASH,
	!2 sash When called as a separate macro, first (normal) sash

	iSashType 					= MITER_SASH_TYPE_O

	bOpening 					= 1

	gosub 20002
return


10105: !DOUBLE_OUTWARDS_SECOND_SASH
	!2 sash When called as a separate macro, 2nd sash (made of different profiles)

	iSashType 					= MITER_SASH_TYPE_I

	bOpening 					= 1
	bFirstSash					= 0

	gosub 20002
return

!----double door sashes------------------------------------------------------------------

10106:	!DOUBLE_DOOR_FIRST_SASH
	!2 sash When called as a separate macro, first (normal) sash

	bOpening					= 1
	iSashType 					= PLINTH_LEAF_TYPE_O

	gosub 20002
return


10107:	!DOUBLE_DOOR_SECOND_SASH
	!2 sash When called as a separate macro, first (normal) sash
	bOpening					= 1
	bFirstSash					= 0
	iSashType 					= PLINTH_LEAF_TYPE_I

	gosub 20002
return


10108: !DOUBLE_DOOR_OUTWARDS_FIRST_SASH,
	!2 sash When called as a separate macro, first (normal) sash

	bOpening 					= 1
	iSashType 				= PLINTH_LEAF_TYPE_O

	gosub 20002
return


10109: !DOUBLE_DOOR_OUTWARDS_SECOND_SASH
	!2 sash When called as a separate macro, 2nd sash (made of different profiles)

	bOpening 					=  1
	bFirstSash					=  0

	iSashType 				= PLINTH_LEAF_TYPE_I

	gosub 20002
return


10110:	!DOUBLE_ZT_DOOR_SECOND_SASH
	!2 sash When called as a separate macro, second ("Z") sash
	bOpening					= 1
	bFirstSash					= 0

	iSashType 					= PLINTH_LEAF_TYPE_Z

	gosub 20002
return


10111:	!DOUBLE_ZT_DOOR_OUTWARDS_SECOND_SASH
	!2 sash When called as a separate macro, first (normal) sash
	bOpening					= 1
	bFirstSash					= 0

	iSashType 					= PLINTH_LEAF_TYPE_Z

	gosub 20002
return

10112:	!DOUBLE_SLIDING_FIRST_SASH
	xMul 									= 1
	iInwardsOpening 						= 1
	bOpening 								= 1
	iSashType								= MITER_SASH_TYPE_O

	gosub 20009
return

10113:	!DOUBLE_SLIDING_SECOND_SASH
	xMul 									= -1								! Mirrored leaf
	iInwardsOpening 						= 1
	bOpening 								= 1
	bFirstSash								= 0
	iSashType								= MITER_SASH_TYPE_I					! DOUBLE_I			!TODO

	gosub 20009
return

!15116:	!SLIDING_FOLDING_FIRST_SASH
!	!2 sash When called as a separate macro, first (normal) sash
!	iSashProfiles	[PROFILE_COMMON]	= iSelectableProfiles[PROF_SASH][1]
!
!	iSashType							= SASH_BASE + WINDOW_SASH_TYPE_O
!	zMax								= 0.077									!Profile width
!	gosub 20002
!return
!
!15117:	!SLIDING_FOLDING_SECOND_SASH
!	!2 sash When called as a separate macro, 2nd sash (made of different profiles)
!
!	iSashType							= SASH_BASE + WINDOW_SASH_DOUBLE_I
!	iSashProfiles	[PROFILE_COMMON]	= iSelectableProfiles[PROF_SASH][1]
!	iSashProfiles	[PROFILE_I]			= 83115
!	bFirstSash							= 0
!
!	xOffsetForMiddleProfile 			=  0.038
!	xOffsetForMiddleProfile2 			= -0.038
!
!	gosub 20002
!return


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! MECHANICS MECHANICS MECHANICS MECHANICS MECHANICS MECHANICS MECHANICS MECHANICS MECHANICS MECHANICS MECHANICS MECHANICS 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! MECHANICS MECHANICS MECHANICS MECHANICS MECHANICS MECHANICS MECHANICS MECHANICS MECHANICS MECHANICS MECHANICS MECHANICS
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! MECHANICS MECHANICS MECHANICS MECHANICS MECHANICS MECHANICS MECHANICS MECHANICS MECHANICS MECHANICS MECHANICS MECHANICS 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

20000:		!all fixed windows
	call "SizeCtrl_WMCC" parameters all \
		bDebug 			= 0,
		iOptype 		= iOpeningType, 
		iProfile		= iSelectableProfiles[PROF_SASH][1],
		iLogic 			= 3,
		UnID			= UnID,
		returned_parameters UnID, x1, y1, x2, y2, x3, y3, x4, y4

		minW = minW + x1 + leafDLeft	+ leafDRight
		maxW = maxW + x2 + leafDLeft	+ leafDRight
		minH = minH + y1 + leafDUpper	+ leafDLower
		maxH = maxH + y2 + leafDUpper	+ leafDLower
		
		xWarnMin = xWarnMin + x3 + leafDLeft	+ leafDRight
		xWarnMax = xWarnMax + x4 + leafDLeft	+ leafDRight
		yWarnMin = yWarnMin + y3 + leafDUpper	+ leafDLower
		yWarnMax = yWarnMax + y4 + leafDUpper	+ leafDLower

!---------------------sash---------------------
	add  leafDLeft, leafDLower,	0
	add2 leafDLeft,				0

	LeafBoxA 	= LeafBoxA - leafDLeft	- leafDRight				! actual leaf sizes TODO remove this here there shouldn't be any leafDs
	LeafBoxB 	= LeafBoxB - leafDUpper	- leafDLower

	iProfileT = PT_NONE
	gosub iSashType
return


20001: !all opening, 1 sash, mostly drawing the frame
	add2 -LeafBoxA/2, 		0
	add  -LeafBoxA/2, 0,	0

	!Fix part, if put in a composite window

		add  leafDLeft, leafDLower,	0
		add2 leafDLeft,				0

		LeafBoxA 	= LeafBoxA - leafDLeft	- leafDRight 			! actual leaf sizes TODO remove this here there shouldn't be any leafDs
		LeafBoxB 	= LeafBoxB - leafDUpper	- leafDLower

		leafDLeft	= 0
		leafDRight 	= 0
		leafDUpper	= 0
		leafDLower	= 0												! /TODO to move to a subroutine all these

		bFirstSide		= 1
!print str(iSelectableProfiles[PROF_FRAME][Zone~],10 ,0)
		if iSelectableProfiles[PROF_FRAME][Zone~] > 0 then
			iProfileT		= PT_FRAME

			gosub iFrameProfile
		endif

minW = minW + leafDLeft		+ leafDRight																		! Size control
maxW = maxW + leafDLeft		+ leafDRight
minH = minH + leafDUpper
maxH = maxH + leafDUpper

xWarnMin = xWarnMin + leafDLeft		+ leafDRight
xWarnMax = xWarnMax + leafDLeft		+ leafDRight
yWarnMin = yWarnMin + leafDUpper
yWarnMax = yWarnMax + leafDUpper

minH = minH + leafDLower
maxH = maxH + leafDLower

yWarnMin = yWarnMin + leafDLower
yWarnMax = yWarnMax + leafDLower

	LeafBoxA = LeafBoxA - leafDLeft		- leafDRight 															! actual leaf sizes
	LeafBoxB = LeafBoxB - leafDUpper	- leafDLower

		if isFrameMirrored then _zML = WIDO_REVEAL_SIDE * zMoveLeaf else _zML = zMoveLeaf + zFrameOffset		! 

		add  leafDLeft, leafDLower,	_zML
		add2 leafDLeft,				_zML

		leafDLeft	= 0
		leafDRight 	= 0
		leafDUpper	= 0
		leafDLower	= 0

	!Opening part
	iProfileT	= PT_SASH

	gosub iMechanics
return


20002:	!MECHA_OPEN
!Moving part of opening stuff, just the mechanics: all side and bottom hung stuff opens here
!circle2 0,0, .01	: hotspot2 0,0		: line2 0,0, 0,1	: line2 0,0, 1,0
!sphere 0.01 		: lin_ 0,0,0, 0,2,0	: lin_ 0,0,0, 1,0,0	: lin_ 0,0,0, 0,0,1
	yD		= yHinge 								!Delta in to wall perpendicular direction
	dHot	= sqr((LeafBoxA - 0.038)**2 + (yD)**2)	!hotspot distance
	dHot	= LeafBoxA - xHinge

	iMulOri	= xMul * iInwardsOpening
!text2 0,0, wido_reveal_side
	add  leafDLeft, leafDLower,	0
	add2 leafDLeft,				0

	!Opening hotspots
	if 	(not (bBottomHung) | (aTiltS[Zone~] < EPS | aTiltS[Zone~] > 180) & bOpening = 1) \
	&	bFirstSash > EPS \
!!	&	iOpeningType <> SLIDING_FOLDING_FIRST_SASH \
	then
		add2 xHinge, 	yHinge
		add  xHinge, 0, yHinge
!!text2 0,0, yHinge
		hotspot2 dHot,														0,														UnID, aOpeningS2D[Zone~], 4 + 128			: UnID = UnID + 1
		hotspot2 dHot * cos (aOpeningS2D[Zone~]),							-iInwardsOpening * (dHot * sin(aOpeningS2D[Zone~])),	UnID, aOpeningS2D[Zone~], 5				: UnID = UnID + 1
		hotspot2 0,															0,														UnID, aOpeningS2D[Zone~], 6 + (iMulOri >0) * 512	: UnID = UnID + 1

		hotspot dHot,								 LeafBoxB/2,			yHinge,													UnID, aOpeningS3D[Zone~], 4 + 128	: UnID = UnID + 1
		hotspot dHot * cos (aOpeningS3D[Zone~]),	 LeafBoxB/2,			-iInwardsOpening * (dHot * sin(aOpeningS3D[Zone~])),	UnID, aOpeningS3D[Zone~], 5		: UnID = UnID + 1
		hotspot 0,									 LeafBoxB/2,			yHinge, 												UnID, aOpeningS3D[Zone~], 6		: UnID = UnID + 1
		hotspot 0,									-LeafBoxB * iMulOri,	yHinge,													UnID, aOpeningS3D[Zone~], 7		: UnID = UnID + 1
		del 1
	endif

	if bBottomHung then
		_dHot = LeafBoxB - xHinge - gs_frame_width

		add LeafBoxA/2, xHinge, -gs_sash_thk
			hotspot 0, 			_dHot,	 			 0,										UnID, aTiltS[Zone~], 4	: UnID = UnID + 1
			hotspot 0, 			cos(aTiltS[Zone~]) * _dHot,	-sin(aTiltS[Zone~]) * _dHot,	UnID, aTiltS[Zone~], 5	: UnID = UnID + 1
			hotspot 0, 			0, 					 0, 									UnID, aTiltS[Zone~], 6	: UnID = UnID + 1
			hotspot LeafBoxA/2, 0, 					 0,										UnID, aTiltS[Zone~], 7	: UnID = UnID + 1
		del 1
	endif

!TODO These not here
	if	iOpeningType = OPTYPE_BOTTOM_HUNG \
	|	iOpeningType = OPTYPE_TOP_HUNG \
	then
	!Bottom/Top hung not opening
		aOpeningS2D[Zone~] = 0
		aOpeningS3D[Zone~] = 0
	endif

	if 	not(bBottomHung) then
		aTiltS[Zone~] = 0
	endif

	if (aTiltS[Zone~] > EPS & aTiltS[Zone~] < 180) then !tilting bottom hung
		add 0, xHinge, yHinge 	 	!HINGE
			if aTiltS[Zone~] > aMax & aTiltS[Zone~] < 180 then aTiltS[Zone~] = aMax
			if aTiltS[Zone~] >= 180 then aTiltS[Zone~] = 0

			aOpeningS2D[Zone~] = 0
			aOpeningS3D[Zone~] = 0

			rotx -aTiltS[Zone~]
		add 0, -xHinge, -yHinge 	!HINGE
	else
		add2 xHinge, 	 yHinge		!HINGE
		add  xHinge, 0,  yHinge	 	!HINGE

			rot2 -iInwardsOpening * aOpeningS2D[Zone~]
			roty  iInwardsOpening * aOpeningS3D[Zone~]

		add2 -xHinge,	 -yHinge 	!HINGE
		add  -xHinge, 0, -yHinge 	!HINGE
	endif

	gosub iSashType

!------------size control------------------------------------------------------------------

	call "SizeCtrl_WMCC" parameters all \
		bDebug 			= 0,
		iOptype 		= iOpeningType, 
		iProfile		= iSelectableProfiles[PROF_SASH][1],
		iLogic 			= 3,
		UnID			= UnID,
		returned_parameters UnID, x1, y1, x2, y2, x3, y3, x4, y4

		minW = minW + x1
		maxW = maxW + x2
		minH = minH + y1
		maxH = maxH + y2
		
		xWarnMin = xWarnMin + x3
		xWarnMax = xWarnMax + x4
		yWarnMin = yWarnMin + y3
		yWarnMax = yWarnMax + y4

!!!------------ handle - currently unused -----------------------------------------------------------------------
!!
!!	if bFirstSash > EPS and \
!!	   (GLOB_SCRIPT_TYPE = 2 and iDetLevel2D < DETLEVEL_2D_50) or \
!!	   (GLOB_SCRIPT_TYPE = 3 and iDetLevel3D < DETLEVEL_3D_50)    \
!!	|	GLOB_CONTEXT = 23 \
!!	then
!!		yHandle			= OffsetGR + yGlazingBead - yHandleOffset
!!
!!		call "Handle_WMCC" parameters all \
!!			iOpeningType	= iOpeningType,
!!			LeafBoxA		= LeafBoxA,
!!			LeafBoxB		= LeafBoxB,
!!			zHandle			= -gs_sash_thk + zO,
!!			yHandle			= yHandle,
!!			xMinP			= 0			+ xMinimalHandleDistFromCorners,
!!			xMaxP			= LeafBoxB	- xMinimalHandleDistFromCorners,
!!			aTiltS			= aTiltS[Zone~],
!!			UnID			= UnID,
!!			zProfile		= gs_sash_thk,
!!			isInnerSide		= iInwardsOpening < 0,
!!			iLeafProfile	= iSelectableProfiles[PROF_SASH][Zone~],
!!			mulHandleZ		= mulHandleZ,
!!			returned_parameters 	UnID
!!
!!		if bDoor then
!!			mulz -1
!!			mul2 1, -1
!!	
!!			addz gs_sash_thk
!!			add2 0, gs_sash_thk
!!				call "Handle_WMCC" parameters all \
!!					iOpeningType	= iOpeningType,
!!					LeafBoxA		= LeafBoxA,
!!					LeafBoxB		= LeafBoxB,
!!					zHandle			= -gs_sash_thk - zO,
!!					yHandle			= yHandle,
!!					xMinP			= 0			+ xMinimalHandleDistFromCorners,
!!					xMaxP			= LeafBoxB	- xMinimalHandleDistFromCorners,
!!					UnID			= UnID,
!!					isInnerSide		= iInwardsOpening > 0,
!!					iLeafProfile	= iSelectableProfiles[PROF_SASH][Zone~],
!!					mulHandleZ		= mulHandleZ,
!!					returned_parameters 	UnID
!!			del 2
!!		endif
!!	endif
return


20003: 															!2 Sash opening, just mechanics
	add2 -LeafBoxA/2, 0
	add  -LeafBoxA/2, 0, 0
		!Fix part

		if iSelectableProfiles[PROF_FRAME][Zone~] > 0 then
			iProfileT		= PT_FRAME

			gosub iFrameProfile
		endif
	del 1

	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	!Opening part

minW = leafDLeft		+ leafDRight							!Size control
maxW = leafDLeft		+ leafDRight
minH = leafDUpper		+ leafDLower
maxH = leafDUpper		+ leafDLower

xWarnMin = leafDLeft		+ leafDRight
xWarnMax = leafDLeft		+ leafDRight
yWarnMin = leafDUpper		+ leafDLower
yWarnMax = leafDUpper		+ leafDLower

	LeafBoxB = LeafBoxB - leafDUpper - LeafDLower

	add	 - LeafBoxA / 2, 0,	0 
	add2 - LeafBoxA / 2,	0

		hotspot  0,					0, -gs_sash_thk,	UnID, xZoneWidth[Zone~], 1 : UnID = UnID + 1
		hotspot  xZoneWidth[Zone~],	0, -gs_sash_thk,	UnID, xZoneWidth[Zone~], 2 : UnID = UnID + 1
		hotspot -1,					0, -gs_sash_thk,	UnID, xZoneWidth[Zone~], 3 : UnID = UnID + 1
	
		hotspot2 0,					0,					UnID, xZoneWidth[Zone~], 1 : UnID = UnID + 1
		hotspot2 xZoneWidth[Zone~],	0,					UnID, xZoneWidth[Zone~], 2 : UnID = UnID + 1
		hotspot2 -1,				0,					UnID, xZoneWidth[Zone~], 3 : UnID = UnID + 1
	
		if isFrameMirrored then _zML = WIDO_REVEAL_SIDE * zMoveLeaf else _zML = zMoveLeaf + zFrameOffset		! 

		add	 leafDLeft, LeafDLower, _zML
		add2 leafDLeft, 			_zML
			CALL "Leaf_WMCC" Parameters	all \
					UnID					= UnID,
					iOpeningType			= iFirstSashType,
					iInwardsOpening 		= iInwardsOpening,
					aTiltS					= aTiltS,
					bBottomHung				= bBottomHung,
					LeafBoxA				= xZoneWidth[Zone~] + xOverLapRight - leafDLeft,
					LeafBoxB				= LeafBoxB,
					leafDLower				= 0,
					leafDLeft 				= 0,										!resetting LeafDLeft since it has been used by now
					iProfileT				= PT_SASH,
					returned_parameters 	x1, y1, x2, y2, x3, y3, x4, y4,				!size controls
											Zone~, iMullionPointer, 
											_calculatedArea, _calculatedPerimeter,
											_LeafDLeft, _LeafDRight, _LeafDUpper, _LeafDLower,
											UnID, xMullionPos

		calculatedArea		= calculatedArea 		+ _calculatedArea
		calculatedPerimeter	= calculatedPerimeter	+ _calculatedPerimeter

		minW = minW + x1
		maxW = maxW + x2
		minH = minH + y1
		maxH = maxH + y2
		
		xWarnMin = xWarnMin + x3
		yWarnMin = yWarnMin + y3
		xWarnMax = xWarnMax + x4
		yWarnMax = yWarnMax + y4

		xMinFromZone1 = LeafDLeft + x1
		if x2 > EPS then xMaxFromZone1 = LeafDLeft + x2 else xMaxFromZone1 = LeafBoxA - LeafDRight
	del 2

	add  LeafBoxA / 2 - leafDRight, LeafDlower,	_zML
	add2 LeafBoxA / 2 - leafDRight,				_zML

	mul2 -1, 1
	mul -1, 1, 1
		CALL "Leaf_WMCC" Parameters	all \
				UnID					= UnID,
				iOpeningType			= iSecondSashType,
				iInwardsOpening 		= iInwardsOpening,
				aTiltS					= aTiltS,
				LeafBoxA				= LeafBoxA - xZoneWidth[Zone~] + xOverLapLeft - leafDRight,
				LeafBoxB				= LeafBoxB,
				leafDLower				= 0,
				leafDLeft 				= 0,										!resetting LeafDLeft since it has been used by now
				iProfileT				= PT_SASH,
				xOverLapLeft			= xOverLapLeft,
				xOverLapRight			= xOverLapRight,
				returned_parameters 	x1, y1, x2, y2, x3, y3, x4, y4,				!size controls
										Zone~, iMullionPointer, 
										_calculatedArea, _calculatedPerimeter,
										_LeafDLeft, _LeafDRight, _LeafDUpper, _LeafDLower,
										UnID, xMullionPos

		calculatedArea		= calculatedArea + _calculatedArea
		calculatedPerimeter	= calculatedPerimeter + _calculatedPerimeter

		minW = minW + x1
		maxW = maxW + x2
		minH = max (minH, y1 + leafDUpper	+ leafDLower)
		maxH = min (maxH, y2 + leafDUpper	+ leafDLower)
		
		xWarnMin = xWarnMin + x3
		yWarnMin = max (yWarnMin, y3 + leafDUpper	+ leafDLower)
		xWarnMax = xWarnMax + x4
		yWarnMax = min (yWarnMax, y4 + leafDUpper	+ leafDLower)

		if x2 > EPS then xMinFromZone2 = LeafBoxA - LeafDRight - x2 else xMinFromZone2 = LeafDRight
		xMaxFromZone2 = LeafBoxA - LeafDRight - x1

		xZoneWidth[Zone~] = min(max(xZoneWidth[Zone~], xMinFromZone1, xMinFromZone2), xMaxFromZone1, xMaxFromZone2)
		parameters xZoneWidth = xZoneWidth
	del 2

	end	minW, minH, maxW, maxH, 
		xWarnMin, yWarnMin, xWarnMax, yWarnMax,
		Zone~, iMullionPointer, xMullionPos, UnID
return


20004:	!MECHA_TOP_HUNG 
!Moving part of opening stuff, just the mechanics: top hung stuff opens here
!circle2 0,0, .01 : hotspot2 0,0 : line2 0,0, 0,1 : line2 0,0, 1,0
!sphere 0.1 : lin_ 0,0,0, 0,1,0 : lin_ 0,0,0, 1,0,0 : lin_ 0,0,0, 0,0,1

	add  leafDLeft, LeafBoxB + leafDLower,	0
	add2 leafDLeft, 						0

	!Opening hotspots
	hotspot LeafBoxA/2, -xHinge - LeafBoxB, 								gs_sash_thk,											UnID, aTiltS[Zone~], 4	: UnID = UnID + 1
	hotspot LeafBoxA/2, -xHinge - cos(aTiltS[Zone~]) * (LeafBoxB - xHinge), gs_sash_thk + sin(aTiltS[Zone~]) * (LeafBoxB - xHinge),	UnID, aTiltS[Zone~], 5	: UnID = UnID + 1
	hotspot LeafBoxA/2, -xHinge, 											gs_sash_thk, 											UnID, aTiltS[Zone~], 6	: UnID = UnID + 1
	hotspot LeafBoxA, 	 0, 												gs_sash_thk,											UnID, aTiltS[Zone~], 7	: UnID = UnID + 1

	add 0, -xHinge, yHinge 	 	!HINGE
		aOpeningS2D[Zone~] = 0
		aOpeningS3D[Zone~] = 0

		rotx -aTiltS[Zone~]
	add 0, xHinge - LeafBoxB, -yHinge		!HINGE

	gosub iSashType

!------------size control------------------------------------------------------------------

	call "SizeCtrl_WMCC" parameters all \
		bDebug 			= 0,
		iOptype 		= iOpeningType, 
		iProfile		= iSelectableProfiles[PROF_SASH][1],
		iLogic 			= 3,
		UnID			= UnID,
		returned_parameters UnID, x1, y1, x2, y2, x3, y3, x4, y4

		minW = minW + x1
		maxW = maxW + x2
		minH = minH + y1
		maxH = maxH + y2
		
		xWarnMin = xWarnMin + x3
		xWarnMax = xWarnMax + x4
		yWarnMin = yWarnMin + y3
		yWarnMax = yWarnMax + y4

!!!------------ handle - currently unused -----------------------------------------------------------------------
!!
!!	if	(GLOB_SCRIPT_TYPE = 2 and iDetLevel2D < DETLEVEL_2D_50) \
!!	|	(GLOB_SCRIPT_TYPE = 3 and iDetLevel3D < DETLEVEL_3D_50) \
!!	then
!!		call "Handle_WMCC" parameters all \
!!			iOpeningType	= iOpeningType,
!!			LeafBoxA		= LeafBoxA,
!!			LeafBoxB		= LeafBoxB,
!!			zHandle			= -gs_sash_thk + zO,
!!			xMinP			= 0			+ xMinimalHandleDistFromCorners,
!!			xMaxP			= LeafBoxB	- xMinimalHandleDistFromCorners,
!!			aTiltS			= aTiltS[Zone~],
!!			UnID			= UnID,
!!			returned_parameters 	UnID
!!	endif
return


20005:	!Top-hung sliding mechanics
!circle2 0,0, .01 : hotspot2 0,0 : line2 0,0, 0,1 : line2 0,0, 1,0
!sphere 0.1 : lin_ 0,0,0, 0,1,0 : lin_ 0,0,0, 1,0,0 : lin_ 0,0,0, 0,0,1
	add  leafDLeft, leafDLower, 0
	add2 leafDLeft, 0

	!Opening hotspots
	hotspot LeafBoxA/2, 0	, 												0,										UnID, aTiltS[Zone~], 4	: UnID = UnID + 1
	hotspot LeafBoxA/2, LeafBoxB - cos(aTiltS[Zone~]) * (LeafBoxB - 0.02),	sin(aTiltS[Zone~]) * (LeafBoxB - 0.02),	UnID, aTiltS[Zone~], 5	: UnID = UnID + 1
	hotspot LeafBoxA/2, LeafBoxB - aTiltS[Zone~] / aMax * ySlide, 			0,										UnID, aTiltS[Zone~], 6	: UnID = UnID + 1
	hotspot LeafBoxA, 	LeafBoxB - aTiltS[Zone~] / aMax * ySlide,			0,										UnID, aTiltS[Zone~], 7	: UnID = UnID + 1

	add 0, LeafBoxB - xHinge - aTiltS[Zone~] / aMax * ySlide, yHinge 	 	!HINGE
		rotx -aTiltS[Zone~]
	add 0, -LeafBoxB + xHinge, -yHinge 									!HINGE

	gosub iSashType

!------------size control------------------------------------------------------------------

	call "SizeCtrl_WMCC" parameters all \
		bDebug 			= 0,
		iOptype 		= iOpeningType, 
		iProfile		= iSelectableProfiles[PROF_SASH][1],
		iLogic 			= 3,
		UnID			= UnID,
		returned_parameters UnID, x1, y1, x2, y2, x3, y3, x4, y4

		minW = minW + x1
		maxW = maxW + x2
		minH = minH + y1
		maxH = maxH + y2
		
		xWarnMin = xWarnMin + x3
		xWarnMax = xWarnMax + x4
		yWarnMin = yWarnMin + y3
		yWarnMax = yWarnMax + y4

!!!------------ handle - currently unused -----------------------------------------------------------------------
!!
!!	if	(GLOB_SCRIPT_TYPE = 2 and iDetLevel2D < DETLEVEL_2D_50) \
!!	|	(GLOB_SCRIPT_TYPE = 3 and iDetLevel3D < DETLEVEL_3D_50) \
!!	then
!!		call "Handle_WMCC" parameters all \
!!			iOpeningType	= iOpeningType,
!!			LeafBoxA		= LeafBoxA,
!!			LeafBoxB		= LeafBoxB,
!!			zHandle			= -gs_sash_thk + zO,
!!			xMinP			= 0			+ xMinimalHandleDistFromCorners,
!!			xMaxP			= LeafBoxB	- xMinimalHandleDistFromCorners,
!!			aTiltS			= aTiltS[Zone~],
!!			UnID			= UnID,
!!			returned_parameters 	UnID
!!	endif
return


20006:	!Side-hung sliding mechanics
!circle2 0,0, .01 	: hotspot2 0,0 		: line2 0,0, 0,1 	: line2 0,0, 1,0
!sphere 0.1 		: lin_ 0,0,0, 0,1,0 : lin_ 0,0,0, 1,0,0 : lin_ 0,0,0, 0,0,1
	dHot	= LeafBoxA - 0.038	! hotspot distance
	iMulOri	= (xMul * iInwardsOpening > 0)

	add  leafDLeft, leafDLower, 0
	add2 leafDLeft, 0

	!Opening hotspots
		add2 xHinge, yHinge
		add xHinge, 0, yHinge
			hotspot2 dHot,							0,													UnID, aOpeningS2D[Zone~], 4+128			: UnID = UnID + 1
			hotspot2 dHot * cos (aOpeningS2D[Zone~]),	-iInwardsOpening * (dHot * sin(aOpeningS2D[Zone~])),	UnID, aOpeningS2D[Zone~], 5				: UnID = UnID + 1
			hotspot2 0,								0,													UnID, aOpeningS2D[Zone~], 6 + iMulOri * 512	: UnID = UnID + 1

			hotspot dHot + xHinge,					LeafBoxB/2,								yD + yHinge,					UnID, aOpeningS3D[Zone~], 4+128	: UnID = UnID + 1
			hotspot dHot * cos (aOpeningS3D[Zone~]),	LeafBoxB/2, -iInwardsOpening * (dHot * sin(aOpeningS3D[Zone~])+yHinge),	UnID, aOpeningS3D[Zone~], 5		: UnID = UnID + 1
			hotspot 0 + xHinge,						LeafBoxB/2, 							yD + yHinge,					UnID, aOpeningS3D[Zone~], 6 		: UnID = UnID + 1
			hotspot 0 + xHinge,						LeafBoxB/2 - xMul * iInwardsOpening,	yD + yHinge,					UnID, aOpeningS3D[Zone~], 7		: UnID = UnID + 1
		del 1

		add2 xHinge + xSlide * aOpeningS2D[Zone~] / 90, 		yHinge 		!HINGE
		add  xHinge + xSlide * aOpeningS3D[Zone~] / 90, 0, 	yHinge	 	!HINGE

			rot2 -iInwardsOpening * aOpeningS2D[Zone~]
			roty iInwardsOpening * aOpeningS3D[Zone~]

		add2 -xHinge, 		-yHinge 	!HINGE
		add  -xHinge, 0, 	-yHinge 	!HINGE

		gosub iSashType

!------------size control------------------------------------------------------------------

	call "SizeCtrl_WMCC" parameters all \
		bDebug 			= 0,
		iOptype 		= iOpeningType, 
		iProfile		= iSelectableProfiles[PROF_SASH][1],
		iLogic 			= 3,
		UnID			= UnID,
		returned_parameters UnID, x1, y1, x2, y2, x3, y3, x4, y4

		minW = minW + x1
		maxW = maxW + x2
		minH = minH + y1
		maxH = maxH + y2
		
		xWarnMin = xWarnMin + x3
		xWarnMax = xWarnMax + x4
		yWarnMin = yWarnMin + y3
		yWarnMax = yWarnMax + y4

!!!------------ handle - currently unused -----------------------------------------------------------------------
!!
	if	(GLOB_SCRIPT_TYPE = 2 and iDetLevel2D < DETLEVEL_2D_50) \
	|	(GLOB_SCRIPT_TYPE = 3 and iDetLevel3D < DETLEVEL_3D_50) \
	then
		call "Handle_WMCC" parameters all \
			iOpeningType	= iOpeningType,
			LeafBoxA		= LeafBoxA,
			LeafBoxB		= LeafBoxB,
			zHandle			= -gs_sash_thk + zO,
			xMinP			= 0			+ xMinimalHandleDistFromCorners,
			xMaxP			= LeafBoxB	- xMinimalHandleDistFromCorners,
			aTiltS			= 0,
			UnID			= UnID,
			returned_parameters 	UnID
	endif
return


20007:	! Composite mechanics
	parameters iOpeningTypeS = iOpeningTypeS

	if Zone~ < 2 then Zone~ = 2	! Against infinite loops

	add2 -LeafBoxA/2, 		0
	add  -LeafBoxA/2, 0,	0

		bFirstSide		= 1
		iProfileT		= PT_FRAME
	
		if isFrameMirrored then
			mul2 1,	-1
			mulz 	-1		
	
			add2 0,		gs_frame_thk + zMoveLeaf
			add	 0,	0,	gs_frame_thk + zMoveLeaf
		endif

			gosub iFrameProfile

		if isFrameMirrored then del 2
	del 1

!-----------------------------------------------

	leafDLeft	= yProf1  - InnerOffset
	leafDRight	= yProf1  - InnerOffset
	leafDLower	= yProf1  - InnerOffset
	leafDUpper	= yProf1  - InnerOffset

!----------------------------

	bDrawFrame = 0

	_Z~ = Zone~

	gosub OPTYPE_BASE + iOpeningTypes[Zone~]							!TODO to update the caller objects, 10100/10101

	iOpeningType = iOpeningTypes[_Z~]									!Small hack to skip through glazing, there is an if + goto there
return


20008:	!Vertical pivot mechanics
!Moving part of opening stuff, just the mechanics: all side and bottom hung stuff opens here

!circle2 0,0, .01 : hotspot2 0,0 : line2 0,0, 0,1 : line2 0,0, 1,0
!sphere 0.1 : lin_ 0,0,0, 0,1,0 : lin_ 0,0,0, 1,0,0 : lin_ 0,0,0, 0,0,1

	leafDLower = 0.03					!TODO

	add  leafDLeft, leafDLower, 0
	add2 leafDLeft, 			0

	add  xHinge, 0,	yHinge 	 			!HINGE
	add2 xHinge,	yHinge 	 			!HINGE

	!Opening hotspots
	if iInwardsOpening > 0 then
		if wido_reveal_side > EPS then zNormal = LeafBoxB else zNormal = 0

		hotspot LeafBoxA, 										LeafBoxB/2, 0,												UnID, aOpeningS3D[Zone~], 4	: UnID = UnID + 1
		hotspot cos(aOpeningS3D[Zone~]) * (LeafBoxA - xHinge),	LeafBoxB/2, -sin(aOpeningS3D[Zone~]) * (LeafBoxA - xHinge),	UnID, aOpeningS3D[Zone~], 5	: UnID = UnID + 1
		hotspot 0, 												LeafBoxB/2, 0,												UnID, aOpeningS3D[Zone~], 6	: UnID = UnID + 1
		hotspot 0, 												zNormal,	0,												UnID, aOpeningS3D[Zone~], 7	: UnID = UnID + 1

		hotspot2 LeafBoxA, 										0,												UnID, aOpeningS2D[Zone~], 4		: UnID = UnID + 1
		hotspot2 cos(aOpeningS2D[Zone~]) * (LeafBoxA - xHinge),	-sin(aOpeningS2D[Zone~]) * (LeafBoxA - xHinge),	UnID, aOpeningS2D[Zone~], 5		: UnID = UnID + 1
		hotspot2 0, 											0,	 											UnID, aOpeningS2D[Zone~], 6 + 512	: UnID = UnID + 1
	else
		if wido_reveal_side > EPS then zNormal = 0 else zNormal = LeafBoxB 

		mulx -1
		mul2 -1, 1

			hotspot LeafBoxA, 							LeafBoxB/2, 0,									UnID, aOpeningS3D[Zone~], 4	: UnID = UnID + 1
			hotspot cos(aOpeningS3D[Zone~]) * (xHinge),	LeafBoxB/2, sin(aOpeningS3D[Zone~]) * (xHinge),	UnID, aOpeningS3D[Zone~], 5	: UnID = UnID + 1
			hotspot 0, 									LeafBoxB/2, 0, 									UnID, aOpeningS3D[Zone~], 6	: UnID = UnID + 1
			hotspot 0, 									zNormal,	0,									UnID, aOpeningS3D[Zone~], 7	: UnID = UnID + 1
	
			hotspot2 LeafBoxA, 							0,										UnID, aOpeningS2D[Zone~], 4	: UnID = UnID + 1
			hotspot2 cos(aOpeningS2D[Zone~]) * (xHinge),	sin(aOpeningS2D[Zone~]) * (xHinge),	UnID, aOpeningS2D[Zone~], 5	: UnID = UnID + 1
			hotspot2 0, 								0,								 		UnID, aOpeningS2D[Zone~], 6	: UnID = UnID + 1
		del 1
	endif

	rot2 -aOpeningS2D[Zone~]
	roty  aOpeningS3D[Zone~]

	add  -xHinge, 0,	-yHinge 		!HINGE
	add2 -xHinge, 		-yHinge 	 	!HINGE

!	call "Handle_WMCC" parameters all \
!		iOpeningType	= iOpeningType,
!		LeafBoxA		= LeafBoxA,
!		LeafBoxB		= LeafBoxB,
!		zHandle			= -gs_sash_thk,
!		xMinP			= 0			+ xMinimalHandleDistFromCorners,
!		xMaxP			= LeafBoxB	- xMinimalHandleDistFromCorners,
!		aTiltS			= aTiltS[Zone~],
!		returned_parameters 	UnID

	if GLOB_SCRIPT_TYPE = 2 then
		!Drawing the frame, Only 2D, hinge side
		bFirstSide = 1											!For asymmetrical profiles
		gosub iSashProfile
	endif

	!Drawing the frame, 3D/2D handle side
		add2 LeafBoxA, 0
		mul2 -1, 1
			bFirstSide = 0
			gosub iSashProfile

	if GLOB_SCRIPT_TYPE = 2 then
		OffsetGBot	= OffsetGBot - OffsetBot					!Correcting double addition (in 2D the profile is called twice)
		OffsetGTop	= OffsetGTop - Offset
		OffsetGR	= OffsetGR   - Offset
		OffsetGL	= OffsetGL   - Offset

		del 2
	endif
return


20009:	!Tilt & slide mechanics
!TODO
!sphere 0.1 : lin_ 0,0,0, 0,1,0 : lin_ 0,0,0, 1,0,0 : lin_ 0,0,0, 0,0,1
	xStop1 = -LeafBoxA/10
	xStop2 = -LeafBoxA/5

	if xMul > 0 then
	!Opening hotspots
		hotspot 0,						LeafBoxB/2, 0,	UnID, xOpeningS3D[Zone~], 1 : UnID = UnID + 1
		hotspot -xOpeningS3D[Zone~],	LeafBoxB/2, 0,	UnID, xOpeningS3D[Zone~], 2 : UnID = UnID + 1
		hotspot 1,						LeafBoxB/2, 0,	UnID, xOpeningS3D[Zone~], 3 : UnID = UnID + 1
	
		hotspot -xStop1,				LeafBoxB/2, 0
		hotspot -xStop2,				LeafBoxB/2, 0
	endif

	if	xOpeningS3D[Zone~] >= xStop1 \
	then
		xDelta1	= 0
		xDelta2	= xStop1
		beta  = -aOpeningMax* (1 - (min (xOpeningS3D[Zone~], 0) - (xDelta1)) / (xDelta2 - xDelta1))

		rotx -aOpeningMax
		addy leafBoxB
		rotx -beta
		addy -leafBoxB
	endif

	if 	xOpeningS3D[Zone~] <  xStop1 \
	&	xOpeningS3D[Zone~] >= xStop2 \
	then
		xDelta1	= xStop1
		xDelta2	= xStop2
		beta  = -aOpeningMax* (1 - (xOpeningS3D[Zone~] - (xDelta1)) / (xDelta2 - xDelta1))

		rotx beta
	endif

	xOpeningS3D[Zone~] = max( min(xOpeningS3D[Zone~], LeafBoxA), xStop2)

	add  -max( min(xOpeningS3D[Zone~], LeafBoxA), 0), 0, 	0
	add2 -max( min(xOpeningS3D[Zone~], LeafBoxA), 0),		0

	gosub iSashType

!!	call "Handle_WMCC" parameters all \
!!		iOpeningType	= iOpeningType,
!!		LeafBoxA		= LeafBoxA,
!!		LeafBoxB		= LeafBoxB,
!!		zHandle			= -gs_sash_thk,
!!		xMinP			= 0			+ xMinimalHandleDistFromCorners,
!!		xMaxP			= LeafBoxB	- xMinimalHandleDistFromCorners,
!!		aTiltS			= -beta,
!!		UnID			= UnID,
!!		returned_parameters 	UnID
return


!:	!Sliding-folding MP
!!circle2 0,0, .01	: hotspot2 0,0		: line2 0,0, 0,1	: line2 0,0, 1,0
!!sphere 0.01 : lin_ 0,0,0, 0,1,0 : lin_ 0,0,0, 1,0,0 : lin_ 0,0,0, 0,0,1 : hotspot 0,0,0
!
!	add2 -LeafBoxA/2,		0
!	add  -LeafBoxA/2, 0,	0
!
!		!Fix part
!		iProfileT = PT_FRAME
!		gosub iFrameProfile
!
!		leafDLeft	= yProf1 - InnerOffset															!LeafBox size set by Frame Profile
!		LeafDRight	= yProf2 - InnerOffset
!		LeafDLower	= yProf1 - InnerOffset
!		leafDUpper	= yProf2 - InnerOffset
!
!		if GLOB_SCRIPT_TYPE = 2 then
!			!other side in 2D
!			add2 LeafBoxA, 0
!			mul2 -1, 1
!				gosub iFrameProfile
!			del 2
!		endif
!	del 1
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!	iLeafs = iArray[NR_OF_LEAFS][1]
!	iEndleafs = 1
!	if iOpeningType = OPTYPE_DOUBLE_SIDE_HUNG then iEndleafs = 2
!
!	!Opening part
!
!	add	 - LeafBoxA / 2 + LeafDLeft, LeafDlower, 0
!	add2 - LeafBoxA / 2 + LeafDLeft, 0
!
!	gosub "RecalculateLeafBox"
!
!	LeafBoxSmall					= LeafBoxA / iLeafs												!Only the x dist between the two hinges
!	aPhi							= atn(abs(yHingeOtherSide - yHinge) / (LeafBoxSmall))			!Diagonal angle of the two hinges connecting line
!	dTemp							= sqr((LeafBoxSmall) ** 2 + (yHingeOtherSide - yHinge) ** 2)	!Length of the two hinges connecting line
!
!	hotspot 0,							0.1, EPS,	UnID, xOpeningS3D[Zone~], 1 : UnID = UnID + 1
!	hotspot xOpeningS3D[Zone~],	0.1, EPS,	UnID, xOpeningS3D[Zone~], 2 : UnID = UnID + 1
!	hotspot -1,							0.1, EPS,	UnID, xOpeningS3D[Zone~], 3 : UnID = UnID + 1
!
!	hotspot2 0,										0,	UnID, xOpeningS3D[Zone~], 1 : UnID = UnID + 1
!	hotspot2 xOpeningS3D[Zone~],				0,	UnID, xOpeningS3D[Zone~], 2 : UnID = UnID + 1
!	hotspot2 -1,									0,	UnID, xOpeningS3D[Zone~], 3 : UnID = UnID + 1
!
!	xOpeningS3D[Zone~] = max(min(LeafBoxA * (iLeafs - iEndleafs)/iLeafs, xOpeningS3D[Zone~]), (iLeafs - iEndleafs) * abs(yHingeOtherSide - yHinge))
!	xDelta							= (xOpeningS3D[Zone~] / (iLeafs - iEndleafs))
!
!	if LeafBoxSmall > xDelta + EPS then																!Nonlinear behaviour
!		aOpeningS3D[Zone~]	= acs(xDelta/dTemp) + aPhi
!		aOpeningS2D[Zone~]	= acs(xDelta/dTemp) + aPhi
!	else
!		aOpeningS3D[Zone~]	= 0
!		aOpeningS2D[Zone~]	= 0
!	endif
!
!	for i = 1 to int(iLeafs - 1) / 2
!		add	 (i-1) * 2 * xDelta, 0, 0
!		add2 (i-1) * 2 * xDelta, 	0
!			if i = 1 then 																			!Hinge pos at frame differs
!				xHingeTemp		= xHingeFrame
!				xOverLapStart	= 0
!				addx 0
!				add2 0, 0
!			else 
!				xHingeTemp		= xHinge
!				xOverLapStart	= xOverLapLeft 
!				addx -xOverLapLeft
!				add2 -xOverLapLeft, 0
!			endif
!
!			CALL "Leaf_WMCC" Parameters	all \
!					UnID					= UnID,
!					iOpeningType			= SLIDING_FOLDING_FIRST_SASH,
!					iInwardsOpening 		= 1,
!					aTiltS					= 0,
!					bBottomHung				= 0,
!					LeafBoxA				= LeafBoxSmall + xOverLapStart + xOverLapRight,
!					LeafBoxB				= LeafBoxB,
!					leafDLower				= 0,
!					leafDLeft 				= 0,													!resetting LeafDLeft since it has been used by now
!					aOpeningS3D				= aOpeningS3D,
!					aOpeningS2D				= aOpeningS2D,
!					xHinge					= xHingeTemp,
!					yHinge					= yHinge,
!					returned_parameters 	x1, y1, x2, y2, x3, y3, x4, y4,				!size controls
!										Zone~, iMullionPointer, xMullionPos, UnID
!		del 2
!
!		add	 (i) * 2 * xDelta + xOverLapRight, 0,	0
!		add2 (i) * 2 * xDelta + xOverLapRight, 		0
!	
!		mul2 -1, 1
!		mul -1, 1, 1
!			CALL "Leaf_WMCC" Parameters	all \
!					UnID					= UnID,
!					iOpeningType			= SLIDING_FOLDING_SECOND_SASH,
!					iInwardsOpening 		= 1,
!					aTiltS					= 0,
!					bBottomHung				= 0,
!					LeafBoxA				= LeafBoxSmall + xOverLapLeft + xOverLapRight,
!					LeafBoxB				= LeafBoxB,
!					leafDLower				= 0,
!					leafDLeft 				= 0,										! resetting LeafDLeft since it has been used by now
!					xHinge					= xHinge,
!					yHinge					= yHinge,
!					returned_parameters 	x1, y1, x2, y2, x3, y3, x4, y4,				! size controls
!										Zone~, iMullionPointer, xMullionPos, UnID
!		del 2
!	next i
!
!	!----------------------------------------Last leaf--------------------------------------------
!
!	Zone~ = Zone~ + 1
!	if	iOpeningType = OPTYPE_SIDE_HUNG \
!	|	iOpeningType = OPTYPE_DOUBLE_SIDE_HUNG \
!	then
!		add	 (i-1) * 2 * xDelta - xOverLapLeft, 0,	0
!		add2 (i-1) * 2 * xDelta - xOverLapLeft, 	0
!			CALL "Leaf_WMCC" Parameters	all \
!					UnID					= UnID,
!					iOpeningType			= DOUBLE_FIRST_SASH,
!					iInwardsOpening 		= 1,
!					aTiltS					= 0,
!					bBottomHung				= 0,
!					LeafBoxA				= LeafBoxSmall + xOverLapLeft,
!					LeafBoxB				= LeafBoxB,
!					leafDLower				= 0,
!					leafDLeft 				= 0,										! resetting LeafDLeft since it has been used by now
!					xHinge					= xHinge,
!					yHinge					= yHinge,
!					Zone~			= Zone~,
!					returned_parameters 	x1, y1, x2, y2, x3, y3, x4, y4,				! size controls
!										Zone~, iMullionPointer, xMullionPos, UnID
!		del 1
!	endif
!
!	if	iOpeningType = OPTYPE_SIDE_HUNG_M \
!	|	iOpeningType = OPTYPE_DOUBLE_SIDE_HUNG \
!	then
!		add	 LeafBoxA - xOverLapLeft,	0,	0
!!		add2 (i-1) * 2 * xDelta - xOverLapLeft + LeafBoxSmall,	0
!		add2 LeafBoxA - xOverLapLeft,		0
!
!		if iOpeningType = OPTYPE_SIDE_HUNG_M then
!			iOpeningType = DOUBLE_FIRST_SASH
!		else
!			iOpeningType = DOUBLE_SECOND_SASH
!		endif
!		mul  -1,1,	1
!		mul2 -1,	1
!			CALL "Leaf_WMCC" Parameters	all \
!					UnID					= UnID,
!					iOpeningType			= iOpeningType,
!					iInwardsOpening 		= 1,
!					aTiltS					= 0,
!					bBottomHung				= 0,
!					LeafBoxA				= LeafBoxSmall + xOverLapStart,
!					LeafBoxB				= LeafBoxB,
!					leafDLower				= 0,
!					leafDLeft 				= 0,										! resetting LeafDLeft since it has been used by now
!					xHinge					= xHinge,
!					yHinge					= yHinge,
!					Zone~			= Zone~,
!					returned_parameters 	x1, y1, x2, y2, x3, y3, x4, y4,				! size controls
!										Zone~, iMullionPointer, xMullionPos, UnID
!		del 2
!	endif
!end	iLeafs * x1, y1, iLeafs * x2, y2, iLeafs * x3, y3, iLeafs * x4, y4,				!size controls
!										Zone~, iMullionPointer, xMullionPos, UnID
!return


20010:	! MECHA_SLIDE
!circle2 0,0, .01	: hotspot2 0,0		: line2 0,0, 0,1	: line2 0,0, 1,0
!sphere 0.01 		: lin_ 0,0,0, 0,2,0	: lin_ 0,0,0, 1,0,0	: lin_ 0,0,0, 0,0,1
	add  leafDLeft, leafDLower,	0
	add2 leafDLeft,				0

	if isPositiveDirection = 1 then _dir = 1 else _dir = -1

		if xOpeningS3D[Zone~] > LeafBoxB	then xOpeningS3D[Zone~] = LeafBoxB
		if xOpeningS3D[Zone~] < 0			then xOpeningS3D[Zone~] = 0

		!Opening hotspots
		if 	isVerticalSliding then
			hotspot LeafBoxA/2,	0,							yHinge,	UnID, xOpeningS3D[Zone~], 1	: UnID = UnID + 1
			hotspot LeafBoxA/2,	_dir * xOpeningS3D[Zone~],	yHinge,	UnID, xOpeningS3D[Zone~], 2	: UnID = UnID + 1
			hotspot LeafBoxA/2,	-1,							yHinge, UnID, xOpeningS3D[Zone~], 3	: UnID = UnID + 1

			add 	0,	_dir * xOpeningS3D[Zone~],	0
			add2	0,								0
		else
			hotspot 0,							LeafBoxB/2,	yHinge,	UnID, xOpeningS3D[Zone~], 1	: UnID = UnID + 1
			hotspot _dir * xOpeningS3D[Zone~],	LeafBoxB/2,	yHinge,	UnID, xOpeningS3D[Zone~], 2	: UnID = UnID + 1
			hotspot -1,							LeafBoxB/2,	yHinge, UnID, xOpeningS3D[Zone~], 3	: UnID = UnID + 1

			hotspot2 0,							LeafBoxB/2,			UnID, xOpeningS2D[Zone~], 1	: UnID = UnID + 1
			hotspot2 _dir * xOpeningS2D[Zone~],	LeafBoxB/2,			UnID, xOpeningS2D[Zone~], 2	: UnID = UnID + 1
			hotspot2 -1,						LeafBoxB/2,			UnID, xOpeningS2D[Zone~], 3	: UnID = UnID + 1

			add 	_dir * xOpeningS3D[Zone~],	0,	0
			add2	_dir * xOpeningS2D[Zone~],		0
		endif

		gosub iSashType

!------------size control------------------------------------------------------------------

	call "SizeCtrl_WMCC" parameters all \
		bDebug 			= 0,
		iOptype 		= iOpeningType, 
		iProfile		= iSelectableProfiles[PROF_SASH][1],
		iLogic 			= 3,
		UnID			= UnID,
		returned_parameters UnID, x1, y1, x2, y2, x3, y3, x4, y4

		minW = minW + x1
		maxW = maxW + x2
		minH = minH + y1
		maxH = maxH + y2
		
		xWarnMin = xWarnMin + x3
		xWarnMax = xWarnMax + x4
		yWarnMin = yWarnMin + y3
		yWarnMax = yWarnMax + y4

!!!------------ handle - currently unused -----------------------------------------------------------------------
!!
!!	if bFirstSash > EPS and \
!!	   (GLOB_SCRIPT_TYPE = 2 and iDetLevel2D < DETLEVEL_2D_50) or \
!!	   (GLOB_SCRIPT_TYPE = 3 and iDetLevel3D < DETLEVEL_3D_50)    \
!!	|	GLOB_CONTEXT = 23 \
!!	then
!!		yHandle			= OffsetGR + yGlazingBead - yHandleOffset
!!
!!		call "Handle_WMCC" parameters all \
!!			iOpeningType	= iOpeningType,
!!			LeafBoxA		= LeafBoxA,
!!			LeafBoxB		= LeafBoxB,
!!			zHandle			= -gs_sash_thk + zO,
!!			yHandle			= yHandle,
!!			xMinP			= 0			+ xMinimalHandleDistFromCorners,
!!			xMaxP			= LeafBoxB	- xMinimalHandleDistFromCorners,
!!			aTiltS			= aTiltS[Zone~],
!!			UnID			= UnID,
!!			zProfile		= gs_sash_thk,
!!			isInnerSide		= iInwardsOpening < 0,
!!			iLeafProfile	= iSelectableProfiles[PROF_SASH][Zone~],
!!			mulHandleZ		= mulHandleZ,
!!			returned_parameters 	UnID
!!
!!		if bDoor then
!!			mulz -1
!!			mul2 1, -1
!!	
!!			addz gs_sash_thk
!!			add2 0, gs_sash_thk
!!				call "Handle_WMCC" parameters all \
!!					iOpeningType	= iOpeningType,
!!					LeafBoxA		= LeafBoxA,
!!					LeafBoxB		= LeafBoxB,
!!					zHandle			= -gs_sash_thk - zO,
!!					yHandle			= yHandle,
!!					xMinP			= 0			+ xMinimalHandleDistFromCorners,
!!					xMaxP			= LeafBoxB	- xMinimalHandleDistFromCorners,
!!					UnID			= UnID,
!!					isInnerSide		= iInwardsOpening > 0,
!!					iLeafProfile	= iSelectableProfiles[PROF_SASH][Zone~],
!!					mulHandleZ		= mulHandleZ,
!!					returned_parameters 	UnID
!!			del 2
!!		endif
!!	endif
return


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! /MECHANICS /MECHANICS /MECHANICS /MECHANICS /MECHANICS /MECHANICS /MECHANICS /MECHANICS 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES PROFILES 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

30000:
!!! Frame commons
	yProf1 = gs_frame_width
	zMax = gs_frame_thk
return


30001:
!!! Sash commons
	yProf1 = gs_sash_width
	zMax = gs_sash_thk
return


30002:
!Mullion commmons
	yProf1 = gs_frame_width / 2
	yProf2 = gs_frame_width
	zMax = gs_frame_thk
return


30003:
!Bottom profile
	yProf1 = gs_fw_lower
	zMax = gs_sash_thk
return


30004:
! Frame -> leaf sealant conversion for fixed windows
	iProfileT		= PT_NONE
	yProf1			= InnerOffset
	zOffset 		= zOffset + gs_frame_thk - gs_sash_thk + zMoveLeaf
	gs_sash_thk		= gs_frame_thk - zFrameOffset + zMoveLeaf

!	if iOpeningTypes[Zone~]	= OPTYPE_FIXED then zOffset = zOffset + zMoveLeaf

!	gosub 30005
return


30005:
! Pivot side changing additional profile
	yProf1 = InnerOffset + OuterOffset
return

30006:
! Mullion for sliding door fix zones
	yProf1 = gs_sash_width / 2
	yProf2 = gs_sash_width / 2
	zMax = gs_frame_thk / 2
return

30007:
! Sash for sliding door fix zones
	yProf1 = gs_sash_width
	zMax = gs_frame_thk / 2
return

30009:
! I profile
	yProf1 = -xOverLapLeft - xOverLapright
return

!-----------------------------------!-----------------------------------!-----------------------------------!-----------------------------------
!-----------------------------------!-----------------------------------!-----------------------------------!-----------------------------------
!-----------------------------------!-----------------------------------!-----------------------------------!-----------------------------------

30012:	!All mullions
!DO NOT DELETE IT
!print iSelectableProfiles[PROF_MULLION][i], i
	gosub iSelectableProfiles[PROF_MULLION][i]

	gosub iMullionOrientation
return

!-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  Selectable alternatives  Selectable alternatives  Selectable alternatives  Selectable alternatives  Selectable alternatives  Selectable alternatives  Selectable alternatives
!-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

!-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  Selectable alternatives  Selectable alternatives  Selectable alternatives  Selectable alternatives  Selectable alternatives  Selectable alternatives  Selectable alternatives
!-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

!-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
!  Selectable alternatives  Selectable alternatives  Selectable alternatives  Selectable alternatives  Selectable alternatives  Selectable alternatives  Selectable alternatives
!-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

!---------------------------------------------------------------------------------------------------------------------------------------
!  Threshold selectable alternatives, fix part  Threshold selectable alternatives, fix part  Threshold selectable alternatives, fix part  
!---------------------------------------------------------------------------------------------------------------------------------------



!----------------------------------------------------------------------------------------------------------------------------------------------------------------
!  Threshold related leaf bottom profiles  Threshold related leaf bottom profiles  Threshold related leaf bottom profiles  Threshold related leaf bottom profiles
!----------------------------------------------------------------------------------------------------------------------------------------------------------------


!!---------------------------------------------------------------------------------------------------------
!! /Threshold selectable alternatives /Threshold selectable alternatives /Threshold selectable alternatives
!!---------------------------------------------------------------------------------------------------------
!
!
!!---------------------------------------------------------------------------------------------------------
!!  Additional profiles  Additional profiles  Additional profiles  Additional profiles  Additional profiles
!!---------------------------------------------------------------------------------------------------------


!-------------------outwards opeining thresholds----------------------------------------------------------------------------------------------------



!--------------------sash/leaf schemas------------------------------------------------------------------------------------------------------------

!--------------------sash/leaf schemas------------------------------------------------------------------------------------------------------------

!--------------------sash/leaf schemas------------------------------------------------------------------------------------------------------------

!These are prewritten sashes/leafs. Profiles set their intersections for themselves based on their own geometry

60000:	!MITER_SASH_FIXED
	if Zone~ > 1 then gs_frame_thk = gs_frame_thk + zFrameOffset						! Since this is moved in 20001

!	yprof1 = 2 * yGlazingBead - 0.005	!????	DETAILED

	dim ProfArr[][]
	PN = 1
!print str(iSelectableProfiles[PROF_SASH][Zone~], 10, 0), gs_sash_thk
	gosub iSelectableProfiles[PROF_SASH][Zone~]

	if GLOB_SCRIPT_TYPE = 2 then
		PUT 0,			0,	 1
		PUT LeafBoxA,	0,	-1
	endif

	if GLOB_SCRIPT_TYPE = 3 then
		PUT LeafBoxA - 1,	0,				0.000, 0
		PUT LeafBoxA,		0,				0.000, 0
		PUT LeafBoxA,		LeafBoxB, 		0.000, 0
		PUT 0,				LeafBoxB, 		0.000, 0
		PUT 0,				0,	 			0.000, 0
		PUT LeafBoxA,		0,	 			0.000, 0
		PUT LeafBoxA,		0 + 1,			0.000, 0
	endif
	
	gosub "PlaceFrameGroup"

	if	GLOB_SCRIPT_TYPE = 2 & iDetLevel2D = DETLEVEL_2D_50 \
	|	GLOB_SCRIPT_TYPE = 3 & iDetLevel3D = DETLEVEL_3D_50 \
	then
		yProf1 = yGlazingBead
	endif

	if	GLOB_SCRIPT_TYPE = 2 & iDetLevel2D = DETLEVEL_2D_100 \
	|	GLOB_SCRIPT_TYPE = 3 & iDetLevel3D = DETLEVEL_3D_100 \
	then
		yProf1 = 0
	endif

	OffsetGTop	= yProf1 - yGlazingBead
	OffsetGL	= yProf1 - yGlazingBead
	OffsetGR	= yProf1 - yGlazingBead
	OffsetGBot	= yProf1 - yGlazingBead
return


60001:	!MITER_SASH_TYPE_O	!All the 4 profiles are the same, all cuts are 45 deg
	!Hinge/upper profile

	iProfileT = PT_SASH
	yProf1 = gs_sash_width													! init and if there is a profile it overwrites this

	bOnlyOffsetData = 1														! getting glassOffsets for cutting neighboring profiles (by setting start/end offsets)
!print str(iSelectableProfiles	[PROF_SASH][Zone~], 10, 0)
		gosub iSelectableProfiles	[PROF_SASH][Zone~]
		glassOffsets				[PROF_SASH]	= yProf1 - yGlazingBead

		if	iSelectableProfiles	[PROF_BOTTOM][Zone~] > 0 \
		then
!print str(iSelectableProfiles	[PROF_BOTTOM][Zone~], 10, 0)
			gosub iSelectableProfiles	[PROF_BOTTOM][Zone~]
			glassOffsets				[PROF_BOTTOM]	= glassOffsets [PROF_SASH] + yProf1
			_yMoveBottom								= yProf1
		else
			glassOffsets				[PROF_BOTTOM]	= glassOffsets [PROF_SASH]
			_yMoveBottom								= 0
		endif
	bOnlyOffsetData = 0

!print str(iSelectableProfiles[PROF_SASH][Zone~], 10, 0)
	gosub iSelectableProfiles[PROF_SASH][Zone~]

	OffsetGTop	= glassOffsets	[PROF_SASH]
	OffsetGL	= glassOffsets	[PROF_SASH]
	OffsetGR	= glassOffsets	[PROF_SASH]
	OffsetGBot	= glassOffsets	[PROF_BOTTOM]

	if GLOB_SCRIPT_TYPE = 2 then
		PUT 0,			0,	 1
		PUT LeafBoxA,	0,	-1
	endif

	if GLOB_SCRIPT_TYPE = 3 then
!--------Vertical profiles for texture mapping!--------
		isTextMapVert = 1

		PUT LeafBoxA - 1,	_yMoveBottom,				0.000, 0
		PUT LeafBoxA,		_yMoveBottom,				0.000, 0
		PUT LeafBoxA,		LeafBoxB, 					0.000, 0
		PUT LeafBoxA - 1,	LeafBoxB, 					0.000, 0
		gosub "PlaceFrameGroup"

		gosub iSelectableProfiles[PROF_SASH][Zone~]
		PUT 0 + 1,			LeafBoxB, 					0.000, 0
		PUT 0,				LeafBoxB, 					0.000, 0
		PUT 0,				_yMoveBottom,	 			0.000, 0
		PUT 0 + 1,			_yMoveBottom,	 			0.000, 0
		gosub "PlaceFrameGroup"

!--------Horizontal profiles for texture mapping!--------
		isTextMapVert = 0

		gosub iSelectableProfiles[PROF_SASH][Zone~]
		PUT LeafBoxA,		LeafBoxB - 1, 				0.000, 0
		PUT LeafBoxA,		LeafBoxB, 					0.000, 0
		PUT 0,				LeafBoxB, 					0.000, 0
		PUT 0,				LeafBoxB - 1, 				0.000, 0
		gosub "PlaceFrameGroup"

		gosub iSelectableProfiles[PROF_SASH][Zone~]
		PUT 0,				_yMoveBottom + 1, 			0.000, 0
		PUT 0,				_yMoveBottom, 				0.000, 0
		PUT LeafBoxA,		_yMoveBottom, 				0.000, 0
		PUT LeafBoxA,		_yMoveBottom + 1,			0.000, 0
	endif

	gosub "PlaceFrameGroup"

	!---------------------------------------------------------------
	!Bottom profiles

	iProfileT = PT_NONE
!print str(iSelectableProfiles[PROF_BOTTOM][Zone~], 10, 0)
	if	GLOB_SCRIPT_TYPE = 3 \
	&	iSelectableProfiles[PROF_BOTTOM][Zone~] \
	then
		OuterD1 = 0
		OuterD2 = 0
		InnerD1 = 0
		InnerD2 = -InnerOffset - InnerOffset
		MiddleD = 0

		gosub iSelectableProfiles	[PROF_BOTTOM][Zone~]

		PUT 0 - 1,										0,		0, 0
		PUT 0			+ InnerOffset + InnerOffset,	0,		0, 0
		PUT LeafBoxA	- InnerOffset - InnerOffset,	0,		0, 0
		PUT LeafBoxA + 1,								0,		0, 0
	
		gosub "PlaceFrameGroup"
	endif

!!	!---- C profile: sealant between frame and leaf that is missing at middle pos ----
!!	iProfileT = PT_NONE
!!
!!	if iSelectableProfiles[PROF_C][Zone~] \
!!	&	((GLOB_SCRIPT_TYPE = 3 & iDetLevel3D = DETLEVEL_3D_10) \
!!	|	 (GLOB_SCRIPT_TYPE = 2 & iDetLevel3D = DETLEVEL_2D_10)) \
!!	then
!!!print str(iSelectableProfiles[PROF_C][Zone~], 10, 0)
!!		gosub iSelectableProfiles[PROF_C][Zone~]
!!
!!		if GLOB_SCRIPT_TYPE = 3 then
!!			if iSashType = MITER_SASH_TYPE_O then
!!				if isCProfileAtBottom then
!!					PUT LeafBoxA - 1,	_yMoveBottom, 			0.000, 0
!!				else
!!					PUT LeafBoxA,		_yMoveBottom - 1, 		0.000, 0
!!				endif
!!
!!				PUT LeafBoxA,			_yMoveBottom,			0.000, 0
!!				PUT LeafBoxA,			LeafBoxB, 				0.000, 0
!!				PUT 0,					LeafBoxB, 				0.000, 0
!!				PUT 0,					_yMoveBottom,			0.000, 0
!!
!!				if isCProfileAtBottom then
!!					PUT LeafBoxA,		_yMoveBottom, 			0.000, 0
!!					PUT LeafBoxA,		_yMoveBottom + 1, 		0.000, 0
!!				else
!!					PUT LeafBoxA,		_yMoveBottom - 1, 		0.000, 0
!!				endif
!!			else
!!			! MITER_SASH_TYPE_I
!!				PUT LeafBoxA + 1,		LeafBoxB, 				0.000, 0
!!				PUT LeafBoxA,			LeafBoxB, 				0.000, 0
!!				PUT 0,					LeafBoxB, 				0.000, 0
!!				PUT 0,					_yMoveBottom,			0.000, 0
!!				if isCProfileAtBottom then
!!					PUT LeafBoxA,		_yMoveBottom, 			0.000, 0
!!					PUT LeafBoxA + 1,	_yMoveBottom,	 		0.000, 0
!!				else
!!					PUT LeafBoxA,		_yMoveBottom - 1, 		0.000, 0
!!				endif
!!			endif
!!		endif
!!
!!		if GLOB_SCRIPT_TYPE = 2 then
!!			if iSashType = MITER_SASH_TYPE_O then
!!				PUT LeafBoxA,	0,	-1
!!			endif
!!				PUT 0,			0,	 1
!!		endif
!!
!!		gosub "PlaceFrameGroup"
!!	endif
return


60002:	!MITER_SASH_TYPE_I						! Typically 2nd leaf of a double window; the inner/handle side has an additional (I) profile. All 45 deg cuts.
	!-----  I profile upper closing cap element, only at 3D high detlev -------------------------------------
	isTextMapVert = 1

!!	if	GLOB_SCRIPT_TYPE = 3 \
!!	& iDetLevel3D = DETLEVEL_3D_10 \
!!	& iSelectableProfiles[PROF_I_CAP][Zone~] \
!!	then
!!		!---------------------top!---------------------
!!		_isCutting = 0
!!		dim ProfArr[][]
!!		PN = 1
!!!print str(iSelectableProfiles[PROF_I_CAP][Zone~], 10, 0)
!!			gosub iSelectableProfiles[PROF_I_CAP][Zone~]					! WARNING fills up internal storage with cutpoly data
!!
!!		material ProfArr[PN-1][11]
!!
!!		OuterD2 = InnerOffset + FrameSashGap + xCap
!!		InnerD2 = OuterD2
!!
!!		if nsp then
!!			if iInwardsOpening < 0 then				! if I profile is mirrored
!!				for _i = 1 to nsp 
!!					if _i % 3 = 1 then
!!						put (-get(1) + 0.087)
!!					else
!!						put(get(1))
!!					endif
!!				next _i
!!			endif
!!
!!			xform \
!!				  0, 0,-1, 	LeafBoxA + 0.05,
!!				  0, 1, 0, 	LeafBoxB - OuterD2,
!!				 -1, 0, 0, 	0
!!	
!!				cutform nsp/3, 1, 0, 0, 0, 1, 0.1, get(nsp)	: _isCutting = 1
!!!				prism_ nsp/3, 0.1, get(nsp)
!!			del 1
!!
!!			xCap = OuterD2
!!		endif
!!
!!		PUT LeafBoxA + xOffsetForMiddleProfile,		LeafBoxB - OuterD2 - 1,		0.000, 0
!!		PUT LeafBoxA + xOffsetForMiddleProfile,		LeafBoxB - OuterD2,			0.000, 0
!!		PUT LeafBoxA + xOffsetForMiddleProfile,		LeafBoxB - OuterD2 + xCap,	0.000, 0
!!		PUT LeafBoxA + xOffsetForMiddleProfile,		LeafBoxB + 1,				0.000, 0
!!
!!			gosub "PlaceFrameGroup"
!!
!!		if _isCutting then cutend
!!
!!		!---------------------bottom!---------------------
!!
!!		if iFrameType = FRAME_WINDOW then
!!			dim ProfArr[][]
!!			PN = 1
!!			_isCutting = 0
!!	
!!				gosub iSelectableProfiles[PROF_I_CAP][Zone~]					! WARNING fills up internal storage with cutpoly data
!!	
!!			material ProfArr[PN-1][11]
!!	
!!			OuterD1 = InnerOffset + FrameSashGap + xCap
!!			InnerD1 = OuterD1
!!	
!!			if nsp then
!!				if iInwardsOpening < 0 then				! if I profile is mirrored
!!					for _i = 1 to nsp 
!!						if _i % 3 = 1 then
!!							put (-get(1) + 0.087)
!!						else
!!							put(get(1))
!!						endif
!!					next _i
!!				endif
!!	
!!				xform \
!!					  0, 0,-1, 	LeafBoxA + 0.05,
!!					  0,-1, 0, 	0 + OuterD1,
!!					 -1, 0, 0, 	0
!!		
!!					cutform nsp/3, 1, 0, 0, 0, 1, 0.1, get(nsp)	: _isCutting = 1
!!!					prism_ nsp/3, 0.1, get(nsp)
!!				del 1
!!	
!!				xCap = OuterD1
!!			endif
!!	
!!			PUT LeafBoxA + xOffsetForMiddleProfile,		0 - 1,				0.000, 0
!!			PUT LeafBoxA + xOffsetForMiddleProfile,		0 + OuterD1 - xCap,	0.000, 0
!!			PUT LeafBoxA + xOffsetForMiddleProfile,		0 + OuterD1,		0.000, 0
!!			PUT LeafBoxA + xOffsetForMiddleProfile,		0 + OuterD1 + 1,	0.000, 0
!!	
!!				gosub "PlaceFrameGroup"
!!	
!!			if _isCutting then cutend
!!		else
!!!FIXME _yBottom!!!
!!			OuterD1 = InnerOffset + FrameSashGap + _yBottom
!!			InnerD1 = OuterD1
!!		endif
!!	endif

	!----- I profile itself -------------------------------------

	yProf1 = -xOverLapLeft - xOverLapright					!Default
	_iProfileTTemp	= iProfileT
	iProfileT		= PT_I
!print str(iSelectableProfiles[PROF_I][Zone~], 10, 0)
	gosub iSelectableProfiles[PROF_I][Zone~]
	yGap = yProf1

	if GLOB_SCRIPT_TYPE = 2 then
		PUT LeafBoxA + xOffsetForMiddleProfile,	0,	-1
	endif

	if GLOB_SCRIPT_TYPE = 3 then
		if	iSelectableProfiles	[PROF_BOTTOM][Zone~] > 0 \
		then
			bOnlyOffsetData = 1
!print str(iSelectableProfiles	[PROF_BOTTOM][Zone~], 10, 0)
			gosub iSelectableProfiles	[PROF_BOTTOM][Zone~]
			_yMoveBottom								= yProf1
		else
			_yMoveBottom								= 0
		endif

		bOnlyOffsetData = 0

		PUT LeafBoxA + xOffsetForMiddleProfile,		0 			+ OuterD1 - 1,				0.000, 0
		PUT LeafBoxA + xOffsetForMiddleProfile,		0 			+ OuterD1,					0.000, 0
		PUT LeafBoxA + xOffsetForMiddleProfile,		LeafBoxB 	- OuterD2,					0.000, 0
		PUT LeafBoxA + xOffsetForMiddleProfile,		LeafBoxB 	- OuterD2 + 1,				0.000, 0
	endif

	yProf1 = yGap

	gosub "PlaceFrameGroup"

	gosub MITER_SASH_TYPE_O
return


60003:	!MITER_SASH_TYPE_Z	
	!Like I type but the two inner profiles are merged.
	!Hinge/upper profile

	bOnlyOffsetData = 1							!Getting glassOffsets for cutting neighboring profiles (by setting start/end offsets)
		gosub iSelectableProfiles	[PROF_SASH][Zone~]
		glassOffsets				[PROF_SASH]	= yProf1 - yGlazingBead

		gosub iSelectableProfiles	[PROF_Z][Zone~]
		glassOffsets				[PROF_Z]	= yProf1 - yGlazingBead

		if	iDoorOption = DOOR_OPT_PLINTH \
		then
!print str(iSelectableProfiles	[PROF_PLINTH][Zone~], 10, 0)
			gosub iSelectableProfiles	[PROF_PLINTH][Zone~]
			glassOffsets				[PROF_PLINTH]	= glassOffsets [PROF_SASH] + yProf1
			_yMoveBottom								= yProf1
		else
			glassOffsets				[PROF_PLINTH]	= glassOffsets [PROF_SASH]
			_yMoveBottom								= 0
		endif
	bOnlyOffsetData = 0

	aThresholdCut1	= -45
	aThresholdCut2	= -45

	dim ProfArr[][]
	PN = 1

	gosub iSelectableProfiles[PROF_SASH][Zone~]
	gosub iSelectableProfiles[PROF_C][Zone~]

	OffsetGTop	= glassOffsets[PROF_SASH]
	OffsetGL	= glassOffsets[PROF_SASH]
	OffsetGR	= glassOffsets[PROF_Z]
	OffsetGBot	= glassOffsets[PROF_PLINTH]

	if GLOB_SCRIPT_TYPE = 2 then
		PUT 0,			0,	 1

		gosub "PlaceFrameGroup"
	endif

	if GLOB_SCRIPT_TYPE = 3 then
!--------Vertical profiles for texture mapping!--------
		isTextMapVert = 1

		PUT 0 + 1,			LeafBoxB, 					0.000, 0
		PUT 0,				LeafBoxB, 					0.000, 0
		PUT 0,				_yMoveBottom,	 			0.000, 0
		PUT 0 + 1,			_yMoveBottom,	 			0.000, 0

		gosub "PlaceFrameGroup"

!--------Horizontal profiles for texture mapping!--------
		isTextMapVert = 0

		gosub iSelectableProfiles[PROF_SASH][Zone~]
		gosub iSelectableProfiles[PROF_C][Zone~]
		PUT LeafBoxA,		LeafBoxB - 1,				0.000, 0
		PUT LeafBoxA,		LeafBoxB, 					0.000, 0
		PUT 0,				LeafBoxB, 					0.000, 0
		PUT 0,				LeafBoxB - 1,				0.000, 0
		gosub "PlaceFrameGroup"

		gosub iSelectableProfiles[PROF_SASH][Zone~]
		gosub iSelectableProfiles[PROF_C][Zone~]
		PUT 0,				_yMoveBottom + 1, 			0.000, 0
		PUT 0,				_yMoveBottom,	 			0.000, 0
		PUT LeafBoxA,		_yMoveBottom,	 			0.000, 0
		PUT LeafBoxA,		_yMoveBottom + 1,			0.000, 0

		xform 	0,	0,	1,	LeafBoxA - InnerOffset - InnerOffset,
				0,	1,	0,	0,
				1,	0,	0,	0
			cutplane{2} 0
		del 1
				gosub "PlaceFrameGroup"
			cutend
	endif

	!---------------------------------------------------------------
	!Handle profile
	iProfileT		= PT_ZT

	dim ProfArr[][]
	PN = 1
!print str(iSelectableProfiles[PROF_Z][Zone~], 10, 0)
	gosub iSelectableProfiles[PROF_Z][Zone~]

	if GLOB_SCRIPT_TYPE = 2 then
		PUT LeafBoxA,		0,	-1

		gosub "PlaceFrameGroup"
	endif

	if GLOB_SCRIPT_TYPE = 3 then
		PUT LeafBoxA - 1,	0,				0.000, 0
		PUT LeafBoxA,		0, 				0.000, 0
		PUT LeafBoxA,		LeafBoxB, 		0.000, 0
		PUT LeafBoxA - 1,	LeafBoxB,	 	0.000, 0

		add LeafBoxA, InnerOffset + InnerOffset, 0
			cutplane{2} 90
		del 1
			add LeafBoxA, LeafBoxB - InnerOffset - InnerOffset, 0
				cutplane{2} -90
			del 1
				gosub "PlaceFrameGroup"
			cutend
		cutend
	endif

	!---------------------------------------------------------------
	!Bottom profiles

	iProfileT = PT_NONE

	if	GLOB_SCRIPT_TYPE = 3 \
	&	iSelectableProfiles[PROF_BOTTOM][Zone~] \
	then
		dim ProfArr[][]
		PN = 1

		OuterD1 = InnerOffset + InnerOffset
		OuterD2 = InnerOffset + InnerOffset
		InnerD1 = InnerOffset + InnerOffset
		InnerD2 = InnerOffset + InnerOffset 
		MiddleD = 0
!print str(iSelectableProfiles[PROF_BOTTOM][Zone~], 10, 0)
		gosub iSelectableProfiles	[PROF_BOTTOM][Zone~]

		PUT 0 - 1,			0,		0, 0
		PUT 0,				0,		0, 0
		PUT LeafBoxA,		0,		0, 0
		PUT LeafBoxA + 1,	0,		0, 0
	
		gosub "PlaceFrameGroup"
	endif
return


!!60006:	!MITER_SASH_DOUBLE_I
!!!Similar to WINDOW_DOUBLE_TYPE_I but I profile is on both sides
!!!iSashProfile2 = 83115
!!	if iDetLevel2D <> DETLEVEL_2D_100 | GLOB_SCRIPT_TYPE = 3 then
!!		dim ProfArr[][]
!!		iProfileT	= PT_NONE
!!		ProfData	= 'Profil_Reynaers_Masterline_8_Door' 
!!		PN = 1
!!	
!!		gosub iSashProfiles[PROFILE_I]				!iSashProfile2
!!
!!		PUT 0 + xOffsetForMiddleProfile2,		LeafBoxB + 1,			0.000, 0
!!		PUT 0 + xOffsetForMiddleProfile2,		LeafBoxB - InnerOffset, 0.000, 0
!!		PUT 0 + xOffsetForMiddleProfile2,		0 + InnerOffset,		0.000, 0	
!!		PUT 0 + xOffsetForMiddleProfile2,		0 - 1,					0.000, 0
!!
!!		PathNum = nsp/4
!!	
!!		add2 xOffsetForMiddleProfile2, 0
!!			gosub "PlaceFrameGroup"
!!		if GLOB_SCRIPT_TYPE = 2 then
!!			del 1
!!		endif
!!	endif
!!
!!	gosub SASH_BASE + MITER_SASH_TYPE_I
!!return

60007:		!MITER_SASH_TYPE_O_MIRRORED
	mul2 1, -1
	add2 0, gs_sash_thk
		gosub MITER_SASH_TYPE_O
	del 2
return


!---------------------------------------plinth/door----------------------------------------------
!Door sashes are like the window leafs but the bottom profile is different and its cut is 90 deg.


60011:	!PLINTH_LEAF_TYPE_O															!All profiles are the same but for threshold position
	!Hinge/upper profile

	iProfileT = PT_SASH

	bOnlyOffsetData	= 1																!getting glassOffsets for cutting neighboring profiles (by setting start/end offsets)
		gosub iSelectableProfiles	[PROF_SASH][Zone~]
		glassOffsets				[PROF_SASH]			= yProf1 - yGlazingBead

		gosub iSelectableProfiles	[PROF_BOTTOM][Zone~]

		if iSelectableProfiles	[PROF_BOTTOM][Zone~] > EPS then _yMoveBottom = yProf1 else _yMoveBottom = 0

		gosub iSelectableProfiles	[PROF_PLINTH][Zone~]

		glassOffsets				[PROF_PLINTH]		= yProf1 + _yMoveBottom - yGlazingBead
	bOnlyOffsetData = 0

	aGlass1			= 45															! Note that many other a, x and y variables are not set here since they are initialized to 0 and it's OK \
	aGlass2			= 45															! but are later overwritten
	xGlass1			= glassOffsets[PROF_PLINTH] - glassOffsets[PROF_SASH] - xThrOffs - _yMoveBottom
	xGlass2			= glassOffsets[PROF_PLINTH] - glassOffsets[PROF_SASH] - xThrOffs - _yMoveBottom
!print str(iSelectableProfiles[PROF_SASH][Zone~], 10, 0)
	gosub iSelectableProfiles[PROF_SASH][Zone~]

	if iSashType = PLINTH_LEAF_TYPE_O then
		gosub iSelectableProfiles[PROF_C][Zone~]
	endif

	if GLOB_SCRIPT_TYPE = 2 then
		PUT 0,			0,	 1
		PUT LeafBoxA,	0,	-1
	endif

	if GLOB_SCRIPT_TYPE = 3 then
!--------Vertical profiles for texture mapping!--------
		isTextMapVert = 1

		PUT LeafBoxA,		_yMoveBottom - 1,	0.000, 0
		PUT LeafBoxA,		_yMoveBottom,		0.000, 0
		PUT LeafBoxA,		LeafBoxB, 			0.000, 0
		PUT LeafBoxA - 1,	LeafBoxB, 			0.000, 0
		gosub "PlaceFrameGroup"

		gosub iSelectableProfiles[PROF_SASH][Zone~]

		if iSashType = PLINTH_LEAF_TYPE_O then
			gosub iSelectableProfiles[PROF_C][Zone~]
		endif

		PUT 0 + 1,			LeafBoxB, 			0.000, 0
		PUT 0,				LeafBoxB, 			0.000, 0
		PUT 0,				_yMoveBottom, 	 	0.000, 0
		PUT 0,				_yMoveBottom - 1,	0.000, 0
		gosub "PlaceFrameGroup"

!--------Horizontal profiles for texture mapping!--------
		isTextMapVert = 0

		if iSashType = PLINTH_LEAF_TYPE_O then
			gosub iSelectableProfiles[PROF_C][Zone~]
		endif

		gosub iSelectableProfiles[PROF_SASH][Zone~]
		PUT LeafBoxA,	LeafBoxB - 1,			0.000, 0
		PUT LeafBoxA,	LeafBoxB, 				0.000, 0
		PUT 0,			LeafBoxB, 				0.000, 0
		PUT 0,			LeafBoxB - 1,			0.000, 0
	endif
	
	gosub "PlaceFrameGroup"

	!---------------------------------------------------------------
	!Plinth profile

	if GLOB_SCRIPT_TYPE = 3 \
	then
		aGlass1	= 45																! Setting bottom profile cuts (because some are cut this way, some -glazing beeds- not)
		aGlass2	= 45

		xGlass1		= glassOffsets[PROF_SASH]	- glassOffsets[PROF_PLINTH] + _yMoveBottom
		xGlass2		= glassOffsets[PROF_SASH]	- glassOffsets[PROF_PLINTH] + _yMoveBottom

		InnerD1		= glassOffsets[PROF_SASH]	- yGlazingBeadDiff - yGlazingIODiff	! Offset for smaller/longer profile (Glazing bead side, usually inner), start/end
		InnerD2		= glassOffsets[PROF_SASH]	- yGlazingBeadDiff - yGlazingIODiff	! yGlazingIODiff because inner/outer glazing size differs (!)

		OuterD1		= glassOffsets[PROF_SASH]	+ yGlazingBead						! Offset for Larger/shorter profile (Usually outer)
		OuterD2		= glassOffsets[PROF_SASH]	+ yGlazingBead

		if	iDetLevel3D = DETLEVEL_3D_100 \
		|	iDetLevel3D = DETLEVEL_3D_50 \
		then
			InnerD1 = OuterD1
			InnerD2 = OuterD2
		endif

		bAsymmetricalPlacing = 1

		iProfileT = PT_NONE

		gosub iSelectableProfiles[PROF_BOTTOM][Zone~]

		PUT 0 - 1,			0,		0, 0
		PUT 0,				0,		0, 0
		PUT LeafBoxA,		0,		0, 0
		PUT LeafBoxA + 1,	0,		0, 0

		gosub "PlaceFrameGroup"

! --------------------------------------------------------------------
		iProfileT = PT_SASH

		if	iDetLevel3D = DETLEVEL_3D_100 \
		|	iDetLevel3D = DETLEVEL_3D_50 \
		then
			yProf1 = yProf1 + _yMoveBottom 
			_yMoveBottom = 0
		endif

		gosub iSelectableProfiles[PROF_PLINTH][Zone~]

		PUT 0 - 1,			_yMoveBottom,		0, 0
		PUT 0,				_yMoveBottom,		0, 0
		PUT LeafBoxA,		_yMoveBottom,		0, 0
		PUT LeafBoxA + 1,	_yMoveBottom,		0, 0

		gosub "PlaceFrameGroup"
	endif

	OffsetGTop	= glassOffsets		[PROF_SASH]
	OffsetGL	= glassOffsets		[PROF_SASH]
	OffsetGR	= glassOffsets		[PROF_SASH]
	OffsetGBot	= glassOffsets		[PROF_PLINTH]

	!---- C profile: sealant between frame and leaf that is missing at middle pos ----

	iProfileT = PT_NONE

	if iSashType = PLINTH_LEAF_TYPE_I then
		gosub iSelectableProfiles[PROF_C][Zone~]

		if GLOB_SCRIPT_TYPE = 3 then
			PUT 0,				_yMoveBottom - 1,	0.000, 0
			PUT 0,				_yMoveBottom,		0.000, 0
			PUT 0,				 LeafBoxB, 			0.000, 0
			PUT LeafBoxA,		 LeafBoxB, 			0.000, 0
			PUT LeafBoxA + 1,	 LeafBoxB, 			0.000, 0
		endif

		if GLOB_SCRIPT_TYPE = 2 then
			PUT 0,			0,	 1
		endif

		gosub "PlaceFrameGroup"
	endif
return


60012:	!PLINTH_LEAF_TYPE_I
!TODO untested TODO untested TODO untested TODO untested TODO untested TODO untested TODO untested TODO untested 
	isTextMapVert = 1

	if	GLOB_SCRIPT_TYPE = 3 \
	& iDetLevel3D = DETLEVEL_3D_10 \
	& iSelectableProfiles[PROF_I_CAP][Zone~] \
	then
		!---------------------top!---------------------
		_isCutting = 0
!print str(iSelectableProfiles[PROF_I_CAP][Zone~], 10, 0)
			gosub iSelectableProfiles[PROF_I_CAP][Zone~]					! WARNING fills up internal storage with cutpoly data

		material ProfArr[PN-1][11]

		OuterD2 = InnerOffset + FrameSashGap + xCap
		InnerD2 = OuterD2

		if nsp then
			if iInwardsOpening < 0 then				! if I profile is mirrored
				for _i = 1 to nsp 
					if _i % 3 = 1 then
						put (-get(1) + 0.087)
					else
						put(get(1))
					endif
				next _i
			endif

			xform \
				  0, 0,-1, 	LeafBoxA + 0.05,
				  0, 1, 0, 	LeafBoxB - OuterD2,
				 -1, 0, 0, 	0
	
				cutform nsp/3, 1, 0, 0, 0, 1, 0.1, get(nsp)	: _isCutting = 1
!				prism_ nsp/3, 0.1, get(nsp)
			del 1

			xCap = OuterD2
		endif

		PUT LeafBoxA + xOffsetForMiddleProfile,		LeafBoxB - OuterD2 - 1,		0.000, 0
		PUT LeafBoxA + xOffsetForMiddleProfile,		LeafBoxB - OuterD2,			0.000, 0
		PUT LeafBoxA + xOffsetForMiddleProfile,		LeafBoxB - OuterD2 + xCap,	0.000, 0
		PUT LeafBoxA + xOffsetForMiddleProfile,		LeafBoxB + 1,				0.000, 0

			gosub "PlaceFrameGroup"

		if _isCutting then cutend
	endif

	!----- I profile itself -------------------------------------

	iProfileT = PT_I
!print str(iSelectableProfiles[PROF_I][Zone~], 10, 0)
	gosub iSelectableProfiles[PROF_I][Zone~]

	if GLOB_SCRIPT_TYPE = 2 then
		PUT LeafBoxA + xOffsetForMiddleProfile,	0,	-1
	endif

	if GLOB_SCRIPT_TYPE = 3 then
		PUT LeafBoxA + xOffsetForMiddleProfile,		0 - 1,			0.000, 0
		PUT LeafBoxA + xOffsetForMiddleProfile,		0,				0.000, 0
		PUT LeafBoxA + xOffsetForMiddleProfile,		LeafBoxB,		0.000, 0
		PUT LeafBoxA + xOffsetForMiddleProfile,		LeafBoxB + 1,	0.000, 0
	endif

	gosub "PlaceFrameGroup"

	gosub PLINTH_LEAF_TYPE_O
return


60013:	!PLINTH_LEAF_TYPE_Z
	!Hinge/upper profile

	iProfileT = PT_SASH

	bOnlyOffsetData	= 1																! Getting glassOffsets for cutting neighboring profiles (by setting start/end offsets from yProf1s)
		gosub iSelectableProfiles	[PROF_SASH][Zone~]
		glassOffsets				[PROF_SASH]			= yProf1 - yGlazingBead

		gosub iSelectableProfiles	[PROF_Z][Zone~]
		glassOffsets				[PROF_Z]			= yProf1 - yGlazingBead

		gosub iSelectableProfiles	[PROF_BOTTOM][Zone~]

		if iSelectableProfiles	[PROF_BOTTOM][Zone~] > EPS then _yMoveBottom = yProf1 else _yMoveBottom = 0

		gosub iSelectableProfiles	[PROF_PLINTH][Zone~]							! TRICKY Here yProf1 is increased by threshold's
		glassOffsets				[PROF_PLINTH]		= yProf1 + _yMoveBottom - yGlazingBead
	bOnlyOffsetData = 0

	aGlass1			= 0																! Note that many other a, x and y variables are not set here since they are initialized to 0 and it's OK \
	aGlass2			= 45															! but are later overwritten
	xGlass1			= glassOffsets[PROF_Z]		- glassOffsets[PROF_SASH]
	xGlass2			= glassOffsets[PROF_PLINTH]	- glassOffsets[PROF_SASH] - xThrOffs

!!TODO
!!	if iSashType = PLINTH_LEAF_TYPE_O then
!!		gosub iSelectableProfiles[PROF_C][Zone~]
!!	endif

	gosub iSelectableProfiles[PROF_SASH][Zone~]

	if GLOB_SCRIPT_TYPE = 2 then
		PUT 0,			0,	 1
	endif

	if GLOB_SCRIPT_TYPE = 3 then
!--------Vertical profiles for texture mapping!--------
		isTextMapVert = 1
		PUT 0 + 1,		LeafBoxB,	 		0.000, 0
		PUT 0,			LeafBoxB,	 		0.000, 0
		PUT 0,			_yMoveBottom,	 	0.000, 0
		PUT 0,			_yMoveBottom - 1,	0.000, 0
		gosub "PlaceFrameGroup"

!--------Horizontal profiles for texture mapping!--------
		isTextMapVert = 0
		gosub iSelectableProfiles[PROF_SASH][Zone~]
		PUT LeafBoxA,	LeafBoxB - 1,		0.000, 0
		PUT LeafBoxA,	LeafBoxB, 			0.000, 0
		PUT 0,			LeafBoxB,	 		0.000, 0
		PUT 0,			LeafBoxB - 1, 		0.000, 0
	endif
	
	gosub "PlaceFrameGroup"

	!---------------------------------------------------------------

	!Handle/ZT profile

	iProfileT = PT_ZT
	isTextMapVert = 1

	aGlass1			= 45														!Note that many other a, x and y variables are not set here since they are initialized to 0 and it's OK \
	aGlass2			= 0															!but are later overwritten
	xGlass1			= glassOffsets[PROF_PLINTH]	- glassOffsets[PROF_Z] - _yMoveBottom
	xGlass2			= glassOffsets[PROF_SASH]	- glassOffsets[PROF_Z]

!print str(iSelectableProfiles[PROF_Z][Zone~], 10, 0)
	gosub iSelectableProfiles[PROF_Z][Zone~]

	glassOffsets [PROF_Z] = yProf1 - yGlazingBead

	if GLOB_SCRIPT_TYPE = 2 then
		PUT LeafBoxA,	0,	-1
	endif

	if GLOB_SCRIPT_TYPE = 3 then
		PUT LeafBoxA,		_yMoveBottom - 1,	0.000, 0
		PUT LeafBoxA,		_yMoveBottom, 		0.000, 0
		PUT LeafBoxA,		LeafBoxB, 			0.000, 0
		PUT LeafBoxA - 1,	LeafBoxB, 			0.000, 0
	endif
	
	gosub "PlaceFrameGroup"

	!---------------------------------------------------------------
	!Plinth  profile

	if GLOB_SCRIPT_TYPE = 3 \
	then
		isTextMapVert = 0
		iProfileT = PT_SASH

		aGlass1	= 45																! Setting bottom profile cuts (because some are cut this way, some -glazing beeds- not)
		aGlass2	= 45

		xGlass1		= glassOffsets[PROF_SASH]	- glassOffsets[PROF_PLINTH] + _yMoveBottom
		xGlass2		= glassOffsets[PROF_Z]		- glassOffsets[PROF_PLINTH] + _yMoveBottom

		InnerD1		= glassOffsets[PROF_SASH]	- yGlazingBeadDiff - yGlazingIODiff	! Offset for smaller/longer profile (Glazing bead side, usually inner), start/end
		InnerD2		= glassOffsets[PROF_Z]		- yGlazingBeadDiff - yGlazingIODiff	! yGlazingIODiff because inner/outer glazing size differs (!)

		OuterD1		= glassOffsets[PROF_SASH]	+ yGlazingBead						! Offset for Larger/shorter profile (Usually outer)
		OuterD2		= glassOffsets[PROF_Z]		+ yGlazingBead

		if	iDetLevel3D = DETLEVEL_3D_100 \
		|	iDetLevel3D = DETLEVEL_3D_50 \
		then
			InnerD1 = OuterD1
			InnerD2 = OuterD2
		endif

! ---------------------------------------------------------------
		iProfileT = PT_NONE

		gosub iSelectableProfiles[PROF_BOTTOM][Zone~]

		PUT 0 - 1,			0,		0, 0
		PUT 0,				0,		0, 0
		PUT LeafBoxA,		0,		0, 0
		PUT LeafBoxA + 1,	0,		0, 0

		gosub "PlaceFrameGroup"

! --------------------------------------------------------------------
		iProfileT = PT_SASH
!print str(iSelectableProfiles[PROF_PLINTH][Zone~], 10, 0)
		gosub iSelectableProfiles[PROF_PLINTH][Zone~]

		PUT 0 - 1,			_yMoveBottom,		0, 0
		PUT 0,				_yMoveBottom,		0, 0
		PUT LeafBoxA,		_yMoveBottom,		0, 0
		PUT LeafBoxA + 1,	_yMoveBottom,		0, 0
	
		gosub "PlaceFrameGroup"
	endif

	OffsetGTop	= glassOffsets		[PROF_SASH]
	OffsetGL	= glassOffsets		[PROF_SASH]
	OffsetGR	= glassOffsets		[PROF_Z]
	OffsetGBot	= glassOffsets		[PROF_PLINTH]

	!---- C profile: sealant between frame and leaf that is missing at middle pos ----

	iProfileT = PT_NONE

	if iSashType = PLINTH_LEAF_TYPE_I then
		gosub iSelectableProfiles[PROF_C][Zone~]

		if GLOB_SCRIPT_TYPE = 3 then
			PUT 0,				_yMoveBottom - 1,	0.000, 0
			PUT 0,				_yMoveBottom,		0.000, 0
			PUT 0,				 LeafBoxB, 			0.000, 0
			PUT LeafBoxA,		 LeafBoxB, 			0.000, 0
			PUT LeafBoxA + 1,	 LeafBoxB, 			0.000, 0
		endif

		if GLOB_SCRIPT_TYPE = 2 then
			PUT 0,			0,	 1
		endif

		gosub "PlaceFrameGroup"
	endif
return

60014:	! PLINTH_LEAF_PIVOT_HOR
return

60015:	! PLINTH_LEAF_PIVOT_VERT
	iProfileT = PT_FRAME

	gosub 30005

	LeafDRight = yProf1

	if	GLOB_SCRIPT_TYPE = 3 then
!--------Vertical profiles for texture mapping!--------
		isTextMapVert = 1

		PUT LeafBoxA - 1,	LeafBoxB - LeafDUpper,	0, 0
		PUT LeafBoxA,		LeafBoxB - LeafDUpper,	0, 0
		PUT LeafBoxA,		0,			0, 0
		PUT LeafBoxA,		0 - 1,		0, 0
		gosub "PlaceFrameGroup"

!--------Horizontal profiles for texture mapping!--------
		isTextMapVert = 0
		gosub 30005

		PUT xHinge - LeafDRight - 1,	LeafBoxB - LeafDUpper,		0, 0
		PUT xHinge - LeafDRight,		LeafBoxB - LeafDUpper,		0, 0
		PUT LeafBoxA,					LeafBoxB - LeafDUpper,		0, 0
		PUT LeafBoxA,					LeafBoxB - LeafDUpper - 1,	0, 0
	else
!TODO this is bad
		PUT LeafBoxA,				0,	 1
	endif

	gosub "PlaceFrameGroup"

	gosub PLINTH_LEAF_TYPE_O
return

60016:	! PLINTH_LEAF_DOUBLE_I
return

!--------------------/sash/leaf schemas------------------------------------------------------------------------------------------------------------

!-------------------- frame schemas------------------------------------------------------------------------------------------------------------

61001:	!FRAME_WINDOW
	yProf1 = gs_frame_width - InnerOffset					! init and if there is a profile it overwrites this
	bOnlyOffsetData = 0
!print str(iSelectableProfiles[PROF_FRAME][Zone~], 10, 0)
	gosub iSelectableProfiles[PROF_FRAME][Zone~]

	if GLOB_SCRIPT_TYPE = 2 then
		PUT 0,			0,	 1
		PUT LeafBoxA, 	0,	-1
	endif

	if GLOB_SCRIPT_TYPE = 3 then
!--------Vertical profiles for texture mapping!--------
		isTextMapVert = 1

		PUT LeafBoxA - 1, 	0, 			0, 0
		PUT LeafBoxA, 		0, 			0, 0
		PUT LeafBoxA, 		LeafBoxB,	0, 0
		PUT LeafBoxA - 1,	LeafBoxB,	0, 0
		gosub "PlaceFrameGroup"

		gosub iSelectableProfiles[PROF_FRAME][Zone~]
		PUT 0 + 1,			LeafBoxB,	0, 0
		PUT 0,				LeafBoxB,	0, 0
		PUT 0,				0,			0, 0
		PUT 0 + 1,			0,			0, 0
		gosub "PlaceFrameGroup"

!--------Horizontal profiles for texture mapping!--------
		isTextMapVert = 0

		gosub iSelectableProfiles[PROF_FRAME][Zone~]
		PUT 0,		 		0 + 1,		0, 0
		PUT 0,		 		0, 			0, 0
		PUT LeafBoxA, 		0, 			0, 0
		PUT LeafBoxA, 		0 + 1,		0, 0
		gosub "PlaceFrameGroup"

		gosub iSelectableProfiles[PROF_FRAME][Zone~]
		PUT LeafBoxA, 		LeafBoxB - 1,	0, 0
		PUT LeafBoxA, 		LeafBoxB, 		0, 0
		PUT 0,		 		LeafBoxB, 		0, 0
		PUT 0,		 		LeafBoxB - 1, 	0, 0
	endif

	if isFrameMirrored then									! z dir mirroring, in/out side changed
		mul2 1,	-1
		mulz 	-1		

		add2 0,		gs_frame_thk + not(WIDO_REVEAL_SIDE) * zMoveLeaf
		add	 0,	0,	gs_frame_thk + not(WIDO_REVEAL_SIDE) * zMoveLeaf
	endif

	gosub "PlaceFrameGroup"

	if isFrameMirrored then del 2

	if yProf1 > -1 then
		LeafDLeft	= yProf1 - InnerOffset
		LeafDRight	= yProf1 - InnerOffset
		LeafDUpper	= yProf1 - InnerOffset
		LeafDLower	= yProf1 - InnerOffset
	endif
return

61002:	! FRAME_WINDOW_MIRRORED

return

61004:	! FRAME_HOR_PIVOT_WINDOW
return

61005:	! FRAME_VERT_PIVOT_WINDOW
return


61011:	!FRAME_DOOR
	yProf1 = gs_frame_width - InnerOffset					! init and if there is a profile it overwrites this
	dim ProfArr[][]
	PN = 1
	bOnlyOffsetData = 0
!print str(iSelectableProfiles[PROF_FRAME][Zone~], 10, 0)
	gosub iSelectableProfiles[PROF_FRAME][Zone~]

	if GLOB_SCRIPT_TYPE = 2 then
		PUT 0,			0,	 1
		PUT LeafBoxA, 	0,	-1
	endif

	if GLOB_SCRIPT_TYPE = 3 then
!--------Vertical profiles for texture mapping!--------
		isTextMapVert = 1

		PUT LeafBoxA, 		0 - 1, 		0, 0
		PUT LeafBoxA, 		0, 			0, 0
		PUT LeafBoxA, 		LeafBoxB,	0, 0
		PUT LeafBoxA - 1,	LeafBoxB,	0, 0
		gosub "PlaceFrameGroup" 

		gosub iSelectableProfiles[PROF_FRAME][Zone~]
		PUT 0 + 1,			LeafBoxB,	0, 0
		PUT 0,				LeafBoxB,	0, 0
		PUT 0,				0,			0, 0
		PUT 0,				0 - 1,		0, 0
		gosub "PlaceFrameGroup" 

!--------Horizontal profiles for texture mapping!--------
		isTextMapVert = 0

		gosub iSelectableProfiles[PROF_FRAME][Zone~]
		PUT LeafBoxA, 		LeafBoxB - 1,	0, 0
		PUT LeafBoxA, 		LeafBoxB,		0, 0
		PUT 0,				LeafBoxB,		0, 0
		PUT 0,				LeafBoxB - 1,	0, 0
	endif

	if isFrameMirrored then									! z dir mirroring, in/out side changed
		mul2 1,	-1
		mulz 	-1		

		add2 0,		gs_frame_thk + not(WIDO_REVEAL_SIDE) * (zMoveLeaf + zFrameOffset)
		add	 0,	0,	gs_frame_thk + not(WIDO_REVEAL_SIDE) * (zMoveLeaf + zFrameOffset)
	endif

		gosub "PlaceFrameGroup" 

	if isFrameMirrored then del 2

	LeafDLeft	= yProf1 - InnerOffset
	LeafDRight	= yProf1 - InnerOffset
	LeafDUpper	= yProf1 - InnerOffset

!-------------- threshold --------------

!print str(iSelectableProfiles[PROF_THRESHOLD][Zone~], 10, 0), izp
	if	GLOB_SCRIPT_TYPE = 3 \
	&	iSelectableProfiles[PROF_THRESHOLD][Zone~] > EPS \
	then
!-------------- cutting threshold --------------
		if iDetLevel3D = DETLEVEL_3D_10 then
			put \
					0,									gs_frame_thk	+ EPSCM,	1,
					0,							0 						- EPSCM,	1,
					LeafDLeft + InnerOffset,			0 				- EPSCM,	1,
					LeafDLeft + InnerOffset,			.023,						1,
					LeafDLeft - FrameSashGap,			.023,						1,
					LeafDLeft - FrameSashGap,			gs_frame_thk	+ EPSCM,	1,
					0,									gs_frame_thk	+ EPSCM,	1
			xform \
				  1,  0, 0, 	0,
				  0,  0, 1, 	0,
				  0, -1, 0, 	0
	
				cutform nsp/3, 1, 0, 0, 0, 1, 0.1, use(nsp) : _nCut = _nCut + 1				!USE
!				prism_ nsp/3, 0.1, use(nsp)
			del 1
	
			xform \
				  -1,  0, 0, 	LeafBoxA,
				  0,  0, 1, 	0,
				  0, -1, 0, 	0
	
				cutform nsp/3, 1, 0, 0, 0, 1, 0.1, get(nsp) : _nCut = _nCut + 1
!				prism_ nsp/3, 0.1, get(nsp)
			del 1
		endif
!--------------/cutting threshold --------------

		dim ProfArr[][]
		PN = 1

		bOnlyOffsetData = 0

		gosub iSelectableProfiles[PROF_THRESHOLD][Zone~]

		PUT 0 - 1,				0, 0, 0
		PUT yProf1 ,			0, 0, 0
		PUT LeafBoxA - yProf1,	0, 0, 0
		PUT LeafBoxA + 1, 		0, 0, 0

		gosub "PlaceFrameGroup" 

		for _i = 1 to _nCut : cutend : next _i

		LeafDLower	= yProf1
	else
		LeafDLower	= 0						! No threshold
	endif
return

!!61012:	! FRAME_WINDOW_MIRRORED
!!
!!return

61014:	! FRAME_HOR_PIVOT_DOOR
return

!/TODO

61015:	! FRAME_VERT_PIVOT_DOOR
	gosub FRAME_DOOR

	gosub 30005

	if	GLOB_SCRIPT_TYPE = 3 then
!--------Vertical profiles for texture mapping!--------
		isTextMapVert = 1

		PUT leafDLeft + 1,	LeafBoxB - LeafDUpper,	0, 0
		PUT leafDLeft,		LeafBoxB - LeafDUpper,	0, 0
		PUT leafDLeft,		0,			0, 0
		PUT leafDLeft,		0 - 1,		0, 0
		gosub "PlaceFrameGroup"

!--------Horizontal profiles for texture mapping!--------
		isTextMapVert = 0
		gosub 30005

		PUT leafDLeft + xHinge + 1,		LeafBoxB - LeafDUpper,		0, 0
		PUT leafDLeft + xHinge,			LeafBoxB - LeafDUpper,		0, 0
		PUT leafDLeft,					LeafBoxB - LeafDUpper,		0, 0
		PUT leafDLeft,					LeafBoxB - LeafDUpper - 1,	0, 0
	else
		PUT leafDLeft,				0,	 1
	endif

	gosub "PlaceFrameGroup"

	leafDLeft	= leafDLeft  + yProf1 - InnerOffset
	leafDRight	= leafDRight + yProf1 - InnerOffset
	leafDUpper	= leafDUpper + yProf1 - InnerOffset
return



!--------------------/frame schemas------------------------------------------------------------------------------------------------------------

!--------------------selectable profiles------------------------------------------------------------------------------------------------------------

!--------------------selectable profiles------------------------------------------------------------------------------------------------------------

!--------------------selectable profiles------------------------------------------------------------------------------------------------------------

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!! Now this is empty
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!---------------------------------------------------------------------------------------------
!  Frame selectable alternatives  Frame selectable alternatives  Frame selectable alternatives
!---------------------------------------------------------------------------------------------



!---------------------------------------------------------------------------------------------
! /Frame selectable alternatives /Frame selectable alternatives /Frame selectable alternatives
!---------------------------------------------------------------------------------------------

!---------------------------------------------------------------------------------------------
!  Sash selectable alternatives  Sash selectable alternatives  Sash selectable alternatives
!---------------------------------------------------------------------------------------------




!---------------------------------------------------------------------------------------------
! /Sash selectable alternatives /Sash selectable alternatives /Sash selectable alternatives
!---------------------------------------------------------------------------------------------


!---------------------------------------------------------------------------------------------
!  Sash threshold selectable alternatives  Sash threshold selectable alternatives
!---------------------------------------------------------------------------------------------


!---------------------------------------------------------------------------------------------
!  /Sash threshold selectable alternatives  /Sash threshold selectable alternatives
!---------------------------------------------------------------------------------------------


!---------------------------------------------------------------------------------------------------
!  Mullion selectable alternatives  Mullion selectable alternatives  Mullion selectable alternatives
!---------------------------------------------------------------------------------------------------



!---------------------------------------------------------------------------------------------------
! /Mullion selectable alternatives /Mullion selectable alternatives /Mullion selectable alternatives
!---------------------------------------------------------------------------------------------------


!---------------------------------------------------------------------------------------------
!  Mixed profiles
!---------------------------------------------------------------------------------------------



!----------------------------------------------------------------------------------------------------
! /Selectable alternatives /Selectable alternatives /Selectable alternatives /Selectable alternatives
!----------------------------------------------------------------------------------------------------

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! /PROFILES /PROFILES /PROFILES /PROFILES /PROFILES /PROFILES /PROFILES /PROFILES /PROFILES
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

40000:
!vertical/standing mullion orientation
	if GLOB_SCRIPT_TYPE = 3 then
		PUT 0, 			LeafBoxB - InnerD1 * (GLOB_SCALE > 15) + 1.00,	-zFrameOffset * (GLOB_SCALE > 15), 0
		PUT 0, 			LeafBoxB - InnerD1 * (GLOB_SCALE > 15),			-zFrameOffset * (GLOB_SCALE > 15), 0
		PUT 0, 			0 + InnerD2 * (GLOB_SCALE > 15),				-zFrameOffset * (GLOB_SCALE > 15), 0
		PUT 0, 			0 + InnerD2 * (GLOB_SCALE > 15) - 1.00,			-zFrameOffset * (GLOB_SCALE > 15), 0
	endif

	if GLOB_SCRIPT_TYPE = 2 then
		PUT 0, -zFrameOffset * (GLOB_SCALE > 15), 1
	endif

	gosub "PlaceFrameGroup"
return

40001:
!horizontal/laying mullion orientation
!This orientation was not ok for horizontal divider, hopefully otherwise neutral

	if GLOB_SCRIPT_TYPE = 3 then
		PUT 0 + InnerD1 * (GLOB_SCALE > 15) - 1.00, 			0, 0.000, 0
		PUT 0 + InnerD1 * (GLOB_SCALE > 15), 					0, 0.000, 0
		PUT LeafBoxA - InnerD2 * (GLOB_SCALE > 15), 			0, 0.000, 0
		PUT LeafBoxA - InnerD2 * (GLOB_SCALE > 15) + 1.00,	 	0, 0.000, 0
	endif

	gosub "PlaceFrameGroup"
return

"RecalculateLeafBox":
!Recalculating LeafBox based on what LeafDs a profile has set and then resetting LeafDs
	LeafBoxA = LeafBoxA - leafDLeft	 - LeafDRight
	LeafBoxB = LeafBoxB - leafDUpper - LeafDLower

	leafDLeft	= 0 
	LeafDRight	= 0
	LeafDLower	= 0
	leafDUpper	= 0
return

!!!!!!!!!!!!!!!!*********************************************************** Place FrameGroup
!!!!!!!!!!!!!!!!*********************************************************** Place FrameGroup
!!!!!!!!!!!!!!!!*********************************************************** Place FrameGroup

"PlaceFrameGroup":
	if	GLOB_SCRIPT_TYPE <> 2 \
	&	GLOB_SCRIPT_TYPE <> 3 \
	&	nsp > EPS \
	then
		gosub "CleanStack"
		return
	endif

	if GLOB_SCRIPT_TYPE = 2 then
		dim TubeCoord[][]
		PathNum = nsp/3
		for tp=1 to nsp/3
			TubeCoord[tp][1] = get(1)	!X
			TubeCoord[tp][2] = get(1)	!Y
			TubeCoord[tp][3] = get(1)	!Mirror
		next tp
	endif

	if GLOB_SCRIPT_TYPE = 3 then
		dim TubeCoord[][]
		PathNum = nsp/4
		for tp=1 to nsp/4
			TubeCoord[tp][1] = get(1)	!X
			TubeCoord[tp][2] = get(1)	!Y
			TubeCoord[tp][3] = get(1)	!Z
			TubeCoord[tp][4] = get(1)	!Rotation, should be 0
		next tp
	endif

	if	GLOB_SCRIPT_TYPE = 2 & iDetLevel2D = DETLEVEL_2D_50  \
	|	GLOB_SCRIPT_TYPE = 2 & iDetLevel2D = DETLEVEL_2D_100 \
	then
		if iProfileT = PT_SASH then
			fillPenBg		= pFillS[FILL_SASH][FP_BGPEN]
			fillPenFg		= pFillS[FILL_SASH][FP_FGPEN]
			contPen			= pFillS[FILL_SASH][FP_CONTPEN]
			fillType		= fFillS[FILL_SASH]
			contLineType	= lFillS[FILL_SASH]
		else
			fillPenBg		= pFillS[FILL_FRAME][FP_BGPEN]
			fillPenFg		= pFillS[FILL_FRAME][FP_FGPEN]
			contPen			= pFillS[FILL_FRAME][FP_CONTPEN]
			fillType		= fFillS[FILL_FRAME]
			contLineType	= lFillS[FILL_FRAME]
		endif
	else

	endif

	if	GLOB_SCRIPT_TYPE = 2 & iDetLevel2D = DETLEVEL_2D_50 \
	|	GLOB_SCRIPT_TYPE = 2 & iDetLevel2D = DETLEVEL_2D_100 \
	|	GLOB_SCRIPT_TYPE = 3 & iDetLevel3D = DETLEVEL_3D_100 \
	|	GLOB_SCRIPT_TYPE = 3 & iDetLevel3D = DETLEVEL_3D_50 \
	then
!!		PN = max(iAdditionalProfiles + 2, 2)											! At low detlevs run less times

!			if	iProfileT = PT_SASH \
!			|	iProfileT = PT_NONE \													! For fixed windows; workaround
!			then																		! Calculating total glass thickness for low detlev
!				zGlassThk = 0
!				GlassLayers = vardim1(GlassThk)
!				
!				for u = 1 to GlassLayers 
!					zGlassThk = zGlassThk + GlassThk[u][GL_THICKNESS] + GlassThk[u][GL_AIRGAP]
!				next u
!
!				zGlassThk = zGlassThk + 1												! Last airgap is -1
!			endif

		if zOffset < EPS then zOffset = 0.01											! Low detlev safety

		!-----PT_FRAME-----------------------------------------------
!!		if iProfileT = PT_FRAME then zMax = gs_frame_thk else zMax = gs_sash_thk		! or iProfileT = PT_MULLION 
!!		if iProfileT = PT_MULLION & iOpeningTypes[1] = 75 then zMax = gs_frame_thk / 2

		if iProfileT = PT_FRAME then
			yProf					= yProf1
			LeafD					= yProf1 - InnerOffset
			zO						= 0

			IF	iDetLevel3D	= DETLEVEL_3D_50 & GLOB_SCRIPT_TYPE = 3 THEN
				put \
					0,						-zOffset,				 2,
					LeafD,					-zOffset,				 2,
					LeafD, 					 0, 					 2,
					0,						 0, 					 2,
					0,						-zOffset,				-1
				material sMaterialS[MAT_OUT]
				gosub "PlaceTubeGroup"

				put \
					0,						-zOffset,				 2,
					LeafD, 					-zOffset,				 2,
					LeafD,				 	-zMax, 					 2,
					0,						-zMax, 					 2,
					0,						-zOffset,				-1
				material sMaterialS[MAT_IN]
			ENDIF

			IF	iDetLevel3D	= DETLEVEL_3D_100 &	GLOB_SCRIPT_TYPE = 3 THEN
				put \
					0,						-zOffset,				 2,
					LeafD,					-zOffset,				 2,
					LeafD, 					 0,						 2,
					0,						 0,						 2,
					0,						-zOffset,				-1
				material sMaterialS[MAT_OUT]
				gosub "PlaceTubeGroup"
		
				put \
					0,						-zOffset,				 2,
					LeafD, 					-zOffset,				 2,
					LeafD,				 	-zMax, 					 2,
					0,						-zMax, 					 2,
					0,						-zOffset,				-1
				material sMaterialS[MAT_IN]
			ENDIF

			IF	iDetLevel2D	= DETLEVEL_2D_50 &	GLOB_SCRIPT_TYPE = 2 THEN
				put \
					0,						0,						1,
					LeafD, 					0,						1,
					LeafD,					-zMax,					1,
					0,						-zMax,					1,
					0,						0,						-1
			ENDIF

			IF	iDetLevel2D	= DETLEVEL_2D_100 &	GLOB_SCRIPT_TYPE = 2 THEN
				put \
					0,						0,						1,
					LeafD, 					0,						1,
					LeafD,					-zMax,					1,
					0,						-zMax,					1,
					0,						0,						-1
			ENDIF

			gosub "PlaceTubeGroup"
		endif

		!-----PT_SASH-----------------------------------------------

		if iProfileT = PT_SASH then
			yProf					= yProf1

			IF	iDetLevel3D	= DETLEVEL_3D_50 &	GLOB_SCRIPT_TYPE = 3 THEN
				put \
					0,						0,						2,
					yProf, 					0,						2,
					yProf, 					-zOffset,				2,
					0,						-zOffset,				2,
					0,						0,						2,
					0,						0,						-1
				material sMaterialS[MAT_SASH_OUT]
				StartOffset = OuterD1
				EndOffset   = OuterD2
!				aStart		= ProfArr[fnm][PAI_STARTROT]
!				aEnd		= ProfArr[fnm][PAI_ENDROT]

				gosub "PlaceTubeGroup"

				put\
					0, 						-zOffset,				2,
					yProf - yGlazingBead,	-zOffset,				2,
					yProf - yGlazingBead,	-zOffset - zGlassThk,	2,
					yProf - yGlazingIODiff,	-zOffset - zGlassThk,	2,
					yProf - yGlazingIODiff,	-zMax,					2,
					0,						-zMax,					2,
					0, 						-zOffset,				1
				material sMaterialS[MAT_SASH_IN]
				StartOffset = InnerD1
				EndOffset   = InnerD2
!				aStart		= ProfArr[fnm][PAI_STARTROT]
!				aEnd		= ProfArr[fnm][PAI_ENDROT]
			ENDIF

			IF	iDetLevel3D	= DETLEVEL_3D_100 &	GLOB_SCRIPT_TYPE = 3 THEN
				put \
					0,						-zOffset,				2,
					yProf,					-zOffset,				2,
					yProf, 					 0,						2,
					0,		 				 0,						2,
					0,						-zOffset,				-1
				material sMaterialS[MAT_SASH_OUT]
				StartOffset = OuterD1
				EndOffset   = OuterD2
!				aStart		= ProfArr[fnm][PAI_STARTROT]
!				aEnd		= ProfArr[fnm][PAI_ENDROT]
				gosub "PlaceTubeGroup"

				put \
					yProf,					-zOffset,				2,
					yProf,					-zMax, 					2,
					0,						-zMax, 					2,
					0,						-zOffset, 				2,
					yProf,					-zOffset,				-1
				material sMaterialS[MAT_SASH_IN]
				StartOffset = InnerD1
				EndOffset   = InnerD2
!				aStart		= ProfArr[fnm][PAI_STARTROT]
!				aEnd		= ProfArr[fnm][PAI_ENDROT]
			ENDIF

			IF	iDetLevel2D	= DETLEVEL_2D_50 &	GLOB_SCRIPT_TYPE = 2 THEN
				put \
					0,						0,						1,
					yProf, 					0,						1,
					yProf, 					-zOffset,				1,
					yProf - yGlazingBead,	-zOffset,				1,
					yProf - yGlazingBead,	-zOffset - zGlassThk,	1,
					yProf - yGlazingIODiff,	-zOffset - zGlassThk,	1,
					yProf - yGlazingIODiff,	-zMax,					1,
					0,						-zMax,					1,
					0,						0,						-1
			ENDIF

			IF	iDetLevel2D	= DETLEVEL_2D_100 &	GLOB_SCRIPT_TYPE = 2 THEN
				put \
					yProf,					zO,						1,
					YProf,					-zMax + zO,				1,
					0,						-zMax + zO,				1,
					0,						zO,						1,
					yProf,					zO,						1
			ENDIF

			gosub "PlaceTubeGroup"
		endif
		
		!-----PT_MULLION -----------------------------------------------

		if iProfileT = PT_MULLION then
!FIXME checking if yProf1 and yProf2 are at good place and not mixed up
			IF	iDetLevel3D	= DETLEVEL_3D_50 &	GLOB_SCRIPT_TYPE = 3 THEN
				put \
					 yProf2- InnerOffset + xOffset,						-zOffset,		 2,
					 yProf2 - InnerOffset + xOffset,					zO,				 2,
					-yProf1 + InnerOffset + xOffset,					zO,				 2,
					-yProf1 + InnerOffset + xOffset,					-zOffset,		 2,
					 yProf2 - InnerOffset + xOffset,					-zOffset,		-1
				gosub "PlaceTubeGroup"
		
				put \
					 yProf2 - InnerOffset + xOffset,					-zOffset,		 2,
					 yProf2 - InnerOffset + xOffset,					-zMax + zO,		 2,
					-yProf1 + InnerOffset + xOffset,					-zMax + zO,		 2,
					-yProf1 + InnerOffset + xOffset,					-zOffset,		 2,
					 yProf2 - InnerOffset + xOffset,					-zOffset,		-1
			ENDIF

			IF	iDetLevel3D	= DETLEVEL_3D_100 &	GLOB_SCRIPT_TYPE = 3 THEN
				put \
					 yProf2 - InnerOffset + xOffset,					-zOffset,	 	 2,
					 yProf2 - InnerOffset + xOffset,					 0,			 	 2,
					-yProf1 + InnerOffset + xOffset,					 0,			 	 2,
					-yProf1 + InnerOffset + xOffset,					-zOffset,	 	 2,
					 yProf2 - InnerOffset + xOffset,					-zOffset,		-1
				gosub "PlaceTubeGroup"
		
				put \
					 yProf2 - InnerOffset + xOffset,					-zOffset,		 2,
					 yProf2 - InnerOffset + xOffset,					-zMax,			 2,
					-yProf1 + InnerOffset + xOffset,					-zMax,			 2,
					-yProf1 + InnerOffset + xOffset,					-zOffset,	 	 2,
					 yProf2 - InnerOffset + xOffset,					-zOffset,		-1
			ENDIF

			IF	iDetLevel2D	= DETLEVEL_2D_50 &	GLOB_SCRIPT_TYPE = 2 THEN
				put \
					 yProf2 - InnerOffset, 	 0,							1,
					 yProf2 - InnerOffset,	-zMax,						1,
					-yProf1 + InnerOffset,	-zMax,						1,
					-yProf1 + InnerOffset, 	 0,							1,
					 yProf2 - InnerOffset, 	 0,							1
			ENDIF

			IF	iDetLevel2D	= DETLEVEL_2D_100 &	GLOB_SCRIPT_TYPE = 2 THEN
				put \
					 yProf2 - InnerOffset, 	 0,							1,
					 yProf2 - InnerOffset,	-zMax,						1,
					-yProf1 + InnerOffset,	-zMax,						1,
					-yProf1 + InnerOffset, 	 0,							1,
					 yProf2 - InnerOffset, 	 0,							1
			ENDIF

			gosub "PlaceTubeGroup"
		endif

		!-----PT_ZT -----------------------------------------------
		
		if iProfileT = PT_ZT then
			IF	iDetLevel3D	= DETLEVEL_3D_50 &	GLOB_SCRIPT_TYPE = 3 THEN
				put \
					0,						-zOffset,				 2,
					yProf,					-zOffset,				 2,
					yProf, 					 0,						 2,
					0,						 0,						 2,
					0,						-zOffset,				-1
				material sMaterialS[MAT_SASH_OUT]
				StartOffset = OuterD1
				EndOffset   = OuterD2
				gosub "PlaceTubeGroup"
		
				put \
					yProf - yGlazingBead,	-zOffset,				 2,
					yProf - yGlazingBead,	-zOffset - zGlassThk,	 2,
					yProf,					-zOffset - zGlassThk,	 2,
					yProf,					-zMax, 					 2,
					0,						-zMax,		 			 2,
					0,						-zOffset, 				 2,
					yProf - yGlazingBead,	-zOffset,				-1
				material sMaterialS[MAT_SASH_IN]
				StartOffset = InnerD1
				EndOffset   = InnerD2
			ENDIF

			IF	iDetLevel3D	= DETLEVEL_3D_100 &	GLOB_SCRIPT_TYPE = 3 THEN
				put \
					0,						-zOffset,				 2,
					yProf,					-zOffset,				 2,
					yProf, 					 0,						 2,
					0,						 0,						 2,
					0,						-zOffset,				-1
				material sMaterialS[MAT_SASH_OUT]
				StartOffset = OuterD1
				EndOffset   = OuterD2
				gosub "PlaceTubeGroup"
		
				put \
					0,						-zOffset, 				 2,
					yProf,					-zOffset,				 2,
					yProf,					-zMax, 					 2,
					0,						-zMax,		 			 2,
					0,						-zOffset, 				-1
				material sMaterialS[MAT_SASH_IN]
				StartOffset = InnerD1
				EndOffset   = InnerD2
			ENDIF

			IF	iDetLevel2D	= DETLEVEL_2D_50 &	GLOB_SCRIPT_TYPE = 2 THEN
				put \
					0,						 0,						1,
					yProf, 					 0,						1,
					yProf, 					-zOffset,				1,
					yProf - yGlazingBead,	-zOffset,				1,
					yProf - yGlazingBead,	-zOffset - zGlassThk,	1,
					yProf,					-zOffset - zGlassThk,	1,
					yProf,					-zMax + zO,				1,
					0,						-zMax + zO,				1,
					0,						 0,						-1
			ENDIF

			IF	iDetLevel2D	= DETLEVEL_2D_100 &	GLOB_SCRIPT_TYPE = 2 THEN
				put \
					yProf,					 0,						1,
					YProf,					-zMax,					1,
					0,						-zMax,					1,
					0, 						 0,						1,
					yProf,					 0,						1
			ENDIF

			gosub "PlaceTubeGroup"
		endif
		
		!-----PT_I -----------------------------------------------

		if iProfileT = PT_I then
			IF	iDetLevel3D	= DETLEVEL_3D_50 &	GLOB_SCRIPT_TYPE = 3 \
			|	iDetLevel3D	= DETLEVEL_3D_100 &	GLOB_SCRIPT_TYPE = 3 \
			THEN
				put \
					 0,						-zOffset,				 2,
					-yProf1,				-zOffset,				 2,
					-yProf1, 				 0,						 2,
					 0,						 0,						 2,
					 0,						-zOffset,				-1
				gosub "PlaceTubeGroup"
		
				put \
					-yProf1,				-zOffset,				 2,
					-yProf1,				-zMax, 					 2,
					 0,						-zMax, 					 2,
					 0,						-zOffset, 				 2,
					-yProf1,				-zOffset,				-1
				gosub "PlaceTubeGroup"
			ENDIF

			IF	iDetLevel2D	= DETLEVEL_2D_50 &	GLOB_SCRIPT_TYPE = 2 \
			|	iDetLevel2D	= DETLEVEL_2D_100 &	GLOB_SCRIPT_TYPE = 2 \
			THEN
				put \
					 0,						-zMax,				 1,
					-yProf1,				-zMax,				 1,
					-yProf1, 				 0,					 1,
					 0,						 0,					 1,
					 0,						-zMax,				-1
				gosub "PlaceTubeGroup"
			ENDIF

			gosub "PlaceTubeGroup"
		endif
	else
		! High detlev
		for fnm = 1 to PN - 1	
			!OUTDATED (or not)
!print str(ProfArr[fnm][1], 10, 0), sMaterialS[MAT_SASH_OUT], sMaterialS[MAT_SASH_IN]
!print iFills[FILL_SEALANT]
			CALL "Profiles_WMCC" PARAMETERS all \
				bReturnOnlyProfileData	= 1,
!				ShowHoles 				= ShowHoles,  
!				ShowArcs 				= ShowArcs, 
				dProfArr				= ProfArr[fnm]

			iAdditionalProfiles = iAdditionalProfiles - 1

			MoveX			=		ProfArr[fnm][PAI_MOVX]
			MoveY 			= 		ProfArr[fnm][PAI_MOVY]
			RotProfile		= 		ProfArr[fnm][PAI_ROT]
			MirrorProfileX 	= int(	ProfArr[fnm][PAI_MIRRX])
			MirrorProfileY 	= int(	ProfArr[fnm][PAI_MIRRX])

			if MirrorProfileX					then gosub "MirrorProfileX"
			if MirrorProfileY					then gosub "MirrorProfileY"
			if ABS(RotProfile)>EPS				then gosub "RotateProfile"
			if ABS(MoveX)>EPS | ABS(MoveY)>EPS	then gosub "MoveProfile"

			fillPenBg		= pFillS[ ProfArr[fnm][PAI_FILL] ][FP_BGPEN]
			fillPenFg		= pFillS[ ProfArr[fnm][PAI_FILL] ][FP_FGPEN]
			contPen			= pFillS[ ProfArr[fnm][PAI_FILL] ][FP_CONTPEN]
			fillType		= fFillS[ ProfArr[fnm][PAI_FILL] ]
			contLineType	= lFillS[ ProfArr[fnm][PAI_FILL] ]

			MATERIAL ProfArr[fnm][PAI_MAT]
!		print ProfArr[fnm][PAI_MAT]

			StartOffset = ProfArr[fnm][PAI_STARTOFFS]
			EndOffset   = ProfArr[fnm][PAI_ENDOFFS]
			aStart		= ProfArr[fnm][PAI_STARTROT]
			aEnd		= ProfArr[fnm][PAI_ENDROT]
			
			gosub "PlaceTubeGroup"
		next fnm
	endif

! Reinit
	dim ProfArr[][]
	PN = 1
return


!!!!!!************************************************************* Place Tube 
!!!!!!************************************************************* Place Tube 

"PlaceTubeGroup":
	ProfilNum = nsp/3

	if GLOB_SCRIPT_TYPE = 3 then
	!3D---------------------------------
		!!!!!********************************************************* OFFSET START
		dx = TubeCoord[2][1] - TubeCoord[3][1] 	: dy= TubeCoord[2][2] - TubeCoord[3][2]
		gosub "VectorAngle"
		AngleXYStart = VectAng

		dx = TubeCoord[1][1] - TubeCoord[2][1] 	: dy= TubeCoord[1][2] - TubeCoord[2][2]
		gosub "VectorAngle"
		AngleXYStart3 = VectAng

		aMAX = 120
		aMIN = 360 - 120

		AngleXYStart2 		= AngleXYStart3 - 2 * aStart
		if AngleXYStart2 > aMAX	and AngleXYStart2 < 180 then AngleXYStart2  = aMAX
		if AngleXYStart2 < aMIN and AngleXYStart2 > 180	then AngleXYStart2  = aMIN

		DL = SQR((TubeCoord[3][1] - TubeCoord[2][1])**2+(TubeCoord[3][2]-TubeCoord[2][2])**2)
		dx = DL  : dy= TubeCoord[3][3]-TubeCoord[2][3]
		gosub "VectorAngle"
		AngleZStart = VectAng

		!!!!!********************************************************* OFFSET END
		dx = TubeCoord[PathNum-1][1]	- TubeCoord[PathNum-2][1] 	: dy= TubeCoord[PathNum-1][2] - TubeCoord[PathNum-2][2]
		gosub "VectorAngle"
		AngleXYEnd = VectAng

		dx = TubeCoord[PathNum][1]		- TubeCoord[PathNum-1][1] 	: dy= TubeCoord[PathNum][2] - TubeCoord[PathNum-1][2]
		gosub "VectorAngle"
		AngleXYEnd3 = VectAng

		AngleXYEnd2 		= AngleXYEnd3 + 2 * aEnd
		if AngleXYEnd2 > aMAX and AngleXYEnd2 < 180 then AngleXYEnd2 = aMAX
		if AngleXYEnd2 < aMIN and AngleXYEnd2 > 180	then AngleXYEnd2 = aMIN

		DL = SQR((TubeCoord[PathNum][1] - TubeCoord[PathNum-1][1])**2+(TubeCoord[PathNum][2] - TubeCoord[PathNum-1][2])**2)
		dx = DL  : dy= TubeCoord[PathNum][3]-TubeCoord[PathNum-1][3]
		gosub "VectorAngle"
		AngleZEnd = VectAng

		for zz=1 to PathNum
			DxMove = 0 : DyMove = 0 : Dzmove = 0

			if zz = 1 then
				DL1 	= SQR((TubeCoord[2][1] - TubeCoord[1][1])**2 + (TubeCoord[2][2] - TubeCoord[1][2])**2)
				dxMove 	= -StartOffset * cos(AngleXYStart) * cos(AngleZStart) 	+ DL1 * (cos(AngleXYStart2) - cos(AngleXYStart3)) * cos(AngleZStart)
				dyMove 	= -StartOffset * sin(AngleXYStart) * cos(AngleZStart) 	+ DL1 * (sin(AngleXYStart2) - sin(AngleXYStart3)) * cos(AngleZStart) 
				dzMove 	= -StartOffset * sin(AngleZStart)
			endif

			if zz = 2 then 
				dxMove = -StartOffset * cos(AngleXYStart) * cos(AngleZStart)
				dyMove = -StartOffset * sin(AngleXYStart) * cos(AngleZStart)
				dzMove = -StartOffset * sin(AngleZStart)
			endif

			if zz = PathNum - 1 then 
				dxMove = -EndOffset * cos(AngleXYEnd) * cos(AngleZEnd)
				dyMove = -EndOffset * sin(AngleXYEnd) * cos(AngleZEnd)
				dzMove = -EndOffset * sin(AngleZEnd) 
			endif

			if zz = PathNum then 
				DL2 = SQR((TubeCoord[PathNum-1][1] - TubeCoord[PathNum][1])**2+(TubeCoord[PathNum-1][2]-TubeCoord[PathNum][2])**2)
				dxMove = -EndOffset * cos(AngleXYEnd) * cos(AngleZEnd) 			+ DL2 * (cos(AngleXYEnd2) - cos(AngleXYEnd3)) * cos(AngleZEnd) 
				dyMove = -EndOffset * sin(AngleXYEnd) * cos(AngleZEnd) 			+ DL2 * (sin(AngleXYEnd2) - sin(AngleXYEnd3)) * cos(AngleZEnd) 
				dzMove = -EndOffset * sin(AngleZEnd)
			endif

			PUT TubeCoord[zz][1]+dxMove, TubeCoord[zz][2]+dyMove, TubeCoord[zz][3]+dzMove, TubeCoord[zz][4]
		next zz

!			if 	ABS(TubeCoord[2][1]-TubeCoord[PathNum-1][1])<EPS & ABS(TubeCoord[2][2]-TubeCoord[PathNum-1][2])<EPS & ABS(TubeCoord[2][3]-TubeCoord[PathNum-1][3])<EPS \
!			then
!				TubeStatus = 1+2
!			else
!				TubeStatus = 1+2 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!			endif

		TubeStatus = 3+64+128
		gosub "PlaceTube"
	!/3D
	endif

	if GLOB_SCRIPT_TYPE = 2 then
		!2D
		!manipulating status codes
		for _i = 1 to nsp/3
			a1 = get (1)
			a2 = get (1)
			a3 = get (1)
			if a3 = 0 then
				a3 = 1
			endif 
			put a1
			put a2
			put a3
		next _i

		for profNum = 1 to vardim1(TubeCoord)
			add2 TubeCoord[profNum][1], TubeCoord[profNum][2]
			mul2 TubeCoord[profNum][3], 1
				gosub "Place2DPolys"
			del 2
		next profNum
		gosub "CleanStack"
	endif
return


!!!!!!!************************************************************* Place Tube 
!!!!!!!************************************************************* Place Tube 

"PlaceTube": 
	!print "iProfilNumber: ProfilNum, PathNum, (3,4), nsp, TubeStatus", iProfilNumber, ": ", ProfilNum, PathNum, 3 * ProfilNum + 4 * PathNum, nsp, TubeStatus

	sect_attrs fillType, fillPenBg, fillPenFg, contPen, contLineType

	if nsp > 8 + 15 & ProfilNum > 2.5 then
		!!!!!
		!README If there is an error here, usually there is an error with extrusion path, worth of checking, this script is usually OK
		!!!!!
		TUBE ProfilNum, PathNum, TubeStatus,
			get(nsp)

		vert 0, 0, 0
		vert 0, 1, 0
		vert 1, 0, 0
		vert 0, 0, 1

		if isTextMapVert then
			coor 2, -1, -2, -3, -4
		else
			coor 2, -1, -3, -2, -4
		endif

		body 1
		base

		if nsp > EPS then gosub "CleanStack"
	else
		gosub "CleanStack"
	endif
return

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

"Place2DPolys":
	if nsp > 8 then
!manipulating status codes
		for _i = 1 to nsp/3
			a1 = get (1)
			a2 = get (1)
			a3 = get (1)
			if a3 = 0 then
				a3 = 1
			endif 
			put a1
			put a2
			put a3
		next _i

		pen contPen
		fill fillType
		poly2_b nsp/3, 1+2, fillPenFg, fillPenBg,
			use(nsp)
	else
		gosub "CleanStack"
	endif
return

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!*********************************************************  Mirror Profile X
"MirrorProfileX":
	if MirrorProfileX then 
		dim StartPoints[][2]
		dim StartStats[]

		for u=1 to nsp/3
			StartPoints[u][1] 	= -1*get(1)
			StartPoints[u][2] 	= get(1)
			if ABS(use(1)-4000)<EPS | ABS(use(1)-4001)<EPS then 
				StartPoints[u][2] = -1*StartPoints[u][2]
			endif
			StartStats[u] 		= get(1)
		next u	

		for t=1 to VARDIM1(StartPoints)
			PUT StartPoints[t][1], StartPoints[t][2], StartStats[t]
		next t
	endif
return

!!!!!!!*********************************************************  Mirror Profile Y
"MirrorProfileY":
	if MirrorProfileY then 
		dim StartPoints[][2]
		dim StartStats[]

		for u=1 to nsp/3
			StartPoints[u][1] 	= get(1)
			StartPoints[u][2] 	= -1*get(1)
!			StartStats[u] 		= get(1)
!!!!!
			if ABS(use(1)-4000)<EPS | ABS(use(1)-4001)<EPS then 
				StartPoints[u][1] = -1*StartPoints[u][1]
			endif
!!!!!
			StartStats[u] 		= get(1)
		next u	

		for t=1 to VARDIM1(StartPoints)
			PUT StartPoints[t][1], StartPoints[t][2], StartStats[t]
		next t
	endif
return

!!!!!!!*********************************************************  Move Profile
"MoveProfile":
	if ABS(MoveX)>EPS | ABS(MoveY)>EPS then 
		dim StartPoints[][2]
		dim StartStats[]

		for u=1 to nsp/3
			StartPoints[u][1] 	= get(1) + MoveX
			StartPoints[u][2] 	= get(1) + MoveY
			StartStats[u] 		= get(1)
		next u	

		for t=1 to VARDIM1(StartPoints)
			PUT StartPoints[t][1], StartPoints[t][2], StartStats[t]
		next t
	endif
return

"RotateProfile":
!!!!!!!*********************************************************  Rotate Profile around Z
	if ABS(RotProfile)>EPS then 
		dim StartPoints[][2]
		dim StartStats[]
		MinPosX =  10000
		MaxPosX = -10000
		MinPosY =  10000
		MaxPosY = -10000

		for u=1 to nsp/3
			StartPoints[u][1] 	= get(1)
			StartPoints[u][2] 	= get(1)
			StartStats[u] 		= get(1)
		
			if 	ABS(StartStats[u]-900)>EPS and ABS(StartStats[u]-901)>EPS &\
				ABS(StartStats[u]-4000)>EPS and ABS(StartStats[u]-4001)>EPS \
			then
				if MinPosX > StartPoints[u][1] then MinPosX  = StartPoints[u][1]
				if MaxPosX < StartPoints[u][1] then MaxPosX  = StartPoints[u][1]
				if MinPosY > StartPoints[u][2] then MinPosY  = StartPoints[u][2]
				if MaxPosY < StartPoints[u][2] then MaxPosY  = StartPoints[u][2]
			endif
		next u	
		
		MoveRotX = 0 
		MoveRotY = 0

		if BoundingRotHere then 
			MoveRotX = (MinPosX+MaxPosX)/2  
			MoveRotY = (MinPosY+MaxPosY)/2  
		endif

		for w=1 to VARDIM1(StartPoints)
			Dx1=0 	: 	Dy1=0 
			Dx2=StartPoints[w][1]-MoveRotX   	:	Dy2=StartPoints[w][2]-MoveRotY 
			
			if ABS(StartStats[w]-4000)>EPS and ABS(StartStats[w]-4001)>EPS then   
				gosub "CalculateVectorAngle"
	
				TempL = SQR((Dx2-Dx1)**2+(Dy2-Dy1)**2)		
		
				StartPoints[w][1] = MoveRotX+TempL*cos(Alfa+RotProfile)
				StartPoints[w][2] = MoveRotY+TempL*sin(Alfa+RotProfile)
			endif
		next w
	
		for t=1 to VARDIM1(StartPoints)
			PUT StartPoints[t][1], StartPoints[t][2], StartStats[t]
		next t			
		
	endif
return

! ==============================================================================
! Calculate Vector Angle
! ------------------------------------------------------------------------------
! Input variables:
!	Dx1, Dy1, Dx2, Dy2  :   Vector
!
! Output variables:
!	Alfa:				angle 		
! ==============================================================================

"CalculateVectorAngle":
	Alfa = -1000

	if ABS((Dx2-Dx1))>EPS then  
		Alfa = ATN((Dy2-Dy1)/(Dx2-Dx1))		  
		if (Dx2-Dx1)<EPS then Alfa = Alfa+180
	else
		Alfa = 0
		if Dy2>Dy1 then Alfa = 90
		if Dy2<Dy1 then Alfa = 270
	endif
	if Alfa >360 then Alfa = Alfa-360
return


! ==============================================================================
!
! End of Macros Script
!
! ==============================================================================

"endMasterSript":




]]>
</Script_1D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_PR SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[





]]>
</Script_PR>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_UI SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[









]]>
</Script_UI>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_VL SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
bOnlyOffsetData = 1

gosub OPTYPE_BASE + iOpeningType

!!!!!!!!*******************************************************  GLASS TYPE

_min = min(0, -(zMoveLeaf + zFrameOffset))
_max = max(gs_frame_thk, -(zMoveLeaf + zFrameOffset) + gs_sash_thk)
total_thk = _max - _min

parameters	gs_frame_thk = gs_frame_thk,
			gs_sash_thk = gs_sash_thk
!			frame_offset = frame_offset,
!			total_thk = total_thk

! ==================================================================
! Detail Levels
! ==================================================================

if GLOB_MODPAR_NAME = "aTiltS" then
	if 	iOpeningType = OPTYPE_HOR_PIVOT \
	|	iOpeningType = OPTYPE_VER_PIVOT \ 
	|	iOpeningType = OPTYPE_PIVOT_DOOR \
	|	iOpeningType = OPTYPE_TOP_HUNG_SLIDING \
	|	iOpeningType = OPTYPE_SIDE_HUNG_SLIDING \
	|	iOpeningType = OPTYPE_COMBINED_TOP_HUNG \
	|	iOpeningType = OPTYPE_PIVOT_DOOR_OUTWARDS \
	then
		aMax = 90
	else
		aMax = 10
	endif
	if aTiltS[Zone~] > aMax & aTiltS[Zone~] < 180 then aTiltS[Zone~] = aMax
	if aTiltS[Zone~] >= 180 then aTiltS[Zone~] = 0
	if aTiltS[Zone~] < 0 then aTiltS[Zone~] = 0
	parameters aTiltS = aTiltS
endif

if GLOB_MODPAR_NAME = "iOpeningTypes" then
	if isDoor then
		xHandle[1]			= min (1.05, LeafBoxB - 0.30)
		parameters xHandle	= xHandle
	else
		xHandle[1]			= LeafBoxB / 2
		parameters xHandle	= xHandle
	endif

!!	if 	iOpeningType = OPTYPE_TOP_HUNG \
!!	|	iOpeningType = OPTYPE_HOR_PIVOT \
!!	then
!!		xHandle[1]			= LeafBoxA / 2
!!		parameters 	xHandle	= xHandle
!!	endif

	if	iOpeningType = OPTYPE_DOUBLE_DOOR \
	|	iOpeningType = OPTYPE_DOUBLE_DOOR_Z_T \
	|	iOpeningType = OPTYPE_DOUBLE_DOOR_OUTWARDS \
	|	iOpeningType = OPTYPE_DOUBLE_DOOR_Z_T_OUTWARDS \
	|	iOpeningType = OPTYPE_DOUBLE_SIDE_HUNG \
	|	iOpeningType = OPTYPE_DOUBLE_TILT_TURN \
	|	iOpeningType = OPTYPE_OUTWARDS_DOUBLE \
	then
		xZoneWidth[1]			= LeafBoxA / 2
		parameters xZoneWidth	= xZoneWidth
	endif
endif

calculatedArea		= (LeafBoxA - OffsetGR - OffsetGL - 2 * yGlazingBead) * (LeafBoxB - 	OffsetGTop - OffsetGBot - 2 * yGlazingBead)
calculatedPerimeter	= 2 * (LeafBoxA - OffsetGR - OffsetGL + LeafBoxB - OffsetGTop - OffsetGBot)

!!values "iFills" range [0, 255]

END	minW, minH, maxW, maxH, 
	xWarnMin, yWarnMin, xWarnMax, yWarnMax, 
	Zone~, iMullionPointer, 
	yProf1, yProf2,
	calculatedArea, calculatedPerimeter,
	LeafDLeft, LeafDRight, LeafDUpper, LeafDLower,
	UnID, xMullionPos

! ==================================================================
! Dividers
! ==================================================================


10100:	!DIVIDER_VERTICAL / vertical division, standing mullions
	!Recursive subroutine for divding frame for placing a number of sashes
	!The processing order of the child sashes is depth-first
	!All the data is put into one dimension arrays, the position in the array pointed by Zone~ is the order of the depth-first walkthrough
	!With exceptions for arrays for Mullions, because for n division/number of sash there is n+1 Mullion pos (the 0th and the n+1st being the two sides of window)

	!Some incoming variables:
	!LeafD1, LeafD2		: Leafbox difference besides mullion, first/second side, set up at the mullion definig subroutine
	!OuterD1, OuterD2	: Mullions' outer profile length difference due to parent profile width, calculated locally form LeafDs, used in mullion profile start/end offsets
	!InnerD1, InnerD1	: The same for inner (and all internal: thermal breaker, etc), longer profiles. InnerDiff should be usually smaller than outerdiff meaning longer profiles	

	!init vars
	iNumberOfZones = iNumbersOfZones[Zone~]											!Division number of THIS divider as an array
	iMullionOrientation = 40000 													!horizontal/standing
	iAllocatedMullionPointer = iMullionPointer + iNumberofZones + 1 				!array of the Mullion grows differently, faster
	xMullionPos[iMullionPointer + iNumberOfZones] = LeafBoxA						!last pos = unit width			???????????
	LeafDTemp	= LeafDLeft															!LeafBox width difference coming from frame/parent
	LeafDEnd	= LeafDRight														!For the last zone, difference from frame

	OuterD1		= LeafDLower	+ OuterOffset										!Difference btween LeafDs and profile widths, for calculating inside mullion length for outer profiles
	OuterD2		= LeafDUpper	+ OuterOffset										!OuterOffset being hopefully a system specific constant, set up in master, at the beginning
	InnerD1		= LeafDLower	+ InnerOffset										!For calculating inside mullion length for inner/inside (longer than outer) profiles
	InnerD2		= LeafDUpper	+ InnerOffset										!InnerOffset being hopefully a system specific constant

minW = 0								!Size control
maxW = 0
minH = 0
maxH = 0

xWarnMin = 0
xWarnMax = 0
yWarnMin = 0
yWarnMax = 0

	if Zone~ > MAX_ALLOWED_ZONE_NUMBER then end MAX_ALLOWED_ZONE_NUMBER + 1	!Some safety against infinite calls
!--------------------------------

		for i = iMullionPointer + 1 to iMullionPointer + iNumberOfZones
			if i < iMullionPointer + iNumberOfZones then												!mullion is not for the last Zone
					gs_frame_mat  = -iMullionColor[2]													!TODO ????
					iProfileT = PT_MULLION
					gosub 30012																			!Mullion; sets yProf1 , yProf2 (profile width from profile axis on 2 sides)
					LeafD1	= yProf1 - OuterOffset														!yProf1 is simple to measure while OuterOffset is system specific (or not...)
					LeafD2	= yProf2 - OuterOffset
			else
				LeafD1 = LeafDEnd
			endif

			Zone~ = Zone~ + 1
			Zone~Prev = Zone~ 

				CALL "Leaf_WMCC" Parameters all \
					LeafBoxA				= xMullionPos[i] - xMullionPos[i-1], 
					LeafBoxB				= LeafBoxB,
					Zone~			= Zone~,
					xMullionPos				= xMullionPos,
					UnID 					= UnID,
					iOpeningType			= iOpeningTypes[Zone~],
					iMullionColor			= iMullionColor,
					gs_sash_mat 			= iZoneColor[Zone~],
!					iSystem					= iSystem,
					iDesignVariant			= iDesignVariant,
					bDrawFrame				= iSelectableProfiles [PROF_FRAME][Zone~] > EPS,		!If frame drawn elsewhere
					leafDLeft				= LeafDTemp,
					leafDRight				= LeafD1,
					iMullionPointer			= iAllocatedMullionPointer \
						returned_parameters x1, y1, x2, y2, x3, y3, x4, y4, 
											Zone~, iAllocatedMullionPointer, 
											yProf1, yProf2,										! For counting egress
											_calculatedArea, _calculatedPerimeter,
											_LeafDLeft, _LeafDRight, _LeafDUpper, _LeafDLower,	! Not used here, only at top level
											UnID, xMullionPos

!if iOpeningTypes[Zone~Prev] <> OPTYPE_FIXED then
		minW = minW + x1 + LeafD1 + LeafDTemp				!x1
		maxW = x2					!maxW + x2 + LeafD1 + LeafDTemp
		minH = max (minH, y1 + leafDUpper	+ leafDLower)	!y1
		maxH = y2					!if i > iMullionPointer + 1 then maxH = min (maxH, y2 + leafDUpper	+ leafDLower) else maxH = y2 + leafDUpper	+ leafDLower	!init

		xWarnMin = x3					!xMin + x3 + LeafD1 + LeafDTemp
		yWarnMin = y3					!y3 + leafDUpper	+ leafDLower
		xWarnMax = x4					!xMax + x4 + LeafD1 + LeafDTemp
		yWarnMax = y4					!y4 + leafDUpper	+ leafDLower
!else
!		minW = minW + xMullionPos[i] - xMullionPos[i-1]
!		maxW = maxW + xMullionPos[i] - xMullionPos[i-1]
!!		minH = max (minH, y1 + leafDUpper	+ leafDLower)
!!		maxH = min (maxH, y2 + leafDUpper	+ leafDLower)
!		
!		xMin = xMin + xMullionPos[i] - xMullionPos[i-1]
!!		yMin = max (yMin, y3 + leafDUpper	+ leafDLower)
!		xMax = xMax + xMullionPos[i] - xMullionPos[i-1]
!!		yMax = min (yMax, y4 + leafDUpper	+ leafDLower)
!endif

_bWriteParamsBack = 0

if i = iMullionPointer + 1 then 																			!1st mullion pos control
	xMullionPos[iMullionPointer + 1] = max(xMullionPos[iMullionPointer + 1], minW)
	_bWriteParamsBack = 1
endif

if i = iMullionPointer + iNumberOfZones - 1 then 															!last mullion pos control
	xMullionPos[iMullionPointer + iNumberOfZones - 1] = min(xMullionPos[iMullionPointer + iNumberOfZones - 1], LeafBoxA - (x1 + LeafD1 + LeafDTemp))
	_bWriteParamsBack = 1
endif

if _bWriteParamsBack then parameters xMullionPos = xMullionPos
			LeafDTemp = LeafD2

			calculatedArea		= calculatedArea		+ _calculatedArea
			calculatedPerimeter	= calculatedPerimeter	+ _calculatedPerimeter
		next i
return



10101:	!DIVIDER_HORIZONTAL / horizontal division, laying mullions
	!init vars
	iNumberOfZones = iNumbersOfZones[Zone~]											!Division number of THIS divider as an array
	iMullionOrientation = 40001 													!vertical/laying
	iAllocatedMullionPointer = iMullionPointer + iNumberofZones + 1 				!array of the Mullions grows differently, faster
	xMullionPos [iMullionPointer + iNumberOfZones] = LeafBoxB - LeafBoxDiff2
	LeafDTemp 	= LeafDLower														!LeafBox width difference coming from frame/parent
	LeafDEnd	= LeafDUpper														!For the last zone, difference from frame

	OuterD1		= LeafDLeft		+ OuterOffset										!OuterOffset being hopefully a system specific constant, set up in master, at the beginning
	OuterD2		= LeafDRight	+ OuterOffset
	InnerD1		= LeafDLeft		+ InnerOffset										!InnerOffset being hopefully a system specific constant
	InnerD2		= LeafDRight	+ InnerOffset

minW = 0							!Size control
maxW = 0
minH = 0
maxH = 0

xWarnMin = 0
xWarnMax = 0
yWarnMin = 0
yWarnMax = 0

	if Zone~ > MAX_ALLOWED_ZONE_NUMBER then end MAX_ALLOWED_ZONE_NUMBER + 1	!Some safety against infinite calls

	for i = iMullionPointer + 1 to iMullionPointer + iNumberOfZones
		if i < iMullionPointer + iNumberOfZones then
				gs_frame_mat  = -iMullionColor[2]
				iProfileT = PT_MULLION
					gosub 30012
				LeafD1	= yProf1 - OuterOffset
				LeafD2	= yProf2 - OuterOffset
		else
				LeafD1 = LeafDEnd
		endif

		Zone~ = Zone~ + 1
			CALL "Leaf_WMCC" Parameters all \
				LeafBoxA				= LeafBoxA,																	!TODO check diff2
				LeafBoxB				= xMullionPos[i] - xMullionPos[i-1],
				Zone~			= Zone~,
				xMullionPos				= xMullionPos,
				UnID					= UnID,
				iOpeningType			= iOpeningTypes[Zone~],
				iMullionColor			= iMullionColor,
				gs_sash_mat 			= iZoneColor[Zone~],
				iDesignVariant			= iDesignVariant,
!				bDrawFrame				= iSelectableProfiles [PROF_FRAME][Zone~] > EPS,								!If frame drawn elsewhere TO BE REMOVED
				leafDLower				= LeafDTemp,
				leafDUpper				= LeafD1,
				iMullionPointer			= iMullionPointer \
					returned_parameters x1, y1, x2, y2, x3, y3, x4, y4, 
										Zone~, iMullionPointer, 
										yProf1, yProf2,																! For counting egress
										_calculatedArea, _calculatedPerimeter,
										_LeafDLeft, _LeafDRight, _LeafDUpper, _LeafDLower,
										UnID, xMullionPos

!if iOpeningTypes[Zone~] <> OPTYPE_FIXED then
		minW = x1						!max (minW, x1 + LeafD1 + LeafDTemp)
		maxW = x2						!if i > iMullionPointer + 1 then maxW = min (maxW, x2 + LeafD1 + LeafDTemp) else maxW = x2 + LeafD1 + LeafDTemp
		minH = y1						!minH + y1 + LeafD1 + LeafDTemp
		maxH = y2						!maxH + y2 + LeafD1 + LeafDTemp

		xWarnMin = x3						!x3 + LeafD1 + LeafDTemp
		yWarnMin = y3						!yMin + y3 + leafDUpper	+ leafDLower
		xWarnMax = x4						!x4 + LeafD1 + LeafDTemp
		yWarnMax = y4						!yMax + y4 + leafDUpper	+ leafDLower
!else
!!		minW = minW + xMullionPos[i] - xMullionPos[i-1]
!!		maxW = maxW + xMullionPos[i] - xMullionPos[i-1]
!		minH = minH + xMullionPos[i] - xMullionPos[i-1]
!		maxH = maxH + xMullionPos[i] - xMullionPos[i-1]
!		
!!		xMin = xMin + xMullionPos[i] - xMullionPos[i-1]
!		yMin = yMin + xMullionPos[i] - xMullionPos[i-1]
!!		xMax = xMax + xMullionPos[i] - xMullionPos[i-1]
!		yMax = yMax + xMullionPos[i] - xMullionPos[i-1]
!endif

if i = iMullionPointer + 1 then 																			!1st mullion pos control
	xMullionPos[iMullionPointer + 1] = max(xMullionPos[iMullionPointer + 1], minW)
	parameters xMullionPos = xMullionPos
endif

if i = iMullionPointer + iNumberOfZones - 1 then 															!last mullion pos control
	xMullionPos[iMullionPointer + iNumberOfZones - 1] = min(xMullionPos[iMullionPointer + iNumberOfZones - 1], LeafBoxB - (x1 + LeafD1 + LeafDTemp))
	parameters xMullionPos = xMullionPos
endif
		LeafDTemp = LeafD2

calculatedArea		= calculatedArea		+ _calculatedArea
calculatedPerimeter	= calculatedPerimeter	+ _calculatedPerimeter
	next i
return



]]>
</Script_VL>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Comment SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Comment>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_FWM SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[









]]>
</Script_FWM>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_BWM SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[









]]>
</Script_BWM>

<Keywords SectVersion="1" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Keywords>

<Picture MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="0" length_in_bytes="48771" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000001000000
	01000802000000D3103F31000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000AEB00000AEB01828B0D5A0000BE
	0E49444154785EC5FD5B90755B96DF07E5CECC9DB7EF7E3DF7AA3E7D53B504DD
	0A497677D8729807BDD8025B175E78E081075EEC0802220840212C0B598220C0
	410401180299908D0D9265C0182CB5AEDDAD7BB770ABBBBAEE55A7AABAFAD4A9
	3AE77CF72FEF7B6726BFFF7F8C79596BEFFCCE77EA647EFDCFB5D71A73CC31C7
	1873CC31E79A6BEF9D9993EF7EF7BB93959595894EE59AF4F9383B3B4BAA8358
	437E1406DA282C3495B6106A0DF2551967222BA35614B74150A55E287D197BDB
	DA80B18280CD0DB5755A060AB3992EB8D3942C8B119CB19564750D03515E54B1
	14B41E5A1B1992373A372BBD749314555ED181A89334A564EB1CE86352AF5D7D
	198226E72BA76A25C52372C111161A0AE97E33D1C217E586DE622F9F48792EAB
	529A8A5F1A554F22CA8B4AA43A49438589AC0D455BA96B301419B197289113CB
	FCE295DDE31CC41249A1E3991CCA8C6BAB754A6244FD60BC16D1B98C641998A5
	6D60BE5897EA654E5243B3A177D8BA763E11E53157904A698EF62AE5B5150A06
	854514D5D53B77B97A277614CE436D9888160DE3B651DD9C372DD60BB03A0A81
	9B2E3679A192DAE47CA98C74BE94BFBD55955C4E05ADD2C2422C3F7A1523FD0C
	509FCF31DF8444766B743658D2A8D76512462FE6E9B714968AD67D831EAEF208
	0D246422782FE8CB10764AB229DC9F033DADCE27B91CA9A81E03B85CF8F6902E
	A4506177586EC90E07A28DD42403B4464185FE91DFD17019CC0ED70A35D40F16
	FC9A68028CA16646503EC416110A17F47C1A9CA744092DDE79C9551A74D5852C
	0EF6B0AA20E577878181AE61B0D5EF0253C3C606929331BB28CD808DAB4B996B
	783B84D9F5F289900104E547E5540C3484C601EB7C9C27267EA993F79DC652A8
	47723F1D4A2F3A74AA5E56EBA7B46AA393360114CD7E552DB6F3180C5B95CA91
	E8EB966349171779B9B48EDC186BB748908105E33D63E07762C1B059EE4B131E
	341C92710C2146CFAC6245AD5F51F1D9206DE7285185AAA283B29CC74B98A58D
	83303840D159E80E5DB184B4AF4FBA5C064D0B8AA703505C265C6C9C8361ABF3
	84E10FAABA3B80924F29D86D13C650274A440341F9DCB8632301B16ACD28940D
	310586ED4B93AE5555D4302E5BBCB470659388E671F825B9251E9939E087CEA1
	1B52D0A0EA94F111B2220B7D1E54BBA06E84DE74B92C3490B1A1AD171A6E36DD
	B083B49CD3745831164A45A5CBCBB514DF17FCFFD458D43F28D70E06D1DB5BB2
	0512CE9D0252DC742FEB9560235AC89DC9D655AE024FF7433DA53AB35F19146C
	502837686C3790B849A1D689C8F4AB301D8C6583D1785C831C4D42B0D82CDC90
	9CEAFCEAB31C62D8665052D3243B2CB419A0C4450DB37DE888422B2FD331522D
	7AD006C48025DBDC853058853B59440223ED1D247C4E15908A918997456418E8
	874F0330B0960642369A149AD33913E065D0672970C1860241CA586535F82E63
	4F0A7AB1A6D7542CA83D1B448DC90EBDD4B24A5E0BAA427990838A01A259EBB2
	FC0D870BD3F5A69623945789A1AA722C2880D19AF09218AF44A38C45FBC99016
	BDA2B48001BFD739D4DF874735BC46A318A85234509B4E3D642B99F269A02164
	9AD827A2888E6C857FF595258B8B36BB7B0678F1E82D62515A2A158E6A29302A
	5698EFE875D5265BB9AB3154B6614EBDBF29276E504BA09A85DA73C45351AB75
	64970A17E6D2CAC0A80A5D39502F68B31C35BC9CD4985739BC4C04CA35D0955A
	3807226EFF22643B9B4DAAD3E58A857DB3959EA3798127B96850DA4844AF82C6
	3D1719D421E455798D6056FF0C90D7F311FA23D6635B2ABFD0BD73D5B7391322
	7D3F92EEAB7B540E527108E22E15179AEEA558DE28F9521ACE861EEB2A2DCE6B
	095A558E72969640A2034D146AB910912594ACCD9C7374765C37EEDB08415503
	83069F80819E40D1C3B5CD950EBDBC688BE894BA6ABD15187D93A5383F9A2DAF
	844E4A1C7375EAEF00791516F2BB542BF3CFB3B81469DFE8E982114FDA9BFE4A
	23A5C35D2A2D96690B9C5FD301CDC550901C69C6CCF39448E0BCBA02FC2E4755
	5EFAD29D83D4250EA1A94EC618FDDA33F4439EB56655A5848A606D1AB242D326
	14C10ABB6D99D281442FE99E8EEA11589C052921EBAA5AB0D641320B12A3E2A2
	D10A498EDA475147BE449FF7109CD78457FC1CD044509CE33817ADCE563F3177
	102B2269AD68A82D17547481B630A766B6E21CCB0EE1587C417624B038B40B08
	AD356E52D00A566796881E6A3366636BD8419FAB98CF12D09B0B156E549AA56C
	576D9CC36E08470B7A3F8428A86FA9288A951C489BE9D47371A44AE85BFE2870
	76F5C9AD9739BE1AA2B214AFF3B64045D78BE07E7770697917AC29D47D92D686
	4F901CC4AB8D756049D34EDEA406B77461A9A5221D94E3B64CAEC63D310E8BA1
	25C4F6F21043A77809D61FE400C14BA195B32AA2A6DD91AC31106F5C51218D51
	1DC17E113AA7922CC597416F60DCAEF47B8097509E1D30AD514FB7122A0D39C0
	C333ACD1C5AFFE0E9075896A0568882B5C11B5A14662295A46348B0DBD821760
	D4B4365AD03704722FD23FA8732666F4076A432A3C90C492CA8A411DE8AB1DEB
	4F425510C4B845FAA2CA664A7EEBBA4CBD449BA4108CE4D526959B1542478E51
	52E745185553E47000ED6F575DC9625FA7665DD532171A4658CA04E961B8E9D6
	B5D0EB066A5E647C312727C020C3030B8C02B71CD5769616C9B1729797AB2F37
	F1529BD74147CE43756A280DF3A59A4BCA82BE2EE808DDC1D6392909EBE55285
	5C8936D10C546219528D2E3D4A9BCAAEC4505BB82B1D7938F91AA361C0CD972E
	4278BBC4CF22D0531D06CCDABCE72ED1B914960B1FE25886A5356696B4727570
	C28FF4C575E657D1EE1960B16F35A1A81C0FCDA0B62A5B8651F2BF0CB055CD31
	59A4FEA5942804A5674DC7D0F3561AF2B385B270B12A91AA3987403DD7DCAD12
	BAE24ADD94E7650435CD6B4147164D89818ABE903E870FA50BE297035670B2B6
	708337B63346B455B3685B9A55A89BEAAB8E788919A138477757D37B3244C7AD
	4ED7638C34973E980876B1A36BA141559113C07D1BE96D7D5D625090C52487B0
	B7E73402B6B4AC7A49748508E900E72B3FDFABD0DFB74CDAE2D07DD50BB4805A
	D58B05B1CC337F95D56331102EA2BA2E09977DCD50B5DAA0AA9ED230658A5CB9
	1AAE3020ADB08836225E7114A854D557BE7AD1F22A205EEF94E0648437D43940
	CFAF8D43BE54998C42AD886207B595FDEA83CF41BA22A811424DFF0C50BB6BAA
	EBF327216C0CC45FD0F647AA8A3E50EF21D4F5056AC0B9DD36ACE77CA8E5E01D
	9525908178D98E9B985A02C9E99070AC9216EEC46DAB3368077D72475DE353A2
	A7859049D11839BD2ACC188CA9E482DBBD7C042C1C259109B95C5E46AD112BB9
	EE5929BAAFC3C3680D1359D1F1E5416304D95527D42E8D74582ABA00DAAC76BD
	13A2DF2356129F808107B5306EFD52DA9019371B715CE83923F91E31921248A1
	916C1D69A1502399016245D7CB4551894619CBED816CE8A3B7585EC6485960C8
	2C8E572EE56089482451EA1C8C100A46B98AEF2A4B177615AD90CF8529C3BC6A
	9AABAC4B37BD450F3963B842A6AA41FBD0F32C17D7FE259CABB64122CBC45031
	B803048AE282AEE5821264E31843ACC276F02D56037B0E16F51758DBA8B18A1D
	AB5A29486D9591847DE85EC94E2C8BD30058E13C14A324862B962B083B61AA97
	086D41657D565B67132DBF35FA0284011F11085F237C3A5C575F0B88FA381ABA
	821C082706122ED566C33C878EE44FB4BA5E4A8D4341AAB1B3465C6B2F92535E
	06447470C01262D2C9BA5F43A3094D800C506B3F42F37F39D46E495BB392CF25
	FD5F8E70A07A98BE062F10642849BABD8251390993A53CB43E92EC21C3B69FBE
	BC1045C60D4A69215EB53CAE103A5EF36828083F8E4A57A460DFBB4895383B60
	AD4995D64967BF5A7D4780A694766A5A9AF7428150119A5AA36133136D366425
	88C6B55DA550A7AAE8480F7183AAAA05F15C1595AA8B511C488D501E82E3721E
	AA86715A7CC24ED9A15A9480336486CFE675D9336E382E2FC5B2CED2B06F8B88
	A496499A1FF5EA6A2F52E81CC2100A747490DD202706542B04A9112E3E6AB88B
	C7E381FF4444B30AB717235F61C7A6C24AF08219756A66F4B4214FC35B9D8CD0
	35C0B01C1D150F2A0A80E824DD739342388F4A55F4DCE0975241A912275F0303
	AD50D06F81FA5AB5AE68DD1CB05501A3E38DAA054B543E0D32D4F1D2612569BB
	0A829E36426669374278097F099CC199E50DCBDA6AA082AF731DB62ACC658926
	6391230FF335EA5972FC72550DCD227AB686DA05B7E2143543D3AE0A324021E5
	4B5556E7C502B500D057A43A2EC81217514BC3D078A3BABED85ADA6E3112EC5E
	3050EAA19A7450712C6D553152DB4F80D425A292422B84818A61C5A85583D9ED
	D4408BC546C372753716554ED45791247A25A24A29265B165E04E96EF93D6E91
	7CB3A143B8BF50356E332AB76CABA0E0C34C6BF1805A345EE69D07354CF1B898
	BB887453B23EE21AA7EA559ACB970EB3057B16EE09613428B81C45B435196091
	D773AC225ADA6AA933BF595D8E683454E8466ABD6465927C95B67A8EC587E0DE
	8FC45853416576F2A3A60562B72A1A52E845A3D8731072177C89CE2C7562D026
	10720E8E89BC9E0349470B1B192398951FCEA4AFBE8CC345394CD78AEA498525
	0A373A5764F3F522D07824322CA6B3960A7D69AE89055BA756A38B507846B9B6
	0808956BBEAA2AA7ABEA912E97532F55A7804B3ADB079D9AA0BD2A47CAD4CA42
	C891F2EA10925578809C006EC129AD1A5D338DBA792374CCD26AA99C6B8BC48B
	D149A16AA46DB9F2000DBBB6B51BAD3F8B4803A9354AC92BE8E85693B18FCBB9
	EA3B1740AF342BC42A73DB97014A79C48F018AC3A57A361A2595D136787D8D0B
	3D033A3B158578451124A79671AA164DB8B12F95A812BE9A2AA8B37D0924ED16
	A5686DA9B81CE2443D282CD1EAF03890058D5FC541B903B8B6D36A895614B54C
	711B3611CB242A06FA120B0C38032746D06D77D1486D507CE8A7F1277855F002
	21AABADA81EA9E04761E568867A34EA4E398AC6AB3D7B52C94765DFB81698A6E
	D4985C830186F329258AE07938B77EA04C2892BE46A13686105DB8594CA04947
	51E89A565DA4D5311FE3E682DA760E2D0804A367A7C5382A42A24C00956A8384
	CB7D9365F01296EA97801E84DA20D2C4D852853BECFA734502D5602FA766D560
	E25CCF12AA7CA140C232CBC623D1AD52BC2C1D6A7BE52C7DD943B38BA6D2300E
	BF162121D758CAE68CF19290ECE54AA271A17AB48A8ACE45485BA922557CDC28
	058DD2D78A5655142E2A5059554D76196AEDB039A53812C35A378A96B562F119
	2051247C6D275F15FB520A853D23215619EE4294D71248425552C775B954EDF6
	A7062D478D55FCF4FA3A3D9D97351BCDE92A3AA8596137BB4B6497B475BA9BAF
	4BA30B425FF8263A2F158342C23CF95DD4192A073BEA8295EC8A42F73C10521C
	CBEC095D55981F1A37532FB1924D318E118A98E0DA4EA4929D9E4A964681B39C
	0070871505B5A254A7C7E52598A3A367825A5F89A06B5930ED04AADCBEFA3CBC
	8C4C8F5E3FF15188BA88BD146A374BD187119C525310C552DB57429783EAAEA6
	92D12A253A818268A6B388104831FAE576438CCBB5FF83B66E287B363A78F928
	42898CE4029A3C4DEB110C0B2C206A3B812AB760C33552B71C211C364D545D5C
	86AD5462020C9981AA7F69FFA24DBC86C3E3022F19EFF99F8062C52D5D3AC76E
	80CAC5FA0153BD0F65C2126562458B5639282C60D89DD45E9826BB7216472822
	FDB11411C6B05164D423754B64B31E4725E355983D863D1B96108611ADA2A1CF
	4116A57DBDB75D755B5DAE51D3E85133155A6901664745560FA5A4B6D87295F5
	350C4B0585CB358E8A0CD36A712BA028EBDCF70094622769AA783C80752CE117
	B8AAD473F5B856C8D4B98F14C8F981635965A7A3238D2887D2A57AC179FC82F6
	BB888BFA856A4350FFCD685DE33A6CB6C0C862E1B71317E9112DA28F56204555
	E1577240CD98312A2F254B830E66057F5C4BB95340290E97061899562F8A9F22
	CC33CBD51D24E223AB6A3746A3EFDA2AD6CB3729389D5D9B4EEB1CDA02A9C2C5
	E0FAD5E08AC65BB03EC688D9C94B53D4CBA29566B9476FE005406C41B2A952ED
	5842B5C11BB0C75856D9F53F30767A8CAC6F6250F5886260C8EFC8024C7B7C44
	16628016C4F47C99D042A77BA1D27E09A2CAB5552482516AB24EA399ACB8BC10
	D191686586F1C256D57D4BA9A4970A3668AE4BF17239D0973A3AC9FE5DA08E94
	6FD1A5052C5F7F1B73545BB586BEAA52569204CB0C199D3664A2E4A875ED17FC
	81D178951A8A0D0486554BD0597B31ACA98A0E8C0492501CFA6301E2295EA2A3
	4D2755C9B266018474303C4181AE85115CA1AF497A2C3C2C7BDC78156E902EC9
	832C169661EE385B6086C771D6A91EE74275AE6F72B583766C193ABE8DF68C80
	1867AB43FF06708BDAACA8A88C2182DD6B3B5F73AFA2D285E82A976BB000A710
	3CCF0AFC38860886CE4D2078059DFD86102982A351CDB12CCCA50A864C9716E5
	9233F4072C881789810A98A396E60CF70C1D49E3E2B9C945647295AA905A521A
	1B319F93599628305B4721CE41AB19C8840DB16A6B4DF7726E18B4AA7EB4C952
	3ACE1D2089651FCEA95D364B7F5FE077F5ADD616C23C1790494FA5C8870B5514
	98CC3297AE265A8696242B8257D92216640CF40D2B87629DB91E235DBDC3A2D3
	4F5DB258100D3B46C0E9A2BAB814A9E464D9FA82020B3A1630100F282F43A1A8
	2C8B93164C045D3989A22ABA23DD50FDD15BB3165B186020230D5DA9AF1861D0
	46CDE2EAB3CA66891B4C4364FF5A004C1DD1B2BACF437054BB9488980CC2541B
	18E37E1A9D82B0518FAC53AB78B998F2519B75C9F3B5D029D1135DE527A1B659
	E233AC21F71CAD5547BB144951A625A3978F1EB6502D557B918E26B341AD1AA0
	71E37729477285995CA96A2E88E75269529B428C8E1E5583CE952A470C6AF2C7
	5850B65C4C6A7C5E820CA86BAB802DD69A4EA2D0A546802E47383B9C78C1B280
	5EED73801EAA4F992538871DE876A555721017F1C602AD7A502B320B5D8B4E3F
	80EE8BA148CCA1580FC9347F5E80A2BB57D447334DE4B2122F5704FA62880627
	A48DBCDA9BCC651062056D6585D2517D8F66B55A4469279EF99DAEA15AD767D3
	546981815470B27B59A16BBE8211ACA09AD5C68ADA2A5020C650739C51D0F33A
	378D2A69A2C92C4793639404194C9B7E953B408819955A243E1916953B1E4E13
	62CA6AD4066124D19C872A8594367AA7BBE63D9632C768869660A8214C26594E
	BA560232E9C6AAAFC20261D4CAA217A1B81221505C8B2BE76C26811073235D41
	91EECAA549A912C6E20328E707152E9726692D8EB876454184DD0BB4AA74B7A0
	147A7650D5FA40DE58EAF118166AAB410714C651D1AC7715BED60940B9AB5B8E
	17D70A29915E790614DBE776EA3CAD3474DB5ADFD38B885A0E0C2D1E7EB5CBA2
	A25201643554354270A11095590841742B3795BD8CB1C068EB786DB5202304B3
	DE05282E8AA9AE5634274466A9B6AE32AD22A82C77C439C6841A2588425BB215
	5C0C649E4972C837370B40A48BD529234A6298E9F8FB24A4CED05D21B2D30054
	1B0DBB09B0B026804E4B34EA198BD0A7451E9BAAA7BB41BF0863B53295E4CBA1
	F4A841AE0C8982259ACF71D292259E5DB3247D4B3D0754A88905CE88C9D04296
	064CCB483285B3B25888629CC52B3229D621AC96763DD537E8B92320516A4F4F
	873DAF9016BDFAEA42A403EE7B0785AB3225D028B74856A92916CE450A2F2235
	74F6D133886AD35B27C0B9A68A96AA2DD59F8F912ACF88AED9A8DACC9E579547
	545E6CAB400ACAAB619477C3CA5EF1B9465ECE7A0735E0E5A36B3CF2442531FC
	6A35954AA2D51851AC99B2205ED1570C2D97A6E257F71AB3B20AB3381725D2F7
	B4888C6D365822C62D9BB91CE77244455E245A9005799E2FD32FB0D7E0B6A9B4
	BCCC0B0CE680405D77077831AA9E208A9521C2C202FF85BE0F2B23348A518D92
	4F855C40699ED7A1502D513BB0931571F179D070E813A0368E2C0416C402515F
	A4AAF4CBE31CBD52A5A0F83286DB2C7B33DB35BDC6A497FA95B21AC7D2C43A8B
	C936C04A807351EADC4C4369699FEB9148AAAF69AACB14485F1AB504A5556BEC
	73AAECF8432C79081EC24DA303550FAF731D7105E2D9D940F7CE8541298E02CB
	3B4ED1ACB604034D43A061B126C55BAB906AE50196F106CC4581CE6F4312C1EB
	6B0ACD95431DEB6B0595F56A16C6B6282F98770E66D3211DB5D9A8B54B8A2188
	23D0E9ED07AB5437649DAA79F5CD55B388E072529719D113EDA238C6D296E8A8
	7A9C074CDBFAC04517D468D8B0CA8CB5D68815F45BA0A10E8A9191EAC800A5D8
	EB19A093EF4C47F4870727C1268AA84DF68C9E1AE23C3EC82A5DAA545A0BC0AD
	159510CEED6F4375DB5069B149C73139306E56DFC60D741A57F4282A14CAA4E2
	12CD97A0309B56CE3472BB72ED6A137265C05049AE91CCE962DB0B0DE14A8BEB
	07590D7A30CD8842451492950ED5491A15E326A00918A3E2A742BF05424FB564
	F793FEB4F07A9FC95E11C57A3444FF0AAB58D57920967C215AC4F11268B24BE4
	B3A6C1C36B42E4A70CC28B845355A8850C43D942E5A040D437F4851ABD4A645B
	0BC946A1C710D3B5D1B6CBB24257AB2926D48C0FD4661045416DE5F5D2D753AD
	FA9C29725830A49AD186221130A9935E5627C600432559CA4B4A73912F5DDBCA
	E9D8BA9EFB0C50847E04D0B4FA3874B6A27851AD8CCD2D6FE766D176D8E01C33
	0D126F4D96A9102A2753A097C0C4D84A5D880782A243B8D44E087D4804213A5B
	48A488093DED521C632C6101290FF5B6E0E40D165093B80947AA16511775B184
	A9D0EE7C818C4AB8D04AFBA855A7AC0501A77B70C5C2EC24FE82BCD8E2147482
	2F0B1B0812B4880393EDB4884553E15539D46C3801546F9973750AC5664A2E43
	549DAFCAAC25B13047A7C5AA4019CE112AB30F30543DA298A5CA5A44115D2A92
	9C256D4B1735E0BA6469D077E502C5384A454A8A19D9D97D5324245BCA199586
	E8F6215C838C46149C85E1CEA0B69E8192326AC8CC244E4F1CC378E9C125A543
	D42DAC2D05B89C6A8BEF3B4524B8EC720FD0E6FF640E66F393130A9C6047BB50
	1984F4F3CA8B217688E9C857C2A225564035AD56285A2AA4A023A2654A4DBEF3
	9DEF04459D9CE72ADD6AD0594DB8365F8BC8668920537A4193B42F6526017C93
	AD6515BAFAD4EBD710482C3213838A568092DEA27CA967154E834A7B9360DFAC
	2E5AD6A204C8E8AACF79D26F237C8E1252ABD01C450957EAC82904218A123183
	1E3A4A89A2B5454BFB699D6E50EDBAA4F319E958D4A94E2F940443BEA69A40E8
	976EE9145F1C79BCEA9986BC5A884B2DE4FADA1AC464558BECAA319F1D9BE10E
	855EDBD5C9D720A831DB05A19486DC8AC60E9DEDFAC9987CFBDBDFEEDBA62E17
	7A2DCD4675F713CC8C5B7728552D93A063F295CA66A4015695CFEA8118958BAD
	529DCF039C232A9FAA9525F0F0D2B6C8C47007A226D0F3039DDE68EF856C34EA
	55847C8ADA5AE4AC7F6C5EF43AD9D444D0A2AB55D7E27EB57957789E7A91A821
	6F329590C40890C21459BB49562A90D74A7E72B2BEBEAE26E8771E23BFBAB686
	33902A3BD16B07A261CDF260431F1C1E7CF4C31F5CBD72757D3A6D7EAA6592C1
	4C4EA0882C65F6489E7A933059CB63F90A4D80242D5D823E1E3F1B482D55D950
	44B0982A4A55A3B2D990D1348CED5523016A9313AD5A75A54241DFAE44BFBE3E
	09523172A420FDEE2AFB4E76A0BD9D770455130997E6C313EA583B9D734850A7
	55345B691D850EBE808C7479AD355F3C31BC644883EA0D31BC1E8B561DAFD825
	D90480D47EC4779B28866D2734E00A53949AE89F41E51A1F2FC98F61FDE15681
	9D6A04248DF70FF63F78FFFDEBD7AF6F6E6ECA402AD32548B17A6EA0D5270AA3
	3251BFD0ACDA177AC940E56802BC5734B8517896ED1BD4A2BE960904B23AE29F
	C8821B9D87818C9454A21640E966C558A043CF28628BA2C101C9CCBCE1EC05CF
	D1900CB479A9A1EB5E504DB8AB2B836056040D484657A00A564A2E4E32ADEE82
	ABB21A0F0B87C5980B6B2EC5789B2532D80BBF94ACB1124B8DB355679D244339
	9CF74BCA285267C2CA5F7055839E6E289A74ED680BE38EBA0F1DB719BCD9DDDD
	FDFEEF7CEFEEBDBB6B6BEB48D84DC4B32550B9E88957D8ED0D04CCA89C4E4A57
	9F4BEC870D53325F51FDDE7BEF0531543040A9692D41281B2125D27C20077019
	A2A24F9A041CAB4A9351DFBB982D7DAEF458CB106301941685A0A8B2EBE6DB2B
	A566F20D98CD5969E022E96C28A2F0CDF2E8C3938CD65D46DDCB2A527E78C81E
	C2975C01598BC49AF3175909F1E3E5594BB5ADB89DEE2150C8858C15178C8A83
	5221E32A5D016BCD972E7145AA1271D56D8407DB021E73D92A893A3BE5A1F798
	BDBE3754B3E3E3773EF7F9CD8D0DDC7BF6ECD977BEFDAD37DE78936703CF4D3A
	64ADA93D221167FF18AA0C5687050648572B8AAB4254554E573C9B7CEB5BDFB2
	3A9FC43286DA4ADD80791E10EA6D536A19E3EE24095CB3201F08DEC0A20AE36E
	0AA101655486AD90821E1212B440CD494E9599C64C8AA50ACB9917B3B49D384B
	03197EAA1DB316E4B3532DCF516BA1A8CA31359CBE1E7DF359B3CD56B564DA96
	4313255D291896EC405CE352AE25795263205881AAC7B735F642ABF313BF4FA3
	B76DF403AD82F379369F5122A78F8E8E486BF4E033B872F5CA749DADFCC44D10
	E3F9F6981648D28A921E1B5626B76FDFBE7BEF5E64FCF3E7CFBEF3DE7BAFDDBF
	BFB6BE1E735B9D6C7ED94907C3CC1680C209D47A970670DBAE832305955F688D
	519D00F90A841B235864CC8F7267B26A6F8894E05CAB0AC169A8501E359531C4
	6A689061B0891B32A22D4A2D52301906C994B69CB8485753A82406C49D730A07
	4B529E3DA13297EDB67D87E1AB90C256AE450C60DE03CAFA0CD772290C4BD220
	CA3D7A96AC2582A4B2E3815292799D3555F2FF9C73C7D06D4194D766833CF475
	CE8EFF546795599BC9D5F96C46BA1E6F6D6D91880F1E3CB87AF51A092D5769AF
	689C1D1F1D23451B38B88EFCD1E1212D1D2AD98E7D7CCE129F982A2845F9871F
	7E44F61F1D1DB2D5F9E37FE24FDEBA7D1BA5287FC604F8D6B7EEDDBF3F9D3201
	34258671C998C64F898E7ADB4AB5225F7D8452C2303F2A93DDD706D40B69CF09
	0074592441292D727D514C86A00A1E19D93571E87CC90E51CEDE2BE1B28D43A2
	31B07484474D2CD74291ADD526DBBA3D91A3198311B2DE276B56902892D30F1B
	650D73A8026188E1095BF0A181990C52725D5306470AC51D2258526D428092F6
	3885C985974E01535E94D5236C784956DB2603A260956C2AC8AAE3A3A3AF7DFD
	EB7BBBBB2CD2B3E3D9D1F1D1C1FEC1DEDEEEFEC1C1071F7CF0C7FED81FFB837F
	F00FD1CDC3C3C3A74F9F54192600CFA3D3F5F50F3FFCF0C68D1BA42C1615AF02
	48F21E90D34C1DBF75336142D150A69F3E35A1FED22A22462D6766D4B56BD710
	26D7FFD89FF86FDEBC71032661A5C977DEFBD6EB6FBC8E2D62ABD0AAF7D210A1
	8993CFF18A0C6DACBC7445C3B188E659C8E4064359C98C05DE7BEF5BC119CBE6
	D518F800B2148D42911660D2A82BEA6C3A10A9C6399441128014CE5901144D18
	C45F1D27D1BD06C3495D6E1CEB3183E4522238605DB76695695B17689D88B9A4
	380D7F2C9D5A96C086C37A8FD25C96064521F31876F79E0CBEC54ADC83A4896D
	06094A5A6E6E6965854F03F61857AE5C9112FBAC18940495C6C90A5B91E974BA
	BFB7FFEFFEBBFF6B56DF6BD7AF5FBBAA1F127A6767676B6B9B36EFFEF88FFFF8
	BB3F4ECE7DF9CB5FFA1BBFF8D76162935A34B2F3D9D8D840238B7D191CCEBAC6
	C4E38EA155E3F414853FFD852F84844744B96EFA9405FE0B5FF8192885C0C05B
	6A387FF4F1C757AF5DA32D7E12FF278F1F7FF73BEFBDFDD6DBB1C6A84F25F211
	C13C97933A2C24DF7456076D840CA86D0AA7A68CCF426BABBAA89FBCF7AD6F71
	4DA15422148E4DA8107E046B88085E1048B98972545742A42D87C64C2A2C2BB1
	68941CE2A582A30685701863C72C19D56909D1B9CF6609C54FD4D036A64D9B87
	95F035341506A83C35D7390BF172847CCD0AA5857DD55D3F3299FE416AA3A16D
	3419BCCFF2BB7F70E3C675359AAC3C7FF69C3BFE74BAF1F0E1039CBE71F3C6E6
	0629AE046205A58334468D8B5A95AF5DBB4E075974592FBD52AEB2B1C00C46A8
	879E63693E63E947FF1FFF937F12F9E7CF9E7DF7BBDF79F3CD37D95B03B20D17
	1DD833F4E0FDD5AB57D7D6D7BEF6D5AFFEEDBFF98B77EEDCFDDCE73E177DD102
	1143A3EF6C9EDCBA75EB0B5FF88207AA41DD3F3BDBDCDA6237EFAE27225E2F00
	02DFFCE637D7A61B8482ED213F4F9F3CFDCEB7DF7BE38DD7F50CC15E11999807
	A2DC229AA99CA5887D56B81C92411AE15293D6A9B8D9DC359A9AE8894FDA02E9
	2276D523845593A1073FBADAE0A2A8AC16C4917A924F2B863338F8610B0E9D85
	60C8E158B7A3A2345618CA7EA34B67D18618897025903E08BE72AAC261A0D123
	E85DCB1227650009EC948E6F01A8D659CD823D272949399667D27A7B677B7D6D
	9D059BF163A9FE7BBFF22BBFFAABBFCAD6776F6FEFF9F3E78F1E3DA2399BE3B7
	DF7EFBCFFCD93F7BFFDE7DF61BBFF66BFFE4CACE95EDEDED870F1FA2910940BC
	A45A4FCC93E7CF7731B1BBB78B1FE4AE6E02C7A4FBE9C1FE3E047922FF26136D
	9AD7D6718A883099E0A3F9BFF25FFDD97FE15FFC1737363731FDE10F3FBC77FF
	9EF24A6F9266CF3C34EA066B30C58F3FFAE8CACEF6E6E638950DC77218EA1EC8
	A3E7FCFA2540F82B5FFD2AF313EB38C4183F79F2E4BBEFBDF7C69B7A1728EFC6
	DD881B61214E66347AC0F43987CFE78ADAFB862651DA4578E292134054BE02B8
	520B69A930F242979C3A27510DAD999D6F6B50E9E733F74FE1CEEE0A164F9DD5
	0F6B4DCD812C98DF2A22601DA3022B2C8D5ECEF0C5F0228D875CFD8476AC949E
	CD0E0E0EB7B6B770959AA74F9ED0E2F6ADDB9B9B1BC8E1360ED186AD2F7A5841
	2323E1909D57AE5E45F7CD5BB7DE7AFB1D46F1EFFC9DBFBDBF7FF0C69B6F6C6D
	6ED2905C6460D993D0D1D75E7B6D6B736B776FEF3FFDABFFC9EFFCF677150E2D
	769A6CA9F0F414F9071F7D846F3FFF0BBF70E3BAB3C4710B4994D0A9DFFFFB7F
	FF75AAF434D507422165EFA1A7D2D333E60FDBEE7BF7EED1903A459BE9B4A6CF
	6E293055B803C07CFEFCD93B6FBF0DF16953F9470326DE7BEFBD8DCDADEBDC0C
	FDD6C5636F81DE7AEBEDB8B34926E49A2F41D7573BF18A0B7D6B8C2C18CEA23C
	357E91EDC49AA03069130074A203BF02C9286D37B6B6D6D6A75968683E143463
	798DEACE98E0612BA2BA92CA91284A647D76A9DB34383A3C62CDD3927C78000D
	01C91ABCB5BDFD335FF8191666728210C748A3436F79CC9818CA669D677A04BC
	7EED3ABB024CB03145AD8A6BABC73C1D1E1D1E1C1CB09D413184DFD43B6103C3
	4D804C7AF4F0E1EEF3E77FF45FFBD7FFF01FFE97D0FF95AF7CE5F5D75F673FCD
	7AA63E19242EADB6B6B6D6A7EBECCE7FF9977F8909853F3FF773BF1F492655DF
	6B824C137297FB064472CF4109905E34A43BFB0787D0F4FDE1A38778A2A5C155
	710E8F986F3BDBD83DE309F8EDB7DEA2EAD50007BEFEF5AF6F5FB9C203714C6C
	EE90EF7DEB1BEFBCF38E368165EF23C172B5DFFDAB7202CBA8CC992E74952C8D
	7B61D0C94BFFF00E9017BF0A61D060C020A0D38DADE9C60654E90CAFA6BC3323
	616D27B44B565273D122EDE59951747ECEA4CA56D80A53A4EFD4923780F63421
	883CB1B16C7FF1B7BEF817FEFCBFF3EE8FBD7BE3E64DF2865403E4FA1FF8837F
	F08FFC913F4212FCE66FFEE637BFF975A24C0A628525995A34900A0C0345ACB0
	A26A337D72CABE999E6DACAFF300C9B6FB7BDFFDF6F6F6D6C1FEDE177ECF17B4
	83880E44BF71E9E4E4EEDD7BBFFF0FFC01CCC26202DCBF7F9FED0DBEA5D86482
	F3F4978757ACEF3EDFFDDEF77EFB177EFEE7E184C052E01E0231DC2F0F662F0B
	0031D30478F890AD05C3A008DA8D2273CABC65E78618778037DF7823F8AF00F8
	406A6D6D33EB77B42F60023C7CF8DBDFF9F63B9F7B87318DDBB890D26ED113BE
	26011A058A604DB3617423085D93416323976039B16C02E4A5BCD24E7AE83309
	BCBE418E6D929DBBBBBBE496B35C49C6931ABB8D5A649D269190D59740C8F2C9
	4479A7DD298BD31113204072C76D9186406B3DA3E7C405A8DCDFDBFB97FEE57F
	F9F6ED3BDFF9F6B7DF7FFF773EF7B9CF6BE9E5D181707AAF8CC69D9D2BC4FA9F
	FEDAAFFDD22FFD5D7620049FFDEE4FFDE44FB2D893EE644CF400FD6C1ED818FC
	F8BB9F87094B984CB4D15E675F84DDF9DDBB7793BF003AC8D24BB67DE94BBFF5
	F6DBEF90EBACFAE8545D7C9FEC6C85698627CF77777FE77BBFFDCFFD21BD0BE9
	A617899C002B2BBBBB7B8F1E3D7CE3F53788468E8EA308CDFC27FEF41416F7C9
	7BE777EAC281F5AF7EF56B3C01C41B59BE033CFCEDEF7EF773EFBC13F3011FBB
	FB00E8D22B50C8C6A970EE7255220FF21FB2B45AD20C04375AC8D8C204E8112E
	994CC585C3304F3501B6C8D15FF9955FF9899FF889A74F9FEEEDED2A69B5B2EA
	1313AAF4B10B2BE2CA195B5286812890D2241F4A6257833CB0E20929CED4C190
	385A7E358EEC852D76F2F9CF7FFE9FFF857FE1DAF56BBFFDDDDF7EF6EC190F9A
	DC347047CBB4DFF1C045329E90FEB35FFF67ACE29FFFDCE74891ADADCD9B376F
	AAF6A520C1E822B3AE1F8B1EF87F7874CCD07DF5AB5F6102C43CB401392D674E
	CFD8143137F73C01FED0254D80B3B383434D00A2F1F0C143028249553839222F
	8824FB3D6FBD56D8D3BDE209F0E52F7FF9C6CD5B57AFF104C204983C79FCE4BB
	DF7EEFCDB7DE6250FCB0AE44F22B2F11F916F442C6A58FA0054D45DCE31412A5
	515E4728B5F5C504F8662B8F3064BBA4532427F9C7227B329FFFD66FFDD6CFFD
	DCCFFDD66F7DF1D7FFCBFF926586BE3130102CEA53EFC575CB7343B202277FFC
	277EE2DA351E8C22D73237081033E3277FEAA7E2894DAC1E7EE6D316EAF4EC83
	0F3EE071EA73E4377BEBB575565FFFE8A32ED65D92E0377EE337DE78EDB59FFE
	E99F2689511513ECE5715EDE577413E0AB3C01E3304D98A8750CB0E809B0BAB7
	BBC716E8B2EE00390126ECDC78087EFB1D260077422DFC9A0005DC84D9A4E1D9
	D1C1E1BD7BAF74027CE31BDFB872F5DACE951D8A44E3C1C70F1E7CF4210F3CD3
	8DA9DF11D14A61671DF1F1AB5D0A22865D7D6145E4A10775C3E60B8534DAEE00
	602004B2DC5DDC2A225B27C097BEF4A59FFDD99FE591FF6B5FFBCA37BFF10D22
	CEF329BB1AF62D7FE89FFB43FFCABFF2AF9210D147E38C6D8C37E29F0E283938
	3AA2974C80E7BBCF3FFFB9CFA3535024F5C3CD66C31380A9F8FA6BAFBDFBEEBB
	4C806CFC6980CAA4CE419D005FF9CA97B90378853B53CEE5477B67DC01B9CBB3
	EF620270DFFF992FF03871791320EF006FBEF5263629C6E21AA384278C82EE00
	4C80C3C3577A07585979EF3BDFD9DEDEE139CD7B9EC9471F7EF4E0E38FEEDFBF
	379D6EB03E2897BC083AAFE2A51C36D9CA058304D72B6B8B88EB41AB2E17306A
	5305B89677A30A8ABE8A564995073276D249B3D491EB14D93D5FD9B9C2AACF46
	9F497FE5EA159E4D6FDDBAFDC61B6FBCFE3A0959A1CF41B4AFFF949049FB8047
	91F73C65AEAE69A585C699EA28758C7A163E253E31FB0B9CD158D25E56AD140D
	586ECD5CD52DD288A4BC2CD888661D37BA93BCD1C5B8843F79F9DD80ACCABCD7
	784377C5A4333A1A4718E2A58CDA99AC65A3C536A01EC63528171AB298154D7D
	F087AAFD6EB31650BCC9BA6C2750AEA5E49591756CDD947487669F43F66F705F
	E0D1D8477CBF2AF3B74334FC91A16C23BF1428EFFDD909C583AC9DD77532F9E1
	0F7F98854F038FC6A780B2DF2E000DA563A9E9889ED2C74FA7F153212C38CF63
	C7951CC505B3F2480817106AEF69BD22B06565FEE318C673B01C165F47CED4A2
	BC2DAF38199552C397E8484849304C06DD2335FAB189BA62B319D2CB7E9AAABC
	C245326515D9893EE2651848FFADEDADCD2DF27F833B00533E642E04A14BB778
	41E3997ED4613628E1463879B9080FC2B23C608CFD13EE88D271D988BEB3E362
	EAE9273763B22FA2CC6ABD3DF56A11890122367A34CA592AAEC6D031D245CC1A
	AAE850487527102229EC0235A5B2233BA470A96E125991EF1B644D910CB85404
	1B428DBD345FBD725EEA3DC9A9DEB6A74E533FD6C28B84D461864D97A3877979
	6047741F5038998AABABB76FDF8E062F8F4FEFAA46506E445BD976C135710521
	70A9C044BCA546D8ED50B1E8ABBD92133C9B99FBEA4054487A0D8F319F9F6874
	F42B97E2057BE0ADC8520C91F3C6248541130B5E6D9FA81AC61540E29E00A21D
	256B5B22E9FABE22822E421D9BC5ED15A6DF945F4789E683BFAF66F18B848658
	17FDC4826736FCB2C25DBCCD05C8057F89C8DFCF910F36AAB0E801004FC209DF
	FA2F11110BE6BC860D671C1557F8D2C5E753BF1BF6D9E1AFFA953F3C114E8AD4
	BAE8A54C5E1ABA5FB538659F40D79B72129A64BC42CC840FE8A00AF4F9A0D0B1
	2AFC8EC1B002FDD544604943AF34C15F9F4ED52D3F11BEFEDAFD3B77B4FA7207
	604B741913005BDC6774ABF1BD3E7CB0FDB4A569F729ED7E2AF9228A65CD405D
	2242FECD5738D1F160C6EDF172107DD7C95F119DBBDBAD230A4E1359D9D9D1DB
	91AF14F16BCA068E6975D0FBD8F6A642A5E2B3AEA661DA77C7707092B85E514C
	56FCB4A3AB372A31641B1A1E71B05B9340615C92116EA893D65AEF34C45059BB
	3DBD19B33A595F5BBF75EB262AA8B58E45359F19EA837E072A22242C1839FE51
	DF05FA54B023C02B2BBE1487CA68085A822F1FBEF1AEA54D1B8C99A0BB91070B
	D45C7C65D0175822491C9C989E0A923871198D5D669DC46B0C932A455F4A3175
	894CFE002A26B79803038BF10CD040654B7D1592049D0644FC29A34B67F58993
	29409F79F6BD79F3863A7C293B20F9E45524EE9B8EA883AB75973A47C35F977F
	59FCC85E6A74698A4577DF7AF43BB25A3FFAC85D16D4591D505A7D1C6E9B653D
	921BDC8EBCE10E993CBF42E04B381019AA8710BD41E00D49179E259142228E44
	A38CBE987461792478C551F33E2F4B8C8D268090C28836E9E882CFD2E940774A
	9DEB1EF795958DE9C69DDBB7603228179B07A8C7A6DE6CD2E7BE8EA5B8AA0AFF
	2A5E66B593C746963F2DF4C4A45917749903624A275AEDD145F67F0C0CA48DB9
	FF1083D23EDD10725DF0DF20F95D0177E9FAE42DB71CA5C814FBD845A710D1A5
	3854D4B87A6CA32C946277702AE8E26D2BBC4AADAFD1A4825D6B5242951442B4
	340AF84F00B85AAA8B72AD36A7FADE3935ECCDE9DAB56BD78B8A0B47C6440EC8
	8DF48373B805981E3BDBDB26CF450CC28F8C30ACE75D7FC82D87429FA3D32BFF
	8C865E8CE82F269A270A8F9D89BA1E97E8C839F0EDB9444B2F96449587BEA9D4
	38AA8FC303AD53224AA9D1648A96ABAD642FC35E81EA24A72659CE163901AA9F
	9231BF0A14485BBCA7C161D1A26D6D9D55F06C36D3EFE93106EC47BFFFFDEF23
	9972170E1BD74B1E8405FDF6D920D5CE4B3B848C2C7E16F80EC4A3275EB8B37E
	C8F3B650EFC694E09CEBC90501332C40D3E9941B2F4577CD374AF924D3CD9357
	0EA2C11DB2990FCAFEE059DCAEB4A246854E956870D6AA8DC65AA47909B3135D
	9CC721AF32034463264028F52949238C0E5845B545EDBE4B06048FF864FF2A37
	DDE9943A589731FAD2AC74D700DB709E6A5A7393E5087A802A7101700856F49B
	7EB2EEC7922030229441B8840074C88138A5C3ECFA64149FCC4D0744266272BE
	4A746190573819B314977126FD44A6F8AC53385CCE711534C4498AE88F84A856
	12C612815A8E00C5334A9E4A1DC630E87261593E7AA32A26AE5C3766C7FA1C80
	CD0FD940EAEFEF1F3C7DF234FE6A52D7FC82A0B71AF5CEA322E8940361A74608
	AEDE138C428745CE670439A7B4D36CA3AF7E0754BEC98D74E5F2816902717870
	C8334086A38306B2F872F2237D35F033A2CD8018322EC150F270745B47E795C9
	BCD8F33CBD084DA050714DE608AAE86ACAAF327548CBA6F2C8B2207FED387320
	57141E0158FB633EECEDED5ED911F42E0482665E20B01B09E781B55B3E61BDDE
	4CC983BDFDFD8CEC65222C44C7F3CD5051E9924FE0D2FD201AABECADBD2024CB
	50403AC6DEDE5E52AF0AAC0EB379F77E34316212E252E685DDAB1E8A88E9AA73
	3FB815C352578C18678B686EE4C5D6DA38645286381320CB81627911852D0168
	07DCC52D7DDF55138954F8F0C30F9F3F7FAE2FA013FD5EEFC501B3CC2E7FB330
	175FCA988A44B440D023F317EF0D11C090F32E42A2B500CA0C97C1C59B1D20CC
	6D6C6E120B95894779AF220252C3B2F1E9BF82FED911EF4DE3010721614AE4DB
	B5764CAE2B5042A3237271A4EF59E2546B5CEC10E556D1EA6DAC92251C05BE03
	545E7AD31A07542E7A0BEDE43319AEEBF6AFFF8030FFE217BFC863B11E0652E4
	E2D1EF7FE4519829B688F2867EC3F8D2410779DE85D018771F78A9DF97D4F331
	72540E0F0F89898CC6843098068A8E6E8CC2D5ABD7827835D018E9E3D1D86210
	0DBF55959FCAE59E75908DF25E37F6319A48D445CB3C82953501E46BD1CB8188
	2297CA7C095ABF9A293592E8D524ABC09606DED1BB5CE778E8C50C6947F1EEBD
	7BD7AE5FFFE0830F627E7B8D4EA317083D7ABA3376DDA10BC03533F8035CBC17
	31C6FAAE8B9D69EB5906FDF22163BC262B532D3736EA93961EA8F0C59722FA4A
	311A0582A524B14B9A1C918EE539311CB5FB22A8755C5D487E545668C28C5842
	A86B57B72B72C9ECEAF219401C9B1B02860F9DDC9BD8D7E0343C3DD3B84AEF81
	C4DB7FA7B76EDD7AF7DD776192A3DC070E0F0E8E8F8F2F6A0E38B1F20B703A98
	63322FDF7CD609C4AA3CC2C5785011FD667EFBAFE16A31F076487741425A8CD9
	E14B87B24963513AA9D1712C945B72334263D6ABC56465EE5F960AC8CB139E0C
	E58A068F6A3B5C635489EAECC8E71CF73C84E59D525D0A2C40999B874FFE329C
	5188A14E4A63867ED401F2D0559A09DA85EB26C0DAFFB5AF7ED59F0CE823E1F7
	DFFF9DC78F1F97FBE045C0A6E5BBC758D95610AB9E08FDE1891677E39C687C26
	C881F8F5FF501F2E25AD13E7F4F3B210BA9DF131094D3115B92AD594285A267E
	77A03FCE0532F6DA0EE8C28F06CAAEF12AD5823DAE706D434F7758DE3909BB81
	AAAB08444707B9909A43A17A35A9B54694A22AD7C5D49F685D3F9E1DB3E91773
	7532F75F0E848F09525F8217847047C39C64B938038254FDE9D9D1E8BBEF17E6
	82517A84D19C81CA3ADF0F2123118B6B54257139C028DE28F8F910A2D541178D
	8F86A3F05F351C057D3D3E2211A7F85D70654E1FA2407173C05DF47DC8C9F9C3
	A93BE2A7941D8EDE5A4F6B0DD5B9F24A4D2754AE4139E9EDBD2783167E08EE74
	8AB8FE32E6162157EA2BF61A01B7BC28B833DE6B290BA39B007B46F81A8B5F8F
	51F1E2A06D0FF0943001EA97A072A5BB34E305EAB706224BB8A1E171A8D87204
	81C8A5FB3184F63BFEF5577927FBE2E8E1CD5076383CED00F2DB448F5E26C446
	1C8E02873BCBA59253FA303A82EF2D501AB6F168B70C54474DC886A560C64248
	B0F7F7F770C1D91F02D67941A87D433F41D4C6570B6F2EBDD59423DCDBCD5697
	00FDF9206CE158663FAC89DF85B403D011994B4374B3EFAF17571BE76CB7D231
	7C0AE2D522324D3FC48AC88447D5AB86E29D2B38550135A8F2412F364F66B44B
	4A18F4D99E24AB5474C3B350571995F44B74E65CDA99C4936EBCF58927FA5D30
	6F7E2EF80E20635A3CB0CEFAA24219D4608657305FD960632A292DB1EDE1A462
	E913F98563AAAF18E4676139FABA1F876F3956BBBBFA1BD4AF120C7F3C9CCB07
	528D4741AE5D78EADAD53341E478E656BE382DC97BD0F80B95D63E541DE8784E
	505AC6015CB7A49DCAF16E83A21C8B2F4C75521FF0E5AF3E5CB97A35849DFD40
	A58B44DC79AA7ECF32B1F3AB19A2C393E09B88EBC58310F812666D8653789846
	B925EE0775E1C83172283424518A9C2A7E99E3CB8AFECD5152AF0AABAB6B7EDF
	D3B05BE119D14922C6263C842C073F358289A8EA10324D4CD72691B6D01C8759
	8D0F5276D90A1DF21DB2094DB3958A917022B5DAFB8D79A6C76C764C912A3967
	B8C145C2D34FDFB3C8B18E1E61C75EF1C219D2EE02DF7E3D0FCE369956FE1966
	CA3D3B62BF2ECD87A6D75F87C6987E1CF3589B1808BB94AEDCBC79D3D2AF085A
	2BFD2DBD2C1325474B23A65370DD8D380A6A4E0FF23BE0526AE8617E138D4EF7
	22A6876D423F5152BBD6F63C64E3329C345607CD76C4351F98F1FA25682DD09E
	2BB210FA2F08D22B8BDC73C2658A8A910C651930013EF8FEF79F3C7912B782CB
	03FDC76AE4BDA8E8A9F71E30C3D50BEDFF00D26ECB98F29ED33FF10C60A338E0
	23E5A64BFE96FD652186A3EC7F80FDF1AF08E3A48A2556010D60399215A03464
	8081581118342C6444200B293B3651FE9A5270075581D6BE87545BB994EA7FA7
	CDE918DB7EFDA96431A448E3B144E16740D1C696CB0B8C7B5798326A9A9AEDED
	ED4BFDD34019561EF7D7F217FFD38B0C78F1095C70083AA87776C3EB7E9058A6
	D704A28E4E45FAFC6AA15B5305DEC8097E9A2F838CE45A8F4088F58E773211F9
	3110B6FA6AA36FDD9A17B40FC206EC842B070A80DE65B375C96366CD7F565CDD
	F2D2A7CF42E30351C90EAD7D36843DE69976968CAE6FAF6DBF11613DD3F77EEF
	DDBB77EDDA35712E0FFE1BE86C77C2685A0FD41EABEA327D30B81F7A7FAFF073
	625CF26D28B911B7E3DF1D7898C2B89CC84F87EC6184689CFAE6D4BAC432EFAB
	58253402B692840EC1020512957C1CC17BA94D42F121F4D20575ABCE3F975464
	C3339FEB7F5B00555423170AF23EEFADEAAB21CAB4DC53C560E1B934D03F3CD1
	7E2C4A3E67F729852F254A9781EC6D7E1E87211FCA7CED3D1510EDBB53CAE757
	076C1387F6101C1CC7C7FEE9ACE02D38D638D1A1203AA8E5522CEB62AF6D69C3
	3A01904BD122E562536A552EAA13EA819971CA8579757D8D5B01253A9F6212B8
	58B096F8AB16C0F71A7FEA145E99A94F1F5F09482F59D7074F8A0367675CD99B
	19971281016436DE14260CE143B075C4435873E7D58135485EA9FB699CB2C62B
	E7AAE021331DDEDA7BD774E8E207394A62B5D0A91A91401C590EA86C4E655B17
	87274004AD6829AA12A3A260E978D0A35A4F60F146040A17102D2E04D5136759
	E6191D9323724502B048CA83C3C357F0AE1F3635A825DC2220ED9219C2E53D04
	0B2522B3D95C3722F73FB91E5D7E88868AC0217A95D0F8304AC54D62157F4443
	AB84EACC3546858A8C635511C5452C6347DB36122048CE1D8FE84460D2D134D4
	7B21B8589A39ADB310727420729D8EF9C2CB6971A1C38F3A9B53F058485AD4BC
	B3544C0D86FC073FF8C1B367CFDAD85F02D4E5DC6694C1745F73CEA72F67FAB3
	799709EC60517741513A2889B003996A149896173A162F030CC6B218C081FC73
	01B9463843A2CA3FED30A7D6D6ABE3EC8E257A7A099A86F3B1EAB40945BDBAE2
	480FEA83876F1EF7DE2132920D9F56448D87EE092F65FF5341EAFC053BFF7645
	18901743C0D9DEDE2EFF83E3825D0055A33BAB323F84826413B73358037689B0
	4DC5C46F09085CAB23F22FF1E4E9D3A45E09708981A85E111FFDADCCB5B5487F
	8EE6D902FACAA439B9539C14EA3C46487E968610DF8DF308B07FE94AA0A79740
	3675B80F2AEB60DF4FD7AA613FA14A4093A01B808B815632EFB8CA6D94B332AF
	FAA3DFFE3EBD7BE7CED5AB5733412F0FB29E9685F8BD083B6557E48D2276C950
	00F2CD283B04F0C96E714A3F56CE8E8F5EE95F87C6AB8D8D0D72C3BEC4D734E4
	8A2FE9D3797037DA915C600DEDA8E8E98A36302930505834C433804E052AF46D
	132933F2298868A246ACBBF7EEDDD3AFA88A05EFE233D0D6FDBE875587910C2B
	F0D53BCF4B873AE73F881256F30E407C8470C453E21261BBFE5D5B07C12C4D06
	CD09F950FD5859B9ED3F5AFCCA80E9E1E0E7FB227E082EEFFF501FC708F85CDC
	6E5814EBA0BE2659D097691B3A7D38280E0F899412BD74EA4AC1060DB7F79AF0
	E981431C15F3F95C7593C9D6D6D69D3B7782A9AE39452E1C36ED8F7BEC2AE7DE
	D074E3F23FF274C7E586933EC2800F005AAE8433FDFDE1D2A0BE979844B18CCB
	2029CA9EF055A25B9894F499F1DAAED9E70687AC0D6180A6A36384E0D43C2D62
	59EC91F578D04998AC9F04A75070F5AAFC40F54DDB0FD7E96CAA6CC4D9F6EDEF
	EF7FE31B5FF75F848C9AB85E0CAA0BF98B88E106E0AACE51B61B93D5A3A3A359
	FC8AC2E541A6B4AFD5B06158E9E7CD5838555C2326495D22BC05223EAB1A1A59
	56BF79E94349C5C04E45CDAB831FCDFB70B04FF6E4D4304144BA3BEF75B658C1
	B00468323AB2C2188AAB7224002AC71779111C7D7B590AE200415015C505A8DE
	EB9C3D07F1C1BB1F49C5D4ED7867E7CAB47E13E11C3D3F1214D0BC879E64AED9
	BA00611F34EA1F7EF8E1EEF3E71EFC8B877BC54946E3F70128375BBA16115E97
	E3C300D856A62B148E80CC6A2EEA5D5A39199C570CFCC0AFF81FE69078C23601
	A7C2433BEB1FD78EFD4B9795A37188538F1E1443DF08D9A6C27461E8CACB326D
	7DB23711C1CE31A1297238E983C828A832C5B4DAADAF6F4CD63636B7AFDCB875
	E7B537DEF25B01597B1190AEFAC682EEA4619B936F08764844F72ED0A520FA84
	21C6D584124DB1F30AE7CA4409E565E2EC6CAADF47D5FBC27506E009B4074945
	5E97EFC700DC94088EBD121C1F3B17FED92598F250874B1957A1A77B7209CEAB
	958AD019FA0D95A289796C81EC4FFA85875C3B8E1826128E6ADED74201343CC6
	5F5593C9E6E6267B8F8F1F3C7CF4F8E9EEFED1ED7BAF5FFC97D2D42D47D3D6FD
	C68BF5DB4D28E27EEBE64DFD75BAEE4DE80B47988CBF7F9F71924331CCA5584F
	9708DD64BCD2ABB35CB3D7F6E1941BD4A53BB01C58ED4C8B984ED7D7461BC28C
	93D0BCEC1BC5A153A1821CA2B22042DC443B455D8F10E3A5F75272C8AA37CDAD
	6123E02A893B0105C55F648C3D09717272BAB7B7FFFCF9EEC347CC82E7B1465E
	109A79FF7E9DBAC79106AA1DBF3303B27819B06E4CCC8EF557F983255E3C9954
	872ED38586F2CF4A6218B8E283965F7D319101C90F5F25F90A8133FA3D29FF41
	D20883BEC29B4152C6B5E040F44745661810D7357D75C5B8A69210C31409E408
	45453723CDC823CA269CDEF6C555FC44BD4A41C2620078BA67C373AAFF207FFD
	C6F59D2B57F427BBD7D72FF2295061B3612D75F90E8C661D2ED6CDF699FE0620
	649DA1970399567AADE96F612824254C365D24CAF9929026F48BB622945E78A3
	82CE51EBA2245FCDBF8DEA417864DC7EE024473CBF656299722133B262547444
	7544749327A8618AF6EC1ED6952797533E18F92E908F3845294F058BCABDAE93
	FF12230F78BE21D03CFEB205DADE12B6B7B7EEDCB9FDF9CFBDCD8D2FE7C94500
	454E3BFFC5C9788B43CE4570D24DB80C76B8149C4B01336D43FF1DD0A1F21C70
	3F31EAB84497E379E9D26033F4345619C740063903AD0B16922B672B0F1E3C70
	F115815B903E9E9663B24FC2C44D296A23DDBC8625A7A0866E01EA5E39AC6151
	2E3A6CDD8588732A8D72146588236664A9D665581A22EBB346E6A088B5E743BE
	D31C5B3D96FF9DED2D9E050E0F8F1090F885C06BDC6C768C7710EE042CFD28BE
	7207FEEAE3C78FF70F0E2ED26E8F8C8CF2DC33AF45038C0739E84B80EDA469A7
	96EDCAA8999CFC6C166CF08AFF4B24C3C19EA786058718179C71C4028C4F1B21
	DCF6F14940E2BC234F05838290523544C6707F12A3E9C3228B0E5586BC757095
	7FFAE22B7793D5D5DDE7CFAE5FBB76F3C60D66C1DEEEEED3A7CF1883CBCA4399
	B7A3BABFEA6F01E9366B3EB720765F76EF12C1187B04F5BD0CC5C1432BAFEABA
	76B9F61318C40B753C970071B4E09EB0E5708E99F723FCF3F0CF086F7B1C029D
	7493C499E4084930257256C0A8958B18D4F685A09D0C81F3F2CD82F153512700
	BC6C67B1B81A79EDA6AEE6AE1A46C015623F7871595B5FE78E3C9FCF4E4EE6DA
	744E2607070755D36744B1AF380625C3B62EE744C8123E5DBB768DCD58C85C38
	6C4CA0CB74356C9B214EE69C4BE1CFE5A1685740EC83ECE6CB4B81EA24605CF2
	7230021EE9F756DB1B715A28191A6D7B7CC32AB33562D5211C8F6380C50AD103
	56A32A4A59574F92A1407EA3C66875E62DF32C01E58D471121DD39C365773E3F
	991F1D1DF1F84F08B8277CEFFDEF87CCC520963A85CF7F18425034C3133958FC
	8229D6A501ED4A3B3F6B7276B8328076A698BFECB42BEAED43DC043C721191A0
	2D74C97E8C813FF13F1C5CD0DD120F286AA216663817E720CF01BE671792321A
	BD58316089606C921D884AB62DC98E729E7A444B9D24624A42451EE0FAF171FE
	7F1E5644BFF3A5D40784802951042F02D6852DBDA3AC98F1D2E712E99C81D5F8
	679551BC3C6838F39EEEC088E3B7625CE9B359970C3FEE328EB1DF880D8F3C52
	B2B5A8BC6A78ED976B691F6F18B21C2A4184E888DC8BFDD42827398215944B68
	AC7A0747B98C910FE9A008E8548921CEAA1769C3B7313A7674944FA5603663FF
	03F40C14DF57B8E014D042B21A37515433CAFC78176E524EEA538293F925FE49
	B688112E30C0645FC43BE28507BAC3BBBC18C1CB01915067BDE00239C045EEB9
	28897333E85210D6F557F16A08FC61854252FCF060A91E660B15BCDED161314A
	1C6E15AF44E39C779C0326406741824D7F5E7DB89CC8125D3428ADAFEBCF34C4
	00C4E003D2C0B3A0EE022F04326DA31013CD401138AD8827BD3A79BEFBFCF0F0
	D2DE052AC01CFD0B22381A62DF91EC9E2A92B84490E565A761C80395F4621D48
	DFE4D3AB46ECF7B320A4137015967C38F711884EF48EF6B5596D46E59B9722AE
	B08D647C0268ABAFA666A9A234EE9448A916DC7E309DEB5C5DA72D07A4A7377B
	1EB7D52D8F57FA789150A2ABA3B2A74E4072E5305BD8D8D8600366F272103D37
	62B91565A7B8D06DF73A16E00BEFFE087AFF979DA70CABF7BE318AAD97A3A412
	DC57E04A43BDF9A47939C05919A1CCD146319E0A54574E3A07314654B87B514A
	4E9E0433A3C6753EE5F12244960C23336C655D8285A294A1D49CF078EB8DF9E8
	73ECFDE9A8562595D4DD8B8254E9207ACAF5D6DFBAF376F9ECECDA55BD0B1402
	9707F4AB77E9148C288850ADCA8239970307000BD3A9FE296DB1E57356891751
	78F80A3F080B8B91099196A43B77032D887867B7BC4C48522316D78EA8876BEB
	C587E16B2918AD60319F4618F25CF27781282850BAE86484A0CE9613D12A4BD1
	8DEA321F3A38AFB125F297BF5508C5170AC23AD7FB4E7A26F1211B650EE81900
	44E1D220F51AD2B2C1F374F47CF060878058AEBD5460198B65EEC55060371C08
	BF54D0BF8E7D55C08579FE73800057AD860A91064B479C2AE466275D8F0AD7D7
	A3A249A5B2AAB3092DB60AA8ADEF00E1C9C01FA0369CA2B1A55D6F310F74CA53
	BBB3B3AD02C2A7A71BD3E9D6E6E6F6F6B6FE61F0F6B6FF6BFC052115E922D376
	82426C349D7CEA24779DB5F5B5F0ED52A1DE96A862CE16ED9B3E1AEFF7BE9707
	99E3A52D90EE8A6639ED22162CB38E922ADE78FD7555BF32841F3E01BCF01723
	E2BD3B3D1B2844A44E3C0F482804BB4B7FF865BA24A39164297A080CA892CF59
	59647AC02BDF051A4246CC0FD7E234B28D7E91E61C1D1D553ECBFFC97CF6ECF1
	C7BB4F1F1E3C7B34391DFDBBAECF8234AFD8FA23A7E0464F5DC8FBBDA27BC929
	881D123D76781ECD1C699F9306A4665297030C71B3F59750E2F6A34BC4854BA4
	BF70B6B2B9B515E42B4004C75F8618DC21F98948C949470E1729BB36E4F228A9
	96072FB342CCCF9AAE4864270B4A311A27E5733637E2A2BB52320A8A30875B94
	7290920F04299EFAA3B3E6F7E4F060FFC9A38F8F0E0F8E0EF68F0EF78F0E76A3
	F6B323F4843B94304E3045C1F6F75E22E911DBDBDB634E5E94DD17A0C62E4C95
	A8342FC5B96468F6118770205FDA9EF95AED43A4CCAB01C15FF57716C305E7BD
	167EC7473E852F9C63FD32E053A703960AE5A8B068911F4B4859D5250C6A7DD1
	F8E89257DD0104978317AFAC4D50366BCCADE89F389F3D7DCCB257936FD8E622
	206FFCFF76F4F68B19707C3F756464905BEDA566BF6C9CAD6CB1A6DA886DC5CD
	47D332EA53A884E532E138382C32EA943347083F2CC5EB1263320219DF3E09B6
	0BDAA3C590159E0E5E3D27B8790A563924D589262A558930190C5E4D348B0E52
	00C9F67568C3C3653AB5D49A446DAD7AC757D7F9FC2418E4A53CF0E720B9240F
	DB5F04FC67E685D883C994D73B2D1BC16042AE5FDA97E1C2681027DA7CE78D48
	11D02CF0A37009DFA578D0E34C8F9B4961352C3B07F0B1DC078CE2D2AB813341
	B0038A49098B2F70C33338D5C59EA802C34243632CAB1D43024B5BB43F305844
	EACDB4883422612989D50CD37A7CA237B9F4D7BFF406BCDE812E59326EFED9A1
	79156A43B7F6E2712B1314E8CB84B57BDC9CFABAB51BE10CA3EBA10617DFF1A5
	D0DD2F086D31D2938CBDA9CE8F57E49290BFB5A76FE902862C5643DCD14608CA
	211442620847338E2896D31834AE47A0EF6F30C559689C51F2D733445846F25E
	C442E67C6865B190E21D7F299FDBAE18FA5682FA58AD7EA2AE4F03294DA302A4
	565F1CB7ED187DD24F1FC65D2A4AB4BD9AF1EC1329AF4E43C49408814B45D8C8
	E9269F0AA93839107ADFDD0B558C6DF5FBF221E3361D4507C45E394AE2668D89
	388AF351A75757301125319641558B75E24423B70FAA125E385D374411A80899
	E438D7E30EE09FBE474C7BBD07ACE9AE1AF32E0C25A4E57782CD0161A7922C36
	E1D265C1A1D4212BEAFEC0D8655AAE909162568BABB719E1489C898673506049
	3A3C3A32F9EAA08760FF120C3467C68485C21E6B918DBB5574C3479EBA6B216A
	792012C7002A0F6A4A8004739D92E206511E820D73E325946B4569AB9F082C1D
	B0926E4FE2A053A11B5E767041D16706EA39134D97E22CC89ECB3C853343CAE8
	5F066448935C29A641AD962EBEB7E7C1D1AF06938E2E6B08743D8DBFC66CBCFF
	FEFB41BC1A9CC6D790BA112013B457CD595A1ED8ECB88F727530BB76861F1F4A
	130B2586A5014ACF0718CBE7DBA03EB70ADFD893165C932CD3120E7137DEDCDC
	808C848BE07330C573965F1C2276EC70C256C0D34D8F5C0EAE7AE247E46E6E5F
	06DC2D9CA087D595BEB3495D64EF9723FA9B896507629CA0721132AEBCDA5F89
	6401D20A65EBE1020F87E18F3E9E13326C2D7A795D863E3BA15C8CA3B11680E6
	AAFC3C44966463A9EDF50C5BD7BA10EB073BBE026D52EF08697FA21D8A6F7B4B
	1CBB00A0D6874E14BBF940F14CFFB2DB7F9E3B799782542EC3FEE8B7FBDE6B67
	F81347E0B3C186BCF929FE8034EFFFCA5823F3D6DB6F07F16A40FC9506252611
	9F48FD88982E7D709AFB4296B8547EDF43105599063EB2A26264208AC189C69C
	7806288AF2E89B500C8CF494B3334C4291EAEEAD02EEECD7EAEF8D7A4D8B8B81
	7B2BBB8A610CAF4FE1834BAAB9E4EC177C9329EB2E36C3A2CEC521952F15B260
	3BB6C8A8F81A05505DE04A74827E4560BBE39BB07DE0A4596A3FEC53FA2534B2
	4F62356A97442B05D51FF55A8A89120B9064E5486C619FE0B6F2A45762344DAE
	727722C03A917EEEB078805CF402C0D3F082A21F1591ED9860A6F99F02C98A92
	BE3811942680FF778BB89783ECB6BAA6D4D72586356DE6450E5DB61B4EAC9313
	7D1CD1EC16C4143579896E2C871C6313D4122C7E77C279E3728FCAF1109652ED
	52306A4D9C03F42E0E5005C050B88A245AAB255F85E85193AB17A30B71035346
	9A1B735D385BB971F3967E1D4B8B3F89CAB8BC40FD678176DEF244BD10B86A36
	D89A3CAB159702750B6319018834AA3075BDBEBCEE0F105B1DD9D2A220F37245
	50545E85070B6057EC07B3661CC7480B3BA690251724194C679C38C92DA84508
	05BB1C038CDA04A3C9A9C4AB3F86CF0001677B2196237E0531808CFE2E4DEC80
	09FDB367CFFC08903F9791013B3B5762BC8BEEBCC42D48E5AEEED2107F7C1C37
	D47151E912C9E76ABB015385CB42EB63D8B2FD60A63FAE33E315C3CF45C519AD
	4D8C4E894504A8E6BA0A71311A37E4FBBAE471AA47A2290AAA6BD58440E58764
	7C5F3625F0A84FFACA37653A1A69F58D620AAFADE98F222AFF262B4747FA0F8D
	BE0708DD54B940C4302BBB8A0B6699E6A2C1BFDCCC13D4BBFCD340EDFD961640
	172FDD8982B0AE6EEB6BF7C110447663FACAE0C5412B23345EE0C9E6E69639DA
	B316875CE3621C814A54749CC54A90CC88767FF6D5E6CA2B2EB514DFCF3E176D
	0E14B82F7A71D2DC41C6222AFAB2BAAABF8C92C77C1E21B8406098387A68ED85
	CF26E489AFD1E90BB6BB14CC816A1D7019C7EB92E72116DBFED390BDE6525C7D
	6770F9958131F257B6B2FBF653DFD84D474C2CFA04836331641DA72343DAAF8A
	85B6363212832C25BF0BD41A158A6B3D40D71654C72B416F917197F4B7F9C97B
	DD017C13E0DE173217076D73EB8A5B810F7243EF0EF9C1A6ACCD97075607105E
	545B41846F3A0D9DBC0C608B3867C168D69B3B0A89EA5E15EC52C447510817F4
	506C8F3C1390CA6553E77A0C81704656E8C84436586827485FEA5C147385BE0B
	D421D4C7AA9F86BB16898E13834E8FC8F8FDFD7DFD8BF6C9E4C9E3C70F1E3C38
	9E1DB311D21DE072E2CE04482AA140C7DD06AF56276BFAE5049CBD14E3028AD7
	A7FAD3D011040D285B2F13AE0F82C3D59706B42FAE051DCEAFB964B0FA3120D5
	3C94DEAA121953A2834ABCE2480C252A0ABBC912808C70F0D01DEA75CA97CBE7
	60F916C87320BEB651EB55D27BFBA82FAC187C3198D9F1AF22D8EA6D6D5DB972
	85D417667A7B2E73E442E0A56463431F3C43040A1BF8419C5EADE9DF84B92A3A
	71A12829CFDEC326D2B689A88952E0121CE88021DD67EB778F8D083827137240
	0FA017380A2F01CCF93E9DEB145EE1A48BF6501259131E1ACABBEA6554F4C739
	2835124A5950E8865299C54064ADC902DD1846F07B7DBEEAC7B3400C7FE005A1
	5D07456866C8F5EBD7D9FCE8F360BF05F4FCF9B3E3E3E38B8A7EF816D62B548C
	518F1BAE53F3FDEF5FE89F645C8632A21AECD241EC0BF2F41541E6E2DBAFB62B
	6782A89C28150F5F111C92669158E124CF0472A6F021EB918C927C92E82A022E
	0577A16E88918468152AA3223E09EEA0249220F2B542CEC4CC8C5E791FD736FD
	B0E9D94CFF1952024F9E3C89270080E457BFFA557644A307B51F0118B2D57381
	237DED2BF8EA0BEEE0555DE402BD8F0EFA2522F463B10F6F046A68FA92FD5886
	F96C8657C01922AF9A1341D573AB681808D76340D6D2E0D5481F5895E1645564
	9963909725E9BB4432D9CA51648C2BE156CC6D3D00A87E7274E8B74181DF06F2
	7848F862C0D0E6B55FE71C5FFD99B6CC450CBEF6DA6B415F3CC29C49DCB0272E
	0C61E6D29A0B44D8F0D2E08014BF806666577CD560090C97A039B3664ED7A7CC
	877132E88DBB92774A1F5DDC265EFD91A711C42BAF8EE4353A023D2D323E096E
	2CD30389724A44CAFB145B212B702688797676F7DEBD78FFC72029D90849FE62
	802A8F3773CCC6437590FA640A86E25EDE8570ED85C3466DDA498645957040FC
	E24D8A5D3EC2AECF1A051B578860FE6ECE81E17B532C85C7B3E3C219B8244F73
	A04AF6A93E5FB8AF236A397CD235C8289657472E87648A8EC0E00E10FB1FBBD4
	5227ADC759864584CF45487167D3AFE8AF9C3D7BFA8C7E6AF9F74688E78494BA
	18C83A379C32AEB9C674503178D199CB036BAC6FF261462649B818E3E6D5D8BD
	0B4398E0ACE8BBABF11E00D0401851FC5D01D649FA2C3832F1BBB24C49AF9BF0
	4A6685F7095871F4AF2229B898CC4A975772FC0A8689802BCCE31C75FEDBA083
	741F648DC4ACC1A73C5B38BA503C3F9B4EF39FE1AD4E5667B3637A4E1E90FA80
	6960998B41BA50BEFD521C11E845A571266E1151BC2C4C26F16B1FD51044C945
	715AC52540CA43BD896AB7A61384FE3E5F19AF60BE22F87D88F845D9304DDA03
	5CE38847C817C3E1CB97F1A20EA8CEAF2CD673320A06450A9A09833B404E8491
	736E56DA468728A92F393D34BFE16AF9E1B2EAFF911187BE0CE41409B1CF8E3A
	CC3101069A15DCA8D504F8E0073F08F6A5C076B1AEEF1D743E54F7A2F86A40EC
	B5DC8C3F1811B4DA96317A955EC952F7688E69FFA9CC966CDA3802671A270ABD
	73AACCB22502EEC048125853E32595724A7104B254508B9CC3A7C289ABC8885B
	8B5E5C404EDE704CC25155E4CECE767676E633EE008CC89977416D23F8D9A160
	79913B3E3E8E21D734F03D55F60C393359D9DEDE8E26E65C30DC6FA98DA77C88
	6A1D0297E495FDEC06F0B2606BB283C5E0809E06E7CD90CBC368E183D6135A71
	2CEE4B145416574788FB14D7382C953C0BB94956677D29AA34B818D12A9236EC
	728496B3FA2B9192CA1A554A2CA52D106884C6BB05940160C1A79A49BFBBBBCB
	C243FF23E89C4320243F23AA03DA5F56BFBCF663BAFA8DDCDDBB7793BE4CE8CB
	2E25D729720EA2E1F2A7403C8A6037220032D74D4594E0E4A2FB4A409F319DCF
	00B6CB8E34684A7AC529214723FD5C234E54008BB94DE301715C17F55114DB2F
	5D962045930A94BB52615B46B4D15136968582EA82A3AF5ED3756E76B1F3D183
	B04F297D7160A4F5A18A1F8533307225DD730A12FF8BB73B84CCE1830C17D300
	EB14DB72DB555D06B0A558940FC262FAA53F0C0A7CFB335D9FAE5FF69F8A1982
	8488C8E00AA7D535FD42B0F8ED1D339F02E1B7207E920B70C36C5EE94EFCDC86
	46111D4AC94BB37C2E324125E9FB40F10F888DC384573732BBA002CB8FC5E27B
	109E0124A17EBA8E5E1022005DDC3226C1D482A7EED4DA8B479AD255435A90DC
	204C67F952E1678030CD19E8861035651E325630837E05C0151C58F347438178
	FF5FCE69D462689C3E4538888A2896700692E763B118E8E901164503CADA1CAB
	AE364593E1B9115F0D0AD27CB5727F7871B0EF8749940F0EF667FA16B4773F86
	A42F088A14C64ACED97EF871064B931028C47A48908F2116978B86CD16DD51F0
	DACF590C332FCBB61186626FD3667BB8E133153EA57751FF0A802B6DC7057176
	36F3B7C2442A33E20EA921537C22481673830273E3B214E756946655408AFB72
	87B62A586051309D5255F7E39E68C31395EC47E27D2EFA4EF6C3D1EA0F605DEC
	E7005DEACB09139CC5AD19A09930F9F0A38FD275D077E83343A9265BB9DF88F1
	0C0B70821908CFE0849397846A143774D6CBCFDFCD91578EB20F8C41E2605350
	438063E97056FA11C08838E9545E3D2823508F85FA0520D64B2D0BC8F0AF42B4
	6B5CEC4FBCCA397FF4EF6E5C65915C7A8DEDED6DB6E8AECC6761042E0C36A76B
	0C76143977010D6CE84FE65764AB8B8382C0CE1B434EB5B42E78D48343581E3D
	7AF4ECD9B34BDA7E8441E0A5C79915A3ECFCF3F2D345E99523BD32704D8EE5AA
	112B88CB76AE9480CB7E25C328BCE0B7438C05242F2E4840D86033D2A17E15C2
	E271CD9295DB64523EEBC794BD5EA86630F42510EBD0BBD0390617084CB0A18C
	3FFE1C5D0A1F30C4395CE372F7EEDDBEC3665F1C1C3220136933018D7BF6446C
	FD52C4E5FE8D3A99F048142F6C2B8A3A0FBC7B75E099BBEFB3EF917A528466AC
	EA92BF0CADCAEE0BEEC5D226AAD4A509472179AAE3AC9FAA239809AF4CAE7645
	1E56E5ABCB41C96F1734ECCEF1340EFC06A887590F647143502F9D97A1E70281
	3A546B6E61A04C0300CD39B24DBEF66977A12E54658C28B4ECDA1371C87ED5A4
	08D1C0D1A02F07BE05757798EA06A3A0777ECA7C08FEAB43C44146D31FF6C9CA
	0F71B41A1797BC582E83D9E7D40D603DC590CF95AEA802237E6C8100029C2C16
	9279CD9738F2B550BE04C1597F24C23D5C534E6AF6EBF15FF9EFBF0E940D2E02
	58E1ECD00959540D27CD09982110BE76B8402F025238F3BFC8C70DCD37F1D27A
	94A2182978E1487B71F12A13C09936E53AD311AB5703AD4DD5076592562BB664
	E19E9919285587EBE20A9518B96BA14534F91F0DB1725849A7C9F96F9BF9320F
	8FC22957053758B1E4C7796D75756B6B0B2E34777F0E8B5D1C9CDCC7474727FA
	3F341A62BB2877CA4208E3CCCFE20374FDFBEC904D9D196CFAE84FE534B47D92
	5924463D39178DAA982B567020D3CB6738D5F4DCBF9E1AF42B0076F5EC67F3F6
	40D78D0DFDBB447BA4579B21017B0BA255307C55934A2FC075826DF87849582D
	1340B1AAC3D62BB1CD7C05A75D41BAA48BFF5F9D07806E832B57AFB031DDDFDF
	3F3C3C3838C8FFCE19C303A2F82323CC32D9D6D6D74FF59C27060188312FA7C9
	871F7EC86580687921B01D7D1CE72D10A67140AEF81C9D0C6BFE3EECE57C2497
	9D55D871236E41E183F9995E51F4479297FDC9608322905B4143140C6D37700C
	97C22BD50C10BCE45632DA57C068920DE676B22391A8B162101AC4687B479797
	231AC7CB423AFB73B07C834F45D37B7BFB4F9F3EBD7FFFB59FF97DBFEF677FEE
	E7BEF033BFF7677EEFEFA392E507300631EF1D9F4F00292E743444185F5D23FB
	F3CFBE9A258DF2A3241EF7DBE40F10CE5E005023551E4C6CEACE537C33E2114F
	277A1DA97939901364FF746383686038D982FC090EE7CDCDCDF845EA57032CE2
	154796ED0B6B21E791634114A84459E7428C608E6B16EB84A8D2250A71966C5E
	02511663F2E52F7F296857E05C56E854F8F1F2A2E2613623D6BBCDAD6DA2BFBB
	BBFBE0E38F3FF7F9CF3F7FF68C7B6D0DB7244ECFB6B6B7F459BD1E9495CD28B1
	6A4E5E44F5DBF462ABAE626572727AA2AF10EAE612AE88BBBBB7379B1D33C73E
	FAE8E377DF7D974A572010B64EA7FEBBD05FFAF2977FFCDD777FFAA77F7AB4EC
	59CF6705563E7EF000CD8F1F3D3A3A3ABA73F78EDEF6B5D3A11E3F98E81BD329
	5DF8F55FFF8D5FF8F97FFE8D37DE88997F81383C3C7CF8E811E1FBE0FBDFDFB9
	72E5DAB56BF220C264100F363EF14FE4B17EF7CE9DADCDCD0BE8FF4B00735FFF
	C637C8027E481956B0AF7FED6B9B1BD35BB76EADAFEB4F692053FDECA84F8623
	DC77C24D31E14281CB4DAAA3B2B94C9A1CFC4EF0A0514536D12BACA48C5418A6
	F5044CC4AF5DBF7EE7CE9DAB57AF32010033617B7B8B8C600F7A32E78991ADFB
	11FB224E1014A1F7B86BEC91D87BCF9F337D9E91DC8F1F3F7E44723D7EFC31B3
	EAE38F3FFAF8E31F7EF8E10F3FFCE1EFBCFF3ED5748E15165D443916579D4CC8
	215D84EF7FFF83EF7DEF7B7A1BFEF973E6E73E5BB1FD7DDB3CD61F6C11DA4DC9
	9AB2299DA43BE721EE4592B33C0D87316B0528B42A0936379375A1084BB81DFE
	D481D092031C1B31C51743D29F22D33E13304760655C85E4E127EE456180E2DD
	CB424AAA1EF5CE7DEC91BD2E47B0828AA24DFA34F9F297BE6456A0680A972C11
	E5D10B44D2AC2BCBB7B8BB7DFDEB5F7BF7DD1F671A384FB470035B50D28860B7
	E010D4040A45707CA5CC7642552A6B0E977B7A94655767649E3C7EFCC10F7EF0
	933FF993BA7BF88FD42261E1B3F5F5294247C7FAC112DE61534ADC9E9BB2CD85
	CD62390C08EA14EE85879457DD0F5CD799A43A39F567DE67ACBE703EFEE8A383
	C383375E7F43DF3943C6BF208117DC00683E9D6E30C999C0BFF0F33F2F23E9E1
	00A1360B9F124C69560A5CFDE0830F586B6EDEB8014D975321DEEA0B0833A61F
	7D201DEFDEBBB7BDB5F5239BFB546071F9EAD7BEBA6D50C4816F7CFDEB3B3BDB
	D7AF5F8F0C09B14A805128FAAA45486EB123E7B7B1EC40BE6A58FB37FF8D7F23
	38AD9E61D4B932C2B1AE9EB28D41ACB119F76752A45A744FC3E02C97880804ED
	989B90612CC15A7BE773F2436FA09C9CC47A0CCDBAAE5FA3D15E4683C7855D84
	9769D6696E21509A752CE6DFFEF6B7AFECECA061369FC5228E3C62BAC3EA4F56
	4DB7B6B63636A6CA787F0F2C2017D41974F857E87D9535EC51B6154EF2066766
	33A6910E438FF307FBDC4FB8474DD969ADAD71CBC2A52B57AFA21645345087A1
	FD088069986427B385FB9D6F3B73B4D1841E71C2BA2899F6A609C7E48F904176
	CC844A141067CC714FA353DC369164178450B42A0D156D242940102EFF43F957
	01BA439488C0FAD4DF879B4C1E3D7CC82CDDDADEB663CE07A3A31BB3A1172D88
	E8043DC232F1901DC8F71A265FFAD26FE9DA0915321AE6995345D54858A71B9B
	3C03C0D2DA13DBDC70A20EC508E7F10B940AF9C6CEA96F030CAA9E3D509A4D27
	13E6097B1BD636A5D1E9098B3D6D482666DF9B6FBCA9B6FA2DCD0D92030FCB0C
	F4B44E357AF6F0345515C570594B3826E0ABA8A91294DAE118ADB2893EE240F9
	F7BFFF7D92FA8D37DFA021C5681B330BA1E9C6948E308F3C2DA7F5DE284BB261
	3FFC5C8433189072DD7054E98BC4F09F0EDABE02A2B33F5AA1B390A4148D7FFB
	BBDFDDDCDABA7BF72EADE824ADA5D76092E819607515E2FEFDFB3B3B3BB5EA53
	E1D3B6C2BD6F7EEB5BDA036F6CD012C7B8035CBB769507154D482B8C509480BC
	1829652F5EC693D0B944B2D7109D9A7CE9B73C01CC5D78C54967112E98C48008
	7282B5962D90999DA8D0170615432C56F41129B571ADFD6290E35F60983F5061
	53644D98D49C74F4283A3968A502AAC8246E28D1266E06DC3D9C5A736F9C349F
	FD3EA79AD0B028491A0FDE7FFF777EF0C10FDEFDF177751BB4A4B35C0D493BE6
	27C23035AF8A2728A06CFBE1979D975641CA83AA50D93C9B9603DE5E33F1B0C5
	A28E1BDC0CD969DCBB774F8E953B1CDA3923C6F2846B3C64BDFFFDEF7357BC71
	FDC6E6D6E69ADE47F38FA75FF491ABBEBF40C1EF327B1A4AA14E2E5750924B1D
	DC95F41D01EC7EFDEB5F57FAF3106CCED7BEF295DBB76FF170680529097AFA47
	46C4EFC59A241272794DBA4D80C21CBC009752CA5720AA0806377872CB7B0F77
	AEC44A979E1E3AD8140DD0E7F428BF175B9CDBE3DE54E9C108A97C047183EF5F
	78675AA0493DA56FBE3F007584E3EC8C7DD1136EF46B6B6C88D8E168AF767A32
	F35F45BD75EBD6CEF6369B43046356D8FFF44B3713E71984F78C7A84B0CD32D9
	64D52C7B1FE9A796D15E924A419CA135138065E8F5D75F8F76D4C1E7CA6466D3
	B5BDBD85301CDC83AB0EB8B6276A51CB806EBF7E5A2B55A13568010F75BBD3C7
	1DFAC8DF91A9038C18DEEEEDEDB131E3A943FF3DD1F25FF9D297EEDCBE75EDFA
	F5D016E740A39B8D865E7229C2FDA017106D07B523F9D104A8B5C3525E9204D5
	5556A3278F9FECEEED46919597FD314C3413231537F4361C4970328FEF44F8B1
	616D8DC541C3AAF58792B220863943A9AB289811DE32F6BAD490A0B0B143BB4B
	464BE671A73F010876C6EAA56ACB2BDE7173576EB91CAD524827F3DB2C72596D
	D420FE53A233D56947814723AAD5CE0FE254B01924B36111234782B6CC995345
	86B0D82CC457BFF2157680F7956D9B7A1C770A8606A6240F66AC4D68CD08724A
	0FB99813645282B816CB6249413BBE04DEA779EEB05DE3063A9FF3CC7385DBD3
	F60EF79CD0C016E8E6CD1BDC01704C8AC4548D15BF089E5F492F8595BD2C1685
	630298AD0EF39312C1CA8A884741D4D413D39D5B9E8B02BDF504C87D88EFB25A
	D818E0E0D7808290A12503E9CDBF9B78C924988C1C2C66074D185A2D4E93F8AF
	F42B7A085DD35BFE00816842AD93C3C9C249CD3016645A8C7E700A864B7DF772
	D84BB1A271CB490A5A4F16901220B447C18D47E8790385A58903A31D94078408
	AB3B5051BFE74FDC91868B2A2DFB04FAE484A7765ABDF1C61B444313C9CDA0D1
	0120682F7D56C38B6A0219CE200CA7D23E2313B9A8578F901C70273C06689FC6
	26C8C5C97BDFFAE6ED9B373798A21E9BE88BCE2F8D706304FBFFB2180947B14C
	00D1FDD944398D10159526538935F3DE1EEA850A30F018B95AED7B34303BCF08
	9BA70D2E34A8B76C27772E967EEAD524090E67EC5AA5665D8CAEA74D3E8E4FD7
	79123DA916992C7A6BC8338726BAFBC4FDC7D334989A2D344D897C0129147286
	3474358BA7721D7096A3EA111CA74246DEB5F2F082E78EAD1CEB2C6441DDF659
	F7A23A8B341CB54568D2FA1DA204393A1CCF48C427EE63DCB409152D6241413C
	4225855CBC69F4DD7D3D74013D82DBCEB7BEF9CD3BB76F331F748FB2B02D7C3A
	A849FAFCA3C06E262A5D274070F2EC2A0A8D0E2CE328B3E979DF3E008DC78787
	87A4A65BA9CF29E08B02E0282846A5A55B054FE0E261B18C18928BD041944642
	243D034DBA28FA0C81072F8C72FF410070EB88C1B1704E246691862AB66A7E10
	86A989A191D64A19C24C2DB28D318EBB8CEF3C9A4BE8C4273181EB82ACA5DA1D
	D4745DE97B690E28D7319AE4275D3A2C2845A466509748D132B981B81695255C
	7ECB560340458C4BF029F761A7F62B5FF9CADD7B773FFFF91F23E670DFFBD6B7
	34017C07706B4999C85108551521F16981AAA486A886A2D88B69023824068CC1
	ABC98111A7D762C84ACF8486453E2D4836B141CF0B371A725789BB415755F474
	57049020C6BEAA02D160869415A8641565F091F7ED029A119284DF2C8FB38691
	71B48CAAD8A0FB93015459B934B026C66D834761AD875E1199332014325BD08E
	0CEBA8B71658F35B0513FDC934139A9F80A91453A610F983253363814F646FDC
	23796D660FF7CFD7D2D7720974FC442AA965C342C598A1B2457B9B4D5753E2B1
	D8DFDF2768376FDC40027CFB5BDFBA75EB168F0465020CB0C8F91110A3F98918
	894D7EEB8B5F2CCC76F2D52553668C719EBD45FEA07BC3EA56D5F34DE7E36311
	E8EA215AAB248611644FECDB8E985183201A3A4F962901C9CBA9CCF629B61F6E
	2D6F5548255A0FA1B5C592B79A3116F09B9E674C0FBDBBEF1553383E3A8AEEC4
	F408D88872283CA036760854708A8D7B6C27D6D7284DB555D39CD49DCAF7275F
	B9CB315D9C583175346B381558B54ED55018EEFBD2AAE29AC5EA99CF209B051A
	650C548461D97110BEF3ED6FDFBA75933B005E17A389F47008B54DF265E13E7D
	02AA4C10586102FCA6489783A8C55A1AA1CA9AEEB34A58DA64080496F439509A
	0F6406E1B044D45566F8106D21357722CFCCA756551C5070CE71919A83FD83B9
	FE98696A238F53856C657E9B8E53D4A464ACD9D8254D256D012A10B0CD14AC4C
	9F553485727D8040FA92EF9EBDBA3F90C7DC7A54B4B4B2C7B73B38DC4338C3F6
	94C8FB1833C24E4A9C5A1E3A295125B727DC94F407CAAD75329D6A43EF691367
	CD1E9FF2276225A0376300EC704150EA4C39F59784EF8DBFFD1D26C02DBD2B5A
	F466A5B507FDA3C3C1790914B94E7EF2C52FFE2665A8FAEA4E3A8F50654D3701
	BA748EFC99FB98B142A4747990883506566FB69A9868A74F4236D40F54EA6C83
	F742C8336DD8BA15BA8EE700C5AD8AEC869F76EA2F9DE4C8C6FAAFF1E608419D
	B916EF24EA5A8158E9279A2366A7B2AEC888139A748372DA86DBC9771D45C0C3
	09C94DFEF108E4D6B9C16316C08949AB964C5AAA6549401B4BB5A4FD517A58E4
	86B63ED55D084E7CB01D88F70FA2A1AFDDCD27A692DFA878FF77BE77FBF66DE4
	712F44501BE8E94F8D08C48BE120FA9AB27DA3C9177FF3372ABBBBB6538F91B9
	4FB0FE32CE2D45B4CB55F33C50972945EF4692A39866C1972AA9925B16861506
	E5491BFC4A184D262EAA9206FDF84F80991BB555799CC4368AC5D08CAB478787
	2CF272D96555B903314F80FC312B5A060DACA9F183430D2C316AB56185627A4A
	0AC18760DE52328F4A114E6ACD0D9AFBDB1C4C03BD8726CD4D46771E923B6857
	C9CF9818CDF4D98AFF5CECF1B5EBD7635E01D714C73AFA5302830B54873E323D
	7AE1C96FFEE66FE82A4E72A37A51E388B3D42418F329963130A8AD454B8678CA
	344EB07D1D35CF6BA1FA7EC645F28E7EA450E1A8AAB5029630E46410C12952D1
	BCB7E5736127A2CB5125B82FBD4048A458CD630BE067EC6482A3726B1D8C94EB
	045A6DBC5500D123EB45E9D49BEB4647C94A11467989E92ADF492C4C66734621
	8CB0CCC25EB550CE9B8F6988CA67464068FB369FFB0B93EBD7AFDFC8BF5563AF
	E2E257965F88C1501AC5899E7A29583C9AE0E86FFE862740308AA2D05839888D
	6C2C37D97321BBF9175E2F6B239428B444F3759477520763A42A6A8AEC801D48
	81E484408CA709589DD74657EC5C00480F45555D385CAB891CD24E7879C00296
	1EBF524FAB0BA658410494FD43DD75B02C292555806BDF5C93C79FA2443790B1
	60C846D35411A0A4C67E8944B868EBC540F528644D9E5DBD7A958960AD6608A1
	B095CF87FDB374148B858E7A39A4BC2FEAC66FFEC63F331F8E4E95A8C51196DA
	5B642E154B846D88ECF8D2FE370554575DD97B9F2B9A406914713529942148B1
	16F0C2A1615E7DEEEA175145326984AE47509DF522BC241C6A510D65E321420F
	278B1689F22A64D223C04DDBA1A0BADA2116EF2CE0A2B63605D1A3A1F2EA4AF9
	6CA7F801B2AA9C3BAAC01340DF9C2F5C8BA5ACD00B07D0D0214AE15217CF85D0
	0EEDBA369B1642570704659A0016C9AA2ABF64C88C317F505E74A694E5D2D8F5
	7433E32AD9E444798071A3C2A945D0548B1B913A1F54A7F8B00B3E8FDAB6FA5E
	D4A8B9C5E9132C1A292BE978E0ED1BA58E64F5F957C852FDC2DEB97251A0995E
	400D41EBCC5284E9FCDC73C107CAA575EF6F30F467C3E991C9C2EFC88E6FC660
	501AA2BEAB5B948BF2F94A0A33544D7EE39FFDBA8B826BB2C9720746DCBED837
	1E5EA3608F0A834BD81FA017ECD1CCB44685239893F6534737384971E9F59B1E
	9D7C8592C4A0BDB845020459D7F5419DD0DA064A79183D5B919F4B5AD73A51C5
	5C5C86A955336D290632CDBAAF63AF477D5C00ADA5269C12CC7D118AF5BC84FD
	41B39750F2220CE3692C610DD1BA29DB4C807FF6EB4C80D6C8ED97EB18E9EEE2
	396AF342278695350055D7384443CDB5362EBD2A4A55B56A63A4F265F4BA0783
	7DEED8F74DF314D7A870BB85CE66751119143A15A0A678A0934DDE28CD6A6DE3
	26CBFA52A95E4D00844CF1B377B8505DF305C02E069AEE81FE40B07A258B9364
	A1E9123D2F8B41E0C7913D07AE2CB2617BB56F629DA548C188C889A8087E1509
	894473A5C0F51289239074E3365D79899A469B0C66772902C35AC1AD9257CFE7
	A0B62947A294C7CC8E11833C7472E84A2DB8D82888CE3FB0980DA12D75B7576B
	228A5A9D93D10B64CB7C9963425E1A5127E9AC1FA0B02567C60B718E8686AE7B
	90718CB19CDB102EC9EFA2DA74E94230972BA9420541EAAD5CA0AAA2530A6B61
	5015C6A230BCFA1574881A8D1322A55617B7C80BE764158EC4A2A46B12E2D57A
	69CE7AF32C1842A24CFA253AABFDF2217A5008BA5EE3E2A335362A91E4A03CAC
	F461EF3AA4BEAC97402B3404C3555161D214509515355622C73E055C5D856D7D
	88ACEF50D4BA791E01D151950C107956B3ADAB31C66543CCA8E01CC74BC3E2E1
	5A50851E608946796E64801A340172584C88AE887243552D3A89722EB52275B8
	9C1CD1D13E88E0EBAC43C5F8D1512A9ABCCA95E8EACD5CA8741DD7AE9BAD2E28
	1782A3ABA8AE42283A75D45229BA3E0895BB4671422A1A847C47C6E152145472
	C1E5CAEBD0338623576A78C52134AA10C1E9F8E5FA0258A4978BE6C1E92BF3F2
	223411A8387C31BF96BBBEEB32C080B7500B9634EACA5DB45D1AC9E61D0058AC
	432BD7AB1D852F862E857055582A7DF1C99595F6D9445C6B2964DCB22928E560
	99696EE5858C8EAE220B2E1AAA09A256FA28D76036B2B1435F2B75451FE976D4
	1544655EAC212A832C0C9DA0FA57F632DAFAE5F380A17279A99C0C9587A80285
	B4501E219F74112C625DA1A2A741998603F94E2AF82A76AFC11117BF8C4A7494
	9182464F0F113D72AF9662A4A216A323650BB4D05E658DB16ACAABB56FE226C4
	8F781AC97393A88C62390A4F9596E12CB62E81E4F8F02524DBE1F6E352BC04D3
	951D22A5A0234ED958754DBE4914324A6214662AAC940B0A680435D8A5C64461
	052FCA5127CE08E248645815E56C55557138560B9C40CAD6AB583A17D160B92E
	9B76D6825790A42E410695EDA36C226A0B4BBC60D6A3BCFAC32FCE968E06B52E
	4A66F4703179BAF46D2B1A59AB52202EF99DF80E92337350D1D1A128C851E3CE
	867E2490A5BC26E92398718DB6AEF5CB8A45456D160AAF1D5915ECD05220AA54
	766CE042D7388A79CE728F60E5CAA776219692B541258C226347ED6A50454EE7
	A0CA25A42D67D994F1295E79549164088DA3EAE009C91233ABEC43F0EBE1BAAC
	CF23D06ACD73DB3CB92ED8BA722ACCD2AEBD0A238EF26A8C2C97E663DA4791F2
	191F0A0B9465A740142F0925D354B045B8326A7C07E8C5524E44F07CCA46C12F
	022192FC52E573216B759509D2471653CA3595EF976AB2D69559CA623D825312
	D4CCE0361195AD33C838959AB09CE8581DBF0924D51882857DED1B2625BB59BF
	14AAB4C321651F550CB814AC7A5859F07A24D750AD8E724AA6DA730D8D85219E
	AFC1AC68B579C44B748AFA0809F32B3A3A484BE6515F15B5EA930E9D74E65A1A
	0E50E42CA54A5FEC6EA0128604FD101CA514E35A1B888AA20E19AE64A90F1355
	2AA82C8B65F952634E21F2E064CA4866BCA2ADB8BE564E57AC9C31524F4316B2
	CD926221A314A760F8D3DA525701A3F15C889FD1C9175D7DCE59CAC514BC82E2
	704A64319A66297966465D45D029E082AFD1A6153AB65E59E21C30D5844A2164
	6BAD996644F17C64AD2F4D3EB9F52AA4857684CDFE10B3541689C62C08BEE0F3
	329180E2AC576E81E2DCAE46E3354895CF36E06AD321E882218E0BA55E3F3EC4
	4BA60E97FD7239658213ECA47D8480E920E325245D0FF3A2959B8D6BAD665834
	0A3750898462D6F152981F9F2AD14EBA702E893D86857475C90D0A0DDCDA3F3E
	5C93575D9251CA29E6729EE21247CA1776AD6A2A441532CB7112C4506DE154C9
	2AD291950A5E5127A65F590C07C287E09443A7A105BFC4AC4DB2A291AE2A4C93
	E52AB2D44421392B93FFDF3FFD353105895A243A2AA2FEE4004675B904B268CA
	A74E3EB0285991D21D51D0BE2523AA53374EA5F46C28B5F443C8B84E9AA16A7B
	84608C5564DB1A3BA15DE327495FCA49A89F9F768E41457DEFFAD2EACAF62585
	173E471E4B174E87CEC90A48B71969ABE8E443A64826CF2C93ADB91012955535
	BA41BE0A6A65209A0ED131FAAE56A84D0E4DAD2F7A6ADBD64294EAF373002385
	4BF64389D3CE225252944F2A98D211EC20A226E0A6852CC2C1D2C5D549242FE9
	5A53E8280E8E7609219D83941F15219542A59815E55A9911A7CA2947D19A1A6C
	2A0F370049FA92271D7E199D70A544143D956A82D1BE6AA814122E847C50B569
	C709695599959CBE52E731B35C0B5440814E692279859F7439C7C5B23ECCD0D1
	BF740C2A7DF8D590CCBC5A3A5009A1E327E46483CCF8A5C32F9F26FFF4D77ED5
	15458893132004CCB7EAFC32C9A219A1716B83C6E81A0419DA4B9255E1E66F54
	1965B52B44A0F0AA1A5D4A6BB3CA2A3542C8F4FCDA6A09BA70F4709341BF40EB
	C6A09408FF8B9E4A55A1BEAE62D8A095C058BE58EE44C628229D55CB07AD86C5
	4693ACE81B944B25D319F39259D0948F352653975E4818E828F5C3789E832A99
	44C23A8A82D4AE8BBC9DFCDAAFFE93E08092823A17D274B4E55272948B359442
	3D454533671412A65B682351628DCADA5E8DA361C6D4543BB58BDA2C7ED7CA0A
	8A1C58A80F1481341990D2243BF4D540CE99B544B455563ACAE151EF55D04DDA
	E80506408AAE462BAA54CC1A55F892A6921F42159271B9C884748864136055AD
	681435A55D2F9E97D2AA11F932ACA0B65E44154C6439C4FBCAA2A8E8A975CB8A
	A573436A0CB521A231015AEAA706B1B21C3F9511E01A5E064C8798D01A2D225A
	263AB1817AA148F99AE9919740664403BA167803BCA86E19C2B9B43CF05074A7
	ADD474FDA957A1776BE44288B9BA6FD183CA9801512AD77A499B45D310B5DC64
	3A69306CD0FC348A54950E48A6BE1AA173A05163732320B8DC136B0CB257E1BE
	665D341C0A8DAFEDD4A33226935FFDC7FF882B8CA2B08EA127851668FDEA836B
	FB8A6218B2F3202582EEC48A72634895972E49178583C1506159B1E30506628B
	58AC0CEBCBF9F626AADC3BC8100785DD2ED97D3772212BC359CB376D8D00035D
	4394C6F15391054E9DA18AA835376FB6A2AA98A94E594163C58883D6A4612846
	B1FDB898882645514551DBB48C103AC728CD6ADB5EC4FC402107D728448B8C57
	A898FC937FFC8FC8D45213088994535A529D6A1A1BD03C4B9D4065BA4232AA88
	B67D93020ACD7ABE2A23DBC655AA92A8A522901837B1C2DAA09CC45645344F7F
	06BA20DB6CAC0DD36F9F0449051573BDABAAC2466AE85459B4B52F4CA1F8564E
	BE8A1A2CB083FA4F40980A22AFD5AE90DA7A5446271864134D2A16FE6E262C43
	B35CAFCB0585172A291A12480E399D85768D42912D275999FCE37FF40F065A14
	9B8C0F975CC55DF029AB0CA8DCB267A9835BFA57B0C56F9295531577E8784139
	0ED539DA16864EFD252574894110570E8C3445B9721B643A657C4A9101B77092
	2BAA310A9607A4688D3419CB84760BC0126F093F2E85056A31787D934A9B701C
	3AA3A0E38B8A564244B8A1CA0C9AAB456B283A7E0AE75C0C7418C88F98A9A12A
	5A6C63C00E914A8022EBEBA0B0E46A4CFED13F6402806C9297A09DC451EA11C9
	4B456FD7748972340B6E6B1E546365D2F99C5C37AB1219D38A1A6548AEA3C12A
	6D7CEA9A76FC8AA81ECCC24E20758C6046846401D9154ED971A11A4E62E0B379
	D1D96C1AD771DBD1B5F5ABD2D997A62A7B25CA4462C8AD5E9656F5E44B41151B
	01312A52345C51613C7F4628DA90AAD68733339415EA1CE32F42D3B6D0D68C31
	D713A02402571BCD9FB3F82B2FC50F49B9A369A3A9727B5795A2CA452C2A41D4
	826414850D6A10956E5A6B5B297EA2A8AB5E6128B982C972B2BEAE52081B099A
	77D5410E1A7557B95CCDE912A854691D32A08AA9A67A6CB6F8BC5CAE88DADA1C
	648F2B23FDCA9B497096203477AD3A95C0D687288A5D28C5E649DFA0C8402519
	5E36BE419311672946AEBC4C9301E483752C73B543CA0C6B27FFF01FFCFDC851
	9D9D913932E5270B862C41868BB53AF83A6745AA2B27C3221E35F3E5359511BF
	1015153AD06B966B9393C5A241355105B2792FE76B770A2D161AA557E7A341EB
	CA48454251169E01773F04C481DDF936542984A43172BB43D8CEDAA82AC24360
	2A2B4AEDF8DA69B6CAE0777D6D94D1DA2F58EC24DD6557773295B3D0F265D18F
	08E8F54455E5749265984150A566A46D80AE26C8C93FF8FB7F2F0795738EAE3A
	699A1F71D01F17F1A3A14FF502444529BD314A29BDAD195F75469B3AF02E957A
	8181C6621654AA758E49134C3A4A41565B20A453241A26EC85D574EEA6884B3A
	852A20E1EAB75E45B48A7744A9EF8C67395BF4D10844934088D52AC38DE39244
	3965D3E4D752AA48BDADD0D707A1932F8592F0D2646A7281BE71AD51EB247B84
	D858EDA211A446CCA59CBC26D5D4FACAA98824AA022B5369F2F77FE597B988CC
	8C15A80B5AE718B9AED3AE4892CA619E8970AB5230551348D2AE52A511B561C4
	1709D5B6FAD37CBAA69510EAF509A15344B432592460981C342CE66A93D20CA4
	B6E074DDB62CB08FBD84908E834E3EA56C7424A05375BB5C8CD4B7A0A81F829E
	2AA7EE0A820CBDD022D24876DD183768FC5A93AD0AE097F6A316DD55A79A8B23
	5F1343B555B882562366E753CAF79C244B8BBE6D154B26A7BEDD2FFFD2DF2D3C
	A7233FBEB899F3D32D9B31B38783EA6BBE0ABB54C505BE1AD4FC5B9003C13474
	0DDB348896B541A543193C11229B8A28A931502B1151321D7A020E74519C1AA4
	D31C170A4F67908DF3024455D7BAB6895A034297E9E885B920E8CA4B7546F622
	6A5DDF9C3391A585ABE066269A461B1889A7EE822894B834A46C39F9DA350351
	EAD407B20D17AB1C6B1EDBE931D435547B2ED28AC56B93655626BFF477FE7675
	4B7F28CFD2F9F82B888897C2CECBF9527446F6F4A3CF6B506A68795A47309A46
	5C1A95751DEA1CB06078211A8888A910B409A3C84346C52873B242A82ED7E6D1
	C2964A9D90F2152A27AF5685EA34D0419C605957717A8060492A541434BEE868
	AF974F598A163E9B5511BDB5ED7420501A1A59E878295AD5822A141245B26064
	B8CF9391A4B0C49F106A51B2C82758A9B0B9AC525A36284C2EF74C01F9C9DFFD
	3B7F2BF8FAD3BEB1AC6AD0059AC11363D57F10381348DA0A6D2A14F3B27D0BAA
	38D1BFF5146D41D541A03F78D95CAFA64B67EB10C7CEA42E35580D29D0C94991
	D92A85ACCB7E15E2CCFFD4D68418B5AE5814E49584A2BA54C170933C8B1F3FAA
	4D9DAD265E42B413162E164E2BEDD4B704B6212A8A1DFA7276BD680B0C1BD492
	3D2E4612540ECD168D3A4547534188D98E79E5A7A1632FDA6AA2A92E2BB39B5D
	65DF2A11ACA182A558D27609A257A906DB7FEB6FFC22BD86AB0C5095977FA72E
	B566E95FDD973E29425C9071ACA2916817422609F384CA96583253734AE84A51
	E710B0B84E86386637811ED9A4CE23CB55435CE5A59584E282F42140B584DC4A
	B46AF205D3D148A270B98853846D4585E0EB0C5C2A12BD0F6949CE45415CD345
	8969CE213940324285A97AAA483DA91984E70B68F907DD99D2B07271FB3258A5
	36A9760A1BE90FE7D2C4659F422CD0F9114E352701D452E1AAC8FA1791164755
	E7D8ADDA267FE3AFFFB5E876FC33AB5E7914ED9D8018F03649ABB15855CED4AA
	FE1F3054D31125DB026A1E5526527314ABB2869086DF89D5A6C10F2DD2997481
	4BEA5EC75D3031309A926E915CD7F22A3A4AF04BB54E8867D9DA42D46D205116
	26FC32B7AB56A1340F474559C8F2AAEC196364E7E252653A61290F25622637DD
	70A93330B8565486C4DDD09CFE926A5336FB954CB708649344710634AAA2B5EE
	518D0A9DE60162E22DD446DBA2502BBBAEBA4C26BFF8D7FE0BF162D74F5B25BA
	6A5D7413C731F81E519DA98BFF86605DA1D9CD842846438958816E23F0AC4780
	887FBE109C6851695B112724471C515D2B9986B459EDBB5416AAAB66B8BAA0B1
	A2953D2DC2628CE41BC2A85DAAA060AE10CEA693598ECAB1C2CEFF8626AD0EE6
	AE2F223040346E2AB846539DE1668312B40AF1A3CE314B6A845063A248350F54
	76F7A2089C71CD9756D1D494535C9DA45146602C1FAC68D9C3729DB0C8349DEC
	88BD7EC6B2204592A8FE4FFEFA7FF1FFA19DB3D9C346B0A1782170A6453D1E03
	90E4CC3D02321357066332A5B3E699591B0899C1FE273AE24451851468A86DAB
	8C39AB305C9FFEB7860B2ACC905334ECA71CFA2845F31EE1B2045C25BB960BBD
	14CD4F855C82AFAA54A546664445D094AA60D1D94B98132D9B58471B61B6F1ED
	8BDA25274C70323F8B4B5164A261364F2C2703E901A86D4C8C3CAB8EB954E5FC
	329ABC0BA5B249DAC3420F25A4DBAD533E2A5384932EB5368A3520A6752A12DA
	F4A6330593FFFC3FFB7F91D027FE5F9FEA8274F0231DFA8787AB6BDC1C421431
	04A8D134706FA53C8CF91A16994B198A826845733B2279D309AA46F2C1B10B20
	FFD90EA542886F015BE4554C87FED016F296F52B1D1829575D69AA66E68B5A22
	6084F280F570CD2641F91257B13AF1062977C5A8B235AB1A03D0B42981B2DDD1
	14EA7324AE45996B8A9FE23809025197D7406916A712D9A6CC17219B65A12AA9
	6EAB49BE428E0AD3A5B24354F54483CAD9D92C55B4025418281D0D67E254514A
	5919D4FFF33FFD4F4A66E8C472CBC340D43BE6E246C4EB04B0A6C60F029CF8FF
	5A078733B489485C956A2D56E29D998E933E05A1278DA2B6329761509305CEB6
	0E500E828F1DAE62BA106E5A86523AA3E6D6E37692EF40C1AC4E79A9D12454AD
	0B26A80F9E84A4C60D43E340AB914256489CD376359412A1B543E834D7D523CD
	D2E8ABD8A93E2F0165426912D7142946AB055746035FAABDA220847C4E46B44B
	F9BC64B311BACA26529CEDCE3AF96299D68D5A5DDA160473F10A2AEBAFFE95BF
	ACF8D0E17CEF1FC75BC6549570EAB20DDD27A81A546FA5470FD3DD6C8147C3D4
	1967105555678FC800101ADC44CA83AE4C502569C5CB9BACD45F4125CCB88F85
	B9F0B5125541B4ADEFF9BA3E3D8E2AB85645512C551605926C505528B49AA895
	6425D293D2308874C0E740D88A3318544951FCB86819BB971DA9CC0A59090195
	74726D12D5399FAC3E79203B9A04A89AE3528A6A505E05B8A3C6419AE352F00A
	A35C13454791E8AAD54E55814651D3DFDC4C87DBC1F0B943F464ED4FFCF17F5D
	094B462BA7E39A0C4E114DE83857D052D15C5939B170D4F6842CC4BF7093A4E4
	4D082100E084405455B5955909D4BA851045CE593647675B87907E3868ABE1B6
	6CF8A642D9A4A5B0340C33454881AA9622A22114456B15CC2B08D5A5329BBB1C
	95553E05B2A63990DC00CCBEE8DAA42CCFABD65A39D76498D4A9F2B3C2ADB269
	DFEBE65B5C38955AC9AA08A0116BCDE0776AD43074804EA85C4534B62BBA2405
	91962969591B2E34972A2A34A914EA515A8185EA52B7F6AFFD37FEEBFE5F6927
	F423F28373603E9F27E52C211D918480CFB9A26F02A4D81CAAEA785BB0490627
	8A7D6DD08A72D110CC4A2F5605111CA17044E73D4DB3346D74ADAAA4E360A3C5
	E140F85621568856FD81AE568920B3CAFBAC41A12EAD21A84D7C15A0D4B15205
	820826A2710545AFA8AC0D64A8551902B59109BDA28FE699947EAD94C9E1A45A
	795ACEAA8A46AE0E6688A9E8B6A96AD49D0AB5931D171AD42A211DBAF6228517
	A6061335A9B4D104F3A57211F6B5B32D029F7BB62600237D72323FF534D089D4
	9FCD9450253BE1700E4051845FCF3083607EA48C99914C5520A693AA8B060864
	68C539847BC04126CE15595794C3A9B66A2D1C74D6DD916C0555E4A50844680B
	BFA22FDB4A530B272A55AEB5A58310E1AB6A8B4B14A22CA254898F27A517E298
	CB297BCB880751908D630C0DB5F525340B8DF059CAA3B3C9D7255E454B08A814
	6A9C159DB4D4BB2351C8A676C4504B21DA16AE6046129C4245511FB1097A0119
	37D36381DAC4326936A8744AAACD0DD1A81DC0AC487F64D7FEE81FFDA38C5C24
	FEFCE444FF41DF1F8985CAD92CFE4BB8B449822A4F14AA5C4C44EA93E29CD11B
	1CD9F1362684A30A20A625D94EAB31978210A60FC8840008822A64D5BE4B7AD7
	37489BB7375184084EB4023039AB775602142F05A2EDDC92A938A6DB81501B4A
	A268DADA4C0742C6444AD66243ADE8B818D3198E55A748D10C1D0EC85C696589
	0293B5D8D7144486EA65A53292E5E4249D5CE5483A4241F1305F451774E29CB2
	59DBC3A5AEC6AF889B912EC659481BB28B9D6C395611A96BB46A85A5B2931F72
	E5943C3BEC48467965EDBFF6877FE1F8F8683E232B9D984A71B49D9E50261D35
	192209B4238A2C8CE48EE480860F918D9D345CE0462D80C17A2C7EC9C54C55CB
	C7C0434BBF932F8C50031F5A32869B6A001CFAF0B326A26C05C12BE464C0322A
	DA44FFD04C9173D0BC9086D649B2E243A313A2982827CB4B2258D929CBB8E8F8
	8A34BF982808662018124D99609B9F64A175495E193FBD64D5E31B10254E4A16
	045B87DA3619F74CBA7C33312885B4CFE5AA235E3AC10A148F96232A1D3CC12D
	E5B93D0D5E4306B9BCAA40B9CA0D31D31DBB96ECFC699EE61C918408348B0C09
	11418907F1BFF81FFCB788CAE9CADA64753A599B9E4ED65657D757D73756D6A6
	6BD3ADC92AFCD5B5B5290446482045F0F46C6D6DEDE4F464CDCCD00A87330291
	88109C4932E481FF43724B56CE00A632D47909E043A3071AC2ED20758926905C
	A043184E486011C22A338E3D900CDF406886686268B07EF4618B4B543111E033
	FDECCEE01D9B00627016ABE04755D8081AB884249C6486BCCA74DCE65C12D4CD
	123A10FC501245E47531C4B192AA3364128302251C965C282D992184A075C850
	B81AEC90A014E255639191710B4A24C9A21684B6208A7C3614A0545DAA82E733
	D79A609218D4AAE42E27DB268A1B458293D48B1840553638F9DFFEA9FFF6D1D1
	312125959E3E7D76E3EA95F5E9C6D14CEBF7EADA944781D3B3D5B3C9FAEA9A8E
	95D5E9CAAACEEB1B5B679A194C0C068E29B34E2AA05089BBC264D13BFFACA024
	D7FADA9ABDB4557731323EB23F984059B6BACA068C334CCE7240738F39163DCD
	1C0AE1C2CB140C3E678ABD5A08646A6DE5B852A0125EE5B85633219480609270
	4C04AB528FE1721FA40A739C3DE711EB954852A44EAA6ACC554DB9EA64F06B2F
	422EF8815107ADA41503F8516E440DB69C42B46AF210A528870AC7750155BACA
	4D4A07A27D3A10DA44662E472DA0DECA4361AA0AC424B78270C08DA2659D12B5
	41D885F6A52A89365EF5B3CE6C8B44AFDC3288D4D910653589BAC9FFE1CFFC77
	B842B3EF50B5F612679335785218BB7B0ABBFB07A7B3E3DB376F1E6AB374329B
	9F902793C9DAFAC626FD3A395B9D69BE6CA1717D639B63C2A2CB44585B5F5B9F
	E297F352778C58EA9821A4010B1F4E002C45E2D28081840E0E559C3507DC7D7C
	A108D403DF2EA236EE39D1A416A1A355980094DC56A1A7CA3CF95065821941E5
	4415F2C1CFAA6C251910C3197C339206B8415B3CEC97F65E4CAB03836488AF79
	21B1900926E7A0FD4AF402EA2374F00B1170319BE203CDDC77F343B94354EF24
	7DF3A0B37170C2734ACE3B334BBB22334031D1578A13C551131765A018E911B2
	AECD21085F643FB8456D6880A6848C792114F57AE9E2ABB4983DF9BFFCF9FFAE
	22E17481A784D7CD975B7018240A6E3361326840C97ECA540A7EC31D658F9F3C
	DF5C9F70EB989D9CB191578C56D7CFB42D5A675BC50D84A9C22D8689B1B2B6C1
	864A16A9D2FFCE6752E8079FB8D96856B09BD2C0782FE4094015B4049CF172DF
	80C65BAAE0C7597D9F4C7870777710C944C453CE410075CB39CA39DA56A61538
	CA76C374864CEA8A00080E041A20C2014C841BA55297EA58B0429E8EA12EF821
	405BCEBD0F88F1A259141190BA183C9FD523CFC3D419F638179F077AC28164EB
	22142662E6AAD8A738BCBA4C8C415DEAAEB41BC9622AD0AC965A1B1023B73461
	ABA3B353D029A7368635EB14FAD34C825651768B429672D061BF5C8A9CCDC09B
	FCC7FFAB7F33EB286A54229A6738A2445E612957DECC67872434AB386231CCD6
	3339D83F58DFD8903AB902675533C4ABF59C257F32D9DB3F383E3CBC7FF7DEF1
	6C7E747CCCED63AE156995ADD4FABA3654DC4556D6B630C4FC585DDF8C89C199
	5B07A62251482F18788B5DAC2853BCF1C013254106412EC4C34670D43FCF93A0
	23CF9CA9D4E60400D64006EBEC22ADD47B84A32D4CDA220F1D08AF423FB51020
	F4AB4833130A8765E0E719BEEE0AD904484C45B789E645AD1D138213083998CD
	5C518EB92A47511C237A110826D690C43F7B244ED61519CEE6E9558A92562B0A
	81E62A35AA740BA1460086F816A8806BF12C1AA9987671530A197ED01377CB50
	6E6DC535D5C75510B7708099A1C394ECE59403B5D5E4FFF1BFFF9F3C7CF47865
	3EBB77FFDEC9E95C39708AC9138D9C064B9FA7B2F66394ED85C70E15BA31D80F
	09B127F28D0281C999EE12F04FB130678458FF6647DA984C370E8F671AB5B3FC
	580A9D543E7DF27C676793B4644F159ED3D913C561BABEBEC16C5B5DDBD0CD84
	E2E6B666886E2C4C99A99CC1251EE9262BD3E994555F0F1527E4043EE5FCD4B4
	D16D8439A9F7AF50BAB1B181730C8EBD745AAFAFE3248659EFE148AD25637C38
	47AE5B61F210874201520E82585857380D7816F00DC10F0FC1240E04D65A740A
	75E188FC2C460184158B400FE7A855684B12C879CD49D1546633053065240653
	B54D3340BED6B2C8A9063ABA631D66100DBA3C862BD1C0A15A0937CD41C866CA
	255ADAC1CFAB69CEA8AAA2D1A8E3588AAEE1B17B625EBD17A8E35922986699EC
	A18AE00C3C32B2E1FFFBFFF8A71C3205E9E44C3B0AD4CC66C711F7DDDDBDBDBD
	67AFDDB945D630AF31E98F8C7DC7F770081A0F8D24B395C943AA8555DC3B3D63
	BC651B81981AF25AAE439E2A79D58995F99C9D15234AE621ACAFA6CEE7B3E3A3
	F9D1C1FEDDDB378F8EE74C0F4E4C9E294F173C854FD67186070F1E4120D63776
	B893402BB5B9A5E8BD29B9C04DC31D5D21ADD18E1BDC5A20CA5D427524876445
	D4EC94C3E67B41A221673DF22A916816554C299EEF43B89E019109E5C10833AA
	759285A16257F749AA90C1253814691E9C384B45A71C4EB81444E1EB1A347C43
	91880A0A55D2032DCDB60EC7A2457F0867DB98C0A953B7478D1D743433375A25
	5C086DA5140AB9AA110C17A3A964ECA11A853055211F5A8319D7D421E4051445
	D2D0EB095455D120544AB208A539B8FFD9BFF73F5240B39E040D8A2C84E906AC
	CF2B673C0A3319497276E7642BEBF3D16CFEE0A38FDF7EEDE66CAEF74ED9A390
	721A6325F1CAF327CFD8B34CB7B6C4B4395951E089842683B6FB01ADBE4A0ECD
	899339496A13739C40EBFCE890FCE5EEC0C49B912E5A4BB4F03F78F4786B636D
	BA3EE59183637DBA3E9FE3243BAB298B3A4631B6B6B1AD3EACAE4F377750ABF4
	F77B598CBF9CF09000195E39E33602233212E003E74C71BC969B311FB8B1287B
	982D62F9D661BED6639AC07138D5573A675BEABF651B2469D3BE2A234346CE9B
	0855C10C1A8418A8B510801E28C7CD54D1371F15391042D2F31F226E746A6889
	90B7913414431345180841216735291C5AA181C504EB80A9895D4ACAF29054F3
	6CA0D8566FADD2D7549E396AA3594577820A556215036E22AAF28DA2C0525459
	2C38D69BCD4DFF7FFF4F7F0A032A498587C4FB5B166FC698958FDC226B8F8F8F
	5443D61293B555966834E8138309B9AAB59F9CE3A5356CF5ECF9D3A74F9EECDD
	BAB175E5DA35E4D1C45E6E654D1F311C1D1D6377CA63837348A6D55199441B4F
	08D0E438338084B593F2839941CC5974D50B7B4A8E3132ECB2344BF9393BE32E
	A13C58393B3A9E3D7FFEECEDD75F3B3C9A71F7D0CF6CAEE78DB575B2978772B9
	BABEA9EDD57493A70E3D87686EE8D19CC94EFF1426763564BA76508A9D2CE0AB
	EF1E209EB3310E8DC8DC9FFA61C27798331E7F68EE955E294BD4D882713B42D5
	89376920062C94C8ACAD7822880F0D15431796F144DC920114B978E68A8300E7
	4805DDC38BFE3A3142009D16D109B86690DF717782941B36AD4234472C22933E
	F8042466AE44EB3B076922948428CE40501D047CF5D6458FA96438FB2AA0A415
	045CCDFE42AB3E2FBAA29730855836E2125ED0957A298E210489C8E417FF2213
	808EE9C955FA9570D8505B392A511636ADD9B283C7FECA831528AB6132E4A153
	2160E114876D039B6996731AACE19746429930393A387AF2ECD9D6E6FAFDBBB7
	792A400FB300F38CA8DF3D120E0F0EF08767009E93F11276AC19AEB6DFEE082E
	B06FD2EA7C72C2E3B55A92DAABA4235BA90937023D716B0EFB475FC198A1E2F1
	E3673B5BD31BD76FEC1D1CFA9643EED28CEDD39A9F31A6DC314ECED6604DB7B6
	D7D6B7981EB4A53BBC387B9997F5E9948787094F177050EF67F47C2F2862823E
	871B3715195A456A06E42C673A1E59EF24834086794E2FA88509077E54A9BF7E
	3EA97A821F9251146DD1CA9469C548F1D24C8A7714BC274444E395EBBD82EA26
	4A142EA8C19C2B54150E44E7AC5C46A217299254AB0A07C43461E39A5AF8A39C
	D1036E48522961FB98C2B295E917D193A49488996ED72DAB9DAC102FBB6C6037
	C44275B02B63F2D7FECF7F5A4C3BF0E4C9B3A3C3FD1FFBFCDBC7B319ABA67BA0
	15C21D941F0AB0845583FFFE2C401CB1276B87BBBB34BF7EF3B6166AED75B46F
	51231675B74250E2343D6377A1D5C8EBE56C75E5F488E57A7ECA53EAB3274FDE
	BC7F873891BC8A945BD1ED681A7300DD10392735AE56EE1909713C637E9EF14C
	803CC94433096366C653B83C8749E8D18F80A606CF3C2773E48F0FF77777F7EF
	DFB9C6C443845987569C3F668FB7CA7E6B833B1D89714A266F6CAE4DB7992A58
	4598D374BA896CA423F70467AA5643F447AC71949B855D561248734422167B54
	78C228AE84526F49098AB3332072DDB539CDEACD24389CA547D150BFA015120B
	9816E84FE45CE881E35A1E5A4A8A38C8762FFD2B1644A307BB34B358B8EAF190
	4E2525AAE051AD15D088866271CA159AAE3A6BA2D6DD97B1D25931D5443C15DD
	FD940FD31432505CA3A924A3A98495FD128FA26A319882424E26295C6102FC5B
	7EEC3CA1565E3344D0EB9BDCFED9F0FBAE83F4E9D3A7CF0F0EF67FE2F36FB0D3
	983975D0EA8E8561F78ECE686C9817E279B14686055E8F9EE862930E9B866C09
	E4130D5295B297484488B83F6042B45DD4C09D9E92D64F9E3E7DEBB5DB8C8F3E
	86D3B7577557C1759BD300C4BC874F27348AB2AE39AA20B0D6CF664747ACFA9A
	4E7E62115FAEAB8F1A4566C81A8F106BDA07C3473179ECD8913767CF9EEF9ECE
	676FBCFE1A5B2C1ED0FD508424BD99320948ECD9E9CAC6D615C565BAC9FD4367
	DF37E0ACB1018B454C773CED2A31899B8440F1CB1A9D7129F20CAE3E45516C25
	83A331971093B7629BEF54A08919066584FDEE530424B48110CEFCB35C30CD97
	063B9013C0FE2008498D1A521FE917ADB8228972681C08B74B73A9EAA7962A5C
	255D316046B4E50CC23198A871A568C9FB05894C5CB222AB742A0CA1A75DE946
	9CCD01A1DAEA7806F8F7FE87DE23901EF3ADED1DC2C053A5B6C50087D8E5C351
	16690CD6D7574FD977DB1D2DB8527BB6BB77C09EFF736FDEA72BE42A7C4D0D75
	5D4BB2A710D03D8FC4D20AE47511A66F6128D60240D795D27384691F6DB80952
	AD98CB261705D97DD283AF76DA7A7A3E3B3D9E9F3CDB7D7EF7F60DBCD2530482
	568145A78AEE15E29C9DCED8F044FF6D4637204D5309E00E2C1E67E6731E1834
	24A7DC0231E7375535341ACEB3A956F7F9FEDE015385B53FA2F0F4F9F393E3E3
	5B376EB15BD4DCD02721D2AC8CD583C1942DD609B39147702D2BECB3B6D63736
	B01913C39F78C80DFACC99C70ADCA30FD09B1B1B9A84B8EA2AED8ECA63094CC1
	49538B8821AF1B82236B8D7A5930F30C8222D622DF14289A3B9BD59CD9E29B86
	1A8457CE95501E67B512476D080E332DD472267A2C82A23D788828EF14745D43
	95AF9A6F1E0469D4A9A8069E005CC50AB5D091135595E26B11E6B73DCD06122A
	26184308D3D44A20DCAE803FF9DB7FE9CFF8DB9728A42E3617384F1CB539D653
	AEF303E00C4A30A5CD09B97372B2B5B343176886411E1E3394B2A5878613DF37
	4E8E8F7EECF36FB1A13AD2165C1615ECB395071F3FB872EDEAD6D6A6370513EC
	78C3AE6E31107BBBFB3B5776D4073F531210E9D6764E334173D21F16481B2DF4
	DE8EBF418D2A0BE1827614CC9CF9ECC993A7776F5F8FF79150A131E3A295C977
	5E857B3EE769441153DE50C72D0B2616F5E9C4EA9AE7BFF2407DF73741141942
	83A38441EB014BC35439C5064C73EC647D32D55E01D74FE68F9F3CB9BAB5B973
	F50A9E1E1DD217C249C8573636B7B9514030254ED8C590F8ECA3D828E906A2B7
	AA982DECBB700C4DD8E607CF311A5322D20E8E567A7C5351238A724D12D7AAC3
	DE20994FB55220AAE06898A45DAD605AC6B73E52AA3C66442D1AAC490A917485
	1ACB1FA7B962EE84838D2E39ACA15113CA3E279044090AB9D8BCF4F8A44B3404
	E179F24DC876D64A2108F9C24C6541A8D6E710C6A606CBF33688D080AB93BFF1
	17FF34DB631E00C918ED7ADD13D244A293B5DDDDA7DC1BAEDFBCC1E3E6E44C4B
	20A3379F6963A02DABFE9604D9127353EF73A096E707F2667B7B8B41887D02BB
	0A72861F4F5DB98B430F1F3DE176F2D61BAF93B8BBFB07878787D7AF5F23B81A
	035AC52021EF318ECE04706F76748CB747C747A7B3198343FDC6A6DE6FD55028
	23E9C2D9EC18A9D955D24E1578C2F86B94D115FE1E1C1D3F7FF69CE70D661D92
	562C4B8AA08646CB87C2616195153FDDC43830727CAC8FDE0821C9CCACC06DF5
	DF0F8E4A09C79089893F10EC1A1972DD6769AD7B010A952BCFF7F68E0F8E6F5C
	BF46733F8D47709811A8E2717C75C6CE54776326C296BF9FCBB66AAA9E90E2BE
	7BE0564CF578C716CFC8482AF5FC7F7AAAF776151445CFA9906184C05B044AFA
	EABDDDF5E9946D803A8BA8B31C418F487C32A8536412ED2520350E0E3E6BB04C
	FAC6050D15F3016FCA7B86D20907B5F229C5254291B831E1A5501CF50B3AE692
	45638E0167A67D88B55FE1026A234DE8728B68155D475EA665B5D415FBDC01FE
	C3FF9922A23C5B79FE7CF7ECF4E8DE9DDB67272BA42441E14C10492FA2E0162C
	C9D2A3F73CF556A9D663B1DD658ABA2FF8DB447646BDD1506B912710EA2C3199
	9F1C9306849BD653361B93D5C78F1E3E7BFCD1D5EBB7AE5DBF41CC3FFCE8C19B
	F76F720798B35CBA07796372A750ED59AA9BB50AF0F5F8C0236F38A084E4AC40
	AEF93BD88E1D394A3F781821A662AA23F26A7D8D565AC97CCF888F7B4E0F8FB9
	6F3C79E3DECDB395F5E3190343472CB1E2CF28687972C23C67D5977666B6CD11
	2E4D1A1D2B3C2F11868DAD6D868AF545A3A368CB101660120BD6099242CBAB64
	D89E2974CA327683BAAD9C3E7BFA6C323FBA7EE306228747F3E3A3638F309B28
	6E827AEB963BF199DEEEC2914DE6093B2B45599FA9E90947B4B4619AF828FA58
	D783381ED297C824BD6FABC4F2286AC0F0C6642C9648E5039B9E09193C85499F
	F6448B40242E502EEA597F5D73C66FD48A1B326A80CEFCE61562F2CC566CD741
	F13BE38889CC783AEC168B0920CFA4CF0DE3C3164AF94D1691515F664BDE2D71
	4655F607A24899FA5B7FE9DF524030E284955DC6C9FB667635FC40ED1F1E3D7B
	FAE48DFBB7597EB8C5AFAEB0F2CE58DFA62C42285592D344BD6095C106D6D413
	A9D47BA04450F70AAD6D73A616CA95451E1F758207DCFD83CDADADC9DA4ABCF3
	44CD14BB0A8866BA1641C568E5E878FEE0C147EFBC714F771FD451A51C72F79C
	5B38A34D949604F5047FBC1153771933EE189B1BACA02B4787FB54B173C2C2DC
	4F05DB3BDB1AE919C3A3B9767C34238D36A62C5D4A67BBA4E81CECEF91E93CF3
	BC76FB1A89A0DD0BD68895BEC7E1CF98140E0D1571577063D185656FB87D6217
	D2D19D3085B4F38B8632A2C58CC98880E6890243C8B4A52647F4A61CD357DB33
	0CA8971F7DFCF0D6B5EDF5F5CDBDC3190619910D9EAD5999F441070FE59E24A2
	F5E1E0C6F695D5F50DB659845D9DF107CFE121A6882E9328A2049F6DDB546F6D
	A9288BEABF1AE9EE757AC263090D951E5EDAF19925521D74D0190DD2425B3CBC
	F7F48BD9A2871F7AE7271C311D124F3F088EF044598B189AE168D89CCABAD32A
	888A0C3F0E97E0FA301BB2D1887EB93656FD98C6695123A10058C2C293C9DFFA
	0FFE6DEECC27F3633DEFE291BEF49FF7381A2A539DAB7022C7883D5C14E007F4
	83070FB737576FDEBE8D1BF4FAF8F8980569EADB2B2D3C3794C7877BCF51CEE4
	D2DD5D4B5EE60A63393BDC97277A5B86BCA0A3749AB1C663DAC9595C40334EB3
	AB599B4EB737D61151EF995D8A324ACE9E3EDB3D9D1FBFF3D66B874747F2900E
	A34EC1C5084D45F9D941BDD66C75EA6B1AC29C28C4189BCF8EF6F776B951D010
	1F59561160CF8FF0E6E606419AE9D715D6D1AFB7FBF4BEBE12CE6979767C7888
	E6BDFDC31B57375819667ABF2B6C45B0E5B2BE425E81D70A91470F7B7690B567
	868DA3230D1F1D6308B5AB948CFAC3FD0777357A1A15F55D315AE37681006B8C
	BB45644E9E3DDB3B3A3878EBCDD7F7760F67277A98E1F9475F16996EE182DCE0
	097E6D839B30CDCFFC8B50ECB1FC2C4E77E88F7E8189E1C771CEE1AE96799993
	09572993D4352881A7FD75765054798D974D8F82928CBED833DA943C0518932D
	D580D0A485DC8514545BB2409E907CC912941BD186586875CAAA3092056A8BFF
	21EB5E287C7AC736FA32F9A5FFDB9F937FA77A874109A7F76AD88DC657F3593E
	7185C49DB03A1ECF67535686753200F3A48D2221C766F3D52949499E7A6D72B7
	D9D3934FF7EEDED65E1C01B4E8B767B0881BF21EBFF083E6D2065635A3688893
	3C371F1D1E4C37B7988D0873DFD010EBFD9963259DD24E1AB847A833FE286AFF
	E080F3CEF61669ADD9A32F3EE0072BD1D9C70F1FDEB8BA75F3C675F61818543E
	C9050F8642852EBC508C28F2D08C6B6A4E4AE1999679F44F584B8F8F0E8F0EF6
	757FA7EB1A81D8766BA8981BECBBF481400CB847C0219EE0DE7CC6D665F2F4D9
	DEE674E5DAB5EBA48A1EA3754B546BCEB1458EF94044B44BC184D31A2FE903FE
	E0064B340F1E544DD778363826B0DC81955CDADB68E0B5C0EAAE81D6B579BCA1
	A689A2B510E59EBDABB47AF4F8E9CEE6F4B57B77D8E9E97B56B3B99E55F0779D
	A55DDFB052AF09B47ED7637BCDCF1ECA55855DD9CD39BAA8318B0CF37C25327A
	E667C12ECFDCBA9D2A1CF24D8B1ECF422773B7558C3506BCB8F9E8AD73ADAD48
	3AEB3C18B494944E88D146C25A07A28F08CA0DF1428DFC0919CDCF5010A3037C
	43E6AAAAD814B9995A4EFEDE5FFEF3C45E3D3F3D79FAE8D1C6E6C6F6F6B6C652
	83079F91424C63A1F7623C97355F68A2192E3DDC9DE14D3737B90DB3C34186A5
	097BDC0AE801CDE99C62A1071DDA9D3EFCF8E337DF7C8DA6242BE341E0D51BAF
	7452AD955B7B0827B1A7840E39CB550BB6BE56A4C55B4B9E44E76C24A0E6C7C7
	3C29D2C48AB4B5C5755C3C3C3C60D26E6E6DDA07FAAF85937E1C1CCF3EFCE8C3
	77DF7E8D8550CFC02BA7ACB7DA61440EE504211775BB53A8341571419F82309B
	15E0B3D3C3C3232D9C1A4E9C5FE14996BCD5FD44F3C729287DECEC596B697F32
	5DDFD4A26EF77CE39D413F7AFAFCEAF6C6F56B578F8EB49961A5F05B6B7A4B97
	4EA00A57A0080D677530668BEEC34A7A024B2CB4BDC2D85C1F7FD3963D0D2D69
	4D51F7756DE5E5FEECE850F3DBDFDA204033261463EFEEA0F7E0E0F0C31F7EF8
	EE5BF79138383A66016098105302AF6F52540026FAA45CF7F9E9064F1D4C0FA7
	2A4B04D383499AB30217143EA60D9A95287E8734535A7913505C59B1F049A9A9
	C813BDE068BC3D8B582FD0ADD1909E6CA294C967361982A68AB05027039E81A1
	44B669605005891A24A3C9E42FFF6FFE7B6CEE99BE3FF8C147EF7FE75BBFF767
	7FDFCEB51B08D146B1D10E975BA6929DA58285F960EF706363FDDA8D6BE84711
	5B0EE5E3C9F1E6F60E2E1DEC1D6C6D6E1ECFE6EB1BFADA59F481C8E3AEEEBBEB
	6B2854A251E514566CDD014AECA6D83ADDBD7B97A57D8E8AF97CBA4958753F65
	D692196C6AD933D31FEDAFB5E8D18E4C11058BD460C229DDF4B72C74DFA7878C
	8913F18C2157BF1D0BF255B55E5095943C186861F372E23C6627B3B7F7FC736F
	BD71EC2F691331D446B6D14A61C167A2772AC7083026A5D36C4D13D2D42B373A
	750FF247A4DC3FB0C2A38E82E9A1A215CA75A3505141202939EB26AA37D48FB0
	F16C779F59F5F69BAF3DDF3BC4078DA80653AB923FB994410FBAEE8681FDE7BB
	DC41D7986A5BDBB87B7474BC31DDE28E4644D7363769A459855B27A16DC23D80
	30AD93C778B372767CB0CF2D69636B877D1E2B206B94B6010CF1E19C3BF96C76
	F4D6DDDB7AD36CB2BA77708893DBDB3BFA85273D943331787A632BB5C9F4389D
	E84BEC5E1D7CEBD05AA6751B403B38FA68CFCF0FFC100A42A7BB9F2455D47249
	34EA33033A10C4E7C85DCEA8422C8AC8A8F3866368A67AA4FD009574DA551C84
	4A11A328995FFE8FFE020B1FB5B439DC3FD8D9DEDCD0EF04CF3EFAE8E3D7EEDC
	D8DADE2154B198D19400ECEF1F6EEFEC6C703B1783EC541C194AB97FBA727CBC
	4F94D6F596DAFAFC88E01F423D7BFA7C7DBA71FDD66D6FC0B454E9FBCF737D81
	677B6B0B732BF0E9DFD9EA6C7E4C00A03D37B42631C43C741E1FEEBDF1FA7D16
	B795F9E9EC444FA85A5ABCF631FACC045ACDF48539755037092F90EE221B0652
	1FFD0E326E3A6BA45DC37A7A7478E85B360BD9BA564834F0107C7CC43690D464
	4A6DF0CCA7C193E7449147CFD7EEDC6663707276AC0E4732AB3A82ADB9C5C841
	7A4090D01FC8E0CE22AB5A0550AF5D91B63D7459EF387834F040A34B8FE52B77
	C6187266325B979BB76F6AB2A80FD6C97E743EDB3B9CB31CDDBF7D757E3A993B
	02A40A96F5FE1437166BD383815C81D4BB430CA4B6852CABAB7A72C00D1EEBD9
	E8ACB3CF517A39427AAF768E13E8D33AB23221E02867CA6917045FD39392DE1A
	816635F4C666F5F193C7776FE8A31B868608682848623AB13ED506C433E494CD
	3402FE4EFBA9DFC8C28A1CD55B4C0A3D1453023FC9599CA19AD10D5A71B14ECE
	202630A18776AA73550F98155EA7B420B84312808EA2857382412039F9EB7FF1
	4FE95E466EB2F7D3C4429332038D8444F9A4354F4B1A99C5D2FA902DF51556F9
	0DE248126B6FC8BABCAE7DAD3AC3F0120E1AAFAFB338A39F213E399BF344440F
	59BF8F6647F49BD59A0D3D1B99C9193BECA9F630F28DFEC8A4D2026BBE4FA149
	96E99857532AF58902BE4DCEF6F70E9F3E79FCEE3BAFF3C4C95CA26B74006F68
	A088E084FA09A5686891D10753F1D52009941B9456525BE58610EF33125CBDB9
	810A2D24DACBD1CB35362C6B5E6EAD40E1C225C697E638F8F8C9B3E3A3FDB7DE
	7C1BE7C841A974F409B4C683B878143C60546902A245A386128F87B934D3948A
	29449269F302A10A49E09E1C2359753FD476D9CDAD4729B042CAD24B36ABCF9E
	3CBDBA4D2EE91B4ACA276D4E9054D63B3B61B0367B2D94726D0CE833CB16ABFB
	FCF88885786DBA898344942DEED1F1113B5D3D342BAC7A446144F55686BF5285
	FFBAF179B2BB572BCC400D07D4D9293B8127CF9E4F2767D7AE5D65DB89096CE5
	E2CDBA4086304358FB3CAA9AC59BDBDC3DF446A06688C649CE3BC731E414D5AF
	31698DD3A0B9DF063D91516712FAE75A62B42E2870168A2591C55323624979FE
	37FFD2FF34EF10748071C2929B91D3AC267A438E201077D5ADB069E54C7E6040
	1FEAF0E4270FB4227FFCF0C1F59DCD9D2BDB4C7A19D2DB558491498F798DBE8C
	69F2291FF131994A79A4A5066D9A79DABA29761A2A77C69192EC1A770A8A7EC4
	507F68ED2742469461703F59DBF4E8F2F183C77776D6B7AE5ED16F2A100D7DDA
	A0E4955B1068D03CCFF701C80FFACE59A635F27A374C21516629686C5670E8C9
	A387546EEF5C111715EEBBC2A59E615C4BBD97251E1EF5868BD89A2EAB0F1E3F
	DA5C9BDCBFFFE6E1F101BB6EFAE4C0AB5F6EE61F018E98F8C2E48A8D074FDEF3
	F97C7363430B9B668F3A82E6BDE7BB6437FE78DDD13BEB98E556468AD331A608
	2AD535BFC90B70955E901F07FB871F3F7870E7D6356EBC5A0E584AF11EA51A77
	059EA58491DDD8DE6255235E8AFCE91977573D9069C555E4F5C987D342136A36
	7BF67C776B6B4B3B497D8291DF63B7631A0B9C94053D2B1EEF3E7BBEB13125E5
	B53D23F0FA0071E5E9D3A76FDEBB898F18FEF0C3474F9F3DFD3D3FF51347F4FF
	94DB327703C68BE5467FAA471EAEFB7B567AC2614C56E37BF5D147BAEF01454A
	61549A61D81C42A7B89E9EEA7EAE90071BEA6CF22B7FE5CF3BEA5E09186CB9AA
	37023CEA7A274EB35B49A0B5CBB389F0B2702B122C0D4C58D43117C87A7298E8
	28FA92D5972E1980DD83C3ED8DD5DBB7EFC0D31CD394F423206B18B1515EA240
	9303DD760B779CADEC1322B33409D59629810B66792E493A6E67720D02A3D6A4
	40F138B8AA376FD889522217903AF9F0C1A3C9E9ECADD7EF1C1356270D11D56C
	D01B5898D5DB147456D3803648186CD810D4A2A5AFF1B1AE4894A1C5299DE5BD
	3E68D343EDC9E9E626BB7C5C62E58A6FF033B5A83DF6DBF07A8F9C0A8D8EBF82
	CA53F8BDDBB7AE5CBD79343BA07BABBACF499B022E25DA2DB1DB60D544A12240
	ACEC244FFC44057D387278A80FDD78BA604A4CD7A7C8788A5A81562E3BC9601D
	1EE8B382ADEDF5E9266BCBE9C9B1F6978A36FD52EC90FFE8E30737AF6E5DD9D9
	39468B5604128735593B54624A2BF54ACF61BA3792983A6B5E28C3E42EE0DEEF
	4F12F4C185A64B706442BE13FD638D2ACB3AF20CAD97388D36E61983439EBC4F
	CFB636B7B811F114F96C77F7AA270C56C806128A8161D8F501A9DE9C648A924D
	D4EA664EBFF4F6EEFA06BD969F531EF415B7006DB1C7CE856828435CA125E0EF
	FF95BF1005FB4F4AE1287DC33F6E286B6493D24F93406B00B736423F3FDA5FDF
	DAD19DCBCB0FD6E6273C4DD20B859C85C8B7C5D3DD678FF69F3DBBFFD6DBD3AD
	0DEE07E49B1421CE69B2F2C38F3E5E5D99DDBB7B0FDB8E083C05C583A7B9423A
	E1B19DA7931E528D2CC3E4043B230ADAD1CA92479C2CE3CA70E83D4C2D0ABA50
	F217E0CEA67E635BD9CA9E123F7938C621ED41517D7A7070F8C10F7EF8F9D76E
	4C377407C349B63D849860F95D20259F94696DC1A453436FA7EB9EBBAEC76BF9
	811BF49B3BB776F09AE65A8894133C2A1E1E320751C03322372465903ED6D0B7
	46A4C14CE2461C508FE0D17CF6ECC9E3375FBB3B59DBE4790C15784D1D69ABDD
	94FA2C1714374D25AC7BC376B6C2031CF3010D1BD34D758E1B35B2969FF14476
	74B87DE51A4668CC8AAA0FB3A7D3F84E079ECF7956F1BB7FCE55FD4AA0F2443F
	5A0DB9A95ED99CDEBA7563460ACB470552A986786CD3115202315AD4B9E36767
	474707DC0DC907966AB97176A2CFE3ED80560B9252FB163D92E584A5A9571984
	3D9027DCC50818B274952D020D5938787047F070FFF0DEDD3B3480E9264A1814
	3F7FFA7CE3DA8DADAD2B2CB13C70105F9C2A5FB262E3E79BBCDED56558CF26FF
	F9FFEEBF7FE7DE3D12425B0B0DB7464150C79447F4C5194072ADCD660CA43F1B
	5FE379E058819BEB5763C9EF23BDDBADEC530495AE33754A2B84BAA74F1689A3
	A7A606D97BEBD3D98C19CB1A6CE54445FBC18F1F6AC3F0DAEBF78E8EA4C10E48
	A1A1F473FAD351EDAA1552B4338F3556F2D3B71F7DC5C5A34E7332857942F414
	4F18B8EA287BF582A2854E769B873FDD61DC0F6D00D4FAFB1FFCE0EAD6F4EEED
	1B2CF152AF3725F4BB3E18C50F38AC4B4E6DBFF14A0B996023A4673BBBA49BA7
	72834DFBE4EC509FE51130C57076A0F7675956953E7ECE5003FD79D623341328
	D67356350879A2DCD21D016BCFF7F65EBF7B83119F1DEB718B8553BD5753D623
	DF48DD0111EC77951D5A5F0F8FD8D9B36AF1BC473EE92947F383ECC46DA5A29C
	948BEA42EED16553A923EDB34366F1E1952B3BB84120DC4DC50CB1C74F9EAFAD
	9CDCBF7B6777775F09AD89C70D59F9856A54F9163ADDDB7DF6F8E1C3DB776E71
	93A4A8DD8FF7027EDF5399CD2609B5F881562CD3571C8C84E2D986B39C4152A2
	4C3EA58206DA3B67F5527349BFCAC4BDE2D9B367B76EB059D5D7A8D046D49884
	28D390E98EA73D153AF450FEB7FEFD3F4D1FF0986C677D57AFD6A60F1F3DB979
	7DFBDACE95E31941C10DD25706080926F1083547C787F40D1F604ED73758CC90
	43BFDEDC3E3EE22EA6655B8B96367F9E1AF1A8EBC709F545B702B24F3E299C1E
	749C40373EEA6941E3AE3EB306ACAEFDF0E3075B1BEBB75981E82BA272426324
	1BBE6AC26A5F4811650ABE4639E60660FA29402CD8E41C6B989E35B124CB1A31
	35C4257FCFF94CDB596EACB2C0C26F2FB4BA5064D7A9DB31ABE5C70F1EEDED3E
	FF7D3FF5B9C3D9FCF070B6B631253278AE4D945644CD40774889A9D1C18E9E0E
	E7D34DF6EE6BBBCF778FF6F7EFBCF69AE6D2E9D93121D2D22EAFC84625C3F131
	66A71B5B6B1BEC7DA5047FFCF6118BA8A03DB1BF9F436409394B3CF7E6BDE7CF
	5FBF7F9B74910A85994E3AA08E92C64B8B8DFAEADE9F1D1C1C6D6F6D224EDA93
	94F08F8EE7EB9B9B04643EE72147DF00408D427E3A3FDCDF67D38D983FF3D29A
	E9B9AD316371393C3C507CFCF8846A86173C7BBE77F0FCE98FBD7D7FFFE0101B
	78A8E66CC42513E9CBD2AE219209FDFD59253D3615747C9076A51EACD80FB83B
	F2DC5398B89E683E465F430994528BFDA1F20A0E959CC90E4DAEB3535CE291F0
	EA956BDCEEC4FF95FFE8CF910438C1CE56EDE98D1EC0F53693BE83A265E518B0
	72D0E5A74F9FFCD83B6FB2513B3A6078B0453FD97E4D58AB9446E8389D3DFCF8
	63AAEFBFF9B6DE00B22758C5516ABD28E9295E7ED3A7D3D383DDDDDDE7CFAFDF
	BEAD6F56AFEA7EA2556E76C2330F92CA49DD5E3085255D952372D7013C3B393C
	3CFEE10F3F6639BC7EF5BA7FB5114140CF152EC58AC54A73C911755E32D51506
	BD67AA2023AC00C522AAADF591A63B3B6925AC75C9504C2FD12808B5CAE99509
	8F8AEA0EF3CD034ECC8F0E8FBFF3BDF7EFDFBAFADA9D6BBB7B07AB6B9BEB1B9B
	CC3C12542BA7B76112952C0157F613072D1FDC03FCD121BAF00720C0524242F9
	0F139F3E7D7E70FDAAFEAC0BCB010EAD6F6CC78A439C881BE9CF6D6473639304
	C34D7602764BAB0FB7AEA74F9F5DBFBA75F5CA36EE91D65A6014166AD95F9184
	724C9DF507859B5B9B24302E21457EAE6FE8AD7A4D1E2D8178A72594DE635331
	D512A48139383850724F37F13D362DDAB96A3B75CAAD97CD3346143F3F72E87D
	C5B395674F9FED3DDBDDDC587FF3EDB78EF43D736D6C880C4D1829C55D93557D
	C19E7E7390C16368D49E2AC58F97E7AADE5154536F0A3C7632461B9B5422114F
	E60C7D9746CD0DAD9D3027BFFC1FFEDBA8F296C87FE904379D252C9968D7EC3B
	617589F76308199B4BB674DA552B0BE5E1EAF3E7BBAC0EF7EEB39811CB63F287
	8199D31DDD74C03A9690579CE4A3428633FBBBCFB1B5B3C333197761A2E93D8D
	3E25637728AFB127F5EC62F52E8DBE284147D46D9CA6077A4742CB03342AC313
	A5ABB3FBE0F0F8C38F1FBC7DFFE6E6F655EDE9B548CC79429200A167A90BF769
	CFA4A409ADD5551884023BF45D777916632B569AA1C2E679298789F3D1D1A13E
	0F5DD73D8188E0891F3BD6B5156608B54869DBA4A7C8B52919FAC30F1F1E1EEC
	FFF48FBD4E38B807B18423C7006ABA9EEAA33AD61062ABDE302B1CE139B7E0D3
	13BD2DE5A7DBD9C94C8FA4DE4093B5F1B573384E623D88639FDD364E69EDA439
	CF1EECF936F4C763D42B465003C1CA867333EE638747B38F3EFCE8FEEDEBBA99
	B029A22FFA5C405FE7241896578631B51C21AD4EDA4E6978B40A204126D13D45
	50120C8ADE0AD5207BD1559A318EEACBD9FAEA14B789290191FBDA3ADA040D15
	6262A0F7A9B0C10AFBF1478F6EDFB872EDEAF6D1EC84CDF0831F7EB8395DDDD8
	9E5EBF7547DB4BED9DF428C990DBB47698E8942702559A45F051CAB81E73EFDA
	A45B3CADF9115EEFDF1C6348C9F3F7FECAFFDCEEF15272C2C5753DC66901E2C9
	9AF06A3B7B3C9B6B5A68566826F9AD1EBD27402380297A4047D9CAC6FD14177F
	F0C30F6F5FDFDAD9E6B192DEE93197A595B3D2EB74FE83F73FD8B9B27DE5C60D
	29D16803F5872493ADF5D5E38323B62BC81FFBB37D4F07A564048EBB30614219
	9B01EAD81B94C9A0F7E6544D7A9D709BC22FADD94C319CE78EFFF0E38FDE7CED
	CEF695ABFE90576F15FB4D010EF24E7E7A2C90F7B0E9FEAC2154944900052A9D
	459031C49CB98459C12335D598BA097B097E66745FFB7BBD9BAFB75E19940DB6
	9AA427125AF1A7ACC27B7BFBEFBFFFC3FBB7AFDDBF7B8B4752E612A1A29EBE6A
	9809811EE3F4DE93CCE08222AF0F2B007E3361B1A8E742FB8F6D7F4B57FDC93C
	8B5BB4F64BBA97907F388472475293811F061759A689D4EB2F779C3ED9DDE729
	E5ADFBB799248AEDE636EEB0D832EDE5F7E6967D23329E217A2B56FB37056675
	C2EEEEE9E3A7376EDDD8B9B2430CE9209A37363789210EE876A7D54E8F0B5A1A
	E6FAE309F498455031A4EEF818D522B4F15BE5E670A464E0E9094393070F784A
	5C215687736E147A7B5679C1D4D282C8538FEFF078235714337C624FA1DCD327
	5F38493E904C5AA6344EFFF0AFFE2F359C8C08B1D353E8EADEC11EF5C488E56A
	6B47BF5082776435023C956B7EE94980A976C25D6B834068CFE2BF3B22FF190C
	3D0470EBD774649941F9AA125463BFB1B177787CB0F7ECED37DE6019B67F9AFE
	CE334657A2A8D02202F3449FA138671814797B32231C68D717C1B6B6B60E0EF4
	ADE6CD9D2B7A6CDC7FBE7395E7B3356605E34B9808D75CDF63D38D1BA79D84CA
	2A628EC3F48871935A458D07C4390BE1E75FBBB375ED9ADEA63BF576051F9C6F
	8C8EA610D2666A262A69B89E1EECEFB3DCFA9D0DE2C37D7F06414E7809D0102B
	24EAA196363A45F434FF6332B014FB2D7C59E1E5B98B113D27E83D03B5F9F8E1
	93C3DD673FF1139F67CDF1BAA0CFBF9D708C25213114404A5A9A95828C17B5CA
	7D2692E60961E1BE7D4C27D94B78B98D45646D734BE9AB35589FAA6AF7AFA743
	F5CF6CEDE699601860E54629B198B1A19ACD1E3C78C8E3C2AD9BD758EC14A8E9
	DA748D0715BD8B82F20897160C28F78C5B134A484D1EA40916DE22CCD304C2E4
	15CAE5F4CA290FD9729AE5F9E86893FBD8BABEDA4D463289235064E911A945B3
	3594E81B848E31173F499D9EFCF0E387B7AF6C5CBF7E8358CCE77A47DBC34574
	5826F47519021CBD421B6AB9934E7EE5FFFEEF68AE691591D7B84F98D4027B2A
	AE716FD127BD6BEBFBDC4F7533D48DE7E498B02A23883D1B676EC7C4953CC00B
	A53312B8B8C20229B54A0043EBA5878849AF458EE5409FF9F3DCB3F9E0D1E3EB
	57B7EFDEBFAF3F1CA475549E2B25B20959856EEDD435BF5DCD42C20C3999E97B
	01D4D389E9744B6BFFEADAD1D181B2845E9D9DB2A6326857AE5C61B40EF7F636
	B4C1D58E8B7B130F36F24AA927596FC0CB5B2E64F0C964EF60FFA38F7FF0CE6B
	F777B66FCCF41BC54738A5945AE7915731D380D14A1D96A35E55DC1A25CE45F4
	68062BA1341D482026A29EFCA8F1CA827D448917BDD5D441CEBDD388F17CE5B6
	276733A2A924572CADE874E5FB3FF8F0E6D6FAEDBBF7145EED6EB14BBCB564A8
	8DDC51F2226BFFF4CE15EEB1FA1D1DB25927483C464FA9663EFA0BD82491660D
	03CC432AFD52F6CAC1F5A319E3AECFD7A58D43F34D1ED050EE71B071D5BBD20C
	E6ECC30F1FDCB9BEA3870DFD2D26DD28E889378CDA9E91271E77E951C8D453AD
	DF1EDE33165416791E3861B35E310CBA294980F5420B34A386E1E954B7321635
	FAA05C208D080737001C514ACD1150001C628A28E731E8C183C737AF6DDEB8A1
	DFB8D2C306D6B5A49D4CFECE7FF0679E3DDB25255E7FEDFE8C25D64E4512302A
	B82AEF58FEF5F4A6FDB1D657BD45A5BD20B90671E2AD08C63537B861E9B96D8D
	98922FB4DDD8DAD8F017EB95913C32A25FAE69874C97D14C8E6A9A31387ACB8C
	013A3BD83F64EFBBBDB3B97B38E311F973EFBCC99D8D1ED14BEDC144280F58DA
	FD94C63E1B0DEC25B84A0BD1D898EA9D135614AD375A6E57A6D3D5A3BDDDC3FD
	E75B3CFEAF4D1F3E7CC894D8DCD9215258D76396DF76A437E874F4C82372CA73
	59EF04F28C442EF3D87736395ED93F3C78F8F8E1EBB7AF5FBD76EBF864767878
	C4E4C18EB6A53CE4B14468EA7A1E4B49190D6E6228247F0E0FA922FFB4EC2817
	D8EB6B578FF2B5E926134C59A251409DB7D77E4823B6F450234713078DB547DB
	52BD4FEF79447A4D563FF8F063D6A7DFF393EFEA4B0D7A34D0A3BF9217313295
	85C3FB0A4D5BA09CF17C9AACEEEFEFCFE7F3ADED2B3CF5D24B546A796285F63B
	546B1B5B78136976B8FBFCF8E0E0D6FD3775C356A628E82CC0B8247D84520B30
	8345BAB32F40C76C776FEFF1A3C7AFDFBBC552CA824414B63637D7583159BC30
	A671CF9B1E7AE40F515174E4A0BE49A5494728E52D3384BB90C2AADD3839A387
	4C36D67EDA97234C610E924B49ABF59258F90D1FBDD3C53DC96F16E1262AB1F8
	B7FFD29FD15B0D7AB45AD1579AB59D3922FA87C7A7DC34DF79E7F523BDAF79C2
	8D5E5D57040918FEA371BE3A5D595FDDD87DFAF4F1C38FDF7CEB8DF58DEDB3D5
	29316218744FE241031996D9B5D583BD5D7F37904E2A29E896960406C6CB0CA3
	2237BD3F53B7F4963B43CEA8E9EDC7D98C3C5E27B7F5E0C23E6A7BE7D1E3279B
	1B6B6FBFF9E6617EF14B0A535EB9A1EFD0123F85CCA3CC89ECD0877847079898
	E96DADE3ED2B57E092169B3B5B38820AA7303EE826430D3121BE9EF3B951A1FB
	70D827681F655F893E3B2CF246B97E7ABABBBBFFF8F1A337EFDFBE7AE5A64649
	F76E659AEC2873B56356F8A44D03ACDEDA410CD26FDD756D0B163A21987A3CC2
	E946115FF1D7C091117A6A22DB582F190968B7469D54A9C832C95D5A03ECFB86
	FE98C5E4F1B3DDA78F1FFDDE9FFAFC9C29CCA3356EA04D6389A655C24D044855
	0ADC9FA444F72E758B7E943F5226654449AB1E81D757FFF56949E493B652D215
	EFD92B68A852609900DE71E1AA12436FCEE84D7DAAE92FBD7BF4E8E9EEF3679F
	7BE3263C7DC140DB1166BBBE89434F7403F15328A25AEA9D7C5CC919E48ED82C
	6D6E102B3D0AEA13AAF9FEEE73FC21E91C14DD386406F3BC8895E2AE43B97776
	B67FB03FF9BBFFD73FC70832D87448A62767B3D9811623FD0143EDE3E906A933
	9B1FE2014F970F1F3F7EE78DFB6421565900F4674359F85261FE669D1E8361C1
	A18E954E0F03FAF850B4EF24A4380BA11ECFF5BEAFB68F64B98653FB0942C448
	52CD45BB4F7A426E136EEE1778853F64090F239ADD7A234CD027EFA72B3FFCE1
	0F7ECF4FBDBBBD73957D14F71F7C425ED382E1F4CE9BCDA5E6AD87819E610307
	BD99F71B56AB4CFBD9D6D60EA9A3A460CA1C1E6877A277609410C787874C1B45
	524F35FA03A9CA19AD5B58A00153CE29C0A68EDD2DEEE1BC97ECE7079A18EFBE
	F5C6D6D5EBEC62492DDD19BC70D35079A6082AE61A31DD6A94C4621203BDDD20
	0FF5569972130B7A1B941584E911A3BCB6BE717874C40C201B74C392BBCA0FC7
	466A35F9F49AF0346D655EFDF05D1BA395DFF9FE0F7EE273AFEFEC5C650DC536
	23CB1CA3531A451C912AA69C66126D943EA72B33EE7B07879B9BFA73F6E4B7B6
	4CBA51326C4A77856395959E6759E2ACA74F45453D12A555066FD48508BE4679
	6D85E9AD78288008E3FC9C07B30767F3C3775EBFCB5D0B954C7D544B217E288F
	E9A0F6F4C4060DEAAAE622793ADFDCD8D477DD151E46569FB6DA791CD7E09D70
	67536C958293BFF9EFFF8F757BD5969DE8D04F2519A32BF5F139A23F6499CD8E
	FCDE024B05BEB1D9DE62648E8FF4299077F04FEFDDBD7AEDDA757DC464DFE4A1
	52C263A09DAB96077AACFE6BAD9CE9AE2C97E012ECB5E3D91123C78E8D49AC5D
	842B594B9464EA865724AF49ACC813BFD93CD1D3C7A1DEB4B6395CA5B873F5DA
	FAC62681104FCBC5CAC3474FE6C7FB3FF9EEBBCC898383437D81029B8019A1D4
	D5330F63C6AE892D09779435DD8BB1C596541B0CBF4DC1CE581BA493E323ED08
	0E0E56F588B6C15091E2724E9B700D1EEB101C728B5BAD03AC1CD2883A7DF450
	E72F1DC095FF9395C74F9F3D7EF8E89DD75EDBBE768D59875DE2AF765226EF18
	5A15942C4E3C35D47694034A2C7AAE50CB13F74A3659C809875B4068FBA4FC43
	372689D27CC6AD9E79AD5C21E7B47DD0BA4EFC953F9A1BFA958DF5E9FA6FFFCE
	F77736D73FF7CE3B873C20EB033EC16ECAAE3AA25CD5924F04359E44607D7A48
	7CA63CF16A3425C9E441BBF35703CE8F567129F1B842AA1049631735279C45FC
	F058AD851D8607CBEB391199CF3F7CFFA3DBB7766EDDBD79C85E450FADECB856
	B8B3E1B7F28EA9E2A70E074066ECA92600F38799491EAA2BECEDFFEE7FFC67A5
	5AA1D0A38C67A73F28C1B68612214D68EDD2485CCD6CAD245228CDEC8EF4DBF1
	D8DFD9D999EBDBA39288BDCA8347CF7636D75E7BED3E371ABAE335457D433FB6
	B4DE323DA4996D995662368E14B57EC81DDC1358F5D59B09776DF6CD0A2CA1D0
	F2A2A492B06614D27A62419B82243FB1E7E57F9D3BB27AB9BA359DF2100C90E4
	36F5FCD9EE7BEF7DEB27DFFDB1EBD7AFF3A4ABB03B4658A4E33CBC6184CEEB1E
	1E5FC3C4043EEBB94389CADA305D9B1ECDF5390001D2B736A440ABD1D3478FAF
	5EBB8200C94E730F31FE2A5A5809F7342E7498ACE34E72B887937A0F8D75DDA3
	B2B6B2BEBBF7ECF1E32777AF5DB972F526F3935DABE3CED2AEAE21850A278B87
	4223890DF90F4F5B50A519CF1B0C07BB9429B1E0918C14894D9D324B8F72C43B
	BC52F2BB853D8B34244C68D42E4FF746CDA815FD313EF282FA274F9E3F7BFAE4
	C73EF736F3594B2F2A9D5BD6A63706AC0D969B296D081D19797274C88E451FD5
	C973858CB4F3A74CF29DC03B0D95217844873545A5E1ECEC787F9FE67ACB5183
	ABF1A039D1F666504ED309A5EBE9CAEEEEC1D3278FDE79E30E9B7677153E1985
	E3B1AA12E67586920E4BCFD9CAFF1F6D1C4F8C026B53320000000049454E44AE
	426082
	]]>
</Picture>

<Copyright SectVersion="1" SectionFlags="0" SubIdent="0">
	<Author>BIMobject</Author>
	<License>
		<Type>CC BY-ND</Type>
		<Version>3.0</Version>
	</License>
</Copyright>

<ParamSection SectVersion="22" SectionFlags="0" SubIdent="0">
	<ParamSectHeader>
		<Version>22</Version>
		<AutoHotspots>no</AutoHotspots>
		<StatBits>
			<STBit_FixSize/>
		</StatBits>
		<WDLeftFrame>0</WDLeftFrame>
		<WDRightFrame>0</WDRightFrame>
		<WDTopFrame>0</WDTopFrame>
		<WDBotFrame>0</WDBotFrame>
		<LayFlags>65535</LayFlags>
		<WDMirrorThickness>0</WDMirrorThickness>
		<WDWallInset>0</WDWallInset>
		<SymbolColor>0</SymbolColor>
	</ParamSectHeader>
	<Parameters>
		<Length Name="A">
			<Description><![CDATA["Width"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1.8</Value>
		</Length>
		<Length Name="B">
			<Description><![CDATA["Height"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1.5</Value>
		</Length>
		<Length Name="ZZYZX">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Boolean Name="AC_show2DHotspotsIn3D">
			<Description><![CDATA["Show 2D Hotspots in 3D"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Length Name="ac_bottomlevel">
			<Description><![CDATA["Bottom Level"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Length Name="ac_toplevel">
			<Description><![CDATA["Top Level"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Integer Name="iProfilType">
			<Description><![CDATA["Profile Type"]]></Description>
			<Value>103001</Value>
		</Integer>
		<Integer Name="iSashSystem">
			<Description><![CDATA["Leaf Type"]]></Description>
			<Value>1</Value>
		</Integer>
		<Integer Name="iThresholdType">
			<Description><![CDATA["Threshold Type"]]></Description>
			<Value>1</Value>
		</Integer>
		<Boolean Name="isWindow">
			<Description><![CDATA["isWindow"]]></Description>
			<Value>1</Value>
		</Boolean>
		<Integer Name="gs_optype_m">
			<Description><![CDATA["DoorType - Single or Double"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="iSashType">
			<Description><![CDATA["Door Leaf Type"]]></Description>
			<Value>11</Value>
		</Integer>
		<Integer Name="DoublePart">
			<Description><![CDATA["DoubleDoor 2. Leaf"]]></Description>
			<Value>1</Value>
		</Integer>
		<Integer Name="iPosSlidingLeaf">
			<Description><![CDATA[""]]></Description>
			<Value>1</Value>
		</Integer>
		<Integer Name="iGlassType">
			<Description><![CDATA["Glazing Type"]]></Description>
			<Value>2</Value>
		</Integer>
		<Boolean Name="bTerraceLeaf">
			<Description><![CDATA["Terrace Leaf"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Integer Name="PlaceHandle">
			<Description><![CDATA["Show Handle  (left/none/right)"]]></Description>
			<Value>0</Value>
		</Integer>
		<Boolean Name="PlaceHinges">
			<Description><![CDATA["Show Hinges"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="HandleHeight">
			<Description><![CDATA["Handle Height"]]></Description>
			<Value>1.1</Value>
		</Length>
		<Integer Name="iHandleTypeIn">
			<Description><![CDATA["Handle Type In"]]></Description>
			<Value>4</Value>
		</Integer>
		<Integer Name="iHandleTypeOut">
			<Description><![CDATA["Handle Type Out"]]></Description>
			<Value>2</Value>
		</Integer>
		<Length Name="MoveXLeaf">
			<Description><![CDATA["Leaf Side Cut Profile Move X"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0.035</Value>
		</Length>
		<Length Name="MoveYLeaf">
			<Description><![CDATA["Leaf Side Cut Profile Move Y"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="LeafBoxA">
			<Description><![CDATA["Leaf Size - for Profil Cut"]]></Description>
			<Value>2</Value>
		</Length>
		<Length Name="LeafBoxB">
			<Description><![CDATA["Leaf Height - for Profil Cut"]]></Description>
			<Value>2.2</Value>
		</Length>
		<PenColor Name="gs_leaf_pen">
			<Description><![CDATA["3D contour Pen"]]></Description>
			<Value>2</Value>
		</PenColor>
		<Length Name="gs_sash_width">
			<Description><![CDATA[""]]></Description>
			<Value>0.05</Value>
		</Length>
		<Length Name="gs_sash_thk">
			<Description><![CDATA[""]]></Description>
			<Value>0.05</Value>
		</Length>
		<String Name="gs_detlevel_3D">
			<Description><![CDATA["3D Detail Level"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value><![CDATA["Detailed"]]></Value>
		</String>
		<Integer Name="lod3D">
			<Description><![CDATA["3D Detail Level"]]></Description>
			<Value>2</Value>
		</Integer>
		<Integer Name="iResolution">
			<Description><![CDATA["Resolution"]]></Description>
			<Value>36</Value>
		</Integer>
		<Boolean Name="bLeafCustMat">
			<Description><![CDATA["Custom Leaf Material"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Material Name="gs_frame_mat">
			<Description><![CDATA["Frame Material"]]></Description>
			<Value>0</Value>
		</Material>
		<Material Name="gs_sash_mat">
			<Description><![CDATA["Leaf Material"]]></Description>
			<Value>17</Value>
		</Material>
		<Material Name="gs_leaf_mat_in">
			<Description><![CDATA["LeafMaterial IN"]]></Description>
			<Value>77</Value>
		</Material>
		<Material Name="gs_glass_mat">
			<Description><![CDATA["Glass material"]]></Description>
			<Value>24</Value>
		</Material>
		<Material Name="HandleMat">
			<Description><![CDATA["Handle Material"]]></Description>
			<Value>45</Value>
		</Material>
		<Material Name="CompMat">
			<Description><![CDATA["Component Material"]]></Description>
			<Value>100</Value>
		</Material>
		<Material Name="SilentMat">
			<Description><![CDATA["Sileant material"]]></Description>
			<Value>49</Value>
		</Material>
		<Material Name="mats">
			<Description><![CDATA["Array for materials"]]></Description>
			<ArrayValues FirstDimension="14" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
				<AVal Row="9">0</AVal>
				<AVal Row="10">0</AVal>
				<AVal Row="11">0</AVal>
				<AVal Row="12">0</AVal>
				<AVal Row="13">0</AVal>
				<AVal Row="14">0</AVal>
			</ArrayValues>
		</Material>
		<String Name="sMaterialS">
			<Description><![CDATA["Materials' string array"]]></Description>
			<ArrayValues FirstDimension="14" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
				<AVal Row="2"><![CDATA[""]]></AVal>
				<AVal Row="3"><![CDATA[""]]></AVal>
				<AVal Row="4"><![CDATA[""]]></AVal>
				<AVal Row="5"><![CDATA[""]]></AVal>
				<AVal Row="6"><![CDATA["Glass"]]></AVal>
				<AVal Row="7"><![CDATA[""]]></AVal>
				<AVal Row="8"><![CDATA[""]]></AVal>
				<AVal Row="9"><![CDATA[""]]></AVal>
				<AVal Row="10"><![CDATA[""]]></AVal>
				<AVal Row="11"><![CDATA[""]]></AVal>
				<AVal Row="12"><![CDATA[""]]></AVal>
				<AVal Row="13"><![CDATA[""]]></AVal>
				<AVal Row="14"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>

		<!-- DoorLeafMa_sp0: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="DoorLeafMa_sp0">
			<Description><![CDATA["2D Parameters"]]></Description>
		</Title>
		<Integer Name="lod2D">
			<Description><![CDATA["2D Detail Level"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<PenColor Name="gs_leaf_pen_cont">
			<Description><![CDATA["Leaf Contour Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</PenColor>
		<FillPattern Name="gs_fillLeaf">
			<Description><![CDATA["Leaf Fill Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>23</Value>
		</FillPattern>
		<PenColor Name="gs_penLeaf_fg">
			<Description><![CDATA["Leaf Fill Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>83</Value>
		</PenColor>
		<PenColor Name="gs_penLeaf_bg">
			<Description><![CDATA["Leaf Fill Background Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>119</Value>
		</PenColor>
		<PenColor Name="penCont_sealant">
			<Description><![CDATA["Sealant Contour Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>2</Value>
		</PenColor>
		<FillPattern Name="fillType_sealant">
			<Description><![CDATA["Sealant Fill Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>10</Value>
		</FillPattern>
		<PenColor Name="fillPenFg_sealant">
			<Description><![CDATA["Sealant Fill Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>8</Value>
		</PenColor>
		<PenColor Name="fillPenBg_sealant">
			<Description><![CDATA["Sealant Fill Background Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>18</Value>
		</PenColor>
		<PenColor Name="penCont_glass">
			<Description><![CDATA["Glass Contour Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>6</Value>
		</PenColor>
		<FillPattern Name="fillType_glass">
			<Description><![CDATA["Glass Fill Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>65</Value>
		</FillPattern>
		<PenColor Name="fillPenFg_glass">
			<Description><![CDATA["Glass Fill Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>6</Value>
		</PenColor>
		<PenColor Name="fillPenBg_glass">
			<Description><![CDATA["Glass Fill Background Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>106</Value>
		</PenColor>
		<PenColor Name="pFillS">
			<Description><![CDATA["Fill types as integer"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="17" SecondDimension="3">
				<AVal Column="1" Row="1">1</AVal>
				<AVal Column="2" Row="1">1</AVal>
				<AVal Column="3" Row="1">1</AVal>
				<AVal Column="1" Row="2">1</AVal>
				<AVal Column="2" Row="2">1</AVal>
				<AVal Column="3" Row="2">1</AVal>
				<AVal Column="1" Row="3">1</AVal>
				<AVal Column="2" Row="3">1</AVal>
				<AVal Column="3" Row="3">1</AVal>
				<AVal Column="1" Row="4">1</AVal>
				<AVal Column="2" Row="4">1</AVal>
				<AVal Column="3" Row="4">1</AVal>
				<AVal Column="1" Row="5">1</AVal>
				<AVal Column="2" Row="5">1</AVal>
				<AVal Column="3" Row="5">1</AVal>
				<AVal Column="1" Row="6">1</AVal>
				<AVal Column="2" Row="6">1</AVal>
				<AVal Column="3" Row="6">1</AVal>
				<AVal Column="1" Row="7">1</AVal>
				<AVal Column="2" Row="7">1</AVal>
				<AVal Column="3" Row="7">1</AVal>
				<AVal Column="1" Row="8">1</AVal>
				<AVal Column="2" Row="8">1</AVal>
				<AVal Column="3" Row="8">1</AVal>
				<AVal Column="1" Row="9">1</AVal>
				<AVal Column="2" Row="9">1</AVal>
				<AVal Column="3" Row="9">1</AVal>
				<AVal Column="1" Row="10">1</AVal>
				<AVal Column="2" Row="10">1</AVal>
				<AVal Column="3" Row="10">1</AVal>
				<AVal Column="1" Row="11">1</AVal>
				<AVal Column="2" Row="11">1</AVal>
				<AVal Column="3" Row="11">1</AVal>
				<AVal Column="1" Row="12">1</AVal>
				<AVal Column="2" Row="12">1</AVal>
				<AVal Column="3" Row="12">1</AVal>
				<AVal Column="1" Row="13">1</AVal>
				<AVal Column="2" Row="13">1</AVal>
				<AVal Column="3" Row="13">1</AVal>
				<AVal Column="1" Row="14">1</AVal>
				<AVal Column="2" Row="14">1</AVal>
				<AVal Column="3" Row="14">1</AVal>
				<AVal Column="1" Row="15">1</AVal>
				<AVal Column="2" Row="15">1</AVal>
				<AVal Column="3" Row="15">1</AVal>
				<AVal Column="1" Row="16">1</AVal>
				<AVal Column="2" Row="16">1</AVal>
				<AVal Column="3" Row="16">1</AVal>
				<AVal Column="1" Row="17">1</AVal>
				<AVal Column="2" Row="17">1</AVal>
				<AVal Column="3" Row="17">1</AVal>
			</ArrayValues>
		</PenColor>
		<FillPattern Name="fFillS">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="17" SecondDimension="0">
				<AVal Row="1">1</AVal>
				<AVal Row="2">1</AVal>
				<AVal Row="3">1</AVal>
				<AVal Row="4">1</AVal>
				<AVal Row="5">1</AVal>
				<AVal Row="6">1</AVal>
				<AVal Row="7">1</AVal>
				<AVal Row="8">1</AVal>
				<AVal Row="9">1</AVal>
				<AVal Row="10">1</AVal>
				<AVal Row="11">1</AVal>
				<AVal Row="12">1</AVal>
				<AVal Row="13">1</AVal>
				<AVal Row="14">1</AVal>
				<AVal Row="15">1</AVal>
				<AVal Row="16">1</AVal>
				<AVal Row="17">1</AVal>
			</ArrayValues>
		</FillPattern>
		<LineType Name="lFillS">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="17" SecondDimension="0">
				<AVal Row="1">1</AVal>
				<AVal Row="2">1</AVal>
				<AVal Row="3">1</AVal>
				<AVal Row="4">1</AVal>
				<AVal Row="5">1</AVal>
				<AVal Row="6">1</AVal>
				<AVal Row="7">1</AVal>
				<AVal Row="8">1</AVal>
				<AVal Row="9">1</AVal>
				<AVal Row="10">1</AVal>
				<AVal Row="11">1</AVal>
				<AVal Row="12">1</AVal>
				<AVal Row="13">1</AVal>
				<AVal Row="14">1</AVal>
				<AVal Row="15">1</AVal>
				<AVal Row="16">1</AVal>
				<AVal Row="17">1</AVal>
			</ArrayValues>
		</LineType>

		<!-- opline2D: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="opline2D">
			<Description><![CDATA[""]]></Description>
		</Title>
		<PenColor Name="gs_opLinePen">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</PenColor>
		<Integer Name="gs_iSwingType">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<LineType Name="gs_swingLineType">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</LineType>
		<Integer Name="gs_iSlidingType">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>

		<!-- bOverride_MVO_3D: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="bOverride_MVO_3D">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="or_bOplines3d">
			<Description><![CDATA["Show Opening Line 3D"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<PenColor Name="gs_pen_3D">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>3</Value>
		</PenColor>
		<PenColor Name="or_opLinePen">
			<Description><![CDATA["Opening Line Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>6</Value>
		</PenColor>
		<Integer Name="or_iOpLineType3dIn">
			<Description><![CDATA["Opening LineType In"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="or_iOpLineType3dOut">
			<Description><![CDATA["Opening LineType Out"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="or_gs_opline_style_m">
			<Description><![CDATA["Opening LineStyle [1-Handle, 2-Hinge]"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="iOplineArrow">
			<Description><![CDATA["Opening Line Arrow End Position"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="iOpeningType">
			<Description><![CDATA["Opening Type"]]></Description>
			<Value>1</Value>
		</Integer>
		<Angle Name="aOpeningS2D">
			<Description><![CDATA["2D openings of zones"]]></Description>
			<ArrayValues FirstDimension="7" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
			</ArrayValues>
		</Angle>
		<Angle Name="aOpeningS3D">
			<Description><![CDATA["3D openings of zones"]]></Description>
			<ArrayValues FirstDimension="7" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
			</ArrayValues>
		</Angle>
		<Integer Name="iZoneColor">
			<Description><![CDATA[""]]></Description>
			<ArrayValues FirstDimension="7" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="iNumbersofZones">
			<Description><![CDATA[""]]></Description>
			<ArrayValues FirstDimension="7" SecondDimension="0">
				<AVal Row="1">2</AVal>
				<AVal Row="2">2</AVal>
				<AVal Row="3">2</AVal>
				<AVal Row="4">2</AVal>
				<AVal Row="5">2</AVal>
				<AVal Row="6">2</AVal>
				<AVal Row="7">2</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="iZoneOpening">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Integer>
		<Integer Name="i">
			<Description><![CDATA["i"]]></Description>
			<Value>0</Value>
		</Integer>
		<Integer Name="iAssemblageType">
			<Description><![CDATA["Horizontal/vertical etc"]]></Description>
			<Value>0</Value>
		</Integer>
		<Angle Name="aTiltS">
			<Description><![CDATA["Opening of top/bottom hung windows"]]></Description>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">0</AVal>
			</ArrayValues>
		</Angle>
		<Integer Name="Zone~">
			<Description><![CDATA["iZonePointer"]]></Description>
			<Value>1</Value>
		</Integer>
		<Length Name="xMullionPos">
			<Description><![CDATA[""]]></Description>
			<ArrayValues FirstDimension="10" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
				<AVal Row="9">0</AVal>
				<AVal Row="10">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="xMullionMin">
			<Description><![CDATA[""]]></Description>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="xMullionMax">
			<Description><![CDATA[""]]></Description>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="iMullionType">
			<Description><![CDATA[""]]></Description>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
			</ArrayValues>
		</Integer>
		<Length Name="iMullionColor">
			<Description><![CDATA[""]]></Description>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="iOpeningTypeS">
			<Description><![CDATA[""]]></Description>
			<ArrayValues FirstDimension="2" SecondDimension="0">
				<AVal Row="1">3</AVal>
				<AVal Row="2">0</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="iMullionPointer">
			<Description><![CDATA["1"]]></Description>
			<Value>1</Value>
		</Integer>
		<Integer Name="UnID">
			<Description><![CDATA["1"]]></Description>
			<Value>1</Value>
		</Integer>
		<Integer Name="iZoneToDrawIn2D">
			<Description><![CDATA["iZoneToDrawIn2D"]]></Description>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">0</AVal>
			</ArrayValues>
		</Integer>
		<Boolean Name="Watchdog">
			<Description><![CDATA["Just to avoid infinite calls"]]></Description>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">0</AVal>
			</ArrayValues>
		</Boolean>
		<Boolean Name="bOplines2d">
			<Description><![CDATA["bOplines2d"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Integer Name="iInwardsOpening">
			<Description><![CDATA["1 if opens inwards, -1 if outwards"]]></Description>
			<Value>1</Value>
		</Integer>
		<Length Name="xHinge">
			<Description><![CDATA[""]]></Description>
			<Value>-0.011</Value>
		</Length>
		<Length Name="yHinge">
			<Description><![CDATA[""]]></Description>
			<Value>-0.0858</Value>
		</Length>
		<Boolean Name="bBottomhung">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>
		<Integer Name="iSystem">
			<Description><![CDATA["System type"]]></Description>
			<Value>0</Value>
		</Integer>
		<Boolean Name="bDrawFrame">
			<Description><![CDATA["If False, don't draw frame around sash (for compositges)"]]></Description>
			<Value>1</Value>
		</Boolean>
		<Integer Name="iSelectableProfiles">
			<Description><![CDATA["Array for selectable profiles"]]></Description>
			<ArrayValues FirstDimension="11" SecondDimension="4">
				<AVal Column="1" Row="1">30000</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">0</AVal>
				<AVal Column="4" Row="1">0</AVal>
				<AVal Column="1" Row="2">30001</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="3" Row="2">0</AVal>
				<AVal Column="4" Row="2">0</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="3" Row="3">0</AVal>
				<AVal Column="4" Row="3">0</AVal>
				<AVal Column="1" Row="4">30002</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="3" Row="4">0</AVal>
				<AVal Column="4" Row="4">0</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">0</AVal>
				<AVal Column="3" Row="5">0</AVal>
				<AVal Column="4" Row="5">0</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">0</AVal>
				<AVal Column="3" Row="6">0</AVal>
				<AVal Column="4" Row="6">0</AVal>
				<AVal Column="1" Row="7">30003</AVal>
				<AVal Column="2" Row="7">0</AVal>
				<AVal Column="3" Row="7">0</AVal>
				<AVal Column="4" Row="7">0</AVal>
				<AVal Column="1" Row="8">0</AVal>
				<AVal Column="2" Row="8">0</AVal>
				<AVal Column="3" Row="8">0</AVal>
				<AVal Column="4" Row="8">0</AVal>
				<AVal Column="1" Row="9">30009</AVal>
				<AVal Column="2" Row="9">0</AVal>
				<AVal Column="3" Row="9">0</AVal>
				<AVal Column="4" Row="9">0</AVal>
				<AVal Column="1" Row="10">0</AVal>
				<AVal Column="2" Row="10">0</AVal>
				<AVal Column="3" Row="10">0</AVal>
				<AVal Column="4" Row="10">0</AVal>
				<AVal Column="1" Row="11">0</AVal>
				<AVal Column="2" Row="11">0</AVal>
				<AVal Column="3" Row="11">0</AVal>
				<AVal Column="4" Row="11">0</AVal>
			</ArrayValues>
		</Integer>
		<Length Name="FirstOffsets">
			<Description><![CDATA["First (left/bottom) side offsets for zones"]]></Description>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="SecondOffsets">
			<Description><![CDATA["Second (right/top) side offsets for zones"]]></Description>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="leafDLower">
			<Description><![CDATA["Leaf Lower dist from the frame outer"]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="leafDUpper">
			<Description><![CDATA["Leaf Upper dist from the frame outer"]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="leafDLeft">
			<Description><![CDATA["Leaf Left dist from the frame outer"]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="leafDRight">
			<Description><![CDATA["Leaf Right dist from the frame outer"]]></Description>
			<Value>0</Value>
		</Length>
		<Boolean Name="bDoor">
			<Description><![CDATA["Is it a door?"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="isDoor">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>
		<Length Name="xDiff">
			<Description><![CDATA["Mullion sizes"]]></Description>
			<ArrayValues FirstDimension="9" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
				<AVal Row="9">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="OuterDiff1">
			<Description><![CDATA["Mullion outer profiles length difference, 1st side"]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="OuterDiff2">
			<Description><![CDATA["Mullion outer profiles length difference, 2nd side"]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="InnerDiff1">
			<Description><![CDATA["Mullion inner profiles length difference, 1st side"]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="InnerDiff2">
			<Description><![CDATA["Mullion inner profiles length difference, 2nd side"]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="yProf1">
			<Description><![CDATA["Mullion outer profiles length difference, 1st side"]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="yProf2">
			<Description><![CDATA["Mullion outer profiles length difference, 2d side"]]></Description>
			<Value>0</Value>
		</Length>

		<!-- Subtype_parameters: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="Subtype_parameters">
			<Description><![CDATA["Subtype parameters"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
		</Title>
		<Integer Name="iArray">
			<Description><![CDATA["Integers' extendable array"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="2" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0</AVal>
			</ArrayValues>
		</Integer>
		<Length Name="rArray">
			<Description><![CDATA["Floats' extendable array"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="2" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0</AVal>
			</ArrayValues>
		</Length>
		<String Name="sArray">
			<Description><![CDATA["Strings' extendable array"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="2" SecondDimension="2">
				<AVal Column="1" Row="1"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="1"><![CDATA[""]]></AVal>
				<AVal Column="1" Row="2"><![CDATA[""]]></AVal>
				<AVal Column="2" Row="2"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<Length Name="xOpening">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Length>
		<Integer Name="iProfileT">
			<Description><![CDATA["Profile position, like FRAME, SASH"]]></Description>
			<Value>0</Value>
		</Integer>
		<Length Name="xHandle">
			<Description><![CDATA[""]]></Description>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">0.993</AVal>
			</ArrayValues>
		</Length>
		<Length Name="xOpeningS3D">
			<Description><![CDATA["3D opening"]]></Description>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="xOpeningS2D">
			<Description><![CDATA["2D opening"]]></Description>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="xZoneWidth">
			<Description><![CDATA[""]]></Description>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="gs_frame_width">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="gs_frame_thk">
			<Description><![CDATA[""]]></Description>
			<Value>0.099</Value>
		</Length>
		<Boolean Name="bPanicBar">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>
		<Length Name="xxx">
			<Description><![CDATA[""]]></Description>
			<Value>1.403584</Value>
		</Length>
		<Integer Name="iDesignVariant">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Integer>
		<Integer Name="iDoorOption">
			<Description><![CDATA["(Plinth/Miter/Panel)"]]></Description>
			<Value>1</Value>
		</Integer>
		<Length Name="frame_offset">
			<Description><![CDATA[""]]></Description>
			<Value>0.1088</Value>
		</Length>
		<Length Name="zGlassThk">
			<Description><![CDATA[""]]></Description>
			<Value>0.024</Value>
		</Length>
		<Boolean Name="isCProfileAtBottom">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="or_bOplines2D">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>
		<Integer Name="iDetLevel2D">
			<Description><![CDATA[""]]></Description>
			<Value>10</Value>
		</Integer>
		<Integer Name="iDetLevel3D">
			<Description><![CDATA[""]]></Description>
			<Value>10</Value>
		</Integer>

		<!-- WMCC: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="WMCC">
			<Description><![CDATA["WMCC"]]></Description>
		</Title>
		<Length Name="xMinimalHandleDistFromCorners">
			<Description><![CDATA["Handle minimal pos from corners"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.3</Value>
		</Length>
		<Length Name="yGlazingBead">
			<Description><![CDATA["Handle minimal pos from corners"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.014</Value>
		</Length>
		<Length Name="yGlazingBeadDiff">
			<Description><![CDATA["Difference between glazing bead border and glass border (positive = glazing bead is the outer)"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.01</Value>
		</Length>
		<Length Name="yGlazingIODiff">
			<Description><![CDATA["Visible glazing side in/out difference, glazing bead to glazing perpendicular planes are not the same, positive means inner (glazing bead) is smaller"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="OuterOffset">
			<Description><![CDATA["OuterD1 - LeafDLeft, mullion outer profile is shorter than LeafBoxSize by (2 times) this length"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.019</Value>
		</Length>
		<Length Name="InnerOffset">
			<Description><![CDATA["InnerD1 - LeafDLeft, mullion inner profile is shorter than LeafBoxSize by (2 times) this length"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="FrameSashGap">
			<Description><![CDATA["Visible gap between sash and frame "]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.0105</Value>
		</Length>
		<Length Name="zMoveLeaf">
			<Description><![CDATA["Leaf is outwards of the frame plane by this distance "]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>-0.0231</Value>
		</Length>
		<Length Name="zOffset">
			<Description><![CDATA["Glass panel offset regarding to leaf; positive inwards"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.0246</Value>
		</Length>
		<Length Name="zGum">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.0083</Value>
		</Length>
		<Length Name="yHandleOffset">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.0322</Value>
		</Length>
		<Length Name="xOverLapRight">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="xOverLapLeft">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_fw_lower">
			<Description><![CDATA["Lower frame (plinth) width"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
	</Parameters>
</ParamSection>

</Symbol>
