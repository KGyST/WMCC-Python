<Symbol IsArchivable="no" IsPlaceable="no" MainGUID="18B05FDA-175A-4F3D-8FDC-89F38791B3F4" MigrationValue="Normal" Owner="1196638531" Signature="1196644685" Version="34">
<Ancestry SectVersion="1" SectionFlags="0" SubIdent="0" Template="no">
	<MainGUID>F938E33A-329D-4A36-BE3E-85E126820996</MainGUID>
	<MainGUID>103E8D2C-8230-42E1-9597-46F84CCE28C0</MainGUID>
	<MainGUID>6ACDA889-69B2-4EC5-936C-CB1DA7032A92</MainGUID>
	<MainGUID>F6AE9687-2BC7-4D47-88C9-8F793E1DE2D6</MainGUID>
</Ancestry>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_3D SectVersion="20" SectionFlags="0" SubIdent="0"><![CDATA[

! Contact person: <NJ>

! ==============================================================================
! This macro draws the Casing
! ------------------------------------------------------------------------------
! Input parameters:
! Geometry ---------------------------------------------------------------------
!	A:						wallhole width (length) (Obsolete)
!	B:						wallhole height (length)
!	refWidth:				reference width in curved walls (length)
!	leftWidth:				wallhole's side distance from the origin at the left side (length)
!	rightWidth:				wallhole's side distance from the origin at the right side (length)
!	AC_Hole_Position_Angle:	Position angle of the window in a curved wall
!	offsY:					for positioning 3D along y (length)
! Functions --------------------------------------------------------------------
!	gs_IsCurved:			Does the window follow the curvature of the wall? (0 / 1)
!	iWindowShape:			Shape of the window (integer)
!								0 = rectangular (default)
!								1 = arched
!							Note: only the rectangular shape can be a Corner Window
!	archHeight:				Height of the arc (length)
!	nArchResolution:		Arc resolution for arched windows (integer)
!								if nArchResolution < 3 then WALL_RESOL used instead
! Reveal -----------------------------------------------------------------------
!	iRevealType:
!	gs_reveal_left_angle:
!	gs_reveal_right_angle:
! Corner Function --------------------------------------------------------------
!	bLeftCornerFunction:		Turn macro in Corner Window mode at the left side (0 / 1)
!	leftCornerAngle:		Angle between connected walls in case of Corner Window (angle)
!	leftConnWallThk:		Thickness of the connected wall in case of Corner Window (length)
!	bRightCornerFunction:	Turn macro in Corner Window mode at the right side (0 / 1)
!	rightCornerAngle:		Angle between connected walls in case of Corner Window (angle)
!	rightConnWallThk:		Thickness of the connected wall in case of Corner Window (length)
! Oversize ---------------------------------------------------------------------
!	gs_left_oversize:		Left opening oversize (length)
!	gs_right_oversize:		Right opening oversize (length)
!	gs_upper_oversize:		Upper opening oversize (length)
!	gs_lower_oversize:		Lower opening oversize (length)
! Casing -----------------------------------------------------------------------
!	gs_trim_inside:
!	gs_trim_outside:
!	gs_trim_width_in:		Width of inside Trim. (length)
!	gs_trim_width_out:		Width of outside Trim. (length)
!	gs_trim_offs_in:		Offset of Casing inside. (length)
!	gs_trim_offs_out:		Offset of Casing outside. (length)
!	gs_trim_thk_in:			Thickness of inside Trim. (length)
!	gs_trim_thk_out:		Thickness of outside Trim. (length)
!	gs_tw_left_in:			Width of inside casing on the left (length)
!	gs_tw_right_in:			Width of inside casing on the right (length)
!	gs_tw_top_in:			Width of inside head casing (length)
!	gs_tw_bottom_in:		Width of inside casing on the bottom (length)
!	gs_tw_left_out:			Width of outside casing on the left (length)
!	gs_tw_right_out:		Width of outside casing on the right (length)
!	gs_tw_top_out:			Width of outside head casing (length)
!	gs_tw_bottom_out:		Width of outside casing on the bottom (length)
! Sill -------------------------------------------------------------------------
!	iSillType:				Identifies the type of the Sill.
!								(integer; 1 = Standard Sill, 2 = Brick Sill, 3 = Stone Sill, 4 = Ceramic Sill)
!								(5 = Eternite Sill, 6 = Concrete Tub, 7 = Aluminum Sill)
!	gs_board_thk:			Thickness of the Board. (length)
! Ganging ----------------------------------------------------------------------
!	gs_stack_left:			Align to door/window on left side (0 / 1)
!	gs_stack_right:			Align to door/window on right side (0 / 1)
!	gs_stack_top:			Align to door/window on upper side (0 / 1)
!	gs_stack_bottom:		Align to door/window on bottom side (0 / 1)
! 2D Representation ------------------------------------------------------------
!	gs_trim_pen_cont:		Cotour pen of the cutted Trim.
!								If it is zero then SYMB_FILL_PEN defines the cutted contour pen. (pen)
!	gs_trim_fill_in:		Type of the fill on the inside Trim. (fill type)
!	gs_trim_pen_fg_in:		Fill pen on the inside Trim. (pen)
!	gs_trim_pen_bg_in:		Fill background pen on the inside Trim. (pen)
!	gs_trim_fill_out:		Type of the fill on the outside Trim. (fill type)
!	gs_trim_pen_fg_out:		Fill pen on the outside Trim. (pen)
!	gs_trim_pen_bg_out:		Fill background pen on the outside Trim. (pen)
! 3D Representation ------------------------------------------------------------
!	lod3D:					Level of detail. Not used. (integer)
!	gs_frame_pen:			Drawing pen of 3D. (pen)
! Materials --------------------------------------------------------------------
!	gs_trim_in_mat:			Inside trim material (material)
!	gs_trim_out_mat:		Outside trim material (material)
!
! Related Global Variables:
!	GLOB_SCRIPT_TYPE
!	GLOB_CONTEXT
!	WALL_THICKNESS
!	WALL_INCL
!	WALL_RESOL
!	WIDO_FRAME_THICKNESS
!	WIDO_SILL
!	WIDO_ORIG_DIST
!	WIDO_REVEAL_SIDE
!	SYMB_MIRRORED
!	SYMB_ROTANGLE
!	SYMB_FILL
!	SYMB_SECT_PEN
!	SYMB_FILL_PEN
!	SYMB_FBGD_PEN
! ==============================================================================

if	iWindowShape <> SHAPE_RECTANGULAR &\
	iWindowShape <> SHAPE_ARCHED &\
	iWindowShape <> SHAPE_ELLIPSEARCH &\
	iWindowShape <> SHAPE_T &\
	iWindowShape <> SHAPE_HALF_T_LEFT &\
	iWindowShape <> SHAPE_ARCHED_T &\
	iWindowShape <> SHAPE_ARCHED_HALF_T_LEFT &\
	iWindowShape <> SHAPE_HALF_T_RIGHT &\
	iWindowShape <> SHAPE_ARCHED_HALF_T_RIGHT then end

if lod3D = 0 then end
if (bInsideCasingNotAvailableByReveal |\
	bInsideCasingNotAvailableByWallType |\
	bInsideCasingNotAvailableByFrameStyle) then
	bDrawInsideTrim  = 0
endif
if (bOutsideCasingNotAvailableByReveal |\
	bOutsideCasingNotAvailableByFrameStyle) then
	bDrawOutsideTrim = 0
endif
if not(bDrawInsideTrim | bDrawOutsideTrim) then end

bShapeEnablesStraightBottomTrim = (	iWindowShape = SHAPE_RECTANGULAR | \
									iWindowShape = SHAPE_ARCHED | \
									iWindowShape = SHAPE_ELLIPSEARCH )
bShapeEnablesStraightLeftTrim   = (	iWindowShape = SHAPE_RECTANGULAR | \
									iWindowShape = SHAPE_ARCHED | \
									iWindowShape = SHAPE_ELLIPSEARCH | \
									iWindowShape = SHAPE_T | \
									iWindowShape = SHAPE_HALF_T_LEFT | \
									iWindowShape = SHAPE_HALF_T_RIGHT | \
									iWindowShape = SHAPE_ARCHED_T | \
									iWindowShape = SHAPE_ARCHED_HALF_T_LEFT | \
									iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT )
bShapeEnablesStraightRightTrim  = (	iWindowShape = SHAPE_RECTANGULAR | \
									iWindowShape = SHAPE_ARCHED | \
									iWindowShape = SHAPE_ELLIPSEARCH | \
									iWindowShape = SHAPE_T | \
									iWindowShape = SHAPE_HALF_T_LEFT | \
									iWindowShape = SHAPE_HALF_T_RIGHT | \
									iWindowShape = SHAPE_ARCHED_T | \
									iWindowShape = SHAPE_ARCHED_HALF_T_LEFT | \
									iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT )
bShapeEnablesStraightTopTrim    = (	iWindowShape = SHAPE_RECTANGULAR | \
									iWindowShape = SHAPE_T | \
									iWindowShape = SHAPE_HALF_T_LEFT | \
									iWindowShape = SHAPE_HALF_T_RIGHT )
bShapeEnablesArchedTopTrim 		= (	iWindowShape = SHAPE_ARCHED | \
									iWindowShape = SHAPE_ARCHED_T | \
									iWindowShape = SHAPE_ARCHED_HALF_T_LEFT | \
									iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT )

! === wido jamb values =========================================================

widoLeftJamb	= gs_reveal_left
widoRightJamb	= gs_reveal_right


! === Initialized variables ====================================================[

archTrimDiff	= 0
bHalfCircle		= 0
pocketThkLeft	= 0
pocketThkRight	= 0

! ]=== End of initialized variables ============================================


! Save the current parameter buffer ============================================

dim savedQueueValues[]
call "SaveQueue_WMCC" parameters returned_parameters savedQueueValues


gs_trim_pen_cont_out	= gs_trim_pen_cont
gs_trim_pen_cont_in		= gs_trim_pen_cont

if gs_trim_fill_in		< 1 then gs_trim_fill_in	= SYMB_FILL
if gs_trim_pen_bg_in	< 1 then gs_trim_pen_bg_in	= SYMB_FBGD_PEN
if gs_trim_pen_fg_in	< 1 then gs_trim_pen_fg_in	= SYMB_FILL_PEN
if gs_trim_fill_out		< 1 then gs_trim_fill_out	= SYMB_FILL
if gs_trim_pen_bg_out	< 1 then gs_trim_pen_bg_out	= SYMB_FBGD_PEN
if gs_trim_pen_fg_out	< 1 then gs_trim_pen_fg_out	= SYMB_FILL_PEN

if AC_HoleSideMaterial then
	if WIDO_REVEAL_SIDE then
		matWallOut	= WALL_MAT_A
		matWallIn	= WALL_MAT_B
	else
		matWallOut	= WALL_MAT_B
		matWallIn	= WALL_MAT_A
	endif
else
	matWallOut	= WALL_MAT_EDGE
	matWallIn	= WALL_MAT_EDGE
endif

muly -1
if WIDO_REVEAL_SIDE then
	mulz -1
	addz -WIDO_FRAME_THICKNESS
endif

! === Window Shape related definitions ========================================[

if nArchResolution < 3 then nArchResolution = WALL_RESOL

if	bShapeEnablesArchedTopTrim then
	if archHeight < EPS then
		if iWindowShape = SHAPE_ARCHED				then iWindowShape = SHAPE_RECTANGULAR
		if iWindowShape = SHAPE_ARCHED_T			then iWindowShape = SHAPE_T
		if iWindowShape = SHAPE_ARCHED_HALF_T_LEFT	then iWindowShape = SHAPE_HALF_T_LEFT
		if iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT	then iWindowShape = SHAPE_HALF_T_RIGHT
	else
		if archHeight > ((leftWidth + rightWidth) / 2 - EPS) then
			archHeight = (leftWidth + rightWidth) / 2
			arcR = archHeight
			bHalfCircle = 1
		else
			arcR = ((leftWidth + rightWidth) / 2) / sin(2 * atn((archHeight) / ((leftWidth + rightWidth) / 2)))
			bHalfCircle = 0
		endif
	endif
endif

if iWindowShape = SHAPE_ELLIPSEARCH then
	openingWidth = (leftWidth + rightWidth - tolerOffsetLeftIn - tolerOffsetRightIn)

	middleRadiusEllips = (openingWidth * openingWidth / 4 - openingWidth * smallRadiusEllips + archHeight * archHeight) / (2 * archHeight - 2 * smallRadiusEllips)

	alphaSide = atn ((middleRadiusEllips - archHeight) / (openingWidth / 2 - smallRadiusEllips))
	alphaMiddle = (90 - alphaSide) * 2
endif

if	iWindowShape <> SHAPE_ARCHED &\
	iWindowShape <> SHAPE_ELLIPSEARCH &\
	iWindowShape <> SHAPE_ARCHED_T &\
	iWindowShape <> SHAPE_ARCHED_HALF_T_LEFT &\
	iWindowShape <> SHAPE_ARCHED_HALF_T_RIGHT then archHeight = 0

! ]=== Window Shape related definitions ========================================


! ==============================================================================
! Common Calculations for Trims
! ==============================================================================

bHolePosSign = (SYMB_MIRRORED exor (SYMB_ROTANGLE > EPS) exor (AC_Hole_Position_Angle < 0))
iHolePosSign = (not(bHolePosSign) - bHolePosSign)

if bLeftCornerFunction then
	! --- Push left side trim ---
	beta_left = atn ((leftConnWallThk * sin(leftCornerAngle)) / (WALL_THICKNESS + leftConnWallThk * cos(leftCornerAngle)))

	if leftCornerAngle > 180 then
		overSizeLeft = max (0, WALL_THICKNESS / tan(360 - leftCornerAngle + beta_left) + WIDO_SILL / tan(leftCornerAngle / 2))
	else
		overSizeLeft = (WIDO_FRAME_THICKNESS + WIDO_SILL) * lx + max (0, WALL_THICKNESS * tan(leftCornerAngle - beta_left - 90))
	endif
	overSizeLeft = overSizeLeft + abs(gs_trim_thk_in / tan(leftCornerAngle / 2)) + gs_tw_left_out + gs_tw_left_in + 0.1
	overSizeLeftOut = overSizeLeft
	overSizeLeftIn 	= overSizeLeft
endif


if bRightCornerFunction then
	! --- Push right side trim ---
	beta = atn ((rightConnWallThk * sin(rightCornerAngle)) / (WALL_THICKNESS + rightConnWallThk * cos(rightCornerAngle)))

	if rightCornerAngle > 180 then
		overSizeRight = max (0, WALL_THICKNESS / tan(360 - rightCornerAngle + beta) + WIDO_SILL / tan(rightCornerAngle / 2))
	else
		overSizeRight = (WIDO_FRAME_THICKNESS + WIDO_SILL) * rx + max (0, WALL_THICKNESS * tan(rightCornerAngle - beta - 90))
	endif
	overSizeRight = overSizeRight + abs(gs_trim_thk_in / tan(rightCornerAngle / 2)) + gs_tw_right_out + gs_tw_right_in + 0.1
	overSizeRightOut = overSizeRight
	overSizeRightIn	 = overSizeRight
endif


if gs_stack_top then
	overSizeTop = gs_upper_oversize
	overSizeTopIn = gs_upper_oversize
else
	overSizeTop = 0
	overSizeTopIn = 0 - widoInnerTopJamb + sfty
endif

if gs_stack_bottom then
	overSizeBottom = gs_lower_oversize
	overSizeBottomIn = gs_lower_oversize
else
	overSizeBottom = 0
	overSizeBottomIn = -not(bDrawBoard) * widoInnerBottomJamb + sfby - bDrawBoard * boardBottom
endif

if gs_trim_show_cover_in then
	gs_trim_jambext_nosing_in = 0
endif
if gs_trim_show_cover_out then
	gs_trim_jambext_nosing_out = 0
endif


resol WALL_RESOL

bCutWall = not (GLOB_CONTEXT > 40 & GLOB_CONTEXT < 50)

bDrawLeftTrimatGangingIn	= not(bLeftCornerFunction) & bShapeEnablesStraightLeftTrim & gs_stack_left & gs_trim_stack_left
bDrawRightTrimatGangingIn	= not(bRightCornerFunction) & bShapeEnablesStraightRightTrim & gs_stack_right & gs_trim_stack_right
bDrawBottTrimatGangingIn	= isWindow & bShapeEnablesStraightBottomTrim & abs(tolerOffsStackCasLowerIn + trinB - gs_trim_offs_in) > EPS & gs_stack_bottom & gs_trim_stack_bottom
bDrawTopTrimatGangingIn		= bShapeEnablesStraightTopTrim & gs_stack_top & abs(-tolerOffsStackCasUpperIn - trinT + gs_trim_offs_in) > EPS & gs_trim_stack_top

bDrawLeftTrimatGangingOut	= not(bLeftCornerFunction) & bShapeEnablesStraightLeftTrim & gs_stack_left & gs_trim_stack_left
bDrawRightTrimatGangingOut	= not(bRightCornerFunction) & bShapeEnablesStraightRightTrim & gs_stack_right & gs_trim_stack_right
bDrawBottTrimatGangingOut	= bShapeEnablesStraightBottomTrim & gs_stack_bottom & ABS(tolerOffsStackCasLowerOut + trim_offs_out_modify - gs_trim_offs_out)>EPS & (iSillType < 2 | not(bDrawBoard)) & gs_trim_stack_bottom
bDrawTopTrimatGangingOut	= bShapeEnablesStraightTopTrim & gs_stack_top & ABS(-tolerOffsStackCasUpperOut - trim_offs_out_modify + gs_trim_offs_out)>EPS & gs_trim_stack_top

bGangedCasingonFrame = abs(WIDO_FRAME_THICKNESS - WALL_THICKNESS) > EPS

! ==============================================================================
!	Draw Trims
! ==============================================================================

if (gs_trimtype_out_int = CASING_COMPLEX) then
	if bArchitraveCapital then
		if	(iArchitraveCapitalType = ARCH_CAPITAL_SQUARE_ONSIDE |\
			 iArchitraveCapitalType = ARCH_CAPITAL_SQUARE_NEXTSIDE) then

			_offsetTop		= 0.01
			_thickBracket	= 0.06
		endif

		if	(iArchitraveCapitalType = ARCH_CAPITAL_DECOR_ONSIDE |\
			 iArchitraveCapitalType = ARCH_CAPITAL_DECOR_NEXTSIDE) then

			_offsetTop		= 0.01
			_thickBracket	= 0.07
		endif

!!!		if iArchitraveCapitalType = 0 then
!!!			_offsetTop		= 0.021
!!!			_thickBracket	= 0.039
!!!		endif
	else
		_offsetTop		= 0.01
		_thickBracket	= 0.035
	endif
endif

if gs_stack_top then
	overSizeTop = gs_upper_oversize
else
	overSizeTop = 0
endif

if gs_stack_bottom then
	overSizeBottom = gs_lower_oversize
else
	if bDrawSill then
		overSizeBottom = -sillBottomOutside + widoThresDepth
	else
		overSizeBottom = - widoThresDepth * not(isWindow)
	endif
endif
overSizeBottomLeft	= overSizeBottom
overSizeBottomRight	= overSizeBottom
if	(bPShapedLeftOpening & not(bDrawLeftSLSill))		| \
	(bTShapedOpening & gs_sidelight_parapet_hgt_left < EPS)		| \
	(bPShapedRightOpening & iWindowShape <> SHAPE_T)		then overSizeBottomLeft = 0
if	(bPShapedRightOpening & not(bDrawRightSLSill))		| \
	(bTShapedOpening & gs_sidelight_parapet_hgt_right < EPS)	| \
	(bPShapedLeftOpening & iWindowShape <> SHAPE_T)			then overSizeBottomRight = 0

! Calculate overhangs to cutting of top and bottom casing in case of corner opening

if gs_trim_show_cover_in then
	casingOverhangIn = gs_trim_thk_in
else
	casingOverhangIn = gs_trim_jambext_nosing_in
endif
if gs_trim_show_cover_out then
	if (gs_trimtype_out_int = CASING_COMPLEX) & (iCasingHeadTypeOut <> CASING_HEAD_RECT) then
		casingOverhangOut = gs_trim_thk_out + _thickBracket + _offsetTop
	else
		casingOverhangOut = gs_trim_thk_out
	endif
else
	casingOverhangOut = gs_trim_jambext_nosing_out
endif


bHasCasingSetBackIn	 = (casingSetBackOnSides_in  > EPS & casingSetBackOnSides_in  < WALL_THICKNESS - (WIDO_SILL + WIDO_FRAME_THICKNESS))
bHasCasingSetBackOut = (casingSetBackOnSides_out > EPS & casingSetBackOnSides_out < WIDO_SILL)

bShowEdgesAtFrame = (not(bDrawOutsideTrim & bDrawInsideTrim  ) |\
					 abs(gs_trim_width_in - gs_trim_width_out) > EPS |\
					 (gs_trim_in_mat <> gs_trim_out_mat) |\
					 abs(WIDO_FRAME_THICKNESS) > EPS |\
					 (bHasCasingSetBackIn | bHasCasingSetBackOut))

! ==============================================================================
! Cut on Board side
! ==============================================================================

numCuts = 0

material gs_trim_in_mat

if bRightCornerFunction then

	! --- Cut right side in case of Corner Window ---

	if bFitModeRight then
		add rightCwDx + rightCwDx2 + rightWidth - (WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS + casingOverhangIn) * rx, 0, WALL_THICKNESS - WIDO_SILL + casingOverhangIn
		rotx 90

!!!		maxDist = WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS + casingOverhangIn + EPS
		maxDist = WALL_THICKNESS - min(0, WIDO_SILL) + casingOverhangOut + casingOverhangIn

		if abs(maxDist) > EPS then
			cutpolya 4, 2, 0,
				0, 0, 10,
				maxDist / tan(rightCornerAngle / 2), -maxDist, 10,
				10 * A, -maxDist, 8,
				10 * A, 0, 8

			numCuts = numCuts + 1
		endif
		del 2
	else
		rotx 90

		if WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS < -EPS then
			cutpolya 4, 2, 0,
				10 * A,																									WALL_THICKNESS - WIDO_SILL - EPS,	8,
				rightCwDx + rightCwDx2 + rightWidth - (WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS - EPS) * rx,	WALL_THICKNESS - WIDO_SILL - EPS,	10,
				rightCwDx + rightWidth,																					WIDO_FRAME_THICKNESS,				8,
				10 * A,																									WIDO_FRAME_THICKNESS,				8
		else
			cutpolya 5, 2, 0,
				10 * A, 																											WALL_THICKNESS - WIDO_SILL + casingOverhangIn,				8,
				rightCwDx + rightCwDx2 + rightWidth - (WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS + casingOverhangIn) * rx,	WALL_THICKNESS - WIDO_SILL + casingOverhangIn,				10,
				rightCwDx + rightWidth - rightCwDx2 * cos(rightCornerAngle),														WIDO_FRAME_THICKNESS + rightCwDx2 * sin(rightCornerAngle),	8,
				rightCwDx + rightWidth,																								WIDO_FRAME_THICKNESS,										8,
				10 * A,																												WIDO_FRAME_THICKNESS,										8
		endif

		numCuts = numCuts + 1
		del 1
	endif
endif

if bLeftCornerFunction then

	! --- Cut left side in case of Corner Window ---

	if bFitModeLeft then
		add -leftCwDx - leftCwDx2 - leftWidth + (WALL_THICKNESS - WIDO_SILL- WIDO_FRAME_THICKNESS + casingOverhangIn) * lx, 0, WALL_THICKNESS - WIDO_SILL + casingOverhangIn
		rotx 90

!!!		maxDist = WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS + casingOverhangIn + EPS
		maxDist = WALL_THICKNESS - min(0, WIDO_SILL) + casingOverhangOut + casingOverhangIn

		if abs(maxDist) > EPS then
			cutpolya 4, 1, 0,
				0, 0, 10,
				-maxDist / tan(leftCornerAngle / 2), -maxDist, 10,
				-10 * A, -maxDist, 8,
				-10 * A, 0, 8

			numCuts = numCuts + 1
		endif
		del 2
	else

		rotx 90

		if WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS < -EPS then
			cutpolya 4, 1, 0,
				-10 * A, 																							WALL_THICKNESS - WIDO_SILL - EPS,	8,
				-leftCwDx - leftCwDx2 - leftWidth + (WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS - EPS) * lx,	WALL_THICKNESS - WIDO_SILL - EPS,	10,
				-leftCwDx - leftWidth,																				WIDO_FRAME_THICKNESS,				8,
				-10 * A,																							WIDO_FRAME_THICKNESS,				8
		else
			cutpolya 5, 1, 0,
				-10 * A, 																										WALL_THICKNESS - WIDO_SILL + casingOverhangIn,				8,
				-leftCwDx - leftCwDx2 - leftWidth + (WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS + casingOverhangIn) * lx,WALL_THICKNESS - WIDO_SILL + casingOverhangIn,				10,
				-leftCwDx - leftWidth + leftCwDx2 * cos(leftCornerAngle),														WIDO_FRAME_THICKNESS + leftCwDx2 * sin(leftCornerAngle),	8,
				-leftCwDx - leftWidth,																							WIDO_FRAME_THICKNESS,										8,
				-10 * A,																										WIDO_FRAME_THICKNESS,										8
		endif

		numCuts = numCuts + 1
		del 1
	endif
endif

! --- Casing Set Back on Sides ---
if bHasCasingSetBackIn then
	add 0, -gs_trim_width_in * isWindow, casingSetBackOnSides_in + WIDO_FRAME_THICKNESS
	rotx 90

	material gs_trim_in_mat
	cutform 4, 1, 1+2,
		0, 0, 1, B*2,
		lengthCasingSetback/2,	0,							1,
		lengthCasingSetback/2,	-casingSetBackOnSides_in,	1,
		-lengthCasingSetback/2,	-casingSetBackOnSides_in,	1,
		-lengthCasingSetback/2,	0,							1
	numCuts = numCuts + 1
	del 2
endif


! ==============================================================================
!	Draw Inside Trim
! ==============================================================================

if bDrawInsideTrim then

	material gs_trim_in_mat

	if	bPShapedLeftOpening & not(gs_trim_below_boardLeft)then

		add -boardRight_sL, -gs_sidelight_parapet_hgt_left - boardSideHeight + (gs_reveal_double_innerBottom_sL - gs_reveal_bottom), WIDO_FRAME_THICKNESS
		roty 90
		rotz -90

		cutform 4, 1, 2+16,
			0, 0, 1, EPS,
			0,0,15,
			-0.5 * tan(boardSideAngle), -0.5, 15,
			-0.5 * tan(boardSideAngle) - 0.5, -0.5, 15,
			-0.5 * tan(boardSideAngle) - 0.5, 0, 15
		numCuts = numCuts + 1
		del 3
	endif

	if	bPShapedRightOpening & not(gs_trim_below_boardRight) then

		add boardLeft_sR, -gs_sidelight_parapet_hgt_right - boardSideHeight + (gs_reveal_double_innerBottom_sR - gs_reveal_bottom), WIDO_FRAME_THICKNESS
		roty 90
		rotz -90
		mulz -1

		cutform 4, 1, 2+16,
			0, 0, 1, EPS,
			0,0,15,
			-0.5 * tan(boardSideAngle), -0.5, 15,
			-0.5 * tan(boardSideAngle) - 0.5, -0.5, 15,
			-0.5 * tan(boardSideAngle) - 0.5, 0, 15
		numCuts = numCuts + 1
		del 4
	endif

	if bBoardPlaneCut then
		add 0, -boardSideHeight, WIDO_FRAME_THICKNESS
		rotx -90 - boardSideAngle
		cutplane
		numCuts = numCuts + 1
		del 2
	endif

	if bThresholdBoardPlaneCut then
		add 0, -ThresholdBoardSideHeight, WIDO_FRAME_THICKNESS
		rotx -90
		cutplane
		numCuts = numCuts + 1
		del 2
	endif

	gosub 1000

endif


! ==============================================================================
!	Draw Apron
! ==============================================================================

if gs_apron then
	gosub 3000
endif

! ==============================================================================

for i = 1 to numCuts
	cutend
next i


! ==============================================================================
! Cut on Sill side
! ==============================================================================

numCuts = 0

material gs_trim_out_mat

if bRightCornerFunction then

	! --- Cut right side in case of Corner Window ---

	add rightCwDx + rightWidth + WIDO_FRAME_THICKNESS * rx, 0, 0
	rotx 90

	maxDist  = WIDO_SILL + casingOverhangOut

	if abs(maxDist) > EPS then
		cutpolya 4, 1, 0,
			0, 0, 8,
			maxDist / tan(rightCornerAngle / 2), -maxDist, 10,
			10 * A, -maxDist, 8,
			10 * A, 0, 8

		numCuts = numCuts + 1
	endif

	del 2
endif

if bLeftCornerFunction then

	! --- Cut left side in case of Corner Window ---

	add -leftCwDx - leftWidth - WIDO_FRAME_THICKNESS * lx, 0, 0
	rotx 90

	maxDist  = WIDO_SILL + casingOverhangOut

	if abs(maxDist) > EPS then
		cutpolya 4, 1, 0,
			0, 0, 8,
			-maxDist / tan(leftCornerAngle / 2), -maxDist, 10,
			-10 * A, -maxDist, 8,
			-10 * A, 0, 8

		numCuts = numCuts + 1
	endif

	del 2
endif

! --- Casing Set Back on Sides ---
if bHasCasingSetBackOut then
	add 0, -gs_trim_width_ou * isWindow, -casingSetBackOnSides_out
	rotx 90

	material gs_trim_out_mat
	cutform 4, 1, 1+2,
		0, 0, 1, B*2,
		lengthCasingSetback/2,	0,							1,
		lengthCasingSetback/2,	casingSetBackOnSides_out,	1,
		-lengthCasingSetback/2,	casingSetBackOnSides_out,	1,
		-lengthCasingSetback/2,	0,							1
	numCuts = numCuts + 1
	del 2
endif


! ==============================================================================
!	Draw Outside Trim
! ==============================================================================

if bDrawOutsideTrim then


	material gs_trim_out_mat

	if	bPShapedLeftOpening & not(gs_trim_below_sillLeft) then

		add -sillRight_sL, -gs_sidelight_parapet_hgt_left - sillBottom - sillSideHeight - (gs_reveal_bottom_sR - gs_reveal_bottom), 0
		roty 90
		rotz 90

		cutform 4, 1, 2+16,
			0, 0, 1, EPS,
			0,0,15,
			0.5 * tan(sillSideAngle), -0.5, 15,
			0.5 * tan(sillSideAngle) + 0.5, -0.5, 15,
			0.5 * tan(sillSideAngle) + 0.5, 0, 15
		numCuts = numCuts + 1
		del 3
	endif

	if	bPShapedRightOpening & not(gs_trim_below_sillRight) then

		add sillLeft_sR, -gs_sidelight_parapet_hgt_right - sillBottom - sillSideHeight - (gs_reveal_bottom_sR - gs_reveal_bottom), 0
		roty 90
		rotz 90
		mulz -1

		cutform 4, 1, 2+16,
			0, 0, 1, EPS,
			0,0,15,
			0.5 * tan(sillSideAngle), -0.5, 15,
			0.5 * tan(sillSideAngle) + 0.5, -0.5, 15,
			0.5 * tan(sillSideAngle) + 0.5, 0, 15
		numCuts = numCuts + 1
		del 4
	endif


	if bSillPlaneCut then
		if bDrawSill then
			add 0, -sillBottom-sillSideHeight, 0
			rotx -90 + sillSideAngle
			cutplane
			numCuts = numCuts + 1
			del 2
		endif
	endif

	if bThresholdSillPlaneCut then
		add 0, -ThresholdSillSideHeight, 0
		rotx -90
		cutplane
		numCuts = numCuts + 1
		del 2
	endif

	gosub 2000

endif

! ==============================================================================

for i = 1 to numCuts
	cutend
next i


! Restore the saved parameter buffer ===========================================

call "LoadQueue_WMCC" parameters savedQueueValues = savedQueueValues

! ==============================================================================
 end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
! ==============================================================================


1000:
! ==============================================================================
!	Draw Inside Trim
! ==============================================================================

	pen gs_frame_pen

	numCutsCornerColumn = 0

	if gs_corner_column then
		matTrim = gs_trim_in_mat

		material gs_trim_in_mat
		sect_fill gs_trim_fill_in, gs_trim_pen_bg_in, gs_trim_pen_fg_in, gs_trim_pen_cont_in

		gosub 100
	endif

	rotx 180

	! ===== Draw Trim Inside =====

	if not(curvedWall) | (curvedWall & gs_trim_atframe_in) then

		! ======================================
		! Inside Trim - Straight Walls
		! ======================================

		addz (-WALL_THICKNESS + WIDO_SILL) * not(gs_trim_atframe_in) - WIDO_FRAME_THICKNESS *gs_trim_atframe_in

		if bTelescopic then
			thk = WALL_THICKNESS
		else
			thk = WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS + gs_trim_jambext_nosing_in + WIDO_FRAME_THICKNESS * gs_sectgar
		endif
		wallIncl = iDir * WALL_INCL

		mask = 10 +\
				1 * bShowEdgesAtFrame +\
				4 * (gs_trim_offs_in > EPS | not(bShowJambExtension) | abs(WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS) < EPS | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS)

		if gs_trim_width_in > EPS & thk > EPS & bShowJambExtension & not(gs_trim_atframe_in) then

			matTrim = gs_trim_in_mat

			material gs_trim_in_mat
			sect_fill gs_trim_fill_in, gs_trim_pen_bg_in, gs_trim_pen_fg_in, gs_trim_pen_cont_in

			! ===== Inside Trim - Straight Walls - Jamb Extensions =====

			maxx = 0
			if abs(wallIncl) > EPS then maxx = abs(thk / tan(wallIncl))		! Maximal distance from origin where the sprism doesn't intersects itself

			addz thk - gs_trim_jambext_nosing_in
			mulz -1

			leftNosingDx   = gs_trim_jambext_nosing_in * tan(gs_reveal_left_angle)   * not(gs_stack_left)
			rightNosingDx  = gs_trim_jambext_nosing_in * tan(gs_reveal_right_angle)  * not(gs_stack_right)
			topNosingDx    = gs_trim_jambext_nosing_in * tan(gs_reveal_top_angle)    * not(gs_stack_top)
			bottomNosingDx = gs_trim_jambext_nosing_in * tan(gs_reveal_bottom_angle) * not(gs_stack_bottom)

			if not(	gs_stack_left | \
					gs_stack_right | \
					gs_stack_top | \
					gs_stack_bottom | \
					bDrawBoard | \
					bLeftCornerFunction | \
					bRightCornerFunction | \
					iWindowShape = SHAPE_ARCHED | \
					iWindowShape = SHAPE_ARCHED_T | \
					iWindowShape = SHAPE_ELLIPSEARCH | \
					not(isWindow)) then
				! --- Not Stacked Window, have no Sill and not a Special Window (eg. Arched) ---

				if not(bInclinedWall) then
					if iRevealType <> REVEAL_SLANTED & iRevealType <> REVEAL_SPLAYED & iRevealType <> REVEAL_HISTORIC & iRevealType <> REVEAL_DOUBLE_SPLAYED then
						cprism_{2} matTrim, matTrim, matTrim,
							10, thk,
							-leftWidth  - overSizeLeftIn  + tolerOffsetLeftIn,		-overSizeBottomIn + tolerOffsetLowerIn, 0, 15, gs_trim_in_mat,
							-leftWidth  - overSizeLeftIn  + tolerOffsetLeftIn,		B + overSizeTopIn - tolerOffsetUpperIn, 0, 15, gs_trim_in_mat,
							 rightWidth + overSizeRightIn - tolerOffsetRightIn,		B + overSizeTopIn - tolerOffsetUpperIn, 0, 15, gs_trim_in_mat,
							 rightWidth + overSizeRightIn - tolerOffsetRightIn,		-overSizeBottomIn + tolerOffsetLowerIn, 0, 15, gs_trim_in_mat,
							-leftWidth  - overSizeLeftIn  + tolerOffsetLeftIn,		-overSizeBottomIn + tolerOffsetLowerIn, 0, -1, gs_trim_in_mat,
							-leftWidth  - overSizeLeftIn  + tolerOffsetLeftIn  + gs_trim_width_in,	-overSizeBottomIn + tolerOffsetLowerIn + gs_trim_width_in, 0, mask, gs_trim_in_mat,
							-leftWidth  - overSizeLeftIn  + tolerOffsetLeftIn  + gs_trim_width_in,	B + overSizeTopIn - tolerOffsetUpperIn - gs_trim_width_in, 0, mask, gs_trim_in_mat,
							 rightWidth + overSizeRightIn - tolerOffsetRightIn - gs_trim_width_in,	B + overSizeTopIn - tolerOffsetUpperIn - gs_trim_width_in, 0, mask, gs_trim_in_mat,
							 rightWidth + overSizeRightIn - tolerOffsetRightIn - gs_trim_width_in,	-overSizeBottomIn + tolerOffsetLowerIn + gs_trim_width_in, 0, mask, gs_trim_in_mat,
							-leftWidth  - overSizeLeftIn  + tolerOffsetLeftIn  + gs_trim_width_in,	-overSizeBottomIn + tolerOffsetLowerIn + gs_trim_width_in, 0, -1, gs_trim_in_mat
					else
						ruled{2} 4, 1 + 2 + 4 + 16 + 32 * not(gs_trim_show_cover_in) + 64,
							leftRevealPnts[idxBoardEndRevealLeft - 1][1] + tolerOffsetLeftIn,			-overSizeBottomIn + tolerOffsetLowerIn + bDrawBoard * boardBottom, 1,
							leftRevealPnts[idxBoardEndRevealLeft - 1][1] + tolerOffsetLeftIn + trinL,	-overSizeBottomIn + tolerOffsetLowerIn + bDrawBoard * boardBottom + trinB, 1,
							leftRevealPnts[idxBoardEndRevealLeft - 1][1] + tolerOffsetLeftIn + trinL,	B + overSizeTopIn - tolerOffsetUpperIn - trinT, 1,
							leftRevealPnts[idxBoardEndRevealLeft - 1][1] + tolerOffsetLeftIn,			B + overSizeTopIn - tolerOffsetUpperIn, 1,

							leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn - leftNosingDx,			-overSizeBottomIn + tolerOffsetLowerIn - sjby - bottomNosingDx + bDrawBoard * boardBottom, thk,
							leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn - leftNosingDx + trinL,	-overSizeBottomIn + tolerOffsetLowerIn - sjby - bottomNosingDx + bDrawBoard * boardBottom + trinB, thk,
							leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn - leftNosingDx + trinL,	B + overSizeTopIn - tolerOffsetUpperIn + sjty + topNosingDx - trinT, thk,
							leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn - leftNosingDx,			B + overSizeTopIn - tolerOffsetUpperIn + sjty + topNosingDx, thk

						ruled{2} 4, 1 + 2 + 4 + 16 + 32 * not(gs_trim_show_cover_in) + 64,
							rightRevealPnts[idxBoardEndRevealright - 1][1] - tolerOffsetRightIn,			-overSizeBottomIn + tolerOffsetLowerIn + bDrawBoard * boardBottom, 1,
							rightRevealPnts[idxBoardEndRevealright - 1][1] - tolerOffsetRightIn - trinR,	-overSizeBottomIn + tolerOffsetLowerIn + bDrawBoard * boardBottom + trinB, 1,
							rightRevealPnts[idxBoardEndRevealright - 1][1] - tolerOffsetRightIn - trinR,	B + overSizeTopIn - tolerOffsetUpperIn - trinT, 1,
							rightRevealPnts[idxBoardEndRevealright - 1][1] - tolerOffsetRightIn,			B + overSizeTopIn - tolerOffsetUpperIn, 1,

							rightRevealPnts[idxBoardEndRevealright][1] - tolerOffsetRightIn + rightNosingDx,		 -overSizeBottomIn + tolerOffsetLowerIn - sjby - bottomNosingDx + bDrawBoard * boardBottom, thk,
							rightRevealPnts[idxBoardEndRevealright][1] - tolerOffsetRightIn + rightNosingDx - trinR, -overSizeBottomIn + tolerOffsetLowerIn - sjby - bottomNosingDx + bDrawBoard * boardBottom + trinB, thk,
							rightRevealPnts[idxBoardEndRevealright][1] - tolerOffsetRightIn + rightNosingDx - trinR, B + overSizeTopIn - tolerOffsetUpperIn + sjty + topNosingDx - trinT, thk,
							rightRevealPnts[idxBoardEndRevealright][1] - tolerOffsetRightIn + rightNosingDx,		 B + overSizeTopIn - tolerOffsetUpperIn + sjty + topNosingDx, thk

						ruled{2} 4, 1 + 2 + 4 + 16 + 32 * not(gs_trim_show_cover_in) + 64,
							 leftRevealPnts[idxBoardEndRevealLeft  - 1][1] + tolerOffsetLeftIn,			 -overSizeBottomIn + tolerOffsetLowerIn + bDrawBoard * boardBottom, 1,
							rightRevealPnts[idxBoardEndRevealRight - 1][1] - tolerOffsetRightIn,		 -overSizeBottomIn + tolerOffsetLowerIn + bDrawBoard * boardBottom, 1,
							rightRevealPnts[idxBoardEndRevealRight - 1][1] - tolerOffsetRightIn - trinR, -overSizeBottomIn + tolerOffsetLowerIn + bDrawBoard * boardBottom + trinB, 1,
							 leftRevealPnts[idxBoardEndRevealLeft  - 1][1] + tolerOffsetLeftIn  + trinL, -overSizeBottomIn + tolerOffsetLowerIn + bDrawBoard * boardBottom + trinB, 1,

							 leftRevealPnts[idxBoardEndRevealLeft ][1] + tolerOffsetLeftIn  - leftNosingDx,			 -overSizeBottomIn + tolerOffsetLowerIn - sjby - bottomNosingDx + bDrawBoard * boardBottom, thk,
							rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn + rightNosingDx,		 -overSizeBottomIn + tolerOffsetLowerIn - sjby - bottomNosingDx + bDrawBoard * boardBottom, thk,
							rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn + rightNosingDx - trinR, -overSizeBottomIn + tolerOffsetLowerIn - sjby - bottomNosingDx + bDrawBoard * boardBottom + trinB, thk,
							 leftRevealPnts[idxBoardEndRevealLeft ][1] + tolerOffsetLeftIn  - leftNosingDx  + trinL, -overSizeBottomIn + tolerOffsetLowerIn - sjby - bottomNosingDx + bDrawBoard * boardBottom + trinB, thk

						ruled{2} 4, 1 + 2 + 4 + 16 + 32 * not(gs_trim_show_cover_in) + 64,
							 leftRevealPnts[idxBoardEndRevealLeft  - 1][1] + tolerOffsetLeftIn,			 B + overSizeTopIn - tolerOffsetUpperIn, 1,
							rightRevealPnts[idxBoardEndRevealRight - 1][1] - tolerOffsetRightIn,		 B + overSizeTopIn - tolerOffsetUpperIn, 1,
							rightRevealPnts[idxBoardEndRevealRight - 1][1] - tolerOffsetRightIn - trinR, B + overSizeTopIn - tolerOffsetUpperIn - trinT, 1,
							 leftRevealPnts[idxBoardEndRevealLeft  - 1][1] + tolerOffsetLeftIn  + trinL, B + overSizeTopIn - tolerOffsetUpperIn - trinT, 1,

							 leftRevealPnts[idxBoardEndRevealLeft ][1] + tolerOffsetLeftIn  - leftNosingDx,			 B + overSizeTopIn - tolerOffsetUpperIn + sjty + topNosingDx, thk,
							rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn + rightNosingDx,		 B + overSizeTopIn - tolerOffsetUpperIn + sjty + topNosingDx, thk,
							rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn + rightNosingDx - trinR, B + overSizeTopIn - tolerOffsetUpperIn + sjty + topNosingDx - trinT, thk,
							 leftRevealPnts[idxBoardEndRevealLeft ][1] + tolerOffsetLeftIn  - leftNosingDx  + trinL, B + overSizeTopIn - tolerOffsetUpperIn + sjty + topNosingDx - trinT, thk
					endif
				else
					if iRevealType <> REVEAL_SLANTED & iRevealType <> REVEAL_SPLAYED & iRevealType <> REVEAL_HISTORIC & iRevealType <> REVEAL_DOUBLE_SPLAYED then
						sprism_ matTrim, matTrim, matTrim,
							10, 0,0, 0,1, thk, wallIncl,
							-leftWidth  - overSizeLeftIn + tolerOffsetLeftIn,		-overSizeBottomIn + tolerOffsetLowerIn, 15,
							-leftWidth  - overSizeLeftIn + tolerOffsetLeftIn,		B + overSizeTopIn - tolerOffsetUpperIn, 15,
							 rightWidth + overSizeRightIn - tolerOffsetRightIn,	B + overSizeTopIn - tolerOffsetUpperIn, 15,
							 rightWidth + overSizeRightIn - tolerOffsetRightIn,	-overSizeBottomIn + tolerOffsetLowerIn, 15,
							-leftWidth  - overSizeLeftIn + tolerOffsetLeftIn,		-overSizeBottomIn + tolerOffsetLowerIn, -1,
							-leftWidth  - overSizeLeftIn + tolerOffsetLeftIn  + gs_trim_width_in,	-overSizeBottomIn + tolerOffsetLowerIn + gs_trim_width_in, mask,
							-leftWidth  - overSizeLeftIn + tolerOffsetLeftIn  + gs_trim_width_in,	B + overSizeTopIn - gs_trim_width_in - tolerOffsetUpperIn, mask,
							 rightWidth + overSizeRightIn - tolerOffsetRightIn - gs_trim_width_in,	B + overSizeTopIn - gs_trim_width_in - tolerOffsetUpperIn, mask,
							 rightWidth + overSizeRightIn - tolerOffsetRightIn - gs_trim_width_in,	-overSizeBottomIn + tolerOffsetLowerIn + gs_trim_width_in, mask,
							-leftWidth  - overSizeLeftIn + tolerOffsetLeftIn  + gs_trim_width_in,	-overSizeBottomIn + tolerOffsetLowerIn + gs_trim_width_in, -1
					endif
				endif
			else
				! --- Stacked Window or Window with Board or Corner Window ---


				! --- Draw left side Jamb Extension ---

				px1 = leftRevealPnts[idxBoardEndRevealright-1][1] + tolerOffsetLeftIn
				px2 = px1 + gs_trim_width_in * not(gs_stack_left)

				if	bShapeEnablesStraightTopTrim then
					py1 = B + overSizeTopIn - tolerOffsetUpperIn
					py2 = py1 - not(gs_stack_top) * gs_trim_width_in

					s1 = 8 + 2 * not(gs_stack_top)		! 15 or 8
					s2 = bitset (mask, 1, not(gs_stack_top))
				endif

				if	bShapeEnablesArchedTopTrim then
					ta = leftWidth + overSizeTopIn - tolerOffsetLeftIn
					tc = arcR + overSizeTopIn
					py1 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))

					ta = ta - gs_trim_width_in
					tc = tc - gs_trim_width_in
					py2 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))

					archTrimDiff = py1 - py2

					s1 = 8
					s2 = mask - 2
				endif

				if iWindowShape = SHAPE_ELLIPSEARCH then
					py1 = B - archHeight		! + overSizeTopIn
					py2 = py1

					s1 = 8
					s2 = mask - 2
				endif

				if	isWindow | \
					(bPShapedLeftOpening & gs_trim_below_boardLeft) then
					py3 = -overSizeBottomIn + not(gs_stack_bottom | bDrawLeftSLBoard) * (gs_trim_width_in + tolerOffsetLowerIn)
					py4 = -overSizeBottomIn + not(gs_stack_bottom | bDrawLeftSLBoard) * tolerOffsetLowerIn

					s3 = 8 + 7 * not(gs_stack_bottom) * bDrawBoard * isWindow + 2 * not(isWindow) 		! 15 or 8
					s4 = 13 + 2 * not(gs_stack_bottom)		! 15 or 13
				else
					py3 = -overSizeBottomIn
					py4 = -overSizeBottomIn

					s3 = 15
					s4 = 15
				endif

				py1r = (-overSizeBottomIn + (tolerOffsetLowerIn * not(bDrawLeftSLBoard)) ) * ((isWindow & not(gs_stack_bottom))) - overSizeBottomIn * not(isWindow) * not(bPShapedLeftOpening)
				py2r = py1r + trinB * ( (isWindow & not(gs_stack_bottom) & not(bDrawBoard)) | (bPShapedLeftOpening & gs_trim_below_boardLeft) )
				py3r = B + (overSizeTopIn - tolerOffsetUpperIn - trinT * (iWindowShape = SHAPE_RECTANGULAR) - (archHeight) - archTrimDiff * not(bHalfCircle)) * not(gs_stack_top)				! tok - belso - felso
				py4r = B + (overSizeTopIn - tolerOffsetUpperIn - (archHeight)) * not(gs_stack_top)					! tok - fal - felso
				py5r = (-overSizeBottomIn + (tolerOffsetLowerIn * not(bDrawLeftSLBoard)) - sjby) * (isWindow & not(gs_stack_bottom)) - overSizeBottomIn * not(isWindow) * not(bPShapedLeftOpening)
				py6r = py5r + trinB * ( (isWindow & not(gs_stack_bottom) & not(bDrawBoard)) | (bPShapedLeftOpening & gs_trim_below_boardLeft) )
				py7r = B + (overSizeTopIn - tolerOffsetUpperIn - trinT * (iWindowShape = SHAPE_RECTANGULAR) + sjty - (archHeight) - archTrimDiff * not(bHalfCircle)) * not(gs_stack_top)	! falsik - belso - felso
				py8r = B + (overSizeTopIn - tolerOffsetUpperIn + sjty - (archHeight)) * not(gs_stack_top)				! falsik - fal - felso

				if	bShapeEnablesArchedTopTrim | \
					iWindowShape = SHAPE_ELLIPSEARCH then
					py3r = py2
					py4r = py1
				endif

				if	bPShapedLeftOpening then
					py1r = py1r + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL
					py2r = py2r + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL
					py5r = py2r + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL
					py6r = py2r + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL
					py3 = py3 + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + overSizeBottomIn
					py4 = py4 + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + overSizeBottomIn
				endif

				if not(gs_stack_left | bLeftCornerFunction) & bShapeEnablesStraightLeftTrim then

					if maxx < EPS | ((sgn(px1) = sgn(wallIncl) | abs(px1) < maxx) & (sgn(px2) = sgn(wallIncl) | abs(px2) < maxx)) then
						addz (not(isWindow) & not(WIDO_REVEAL_SIDE)) * pocketThkLeft

						if bInclinedWall then
							if iRevealType <> REVEAL_SLANTED & iRevealType <> REVEAL_SPLAYED & iRevealType <> REVEAL_HISTORIC & iRevealType <> REVEAL_DOUBLE_SPLAYED then
								sprism_ matTrim, matTrim, matTrim,
									4, 0,0, 0,1, thk - pocketThkLeft, wallIncl,
									px1,	py1, 	s1,
									px2,	py2, 	s2,
									px2,	py3,	s3,
									px1,	py4, 	s4
							endif
						else
							if iRevealType <> REVEAL_SLANTED & iRevealType <> REVEAL_SPLAYED & iRevealType <> REVEAL_HISTORIC & iRevealType <> REVEAL_DOUBLE_SPLAYED then
								cprism_{2} gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
									4, thk,
									leftRevealPnts[idxBoardEndRevealLeft-1][1] + tolerOffsetLeftIn,			py4,	0, 8 + 7 * not(bPShapedLeftOpening) * not(isWindow), gs_trim_in_mat,
									leftRevealPnts[idxBoardEndRevealLeft-1][1] + tolerOffsetLeftIn + trinL,	py3,	0, 8 + 1 * bShowEdgesAtFrame + 2 * not(gs_stack_bottom) + 4 * (abs(gs_trim_offs_in) > EPS | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS), gs_trim_in_mat,
									leftRevealPnts[idxBoardEndRevealLeft-1][1] + tolerOffsetLeftIn + trinL,	py3r,	0, s1, gs_trim_in_mat,
									leftRevealPnts[idxBoardEndRevealLeft-1][1] + tolerOffsetLeftIn,			py4r,	0, 15, gs_trim_in_mat
							else
								ruled{2} 4, 1 + 2 + 4 + 16 + 32 * not(gs_trim_show_cover_in) + 64,
									leftRevealPnts[idxBoardEndRevealLeft-1][1] + tolerOffsetLeftIn,			py1r, 1,
									leftRevealPnts[idxBoardEndRevealLeft-1][1] + tolerOffsetLeftIn + trinL,	py2r, 1,
									leftRevealPnts[idxBoardEndRevealLeft-1][1] + tolerOffsetLeftIn + trinL,	py3r, 1,
									leftRevealPnts[idxBoardEndRevealLeft-1][1] + tolerOffsetLeftIn,			py4r, 1,

									leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn - leftNosingDx,			py5r - bottomNosingDx, thk,
									leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn - leftNosingDx + trinL,	py6r - bottomNosingDx, thk,
									leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn - leftNosingDx + trinL,	py7r + topNosingDx, thk,
									leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn - leftNosingDx,			py8r + topNosingDx, thk

								if abs(gs_trim_offs_in) > EPS | abs(gs_trim_thk_in) < EPS then
									lin_ leftRevealPnts[idxBoardEndRevealleft][1] + tolerOffsetLeftIn - leftNosingDx + trinL, py6r - bottomNosingDx, thk,
										 leftRevealPnts[idxBoardEndRevealleft][1] + tolerOffsetLeftIn - leftNosingDx + trinL, py7r + topNosingDx, thk
								endif
							endif
						endif

						gosub "TextCoord_Vert"

						del 1
					endif
				endif
				if	bPShapedLeftOpening & gs_trim_below_boardLeft then
					! --- Draw Door's Left side Jamb Extension ---
					px1LSL = leftRevealPnts[idxBoardEndRevealright-1][1] + gs_sidelight_WHole_width_left
					px2LSL = px1LSL + gs_trim_width_in
					px1LSLW = leftRevealPnts[idxBoardEndRevealLeft-1][1] + tolerOffsetLeftIn
					px2LSLW = leftRevealPnts[idxBoardEndRevealLeft-1][1] + tolerOffsetLeftIn + trinL * not(gs_stack_left)

					py1 = -overSizeBottomIn
					py2 = -overSizeBottomIn

					sprism_ matTrim, matTrim, matTrim,
						4, 0,0, 0,1, thk - pocketThkRight, wallIncl,
						 px1LSL,	py1,	15,
						 px2LSL,	py2,	mask,
						 px2LSL,	py3,	s3,
						 px1LSL,	py4,	s4
					gosub "TextCoord_Vert"

					if	not(bDrawLeftSLBoard) then
						! --- Draw Left Sidelight lower side Jamb Extension ---
						sprism_ matTrim, matTrim, matTrim,
							4, 0,0, 0,1, thk - pocketThkRight, wallIncl,
							 px2LSL,	py3,	15,
							 px1LSL,	py4,	15,
							 px1LSLW,	py4,	15,
							 px2LSLW,	py3,	mask - 2 * gs_stack_left
						gosub "TextCoord_Hor"
					endif
				endif


				! --- Draw right side Jamb Extension ---

				px1 = rightRevealPnts[idxBoardEndRevealright - 1][1] - tolerOffsetRightIn
				px2 = px1 - gs_trim_width_in * not(gs_stack_right)

				if	bShapeEnablesStraightTopTrim then
					py1 = B + overSizeTopIn - tolerOffsetUpperIn
					py2 = py1 - not(gs_stack_top) * gs_trim_width_in

					s1 = 8 + 2 * not(gs_stack_top)			! 15 or 8
					s2 = bitset (mask, 1, not(gs_stack_top))
				endif

				if	bShapeEnablesArchedTopTrim then
					ta = rightWidth + overSizeTopIn - tolerOffsetRightIn
					tc = arcR + overSizeTopIn
					py1 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))

					ta = ta - gs_trim_width_in
					tc = tc - gs_trim_width_in
					py2 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))

					archTrimDiff = py1 - py2

					s1 = 8
					s2 = mask - 2
				endif

				if iWindowShape = SHAPE_ELLIPSEARCH then
					py1 = B - archHeight	! + overSizeTopIn
					py2 = py1

					s1 = 8
					s2 = mask - 2
				endif

				if	isWindow | \
					(bPShapedRightOpening & gs_trim_below_boardRight) then
					py3 = -overSizeBottomIn + not(gs_stack_bottom | bDrawRightSLBoard) * (gs_trim_width_in + tolerOffsetLowerIn)
					py4 = -overSizeBottomIn + not(gs_stack_bottom | bDrawRightSLBoard) * tolerOffsetLowerIn

					s3 = 8 + 7 * not(gs_stack_bottom) * bDrawBoard * isWindow + 2 * not(isWindow)		! 15 or 8
					s4 = 13 + 2 * not(gs_stack_bottom)		! 15 or 13
				else
					py3 = -overSizeBottomIn
					py4 = -overSizeBottomIn

					s3 = 15
					s4 = 15
				endif

				py1r = (-overSizeBottomIn + (tolerOffsetLowerIn * not(bDrawRightSLBoard)) ) * ((isWindow & not(gs_stack_bottom))) - overSizeBottomIn * not(isWindow) * not(bPShapedRightOpening)
				py2r = py1r + trinB * ( (isWindow & not(gs_stack_bottom) & not(bDrawBoard)) | (bPShapedRightOpening & gs_trim_below_boardRight ) )
				py3r = B + (overSizeTopIn - tolerOffsetUpperIn - trinT * (iWindowShape = SHAPE_RECTANGULAR) - (archHeight) - archTrimDiff * not(bHalfCircle)) * not(gs_stack_top)
				py4r = B + (overSizeTopIn - tolerOffsetUpperIn - (archHeight)) * not(gs_stack_top)
				py5r = (-overSizeBottomIn + (tolerOffsetLowerIn * not(bDrawRightSLBoard)) - sjby) * (isWindow & not(gs_stack_bottom)) - overSizeBottomIn * not(isWindow) * not(bPShapedRightOpening)
				py6r = py5r + trinB * ( (isWindow & not(gs_stack_bottom) & not(bDrawBoard)) | (bPShapedRightOpening & gs_trim_below_boardRight) )
				py7r = B + (overSizeTopIn - tolerOffsetUpperIn - trinT * (iWindowShape = SHAPE_RECTANGULAR) + sjty - (archHeight) - archTrimDiff * not(bHalfCircle)) * not(gs_stack_top)
				py8r = B + (overSizeTopIn - tolerOffsetUpperIn + sjty - (archHeight)) * not(gs_stack_top)

				if	bShapeEnablesArchedTopTrim | \
					iWindowShape = SHAPE_ELLIPSEARCH then
					py3r = py2
					py4r = py1
				endif

				if	bPShapedRightOpening then
					py1r = py1r + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR
					py2r = py2r + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR
					py5r = py2r + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR
					py6r = py2r + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR
					py3 = py3 + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + overSizeBottomIn
					py4 = py4 + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + overSizeBottomIn
				endif

				if not(gs_stack_right | bRightCornerFunction) & bShapeEnablesStraightRightTrim then

					if maxx < EPS | ((sgn(px1) = sgn(wallIncl) | abs(px1) < maxx) & (sgn(px2) = sgn(wallIncl) | abs(px2) < maxx)) then
						addz (not(isWindow) & not(WIDO_REVEAL_SIDE)) * pocketThkRight

						if bInclinedWall then
							if iRevealType <> REVEAL_SLANTED & iRevealType <> REVEAL_SPLAYED & iRevealType <> REVEAL_HISTORIC & iRevealType <> REVEAL_DOUBLE_SPLAYED then
								sprism_ matTrim, matTrim, matTrim,
									4, 0,0, 0,1, thk - pocketThkRight, wallIncl,
									 px1,	py1,	s1,
									 px2,	py2,	s2,
									 px2,	py3,	s3,
									 px1,	py4,	s4
							endif
						else
							if iRevealType <> REVEAL_SLANTED & iRevealType <> REVEAL_SPLAYED & iRevealType <> REVEAL_HISTORIC & iRevealType <> REVEAL_DOUBLE_SPLAYED then
								cprism_{2} gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
									4,thk,
									rightRevealPnts[idxBoardEndRevealright - 1][1] - tolerOffsetRightIn,			py4,	0, 8 + 7 * not(bPShapedLeftOpening) * not(isWindow), gs_trim_in_mat,
									rightRevealPnts[idxBoardEndRevealright - 1][1] - tolerOffsetRightIn - trinR,	py3,	0, 8 + 1 * bShowEdgesAtFrame + 2 * not(gs_stack_bottom) + 4 * (abs(gs_trim_offs_in) > EPS | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS), gs_trim_in_mat,
									rightRevealPnts[idxBoardEndRevealright - 1][1] - tolerOffsetRightIn - trinR,	py3r,	0, s1, gs_trim_in_mat,
									rightRevealPnts[idxBoardEndRevealright - 1][1] - tolerOffsetRightIn,			py4r,	0, 15, gs_trim_in_mat
							else
								ruled{2} 4, 1 + 2 + 4 + 16 + 32 * not(gs_trim_show_cover_in) + 64,
									rightRevealPnts[idxBoardEndRevealright - 1][1] - tolerOffsetRightIn,			py1r, 1,
									rightRevealPnts[idxBoardEndRevealright - 1][1] - tolerOffsetRightIn - trinR,	py2r, 1,
									rightRevealPnts[idxBoardEndRevealright - 1][1] - tolerOffsetRightIn - trinR,	py3r, 1,
									rightRevealPnts[idxBoardEndRevealright - 1][1] - tolerOffsetRightIn,			py4r, 1,

									rightRevealPnts[idxBoardEndRevealright][1] - tolerOffsetRightIn + rightNosingDx,			py5r - bottomNosingDx, thk,
									rightRevealPnts[idxBoardEndRevealright][1] - tolerOffsetRightIn + rightNosingDx - trinR,	py6r - bottomNosingDx, thk,
									rightRevealPnts[idxBoardEndRevealright][1] - tolerOffsetRightIn + rightNosingDx - trinR,	py7r + topNosingDx, thk,
									rightRevealPnts[idxBoardEndRevealright][1] - tolerOffsetRightIn + rightNosingDx,			py8r + topNosingDx, thk

								if abs(gs_trim_offs_in) > EPS | abs(gs_trim_thk_in) < EPS then
									lin_ rightRevealPnts[idxBoardEndRevealright][1] - tolerOffsetRightIn + rightNosingDx - trinR, py6r - bottomNosingDx, thk,
										 rightRevealPnts[idxBoardEndRevealright][1] - tolerOffsetRightIn + rightNosingDx - trinR, py7r + topNosingDx, thk
								endif
							endif
						endif
						gosub "TextCoord_Vert"

						del 1
					endif
				endif

				if	bPShapedRightOpening & gs_trim_below_boardRight then
					! --- Draw Door's Right side Jamb Extension ---
					px1RSL = rightRevealPnts[idxBoardEndRevealright - 1][1] - gs_sidelight_WHole_width_right - gs_trim_width_in
					px2RSL = px1RSL + gs_trim_width_in
					px1RSLW = rightRevealPnts[idxBoardEndRevealright - 1][1] - tolerOffsetRightIn
					px2RSLW = rightRevealPnts[idxBoardEndRevealright - 1][1] - tolerOffsetRightIn - trinR * not(gs_stack_right)

					py1 = -overSizeBottomIn
					py2 = -overSizeBottomIn

					sprism_ matTrim, matTrim, matTrim,
						4, 0,0, 0,1, thk - pocketThkRight, wallIncl,
						 px2RSL,	py1,	15,
						 px1RSL,	py2,	mask,
						 px1RSL,	py3,	s3,
						 px2RSL,	py4,	s4
					gosub "TextCoord_Vert"

					if	not(bDrawRightSLBoard) then
						! --- Draw Right Sidelight lower side Jamb Extension ---
						sprism_ matTrim, matTrim, matTrim,
							4, 0,0, 0,1, thk - pocketThkRight, wallIncl,
							px1RSL,	py3,	15,
							px2RSL,	py4,	15,
							px1RSLW,py4,	15,
							px2RSLW,py3,	mask - 2 * gs_stack_right
						gosub "TextCoord_Hor"
					endif
				endif

				if bShapeEnablesStraightTopTrim & not(gs_stack_top) then
					! --- Draw upper side Jamb Extension ---

					px1 = -leftWidth - overSizeLeftIn + tolerOffsetLeftIn
					px2 = px1 + not(gs_stack_left) * gs_trim_width_in
					px4 = rightWidth + overSizeRightIn - tolerOffsetRightIn
					px3 = px4 - not(gs_stack_right) * gs_trim_width_in

					if maxx > EPS then
						if sgn(wallIncl) < 0 then
							px1 = min(maxx - EPS, px1)
							px2 = min(maxx - EPS, px2)
							px3 = min(maxx - EPS, px3)
							px4 = min(maxx - EPS, px4)
						else
							px1 = max(-maxx + EPS, px1)
							px2 = max(-maxx + EPS, px2)
							px3 = max(-maxx + EPS, px3)
							px4 = max(-maxx + EPS, px4)
						endif
					endif

					py1 = B + overSizeTopIn - tolerOffsetUpperIn
					py2 = B + overSizeTopIn - tolerOffsetUpperIn - gs_trim_width_in
					py3 = B + overSizeTopIn - tolerOffsetUpperIn - gs_trim_width_in
					py4 = B + overSizeTopIn - tolerOffsetUpperIn

					py1r = B + overSizeTopIn - tolerOffsetUpperIn
					py2r = B + overSizeTopIn - tolerOffsetUpperIn
					py3r = B + overSizeTopIn - tolerOffsetUpperIn - trinT
					py4r = B + overSizeTopIn - tolerOffsetUpperIn - trinT
					py5r = B + overSizeTopIn - tolerOffsetUpperIn + sjty
					py6r = B + overSizeTopIn - tolerOffsetUpperIn + sjty
					py7r = B + overSizeTopIn - tolerOffsetUpperIn + sjty - trinT
					py8r = B + overSizeTopIn - tolerOffsetUpperIn + sjty - trinT

					s1 = mask	!8 + 7 * not(gs_stack_left)
					s2 = 8 + 2 * not(gs_stack_right)
					s3 = 10 + 1 * bShowEdgesAtFrame + 4 * (abs(gs_trim_offs_in) > EPS | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS) - 2 * gs_stack_right
					s4 = 8 + 2 * not(gs_stack_left)

					if bInclinedWall then
						if iRevealType <> REVEAL_SLANTED & iRevealType <> REVEAL_SPLAYED & iRevealType <> REVEAL_HISTORIC & iRevealType <> REVEAL_DOUBLE_SPLAYED then
							sprism_ matTrim, matTrim, matTrim,
								4, 0,0, 0,1, thk, wallIncl,
								px1,	py1,	8 + 2 * not(gs_stack_left),			! 15 or 8
								px2,	py2,	bitset(bitset (mask, 1, not(gs_stack_left)), 0, not(bRightCornerFunction) | not(bFitModeRight)),
								px3,	py3,	8 + 2 * not(gs_stack_right),		! 15 or 8
								px4,	py4,	13 + 2 * not(gs_stack_right)		! 15 or 13
						endif
					else
						if iRevealType <> REVEAL_SLANTED & iRevealType <> REVEAL_SPLAYED & iRevealType <> REVEAL_HISTORIC & iRevealType <> REVEAL_DOUBLE_SPLAYED then
							if bLeftCornerFunction then
								pxL = min(leftRevealPnts[idxBoardEndRevealLeft][1], leftRevealPnts[idxBoardEndRevealLeft - 1][1]) - 1.0
							else
								pxL = leftRevealPnts[idxBoardEndRevealLeft - 1][1]
							endif
							if bRightCornerFunction then
								pxR = max(rightRevealPnts[idxBoardEndRevealRight][1], rightRevealPnts[idxBoardEndRevealRight - 1][1]) + 1.0
							else
								pxR = rightRevealPnts[idxBoardEndRevealRight - 1][1]
							endif
							cprism_{2} gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
								4, thk,
								pxL + tolerOffsetLeftIn,														py1r, 0, s1, gs_trim_in_mat,
								pxR - tolerOffsetRightIn,														py2r, 0, s2, gs_trim_in_mat,
								pxR - tolerOffsetRightIn - not(gs_stack_right | bRightCornerFunction) * trinR,	py3r, 0, s3, gs_trim_in_mat,
								pxL + tolerOffsetLeftIn  + not(gs_stack_left  | bLeftCornerFunction)  * trinL,	py4r, 0, s4, gs_trim_in_mat
						else
							ruled{2} 4, 1 + 2 + 4 + 16 + 32 * not(gs_trim_show_cover_in),
								 leftRevealPnts[idxBoardEndRevealLeft  - 1][1] + tolerOffsetLeftIn,  py1r, 1,
								rightRevealPnts[idxBoardEndRevealRight - 1][1] - tolerOffsetRightIn, py2r, 1,
								rightRevealPnts[idxBoardEndRevealRight - 1][1] - tolerOffsetRightIn - not(gs_stack_right | bRightCornerFunction) * trinR, py3r, 1,
								 leftRevealPnts[idxBoardEndRevealLeft  - 1][1] + tolerOffsetLeftIn  + not(gs_stack_left  | bLeftCornerFunction)  * trinL, py4r, 1,

								 leftRevealPnts[idxBoardEndRevealLeft] [1] + tolerOffsetLeftIn  - leftNosingDx,  py5r + topNosingDx, thk,
								rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn + rightNosingDx, py6r + topNosingDx, thk,
								rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn + rightNosingDx - not(gs_stack_right | bRightCornerFunction) * trinR, py7r + topNosingDx, thk,
								 leftRevealPnts[idxBoardEndRevealLeft ][1] + tolerOffsetLeftIn  - leftNosingDx  + not(gs_stack_left  | bLeftCornerFunction)  * trinL, py8r + topNosingDx, thk

							if abs(gs_trim_offs_in) > EPS | abs(gs_trim_thk_in) < EPS then
								lin_ leftRevealPnts[idxBoardEndRevealLeft ][1] + tolerOffsetLeftIn  - leftNosingDx  + not(gs_stack_left  | bLeftCornerFunction)  * trinL, py8r + topNosingDx, thk,
									rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn + rightNosingDx - not(gs_stack_right | bRightCornerFunction) * trinR, py7r + topNosingDx, thk
							endif
						endif
					endif
				endif
				if	bShapeEnablesArchedTopTrim then

					resol nArchResolution
					addy B - archHeight - tolerOffsetUpperIn

					px1L = -leftWidth - overSizeLeftIn + tolerOffsetLeftIn
					px2L = px1L + gs_trim_width_in

					px1R = rightWidth + overSizeRightIn - tolerOffsetRightIn
					px2R = px1R - gs_trim_width_in

					if maxx < EPS | abs(px1L) < maxx | abs(px1R) < maxx then

						if bHalfCircle then

							sprism_ matTrim, matTrim, matTrim,
								9, 0,0, 0,1, thk, wallIncl,
								px1L,	0, 	   8 + 7 * gs_stack_left,		! 15 or 8
								px2L,	0,	  62 + mask,
								 0,		0,	 900,
								 0,	archHeight - gs_trim_width_in,	3062 + mask,		! 1015 or 1008
								 px2R,	0,	3008 + 7 * gs_stack_right,		! 1015 or 1008
								 px1R,	-EPS,  8 + 7 * gs_stack_right,		! 15 or 8
								 px1R,	0,	  79,
								 0,		archHeight, 	3079,
								px1L,	0, 	3015

							! --- Draw missing lines ---
							if gs_stack_left then lin_ px2L,0,0, px2L,0,thk + px2L * tan(wallIncl)
						else
							ta = leftWidth + overSizeTopIn - tolerOffsetLeftIn
							tc = arcR + overSizeTopIn
							py1L = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight - tolerOffsetUpper

							ta = ta - gs_trim_width_in
							tc = tc - gs_trim_width_in
							py2L = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight - tolerOffsetUpper

							ta = rightWidth + overSizeTopIn - tolerOffsetRightIn
							tc = arcR + overSizeTopIn
							py1R = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight - tolerOffsetUpper

							ta = ta - gs_trim_width_in
							tc = tc - gs_trim_width_in
							py2R = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight - tolerOffsetUpper

							sprism_ matTrim, matTrim, matTrim,
								8, 0,0, 0,1, thk, wallIncl,
								 0,		archHeight - arcR, 900,
								px1L,	py1L, 	  8 + 7 * gs_stack_left,		! 15 or 8
								px2L,	py2L,	  62 + mask,
								 0,		archHeight - gs_trim_width_in,	3062 + mask,		! 1015 or 1008
								 px2R,	py2R,	3010 + 5 * gs_stack_right,		! 1015 or 1008
								 px1R,	py1R,	  79,
								 0,		archHeight, 	3079,
								px1L,	py1L, 	3015

							lin_ px2L,py2L,0, px2L,py2L,thk + px2L * tan(wallIncl)
						endif

					endif

					del 1
				endif
				if iWindowShape = SHAPE_ELLIPSEARCH then

					resol nArchResolution

					px1 = -leftWidth - overSizeLeftIn + tolerOffsetLeftIn
					px2 = px1 + not(gs_stack_left) * gs_trim_width_in
					px4 = rightWidth + overSizeRightIn - tolerOffsetRightIn
					px3 = px4 - not(gs_stack_right) * gs_trim_width_in

					pxcL = -leftWidth + smallRadiusEllips
					pxcR = rightWidth - smallRadiusEllips

					py1 = B - tolerOffsetUpperIn

					s3 = 9 + 4 * (abs(gs_trim_offs_in) > EPS | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS) - 2 * gs_stack_right

					sprism_ matTrim, matTrim, matTrim,
						13, 0,0, 0,1, thk, wallIncl,
						px4,	py1 - archHeight,			13,
						pxcR,	py1 - archHeight,			913,
						0,		alphaSide,					4013,
						0,		py1 - middleRadiusEllips, 	913,
						0,		alphaMiddle,				4013,
						pxcL,	py1 - archHeight,			913,
						0,		alphaSide,					4008,
						px2,	py1 - archHeight,			s3,
						0,		-alphaSide,					4000+s3,
						0,		py1 - middleRadiusEllips, 	900+s3,
						0,		-alphaMiddle,				4000+s3,
						pxcR,	py1 - archHeight,			900+s3,
						0,		-alphaSide,					4000+s3
				endif
				gosub "TextCoord_Hor"

				if not(gs_stack_bottom) & isWindow & bShapeEnablesStraightBottomTrim & not (bDrawBoard) then
					! --- Draw lower side Jamb Extension ---

					px1 = -leftWidth - overSizeLeftIn + tolerOffsetLeftIn
					px2 = px1 + not(gs_stack_left) * gs_trim_width_in
					px4 = rightWidth + overSizeRightIn - tolerOffsetRightIn
					px3 = px4 - not(gs_stack_right) * gs_trim_width_in

					if  maxx > EPS then
						if sgn(wallIncl) < 0 then
							px1 = min(maxx - EPS, px1)
							px2 = min(maxx - EPS, px2)
							px3 = min(maxx - EPS, px3)
							px4 = min(maxx - EPS, px4)
						else
							px1 = max(-maxx + EPS, px1)
							px2 = max(-maxx + EPS, px2)
							px3 = max(-maxx + EPS, px3)
							px4 = max(-maxx + EPS, px4)
						endif
					endif

					if bInclinedWall then
						if iRevealType <> REVEAL_SLANTED & iRevealType <> REVEAL_SPLAYED & iRevealType <> REVEAL_HISTORIC & iRevealType <> REVEAL_DOUBLE_SPLAYED then
							sprism_ matTrim, matTrim, matTrim,
								4, 0,0, 0,1, thk, wallIncl,
								px1,	-overSizeBottomIn + tolerOffsetLowerIn, 						8 + 2 * not(gs_stack_left),		! 15 or 8
								px2,	-overSizeBottomIn + tolerOffsetLowerIn + gs_trim_width_in,		bitset(bitset (mask, 1, not(gs_stack_left)), 0, not(bRightCornerFunction) | not(bFitModeRight)),
								px3,	-overSizeBottomIn + tolerOffsetLowerIn + gs_trim_width_in,		8 + 2 * not(gs_stack_right),		! 15 or 8
								px4,	-overSizeBottomIn + tolerOffsetLowerIn, 						13 + 2 * not(gs_stack_right)		! 15 or 13
						endif
					else
						if iRevealType <> REVEAL_SLANTED & iRevealType <> REVEAL_SPLAYED & iRevealType <> REVEAL_HISTORIC & iRevealType <> REVEAL_DOUBLE_SPLAYED then
							if bLeftCornerFunction then
								pxL = min(leftRevealPnts[idxBoardEndRevealLeft][1], leftRevealPnts[idxBoardEndRevealLeft - 1][1]) - 1.0
							else
								pxL = leftRevealPnts[idxBoardEndRevealLeft - 1][1]
							endif
							if bRightCornerFunction then
								pxR = max(rightRevealPnts[idxBoardEndRevealRight][1], rightRevealPnts[idxBoardEndRevealRight - 1][1]) + 1.0
							else
								pxR = rightRevealPnts[idxBoardEndRevealRight - 1][1]
							endif

							cprism_{2} gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
								4,thk,
								pxL + tolerOffsetLeftIn,														-overSizeBottomIn + tolerOffsetLowerIn,		0, 15, gs_trim_in_mat,
								pxR - tolerOffsetRightIn,														-overSizeBottomIn + tolerOffsetLowerIn,		0, 8 + 2 * not(gs_stack_right), gs_trim_in_mat,
								pxR - tolerOffsetRightIn - not(gs_stack_right | bRightCornerFunction) * trinR,	-overSizeBottomIn + tolerOffsetLowerIn + trinB,	0, mask, gs_trim_in_mat,
								pxL + tolerOffsetLeftIn  + not(gs_stack_left  | bLeftCornerFunction)  * trinL,	-overSizeBottomIn + tolerOffsetLowerIn + trinB,	0, 8 + 2 * not(gs_stack_left),  gs_trim_in_mat
						else
							ruled{2} 4, 1 + 2 + 4 + 16 + 32 * not(gs_trim_show_cover_in),
								 leftRevealPnts[idxBoardEndRevealLeft  - 1][1] + tolerOffsetLeftIn, -overSizeBottomIn + tolerOffsetLowerIn, 1,
								rightRevealPnts[idxBoardEndRevealRight - 1][1] - tolerOffsetRightIn, -overSizeBottomIn + tolerOffsetLowerIn, 1,
								rightRevealPnts[idxBoardEndRevealRight - 1][1] - tolerOffsetRightIn - not(gs_stack_right | bRightCornerFunction) * trinR, -overSizeBottomIn + tolerOffsetLowerIn + trinB, 1,
								 leftRevealPnts[idxBoardEndRevealLeft  - 1][1] + tolerOffsetLeftIn  + not(gs_stack_left  | bLeftCornerFunction)  * trinL, -overSizeBottomIn + tolerOffsetLowerIn + trinB, 1,

								 leftRevealPnts[idxBoardEndRevealLeft ][1] + tolerOffsetLeftIn  - leftNosingDx,											 -overSizeBottomIn + tolerOffsetLowerIn - bottomNosingDx - sjby, thk,
								rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn + rightNosingDx,										 -overSizeBottomIn + tolerOffsetLowerIn - bottomNosingDx - sjby, thk,
								rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn + rightNosingDx - not(gs_stack_right | bRightCornerFunction) * trinR, -overSizeBottomIn + tolerOffsetLowerIn - bottomNosingDx - sjby + trinB, thk,
								 leftRevealPnts[idxBoardEndRevealLeft ][1] + tolerOffsetLeftIn  - leftNosingDx  + not(gs_stack_left  | bLeftCornerFunction)  * trinL, -overSizeBottomIn + tolerOffsetLowerIn - bottomNosingDx - sjby + trinB, thk

							if abs(gs_trim_offs_in) > EPS | abs(gs_trim_thk_in) < EPS then
								lin_ rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn + rightNosingDx - not(gs_stack_right | bRightCornerFunction) * trinR, -overSizeBottomIn + tolerOffsetLowerIn - bottomNosingDx + trinB - sjby, thk,
									  leftRevealPnts[idxBoardEndRevealLeft ][1] + tolerOffsetLeftIn  - leftNosingDx  + not(gs_stack_left  | bLeftCornerFunction)  * trinL, -overSizeBottomIn + tolerOffsetLowerIn - bottomNosingDx + trinB - sjby, thk
							endif
						endif
					endif
				endif
				gosub "TextCoord_Hor"
			endif

			del 2
		endif

		mask = 11 + 4 * (gs_trim_offs_in > EPS | not(bShowJambExtension) | abs(WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS) < EPS | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS)

		if gs_trim_thk_in > EPS & gs_trim_show_cover_in & gs_sectgar = 0 then

			material gs_trim_in_mat
			sect_fill gs_trim_fill_in, gs_trim_pen_bg_in, gs_trim_pen_fg_in, gs_trim_pen_cont_in

			! ===== Inside Trim - Straight Walls - Casing =====

			maskTop		= 8 + 2 * not(gs_stack_top)
			maskBottom	= 8 + 2 * not(gs_stack_bottom)
			maskLeft	= 8 + 2 * not(gs_stack_left)
			maskRight	= 8 + 2 * not(gs_stack_right)

			maskLeft2	= bDrawBoard*(not(bTrimovbotleftin)*(15-7*gs_stack_left)+bTrimovbotleftin*(10-2*gs_stack_left))
			maskRight2	= bDrawBoard*(not(bTrimovbotrightin)*(15-7*gs_stack_right)+bTrimovbotrightin*(10-2*gs_stack_right))

			TrimLeftTopMiterAngle	= atn(gs_tw_top_in / gs_tw_left_in)
			TrimRightTopMiterAngle	= atn(gs_tw_top_in / gs_tw_right_in)
			TrimLeftBotMiterAngle	= atn(gs_tw_bottom_in / gs_tw_left_in)
			TrimRightBotMiterAngle	= atn(gs_tw_bottom_in / gs_tw_right_in)

			! --- Stacked Window or Window with Board or Corner Window ---

			if bInclinedWall & not(gs_trim_atframe_in) then
				if iRevealType <> REVEAL_SLANTED & iRevealType <> REVEAL_SPLAYED & iRevealType <> REVEAL_HISTORIC & iRevealType <> REVEAL_DOUBLE_SPLAYED then
					roty wallIncl
					addz -gs_trim_thk_in


					! --- Draw left side Trim Inclined Wall ---

					px2 = -(leftWidth - tolerOffsetLeftIn + overSizeLeftIn - gs_trim_width_in + gs_trim_offs_in) / cos(wallIncl) + gs_trim_thk_in * tan(wallIncl)
					px1 = px2 - gs_tw_left_in

					if	bShapeEnablesStraightTopTrim then
						py1 = B + overSizeTopIn + not(gs_stack_top) * (-gs_trim_width_in - tolerOffsetUpperIn + gs_trim_offs_in + gs_tw_top_in*not(bTrimovtopleftin))
						py2 = B + overSizeTopIn + not(gs_stack_top) * (- gs_trim_width_in - tolerOffsetUpperIn + gs_trim_offs_in)

						s1 = 15 - 7 * (gs_stack_top | bTrimovtopleftin)
						s2 = bitset (mask, 1, not(gs_stack_top))
					endif

					if	bShapeEnablesArchedTopTrim then
						ta = leftWidth + overSizeTopIn - tolerOffsetLeftIn - gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in
						tc = arcR + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in
						py1 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))

						ta = ta - gs_tw_right_in
						tc = tc - gs_tw_right_in
						py2 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))

						s1 = 8
						s2 = mask - 2
					endif

					if iWindowShape = SHAPE_ELLIPSEARCH then
						py1 = B + overSizeTopIn - archHeight
						py2 = py1

						s1 = 8
						s2 = mask - 2
					endif

					if	isWindow | \
						(bPShapedLeftOpening & gs_trim_below_boardLeft) then
						py3 = -overSizeBottomIn + not(bDrawLeftSLBoard) * tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawLeftSLBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawLeftSLBoard)\
							- gs_trimov_bot_left_in - gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron) - gs_apron_width * bTrimovbotleftin * gs_apron) - sjby
						py4 = -overSizeBottomIn + not(bDrawLeftSLBoard) * tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawLeftSLBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawLeftSLBoard)\
							- gs_trimov_bot_left_in - gs_tw_bottom_in * (not(bDrawLeftSLBoard) | (bDrawLeftSLBoard & (bTrimovbotleftin | gs_trim_below_boardLeft))) * not(gs_apron) - gs_apron_width * bTrimovbotleftin * gs_apron) - sjby

						py5=py3 + not(gs_stack_bottom) * (gs_trimov_bot_left_in + gs_tw_bottom_in*bTrimovbotleftin * not(gs_apron) + gs_apron_width * bTrimovbotleftin * gs_apron)
						py6=py3 + not(gs_stack_bottom) * gs_trimov_bot_left_in

						s3 = 15	* isWindow + 15 * bPShapedLeftOpening					! 15 or 10 or 8
						s4 = 13 + 2 * not(gs_stack_bottom)	! 15 or 13
					else
						py3 = -overSizeBottomIn
						py4 = -overSizeBottomIn

						s3 = 15
						s4 = 15
					endif

					if	bPShapedLeftOpening then
						py3 = py3 + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + overSizeBottomIn
						py4 = py4 + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + overSizeBottomIn
						py5 = py5 + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + overSizeBottomIn
						py6 = py6 + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + overSizeBottomIn
					endif

					if not(gs_stack_left | bLeftCornerFunction) & bShapeEnablesStraightLeftTrim then
						! mitered joint of inclined casing
						addz gs_trim_thk_in
						roty -wallIncl + 90
						numMiterCuts = 0
						if bShapeEnablesStraightTopTrim & not(gs_stack_top) then
							if	not(gs_stack_top) & not(bTrimovtoprightin) then
								add 0, B + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in, -leftWidth - overSizeLeftIn + tolerOffsetLeftIn + gs_trim_width_in - gs_trim_offs_in
								py2 = py1
								cutplane{2} 270 + TrimLeftTopMiterAngle, 4
								numMiterCuts = numMiterCuts + 1
								del 1
							endif
						endif
						if	bShapeEnablesArchedTopTrim then
							ta = leftWidth + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in
							tc = arcR + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in
							py1L = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

							ta = ta + gs_tw_right_in
							tc = tc + gs_tw_right_in
							py2L = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

							! mitered joint of inclined casing
							TrimLeftTopMiterAngle	= atn( (py2L - py1L) / (gs_tw_right_in * cos(wallIncl) - bDir * gs_trim_thk_in*incV) )

							py1 = py1 + gs_tw_right_in
							py2 = py1

							add 0, py1L + B - archHeight - tolerOffsetUpperIn, -leftWidth - overSizeLeftIn + tolerOffsetLeftIn + gs_trim_width_in - gs_trim_offs_in
							cutplane{2} 270 + TrimLeftTopMiterAngle, 4
							numMiterCuts = numMiterCuts + 1
							del 1
						endif
						if	((bPShapedLeftOpening & gs_trim_below_boardLeft) | isWindow) & not(bTrimovbotleftin) then
							add 0, gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL - (gs_trim_width_in - gs_trim_offs_in) * bDrawLeftSLBoard + gs_trim_width_in - gs_trim_offs_in, \
									-leftWidth - overSizeLeftIn + tolerOffsetLeftIn + gs_trim_width_in - gs_trim_offs_in
							py3 = py4
							cutplane{2} TrimLeftbotMiterAngle, 4
							numMiterCuts = numMiterCuts + 1
							del 1
						endif
						del 2

						body -1
						if (gs_apron & abs(gs_trim_thk_in - gs_apron_thk) < EPS) | (not(gs_apron) & (not(bDrawLeftSLBoard) | gs_trim_below_boardLeft)) then
							croof_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
								4+2, 0,0, 1,0, 0, 0, -gs_trim_thk_in,
								px1,	py1,	0,			s1,
								px2,	py2,	wallIncl,	s2,
								px2,	py5,	wallIncl,	8,
								px2,	py6,	wallIncl,	15-2 * (gs_stack_bottom),
								px2,	py3,	0,			s3*not(bTrimovbotleftin) + bTrimovbotleftin * (15-7*gs_stack_bottom),
								px1,	py4,	0,			s4
						else
							croof_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
								4+1, 0,0, 1,0, 0, 0, -gs_trim_thk_in,
								px1,	py1,	0,	s1,
								px2,	py2,	wallIncl*bTrimovbotleftin,	s2,
								px2,	py3+gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron)+gs_trimov_bot_left_in, wallIncl*(bTrimovbotleftin), 15-6 * (gs_stack_bottom | ABS(gs_trim_offs_in) < EPS),
								px2,	py3+gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron),	0, 15-7*gs_stack_bottom,
								px1,	py3+gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron),	0, s4

							if not(gs_stack_bottom) & ABS(gs_trim_offs_in) < EPS & bTrimovbotleftin then
								lin_ px2-gs_trim_thk_in * tan(wallIncl),	py3+gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron),							gs_trim_thk_in,
									 px2-gs_trim_thk_in * tan(wallIncl),	py3+gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron)+gs_trimov_bot_left_in,	gs_trim_thk_in
								lin_ px2,	py3+gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron)+gs_trimov_bot_left_in,	gs_trim_thk_in,
									 px2,	py3+gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron)+gs_trimov_bot_left_in,	0
							endif
						endif
						gosub "TextCoord_Vert"
						for i = 1 to numMiterCuts
							cutend
						next i
					endif

					! --- Draw Door's Left side Trim Inclined Wall ---
					py1 = -overSizeBottomIn
					py2 = -overSizeBottomIn
					py3LSL = gs_reveal_double_innerBottom_sL + tolerOffsetLowerIn + gs_sidelight_parapet_hgt_left + not(gs_stack_bottom) * (trinB*not(bDrawLeftSLBoard) \
							 - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawLeftSLBoard)) - sjBy
					py4LSL = gs_reveal_double_innerBottom_sL + tolerOffsetLowerIn + gs_sidelight_parapet_hgt_left + not(gs_stack_bottom) * (trinB*not(bDrawLeftSLBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawLeftSLBoard) - gs_tw_bottom_in) - sjBy

					if	bPShapedLeftOpening & gs_trim_below_boardLeft then
						px2 = -(leftWidth - gs_sidelight_WHole_width_left - tolerOffsetLeftIn + overSizeLeftIn - gs_trim_width_in + gs_trim_offs_in) / cos(wallIncl) + gs_trim_thk_in * tan(wallIncl)
						px1 = px2 - gs_tw_left_in

						! mitered joint of inclined casing
						addz gs_trim_thk_in
						roty -wallIncl + 90
						add 0, gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL - (gs_trim_width_in - gs_trim_offs_in) * bDrawLeftSLBoard + gs_trim_width_in - gs_trim_offs_in, \
								-leftWidth + gs_sidelight_WHole_width_left - overSizeLeftIn + tolerOffsetLeftIn + gs_trim_width_in - gs_trim_offs_in
						cutplane{2} 270 - TrimLeftBotMiterAngle, 4
						del 3
						croof_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							4, 0,0, 1,0, 0, 0, -gs_trim_thk_in,
							px1,	py1,	0,			15,
							px2,	py2,	wallIncl,	s2,
							px2,	py3LSL,	0,			10,
							px1,	py3LSL,	-wallIncl,	s4
						gosub "TextCoord_Vert"

						cutend
					endif

					! --- Draw right side Trim Inclined Wall ---

					px2 = (rightWidth - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in + gs_trim_offs_in) / cos(wallIncl) + gs_trim_thk_in * tan(wallIncl)
					px1 = px2 + gs_tw_right_in

					if	bShapeEnablesStraightTopTrim then
						py1 = B + overSizeTopIn + not(gs_stack_top) * (-gs_trim_width_in - tolerOffsetUpperIn + gs_trim_offs_in + gs_tw_top_in*not(bTrimovtoprightin))
						py2 = B + overSizeTopIn + not(gs_stack_top) * (-gs_trim_width_in - tolerOffsetUpperIn + gs_trim_offs_in)

						s1 = 15 - 7 * (gs_stack_top | bTrimovtoprightin)
						s2 = bitset (mask, 1, not(gs_stack_top))
					endif

					if	bShapeEnablesArchedTopTrim then
						ta = rightWidth + overSizeTopIn - tolerOffsetRightIn - gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in
						tc = arcR + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in
						py1 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))

						ta = ta - gs_tw_right_in
						tc = tc - gs_tw_right_in
						py2 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))

						s1 = 8
						s2 = mask - 2
					endif

					if iWindowShape = SHAPE_ELLIPSEARCH then
						py1 = B + overSizeTopIn - archHeight
						py2 = py1

						s1 = 8
						s2 = mask - 2
					endif

					if	isWindow | \
						(bPShapedRightOpening & gs_trim_below_boardRight) then
						py3 = -overSizeBottomIn + not(bDrawRightSLBoard) * tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawRightSLBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawRightSLBoard) \
						- gs_trimov_bot_right_in - gs_tw_bottom_in*bTrimovbotrightin * not(gs_apron) - gs_apron_width*bTrimovbotrightin * gs_apron) - sjBy
						py4 = -overSizeBottomIn + not(bDrawRightSLBoard) * tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawRightSLBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawRightSLBoard) \
						- gs_trimov_bot_right_in - gs_tw_bottom_in * (not(bDrawRightSLBoard) | (bDrawRightSLBoard & (bTrimovbotrightin | gs_trim_below_boardRight))) * not(gs_apron) - gs_apron_width * bTrimovbotleftin * gs_apron) - sjBy

						py5=py3 + not(gs_stack_bottom) * (gs_trimov_bot_right_in + gs_tw_bottom_in*bTrimovbotrightin)
						py6=py3 + not(gs_stack_bottom) * gs_trimov_bot_right_in

						s3 = 15 * isWindow + 15 * bPShapedRightOpening					! 15 or 10 or 8
						s4 = 13 + 2 * not(gs_stack_bottom)	! 15 or 13
					else
						py3 = -overSizeBottomIn
						py4 = -overSizeBottomIn

						s3 = 15
						s4 = 15
					endif

					if	bPShapedRightOpening then
						py3 = py3 + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + overSizeBottomIn
						py4 = py4 + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + overSizeBottomIn
						py5 = py5 + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + overSizeBottomIn
						py6 = py6 + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + overSizeBottomIn
					endif

					if not(gs_stack_right | bRightCornerFunction) then
						! mitered joint of inclined casing
						addz gs_trim_thk_in
						roty -wallIncl + 90
						numMiterCuts = 0
						if bShapeEnablesStraightTopTrim & not(gs_stack_top) then
							if	not(gs_stack_top) & not(bTrimovtoprightin) then
								add 0, B + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in, rightWidth + overSizeRightIn - tolerOffsetRightIn - gs_trim_width_in + gs_trim_offs_in
								py2 = py1
								cutplane{2} 270 - TrimRightTopMiterAngle, 4
								numMiterCuts = numMiterCuts + 1
								del 1
							endif
						endif

						if	bShapeEnablesArchedTopTrim then
							ta = rightWidth + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in
							tc = arcR + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in
							py1R = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

							ta = ta + gs_tw_right_in
							tc = tc + gs_tw_right_in
							py2R = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

							! mitered joint of inclined casing
							TrimRightTopMiterAngle	= atn( (py2R - py1R) / (gs_tw_right_in * cos(wallIncl) + not(bDir) * gs_trim_thk_in*incV) )

							py1 = py1 + gs_tw_right_in
							py2 = py1

							add 0, py1R + B - archHeight - tolerOffsetUpperIn, rightWidth + overSizeRightIn - tolerOffsetRightIn - gs_trim_width_in + gs_trim_offs_in
							cutplane{2} 270 - TrimRightTopMiterAngle, 4
							numMiterCuts = numMiterCuts + 1
							del 1
						endif

						if	((bPShapedRightOpening & gs_trim_below_boardRight) | isWindow) & not(bTrimovbotrightin) then
							add 0, gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR - (gs_trim_width_in - gs_trim_offs_in) * bDrawRightSLBoard + gs_trim_width_in - gs_trim_offs_in, \
									rightWidth + overSizeRightIn - tolerOffsetRightIn - gs_trim_width_in + gs_trim_offs_in
							py3 = py4
							cutplane{2} 180 - TrimRightBotMiterAngle, 4
							numMiterCuts = numMiterCuts + 1
							del 1
						endif

						del 2

						body -1
						if (gs_apron & abs(gs_trim_thk_in - gs_apron_thk) < EPS) | (not(gs_apron) & (not(bDrawRightSLBoard) | gs_trim_below_boardRight)) then
							croof_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
								4+2, 0,0, 1,0, 0, 0, -gs_trim_thk_in,
								px1,	py1,	0,			s1,
								px2,	py2,	-wallIncl,	s2,
								px2,	py5,	-wallIncl,	8,
								px2,	py6,	-wallIncl,	15-2 * gs_stack_bottom,
								px2,	py3,	0,			s3*not(bTrimovbotrightin)+bTrimovbotrightin*(15-7*gs_stack_bottom),
								px1,	py4,	0,			s4
						else
							croof_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
								4+1, 0,0, 1,0, 0, 0, -gs_trim_thk_in,
								px1,	py1,	0,			s1,
								px2,	py2,	-wallIncl,	s2,
								px2,	py3+gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron)+gs_trimov_bot_right_in, 0, 15-6 * (gs_stack_bottom | ABS(gs_trim_offs_in) < EPS),
								px2,	py3+gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron),	0, 15-7*gs_stack_bottom,
								px1,	py3+gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron),	0, s4

							if not(gs_stack_bottom) & ABS(gs_trim_offs_in) < EPS & bTrimovbotrightin then
								lin_ px2-gs_trim_thk_in * tan(wallIncl),	py3+gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron),						gs_trim_thk_in,
									 px2-gs_trim_thk_in * tan(wallIncl),	py3+gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron)+gs_trimov_bot_right_in, gs_trim_thk_in
								lin_ px2,	py3+gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron)+gs_trimov_bot_right_in, gs_trim_thk_in,
									 px2,	py3+gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron)+gs_trimov_bot_right_in, 0
							endif
						endif
						gosub "TextCoord_Vert"
						for i = 1 to numMiterCuts
							cutend
						next i
					endif

					! --- Draw Door's Right side Trim Inclined Wall ---
					py1 = -overSizeBottomIn
					py2 = -overSizeBottomIn
					py3RSL = gs_reveal_double_innerBottom_sR + tolerOffsetLowerIn + gs_sidelight_parapet_hgt_right + not(gs_stack_bottom) * (trinB*not(bDrawRightSLBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawRightSLBoard)) - sjBy
					py4RSL = gs_reveal_double_innerBottom_sR + tolerOffsetLowerIn + gs_sidelight_parapet_hgt_right + not(gs_stack_bottom) * (trinB*not(bDrawRightSLBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawRightSLBoard) - gs_tw_bottom_in) - sjBy

					if	bPShapedRightOpening & gs_trim_below_boardRight then
						px2 = (rightWidth - gs_sidelight_WHole_width_right - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in + gs_trim_offs_in) / cos(wallIncl) + gs_trim_thk_in * tan(wallIncl)
						px1 = px2 + gs_tw_right_in

						! mitered joint of inclined casing
						addz gs_trim_thk_in
						roty -wallIncl + 90
						add 0, gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR - (gs_trim_width_in - gs_trim_offs_in) * bDrawRightSLBoard + gs_trim_width_in - gs_trim_offs_in, \
									rightWidth - gs_sidelight_WHole_width_right + overSizeRightIn - tolerOffsetRightIn - gs_trim_width_in + gs_trim_offs_in

						cutplane{2}   TrimRightBotMiterAngle - 90, 4
						del 3

						croof_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							4, 0,0, 1,0, 0, 0, -gs_trim_thk_in,
							px1,	py1,	0,			15,
							px2,	py2,	-wallIncl,	s2,
							px2,	py3RSL,	0,			10,
							px1,	py3RSL,	wallIncl,	s4
						gosub "TextCoord_Vert"
						cutend
					endif

					if	bPShapedLeftOpening & gs_trim_below_boardLeft then
						! --- Draw Left lower Trim Inclined Wall ---
						px2 = (gs_trim_width_in - gs_trim_offs_in) / cos(wallIncl)
						px1 = px2 - gs_tw_left_in * not(bTrimovbotleftin)
						px3 = gs_tw_left_in
						pxL = -(leftWidth - tolerOffsetLeftIn + overSizeLeftIn)  / cos(wallIncl) + bBottomtriminthk * tan(wallIncl)
						pxR = -(leftWidth - gs_sidelight_WHole_width_left - gs_trim_width_in + gs_trim_offs_in + overSizeLeftIn)  / cos(wallIncl) + bBottomtriminthk * tan(wallIncl)

						! mitered joint of inclined casing
						if	not(gs_stack_left) & not(gs_trimov_bot_left_in) then
							lin_ pxL + not(gs_stack_left)  * px2,	py3LSL,	0,
								 pxL + not(gs_stack_left)  * px2 - gs_trim_thk_in * tan(wallIncl),	py3LSL,	gs_trim_thk_in
						endif
						lin_ pxR - gs_tw_left_in,	py4LSL,	0,
							 pxR - gs_tw_left_in - gs_trim_thk_in * tan(wallIncl),	py4LSL,	gs_trim_thk_in

						addz gs_trim_thk_in
						roty -wallIncl + 90
						numMiterCuts = 0
						if	not(gs_stack_left) & not(bTrimovbotleftin) then
							add 0, gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL - (gs_trim_width_in - gs_trim_offs_in) * bDrawLeftSLBoard + gs_trim_width_in - gs_trim_offs_in, \
									-leftWidth - overSizeLeftIn + tolerOffsetLeftIn + gs_trim_width_in - gs_trim_offs_in
							px2 = px1
							cutplane{2} 180 + TrimLeftBotMiterAngle, 4
							numMiterCuts = numMiterCuts + 1
							del 1
						endif
						add 0, gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL - (gs_trim_width_in - gs_trim_offs_in) * bDrawLeftSLBoard + gs_trim_width_in - gs_trim_offs_in, \
								-leftWidth + gs_sidelight_WHole_width_left - overSizeLeftIn + tolerOffsetLeftIn + gs_trim_width_in - gs_trim_offs_in
						px4 = px3
						cutplane{2} 90 - TrimLeftBotMiterAngle, 4
						numMiterCuts = numMiterCuts + 1
						del 1
						del 2

						croof_ bBottomtriminmat, bBottomtriminmat, bBottomtriminmat,
							4, 0,0, 1,0, 0, 0, -bBottomtriminthk,
							pxL + not(gs_stack_left)  * px1,	py4LSL, 	-gs_stack_left * wallIncl * not(bTrimovbotleftin),	15,
							pxL + not(gs_stack_left)  * px2,	py3LSL,		0,													mask - 2 * gs_stack_left,
							pxR + px3,							py3LSL,		wallIncl * bTrimovbotrightin,						maskRight + 5 * not(gs_trim_below_boardLeft),
							pxR + px3,							py4LSL, 	0,													13
						gosub "TextCoord_Hor"
						for i = 1 to numMiterCuts
							cutend
						next i
					endif

					if	bPShapedRightOpening & gs_trim_below_boardRight then
						! --- Draw Right lower Trim Inclined Wall ---
						px2 = -(gs_trim_width_in - gs_trim_offs_in) / cos(wallIncl)
						px1 = px2 + gs_tw_right_in * not(bTrimovbotrightin)
						px3 = -gs_tw_right_in
						pxL = (rightWidth - tolerOffsetRightIn + overSizeRightIn)  / cos(wallIncl) + bBottomtriminthk * tan(wallIncl)
						pxR = (rightWidth - gs_sidelight_WHole_width_right - gs_trim_width_in + gs_trim_offs_in + overSizeRightIn)  / cos(wallIncl) + bBottomtriminthk * tan(wallIncl)

						! mitered joint of inclined casing
						if	not(gs_stack_right) & not(gs_trimov_bot_right_in) then
							lin_ pxL + not(gs_stack_right)  * px2,	py3RSL,	0,
								 pxL + not(gs_stack_right)  * px2 - gs_trim_thk_in * tan(wallIncl),	py3RSL,	gs_trim_thk_in
						endif
						lin_ pxR + gs_tw_right_in,	py4RSL,	0,
							 pxR + gs_tw_right_in - gs_trim_thk_in * tan(wallIncl),	py4RSL,	gs_trim_thk_in

						addz gs_trim_thk_in
						roty -wallIncl + 90
						numMiterCuts = 0
						if	not(gs_stack_right) & not(bTrimovbotrightin) then
							add 0, gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR - (gs_trim_width_in - gs_trim_offs_in) * bDrawRightSLBoard + gs_trim_width_in - gs_trim_offs_in, \
									rightWidth + overSizeRightIn - tolerOffsetRightIn - gs_trim_width_in + gs_trim_offs_in
							px2 = px1
							cutplane{2} 360 - TrimRightBotMiterAngle, 4
							numMiterCuts = numMiterCuts + 1
							del 1
						endif
						add 0, gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR - (gs_trim_width_in - gs_trim_offs_in) * bDrawRightSLBoard + gs_trim_width_in - gs_trim_offs_in, \
									rightWidth - gs_sidelight_WHole_width_right + overSizeRightIn - tolerOffsetRightIn - gs_trim_width_in + gs_trim_offs_in
						cutplane{2} TrimRightBotMiterAngle + 90, 4
						numMiterCuts = numMiterCuts + 1
						del 1
						del 2

						croof_ bBottomtriminmat, bBottomtriminmat, bBottomtriminmat,
							4, 0,0, 1,0, 0, 0, -bBottomtriminthk,
							pxL + not(gs_stack_right)  * px1,	py4RSL, 	-gs_stack_right * wallIncl * not(bTrimovbotrightin),	15,
							pxL + not(gs_stack_right)  * px2,	py3RSL,		0,		mask - 2 * gs_stack_right,
							pxR + px3,							py3RSL,		wallIncl * bTrimovbotrightin,	maskRight + 5 * not(gs_trim_below_boardRight),
							pxR + px3,							py4RSL, 	0,				13
						gosub "TextCoord_Hor"
						for i = 1 to numMiterCuts
							cutend
						next i
					endif


					! --- Draw upper Trim  Inclined Wall ---

					px2 = (gs_trim_width_in - gs_trim_offs_in) / cos(wallIncl)
					px1 = px2 - gs_tw_left_in
					px3 = -px2
					px4 = px3 + gs_tw_right_in
					pxL = -(leftWidth - tolerOffsetLeftIn + overSizeLeftIn)  / cos(wallIncl) + gs_trim_thk_in * tan(wallIncl)
					pxR =  (rightWidth - tolerOffsetRightIn + overSizeRightIn) / cos(wallIncl) + gs_trim_thk_in * tan(wallIncl)

					py2 = B - tolerOffsetUpperIn + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in
					py1 = py2 + gs_tw_top_in

					numMiterCuts = 0

					if bShapeEnablesStraightTopTrim & not(gs_stack_top) then

						! mitered joint of inclined casing
						if	not(gs_stack_left) & not(bTrimovtopleftin) then
							lin_ pxL + not(gs_stack_left)  * px2,	py2,	0,
								 pxL + not(gs_stack_left)  * px2 - gs_trim_thk_in * tan(wallIncl),	py2,	gs_trim_thk_in
						endif
						if	not(gs_stack_right) & not(bTrimovtoprightin) then
							lin_ pxR - not(gs_stack_right)  * px2,	py2,	0,
								 pxR - not(gs_stack_right)  * px2 - gs_trim_thk_in * tan(wallIncl),	py2,	gs_trim_thk_in
						endif
						addz gs_trim_thk_in
						roty -wallIncl + 90
						if	not(gs_stack_left) & not(bTrimovtopleftin) then
							add 0, B + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in, -leftWidth - overSizeLeftIn + tolerOffsetLeftIn + gs_trim_width_in - gs_trim_offs_in
							px2 = px1
							cutplane{2} 90 + TrimLeftTopMiterAngle, 4
							numMiterCuts = numMiterCuts + 1
							del 1
						endif
						if	not(gs_stack_right) & not(bTrimovtoprightin) then
							add 0, B + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in, rightWidth + overSizeRightIn - tolerOffsetRightIn - gs_trim_width_in + gs_trim_offs_in
							px3 = px4
							cutplane{2} 90 - TrimRightTopMiterAngle, 4
							numMiterCuts = numMiterCuts + 1
							del 1
						endif
						del 2

						if not(bTrimovtopleftin) and not(bTrimovtoprightin) then
							croof_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
								4, 0,0, 1,0, 0, 0, -gs_trim_thk_in,
								pxL + not(gs_stack_left)  * px1,	py1,	-gs_stack_left * wallIncl,	8 + 7 * not(gs_stack_left),
								pxL + not(gs_stack_left)  * px2,	py2,	0,							bitset (mask, 1, not(gs_stack_left)),
								pxR + not(gs_stack_right) * px3,	py2,	gs_stack_right * wallIncl,	8 + 7 * not(gs_stack_right),
								pxR + not(gs_stack_right) * px4,	py1, 	0,							13 + 2 * not(gs_stack_right)
						endif
						if bTrimovtopleftin and not(bTrimovtoprightin) then
							croof_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
								4+2, 0,0, 1,0, 0, 0, -gs_trim_thk_in,
								pxL + not(gs_stack_left)  * px1-gs_trimov_top_left_in*not(gs_stack_left),	py1,	-gs_stack_left * wallIncl,	8 + 7 * not(gs_stack_left),
								pxL + not(gs_stack_left)  * px1-gs_trimov_top_left_in*not(gs_stack_left),	py2,	0,						15,
								pxL + not(gs_stack_left)  * px1,											py2,	0,						10,
								pxL + not(gs_stack_left)  * px2,											py2,	0,						bitset (mask, 1, not(gs_stack_left)),
								pxR + not(gs_stack_right) * px3,											py2,	gs_stack_right * wallIncl,	8 + 7 * not(gs_stack_right),
								pxR + not(gs_stack_right) * px4,											py1, 	0,						13 + 2 * not(gs_stack_right)
						endif
						if not(bTrimovtopleftin) and bTrimovtoprightin then
							croof_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
								4+2, 0,0, 1,0, 0, 0, -gs_trim_thk_in,
								pxL + not(gs_stack_left)  * px1,											py1,	-gs_stack_left * wallIncl,	8 + 7 * not(gs_stack_left),
								pxL + not(gs_stack_left)  * px2,											py2,	0,						bitset (mask, 1, not(gs_stack_left)),
								pxR + not(gs_stack_right) * px3,											py2,	gs_stack_right * wallIncl,	10,
								pxR + not(gs_stack_right) * px4,											py2, 	0,						15,
								pxR + not(gs_stack_right) * px4+gs_trimov_top_right_in*not(gs_stack_right),	py2, 	0,						8 + 7 * not(gs_stack_right),
								pxR + not(gs_stack_right) * px4+gs_trimov_top_right_in*not(gs_stack_right),	py1, 	0,						15
						endif
						if bTrimovtopleftin and bTrimovtoprightin then
							if gs_trimtype_in_int = CASING_NORMAL then				! Rectangular casing type
								croof_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
									4+4, 0,0, 1,0, 0, 0, -gs_trim_thk_in,
									pxL + not(gs_stack_left)  * px1-gs_trimov_top_left_in*not(gs_stack_left),	py1,	-gs_stack_left * wallIncl,	8 + 7 * not(gs_stack_left),
									pxL + not(gs_stack_left)  * px1-gs_trimov_top_left_in*not(gs_stack_left),	py2,	0,						15,
									pxL + not(gs_stack_left)  * px1,											py2,	0,						maskLeft,
									pxL + not(gs_stack_left)  * px2,											py2,	0,						bitset (mask, 1, not(gs_stack_left)),

									pxR + not(gs_stack_right) * px3,											py2,	gs_stack_right * wallIncl,	maskRight,
									pxR + not(gs_stack_right) * px4,											py2, 	0,						15,
									pxR + not(gs_stack_right) * px4+gs_trimov_top_right_in*not(gs_stack_right),	py2, 	0,						8 + 7 * not(gs_stack_right),
									pxR + not(gs_stack_right) * px4+gs_trimov_top_right_in*not(gs_stack_right),	py1, 	0,						15
							endif

							if gs_trimtype_in_int = CASING_OVERHANG then				! SWE traditional casing type
								croof_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
									5+5, 0,0, 1,0, 0, 0, -gs_trim_thk_in,
									pxL + not(gs_stack_left)  * (px1-gs_trimov_top_left_in),	py1,		-gs_stack_left * wallIncl,	8 + 7 * not(gs_stack_left),
									pxL + not(gs_stack_left)  * (px1-gs_trimov_top_left_in),	py1-0.04,	-gs_stack_left * wallIncl,	8 + 7 * not(gs_stack_left),
									pxL + not(gs_stack_left)  * (px1-gs_trimov_top_left_in/2),	py2,		0,							15,
									pxL + not(gs_stack_left)  * px1,							py2,		0,							maskLeft,
									pxL + not(gs_stack_left)  * px2,							py2,		0,							bitset (mask, 1, not(gs_stack_left)),

									pxR + not(gs_stack_right) * px3,							py2,		gs_stack_right * wallIncl,	maskRight,
									pxR + not(gs_stack_right) * px4,							py2, 		0,							15,
									pxR + not(gs_stack_right) * (px4+gs_trimov_top_right_in/2),	py2, 		0,							8 + 7 * not(gs_stack_right),
									pxR + not(gs_stack_right) * (px4+gs_trimov_top_right_in),	py1-0.04, 	0,							15,
									pxR + not(gs_stack_right) * (px4+gs_trimov_top_right_in),	py1, 		0,							15
							endif
						endif
					endif

					if	bShapeEnablesArchedTopTrim then

						resol nArchResolution

						pxL = (-leftWidth - overSizeLeftIn + tolerOffsetLeftIn + gs_trim_width_in - gs_trim_offs_in) / cos(wallIncl)
						pxR = (rightWidth + overSizeLeftIn - tolerOffsetRightIn - gs_trim_width_in + gs_trim_offs_in) / cos(wallIncl)
						px1 = gs_trim_thk_in * tan(wallIncl)

						IncModifiedRad = ((leftWidth / cos(wallIncl))^2 + archHeight^2) / (2 * archHeight)

						addy B - archHeight - tolerOffsetUpperIn

						ta = leftWidth + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in
						tc = arcR + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in
						py1L = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

						ta = ta + gs_tw_right_in
						tc = tc + gs_tw_right_in
						py2L = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

						ta = rightWidth + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in
						tc = arcR + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in
						py1R = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

						ta = ta + gs_tw_right_in
						tc = tc + gs_tw_right_in
						py2R = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

						! mitered joint of inclined casing
						TrimLeftTopMiterAngle	= atn( (py2L - py1L) / (gs_tw_right_in * cos(wallIncl) - bDir * gs_trim_thk_in*incV) )
						TrimRightTopMiterAngle	= atn( (py2R - py1R) / (gs_tw_right_in * cos(wallIncl) + not(bDir) * gs_trim_thk_in*incV) )
						addz gs_trim_thk_in
						roty -wallIncl + 90

						add 0, py1L, -leftWidth - overSizeLeftIn + tolerOffsetLeftIn + gs_trim_width_in - gs_trim_offs_in
						cutplane{2} 90 + TrimLeftTopMiterAngle, 4
						numMiterCuts = numMiterCuts + 1
						del 1
						add 0, py1R, rightWidth + overSizeRightIn - tolerOffsetRightIn - gs_trim_width_in + gs_trim_offs_in
						cutplane{2} 90 - TrimRightTopMiterAngle, 4
						numMiterCuts = numMiterCuts + 1
						del 1

						del 2

						cutform 5,1,1 + 2 + 8 + 16,
							-sin(wallIncl), 0, cos(wallIncl),	0,
							px1,		archHeight - IncModifiedRad,	900,
							pxL + px1,	py1L-0.5,	  		8,
							pxR + px1,	py1L-0.5,			8,
!							pxR + px1,	py1R-0.00001,	  	15,
							pxR + px1,	py1R,	  			62 + mask,
							pxL + px1,	py1L,	  			3015 - 7 * bHalfCircle

						prism_ 10, gs_trim_thk_in,
							px1,						archHeight - IncModifiedRad,	900,
							pxL + px1,					py1L-1,	  			15,
							pxL + px1,					py1L,	  			15,
							pxR + px1,					py1R,				15,
							pxR + px1,					py1R-1,				15,
							pxR + px1 + gs_tw_right_in,	py1R-1,				15,
							pxR + px1 + gs_tw_right_in,	py2R-0.0001,		15,
							pxR + px1 + gs_tw_right_in,	py2R,				79,
							pxL + px1 - gs_tw_right_in,	py2L,				3015 - 7 * bHalfCircle,
							pxL + px1 - gs_tw_right_in,	py1L-1,	  			15

						cutend

						del 1
					endif

					if iWindowShape = SHAPE_ELLIPSEARCH then

						resol nArchResolution

						pxt = gs_trim_thk_in * tan(wallIncl)
						px1 = -leftWidth - overSizeLeftIn + tolerOffsetLeftIn - gs_trim_offs_in + gs_trim_width_in
						px2 =  rightWidth + overSizeLeftIn - tolerOffsetRightIn + gs_trim_offs_in - gs_trim_width_in
						px3 = -leftWidth - overSizeLeftIn + tolerOffsetLeftIn
						px4 = rightWidth + overSizeLeftIn - tolerOffsetRightIn
						py1 = B + overSizeTopIn - tolerOffsetUpperIn

						pxcL = -leftWidth + smallRadiusEllips
						pxcR = rightWidth - smallRadiusEllips

						s1 = 9 + 4 * (abs(gs_trim_offs_in) > EPS | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS)

						addx pxt
						roty -wallIncl
						cutform 7,1,1 + 2 + 8 + 16,
							0, 0, 1,	0,
							px2,					py1 - archHeight,			s1,
							pxcR,					py1 - archHeight,			900+s1,
							0,		 				alphaSide,					4000+s1,
							0,						py1 - middleRadiusEllips, 	900+s1,
							0,		 				alphaMiddle,				4000+s1,
							pxcL,					py1 - archHeight,			900+s1,
							0,		 				alphaSide,					4000+s1
						del 2

						mulx 1 / cos(wallIncl)

						prism_ 7,gs_trim_thk_in,
							px2 + (gs_tw_right_in + pxt) * cos(wallIncl),	py1 - archHeight,			13+64,
							pxcR + pxt * cos(wallIncl),						py1 - archHeight,			915+64,
							0,		 										alphaSide,					4015+64,
							0 + pxt * cos(wallIncl),						py1 - middleRadiusEllips, 	915+64,
							0,		 										alphaMiddle,				4015+64,
							pxcL + pxt * cos(wallIncl),						py1 - archHeight,			915+64,
							0,		 										alphaSide,					4008+64
						del 1

						cutend
					endif
					gosub "TextCoord_Hor"
					for i = 1 to numMiterCuts
						cutend
					next i

					! --- Draw lower Trim  Inclined Wall ---
					px2 = (gs_trim_width_in - gs_trim_offs_in) / cos(wallIncl)
					px1 = px2 - gs_tw_left_in * not(bTrimovbotleftin)
					px3 = -px2
					px4 = px3 + gs_tw_right_in * not(bTrimovbotrightin)


					py1 = -overSizeBottomIn + not(gs_stack_bottom) * (gs_trim_width_in*not(bDrawBoard) + tolerOffsetLowerIn - gs_trim_offs_in - gs_tw_bottom_in)
					py2 = -overSizeBottomIn + not(gs_stack_bottom) * (gs_trim_width_in*not(bDrawBoard) + tolerOffsetLowerIn - gs_trim_offs_in)

					addz gs_trim_thk_in
					roty -wallIncl + 90
					numMiterCuts = 0
					if	not(gs_stack_left) & not(bTrimovbotleftin) then
						add 0, -overSizeBottomIn + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL - (gs_trim_width_in - gs_trim_offs_in) * bDrawLeftSLBoard + gs_trim_width_in - gs_trim_offs_in, \
								-leftWidth - overSizeLeftIn + tolerOffsetLeftIn + gs_trim_width_in - gs_trim_offs_in
						px2 = px1

						cutplane{2} 180 + TrimLeftBotMiterAngle, 4
						numMiterCuts = numMiterCuts + 1
						del 1
					endif
					if	not(gs_stack_right) & not(bTrimovbotrightin) then
						add 0, -overSizeBottomIn + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR - (gs_trim_width_in - gs_trim_offs_in) * bDrawRightSLBoard + gs_trim_width_in - gs_trim_offs_in, \
								rightWidth + overSizeRightIn - tolerOffsetRightIn - gs_trim_width_in + gs_trim_offs_in
						px3 = px4
						cutplane{2} 360 - TrimRightBotMiterAngle, 4
						numMiterCuts = numMiterCuts + 1
						del 1
					endif
					del 2

					if not(gs_stack_bottom | not(isWindow)) & bShapeEnablesStraightBottomTrim & abs(gs_tw_bottom_in) > EPS then
						if (not(gs_apron) & not(bDrawBoard)) then
							material bBottomtriminmat
							if abs(gs_trim_thk_in - gs_apron_thk) < EPS | (not(gs_apron) & not(bDrawBoard)) then
								pxL = -(leftWidth - tolerOffsetLeftIn + overSizeLeftIn)  / cos(wallIncl) + bBottomtriminthk * tan(wallIncl)
								pxR =  (rightWidth - tolerOffsetRightIn + overSizeRightIn) / cos(wallIncl) + bBottomtriminthk * tan(wallIncl)

								croof_ bBottomtriminmat, bBottomtriminmat, bBottomtriminmat,
									4+2, 0,0, 1,0, 0, 0, -bBottomtriminthk,
									pxL + not(gs_stack_left)  * px1,	py1, 	-gs_stack_left * wallIncl * not(bTrimovbotleftin),	maskLeft*not(bDrawBoard)+maskLeft2*bDrawBoard,
									pxL + not(gs_stack_left)  * px1,	py1 + gs_tw_bottom_in*bDrawBoard, 	-wallIncl*(bTrimovbotleftin), 15 - 7 * gs_stack_left,
									pxL + not(gs_stack_left)  * px2,	py2,				0,				bitset (mask, 1, not(gs_stack_left)),
									pxR + not(gs_stack_right) * px3,	py2,				wallIncl * bTrimovbotrightin,	15 - 7 * gs_stack_right,
									pxR + not(gs_stack_right) * px4,	py1 + gs_tw_bottom_in*bDrawBoard, 	wallIncl*bTrimovbotrightin, maskRight*not(bDrawBoard)+maskRight2*bDrawBoard,
									pxR + not(gs_stack_right) * px4,	py1, 	0,				13 + 2 * not(gs_stack_right)	! 15 or 13
							else
								pxL = -(leftWidth  + overSizeLeftIn)  / cos(wallIncl) + (gs_trim_thk_in*not(bTrimovbotleftin)+bBottomtriminthk*bTrimovbotleftin) * tan(wallIncl)
								pxR =  (rightWidth + overSizeRightIn) / cos(wallIncl) + (gs_trim_thk_in*not(bTrimovbotrightin)+bBottomtriminthk*bTrimovbotrightin) * tan(wallIncl)

								addz (gs_trim_thk_in - gs_apron_thk)
								croof_ bBottomtriminmat, bBottomtriminmat, bBottomtriminmat,
									4, 0,0, 1,0, 0, 0, -bBottomtriminthk,
									pxL + not(gs_stack_left)  * px1,	py1, 	-wallIncl*bTrimovbotleftin,	8 + 7 * not(gs_stack_left),
									pxL + not(gs_stack_left)  * px1,	py2, 	0, 13 + 2 * not(gs_stack_left),
									pxR + not(gs_stack_right) * px4,	py2, 	wallIncl*bTrimovbotrightin, 8 + 7 * not(gs_stack_right),
									pxR + not(gs_stack_right) * px4,	py1, 	0,	13 + 2 * not(gs_stack_right)
								del 1
							endif
							material gs_trim_in_mat
						endif
					endif
					gosub "TextCoord_Hor"
					for i = 1 to numMiterCuts
						cutend
					next i

					del 2
				endif
			else		! Straight wall

				addz -gs_trim_thk_in


				! --- Draw left side Trim ---

				px2 = leftRevealPnts[idxBoardEndRevealLeft][1]  + tolerOffsetLeftIn + trinL - gs_trim_offs_in
				px1 = px2 - gs_tw_left_in

				if	bShapeEnablesStraightTopTrim then
					py1 = B + overSizeTopIn + not(gs_stack_top) * (- tolerOffsetUpperIn - trinT + gs_trim_offs_in + gs_tw_top_in*not(bTrimovtopleftin)) + sjty
					py2 = B + overSizeTopIn + not(gs_stack_top) * (- tolerOffsetUpperIn - trinT + gs_trim_offs_in) + sjty
					py22 = py2 - gs_stack_top * gs_trim_stack_top * gs_tw_top_in / 2

					s1 = maskTop				! 15 or 10 or 8
					if not(gs_stack_top) then
						s2 = bitset (mask, 1, not(gs_stack_top)) + 4 * gs_trim_atframe_in
					else
						s2 = 9 + 4 * gs_trim_atframe_in
					endif
					s22 = bitset (mask, 1, not(gs_stack_top)) + 4 * gs_trim_atframe_in
					if iWindowShape = SHAPE_RECTANGULAR then
						s5 = 9 + 4 * gs_trim_atframe_in
					else
						s5 = 10
					endif
				endif
				if	bShapeEnablesArchedTopTrim then
					ta = leftWidth + overSizeTopIn - tolerOffsetLeftIn - gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in
					tc = arcR + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in
					py1 = B - arcR - tolerOffsetUpperIn + sqr(max(0, (tc * tc - ta * ta))) - tolerOffsetUpper * not(bHalfCircle)

					ta = ta - gs_tw_right_in
					tc = tc - gs_tw_right_in
					py2 = B - arcR - tolerOffsetUpperIn + sqr(max(0, (tc * tc - ta * ta))) - tolerOffsetUpper * not(bHalfCircle)
					py22 = py2

					s1 = 8
					s2 = mask - 2
					s22 = mask - 2
					if iWindowShape = SHAPE_ARCHED then
						s5 = 9 + 4 * gs_trim_atframe_in
					else
						s5 = 10
					endif
				endif
				if iWindowShape = SHAPE_ELLIPSEARCH then
					py1 = B - archHeight
					py2 = B - archHeight
					py22 = py2

					s1 = 8
					s2 = mask - 2
					s22 = 9 + 4 * (abs(gs_trim_offs_in) > EPS | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS)
					s5 = 9 + 4 * gs_trim_atframe_in
				endif
				if	isWindow | \
					(bPShapedLeftOpening & gs_trim_below_boardLeft) then
					py3 = -overSizeBottomIn + not(bDrawLeftSLBoard) * tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawLeftSLBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawLeftSLBoard)\
					  - gs_trimov_bot_left_in - gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron) - gs_apron_width * bTrimovbotleftin * gs_apron) - sjby
					py4 = -overSizeBottomIn + not(bDrawLeftSLBoard) * tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawLeftSLBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawLeftSLBoard)\
					 - gs_trimov_bot_left_in - gs_tw_bottom_in * (not(bDrawLeftSLBoard) | (bDrawLeftSLBoard & (bTrimovbotleftin | gs_trim_below_boardLeft))) * not(gs_apron) - gs_apron_width * bTrimovbotleftin * gs_apron) - sjby

					s3 = maskBottom						! 15 or 10 or 8
					s4 = 13 + 2 * not(gs_stack_bottom)	! 15 or 13
				else
					py3 = -overSizeBottomIn
					py4 = -overSizeBottomIn

					s3 = 15-7*gs_stack_bottom
					s4 = 15
				endif

				py5 = py3 + not(gs_stack_bottom) * bTrimovbotleftin * (gs_trimov_bot_left_in + gs_tw_bottom_in * not(gs_apron) + gs_apron_width * gs_apron) + gs_stack_bottom * gs_trim_stack_bottom * gs_tw_bottom_in / 2
				py6 = py3 + not(gs_stack_bottom) * bTrimovbotleftin * gs_trimov_bot_left_in

				if	bPShapedLeftOpening then
					py3 = py3 + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + overSizeBottomIn
					py4 = py4 + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + overSizeBottomIn
					py5 = py5 + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + overSizeBottomIn
					py6 = py6 + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + overSizeBottomIn
				endif

				if bDrawBottTrimatGangingIn * not(bGangedCasingonFrame) then
					py6 = py6 + tolerOffsStackCasLowerIn + trinB - gs_trim_offs_in
					s5 = 13
				endif
				if bDrawTopTrimatGangingIn then
					py22 = py2
					if not(bGangedCasingonFrame) then
						py22 = py2 - tolerOffsStackCasUpperIn - trinT + gs_trim_offs_in
						s2 = 10
						s5 = 13
					endif
				endif

				pxWCutTopLeftIn		= px1
				pxWCutTopOHLeftIn	= px1
				pxWCutMidLeftIn		= px1
				pxWCutMidOHLeftIn	= px2
				pxWCutBotLeftIn		= px1
				pyWCutTopLeftIn		= py1
				pyWCutTopOHIn		= py1
				pyWCutMidLeftIn		= py4

				if not(gs_stack_left | bLeftCornerFunction) & bShapeEnablesStraightLeftTrim then

					body -1
					if (gs_apron & abs(gs_trim_thk_in - gs_apron_thk) < EPS) | (not(gs_apron) & (not(bDrawLeftSLBoard) | gs_trim_below_boardLeft) & (isWindow | bPShapedLeftOpening)) then
						if iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE_SPLAYED then
							ruled{2} 7, 1+2+4,
								px1,	py1 + scTy * bTrimovtopleftin,	0,
								px2 - scLx,	py2 + scTy,	0,
								px2 - scLx,	py22 + scTy,	0,
								px2 - scLx,	py5 - scBy,	0,
								px2 - scLx,	py6 - scBy,	0,
								px2 - scLx,	py3 - scBy,	0,
								px1,	py4,	0,

								px1,	py1,	gs_trim_thk_in,
								px2,	py2,	gs_trim_thk_in,
								px2,	py22,	gs_trim_thk_in,
								px2,	py5,	gs_trim_thk_in,
								px2,	py6,	gs_trim_thk_in,
								px2,	py3,	gs_trim_thk_in,
								px1,	py4,	gs_trim_thk_in

							lin_ px2 - scLx, py2 + scTy, 0, px2 - scLx, py3 - scBy, 0
							lin_ px1, py1 + scTy * bTrimovtopleftin, 0, px1, py4, 0
							lin_ px1, py1 + scTy * bTrimovtopleftin, gs_trim_thk_in, px1, py4, gs_trim_thk_in
						else
							cprism_{2} gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
								7, gs_trim_thk_in,
								px1,	py1,	0, s1, gs_trim_in_mat,
								px2,	py2,	0, s2, gs_trim_in_mat,
								px2,	py22,	0, s22, gs_trim_in_mat,
								px2,	py5,	0, s5, gs_trim_in_mat,
								px2,	py6,	0, s3*not(bTrimovbotleftin)+bTrimovbotleftin*15, gs_trim_in_mat,
								px2,	py3,	0, (s3+5*not(gs_tw_bottom_in))*not(bTrimovbotleftin)+bTrimovbotleftin*(15-7*gs_stack_bottom), gs_trim_in_mat,
								px1,	py4,	0, s4, gs_trim_in_mat
						endif
					else
						if iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE_SPLAYED then
							ruled{2} 6, 1+2+4,
								px1,	py1 + scTy * bTrimovtopleftin,	0,
								px2 - scLx,	py2 + scTy,	0,
								px2 - scLx,	py22 + scTy,	0,
								px2 - scLx,	py3 + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron) + gs_trimov_bot_left_in * bTrimovbotleftin,	1,
								px2 - scLx,	py3 + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron),	1,
								px1,		py3 + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron),	1,

								px1,	py1,	gs_trim_thk_in,
								px2,	py2,	gs_trim_thk_in,
								px2,	py22,	gs_trim_thk_in,
								px2,	py3 + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron) + gs_trimov_bot_left_in * bTrimovbotleftin,	gs_trim_thk_in,
								px2,	py3 + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron),	gs_trim_thk_in,
								px1,	py3 + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron),	gs_trim_thk_in

							lin_ px2 - scLx,	py2 + scTy,						0,						px2 - scLx, py3 + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron) + gs_trimov_bot_left_in * bTrimovbotleftin, 0
							lin_ px1, 			py1 + scTy * bTrimovtopleftin,	0,						px1,		py3 + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron), 0
							lin_ px1,			py1 + scTy * bTrimovtopleftin,	gs_trim_thk_in, 		px1,		py3 + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron), gs_trim_thk_in
						else
							cprism_{2} gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
								6, gs_trim_thk_in,
								px1,	py1,	0, s1, gs_trim_in_mat,
								px2,	py2,	0, s2, gs_trim_in_mat,
								px2,	py22,	0, s22, gs_trim_in_mat,
								px2,	py3 + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron) + gs_trimov_bot_left_in * bTrimovbotleftin,	0, 15-6*gs_stack_bottom, gs_trim_in_mat,
								px2,	py3 + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron),	0, 15-7*gs_stack_bottom, gs_trim_in_mat,
								px1,	py3 + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron),	0, s4, gs_trim_in_mat
						endif
					endif
					gosub "TextCoord_Vert"
				endif


				! --- Draw Door's Left side Trim ---

				py1 = -overSizeBottomIn
				py2 = -overSizeBottomIn
				py3 = py4 + gs_trimov_bot_left_in
				py4 = py3 + gs_tw_bottom_in

				if	bPShapedLeftOpening & gs_trim_below_boardLeft then
					px1 = leftRevealPnts[idxBoardEndRevealLeft][1] + gs_sidelight_WHole_width_left + trinL - gs_trim_offs_in  !+ tolerOffsetLeftIn
					px2 = px1 - gs_tw_left_in

					prism_ 	4, gs_trim_thk_in,
						px1,	py1,	15,
						px2,	py2,	s4,
						px2,	py3,	s3,
						px1,	py4,	s2
					gosub "TextCoord_Vert"

					! --- Draw Left lower Trim in Straight Wall ---

					px1 = leftRevealPnts[idxBoardEndRevealLeft][1] + not(gs_stack_left) * (tolerOffsetLeftIn - gs_trim_offs_in - gs_tw_left_in * not(bTrimovbotleftin)) + trinL * not(gs_stack_left)
					px2 = leftRevealPnts[idxBoardEndRevealLeft][1] + not(gs_stack_left) * (tolerOffsetLeftIn - gs_trim_offs_in) + trinL * not(gs_stack_left)
					px3 = leftRevealPnts[idxBoardEndRevealLeft][1] + gs_sidelight_WHole_width_left + trinL - gs_trim_offs_in  !+ tolerOffsetLeftIn
					px4 = px3 - gs_tw_left_in * gs_trim_below_boardLeft


					if (not(gs_apron) & not(bDrawLeftSLBoard)) | gs_trim_below_boardLeft then
						addz (WIDO_FRAME_THICKNESS - WALL_THICKNESS + WIDO_SILL) * gs_trim_atframe_in

						if abs(gs_trim_thk_in - gs_apron_thk) < EPS | (not(gs_apron) & not(bDrawLeftSLBoard)) | gs_trim_below_boardLeft then
							prism_ 	4, bBottomtriminthk,
								px1,	py3,	10,
								px2,	py4,	mask - 2 * gs_stack_left,
								px3,	py4,	10 + 5 * not(gs_trim_below_boardLeft),
								px4,	py3,	15
						else
							addz gs_trim_thk_in - gs_apron_thk
							prism_ 4, bBottomtriminthk,
								px1,	py3, 	8 + 7 * not(gs_stack_left),
								px1,	py4,	13 + 2 * not(gs_stack_left),
								px4,	py4,	8 + 7 * not(gs_stack_right),
								px4,	py3, 	13 + 2 * not(gs_stack_right)
							del 1
						endif
						gosub "TextCoord_Hor"

						del 1
					endif
					pxWCutBotLeftIn = px4
				endif

				pyWCutBotLeftIn = py1


				! --- Draw right side Trim ---

				px2 = rightRevealPnts[idxBoardEndRevealright][1] - tolerOffsetRightIn - trinR + gs_trim_offs_in
				px1 = px2 + gs_tw_right_in

				if	bShapeEnablesStraightTopTrim then
					py1 = B + overSizeTopIn + not(gs_stack_top) * (- tolerOffsetUpperIn - trinT + gs_trim_offs_in + gs_tw_top_in*not(bTrimovtoprightin)) + sjty
					py2 = B + overSizeTopIn + not(gs_stack_top) * (- tolerOffsetUpperIn - trinT + gs_trim_offs_in) + sjty
					py22 = py2 - gs_stack_top * gs_trim_stack_top * gs_tw_top_in / 2

					s1 = maskTop						! 15 or or 10 8
					if not(gs_stack_top) then
						s2 = bitset (mask, 1, not(gs_stack_top)) + 4 * gs_trim_atframe_in
					else
						s2 = 9 + 4 * gs_trim_atframe_in
					endif
					s22 = bitset (mask, 1, not(gs_stack_top)) + 4 * gs_trim_atframe_in
					if iWindowShape = SHAPE_RECTANGULAR then
						s5 = 9 + 4 * gs_trim_atframe_in
					else
						s5 = 10
					endif
				endif
				if	bShapeEnablesArchedTopTrim then
					ta = rightWidth + overSizeTopIn - tolerOffsetRightIn - gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in
					tc = arcR + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in
					py1 = B - arcR - tolerOffsetUpperIn + sqr(max(0, (tc * tc - ta * ta))) - tolerOffsetUpper * not(bHalfCircle)

					ta = ta - gs_tw_right_in
					tc = tc - gs_tw_right_in
					py2 = B - arcR - tolerOffsetUpperIn + sqr(max(0, (tc * tc - ta * ta))) - tolerOffsetUpper * not(bHalfCircle)
					py22 = py2

					s1 = 8
					s2 = mask - 2
					s22 = mask - 2
					if iWindowShape = SHAPE_ARCHED then
						s5 = 9 + 4 * gs_trim_atframe_in
					else
						s5 = 10
					endif
				endif
				if iWindowShape = SHAPE_ELLIPSEARCH then
					py1 = B - archHeight
					py2 = B - archHeight
					py22 = py2

					s1 = 8
					s2 = mask - 2
					s22 = 9 + 4 * (abs(gs_trim_offs_in) > EPS | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS)
					s5 = 9 + 4 * gs_trim_atframe_in
				endif

				if	isWindow | \
					(bPShapedRightOpening & gs_trim_below_boardRight) then
					py3 = -overSizeBottomIn + not(bDrawRightSLBoard) * tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawRightSLBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawRightSLBoard)\
					 - gs_trimov_bot_right_in - gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron) - gs_apron_width*bTrimovbotrightin * gs_apron) - sjBy
					py4 = -overSizeBottomIn + not(bDrawRightSLBoard) * tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawRightSLBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawRightSLBoard)\
					 - gs_trimov_bot_right_in - gs_tw_bottom_in * (not(bDrawRightSLBoard) | (bDrawRightSLBoard & (bTrimovbotrightin | gs_trim_below_boardRight))) * not(gs_apron) - gs_apron_width * bTrimovbotleftin * gs_apron) - sjBy

					s3 = maskBottom						! 15 or 10 or 8
					s4 = 13 + 2 * not(gs_stack_bottom)	! 15 or 13
				else
					py3 = -overSizeBottomIn
					py4 = -overSizeBottomIn

					s3 = 15-7*gs_stack_bottom
					s4 = 15
				endif

				py5 = py3 + not(gs_stack_bottom) * bTrimovbotrightin * (gs_trimov_bot_right_in + gs_tw_bottom_in * not(gs_apron) + gs_apron_width * gs_apron) + gs_stack_bottom * gs_trim_stack_bottom * gs_tw_bottom_in / 2
				py6 = py3 + not(gs_stack_bottom) * bTrimovbotrightin  * gs_trimov_bot_right_in

				if	bPShapedRightOpening then
					py3 = py3 + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + overSizeBottomIn
					py4 = py4 + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + overSizeBottomIn
					py5 = py5 + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + overSizeBottomIn
					py6 = py6 + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + overSizeBottomIn
				endif

				if bDrawBottTrimatGangingIn * not(bGangedCasingonFrame) then
					py6 = py6 + tolerOffsStackCasLowerIn + trinB - gs_trim_offs_in
					s5 = 13
				endif
				if bDrawTopTrimatGangingIn then
					py22 = py2
					if not(bGangedCasingonFrame) then
						py22 = py2 - tolerOffsStackCasUpperIn - trinT + gs_trim_offs_in
						s2 = 10
						s5 = 13
					endif
				endif

				pxWCutTopRightIn	= px1
				pxWCutBotRightIn	= px1
				pxWCutMidRightIn	= px1
				pxWCutMidOHRightIn	= px2
				pyWCutTopRightIn 	= py1
				pyWCutMidRightIn	= py4

				if not(gs_stack_right | bRightCornerFunction) & bShapeEnablesStraightRightTrim then

					body -1
					if (gs_apron & abs(gs_trim_thk_in - gs_apron_thk) < EPS) | (not(gs_apron) & (not(bDrawRightSLBoard) | gs_trim_below_boardRight) & (isWindow | bPShapedRightOpening)) then
						if iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE_SPLAYED then
							ruled{2} 7, 1+2+4,
								px1,	py1 + scTy * bTrimovtoprightin,	0,
								px2 + scRx,	py2 + scTy,	1,
								px2 + scRx,	py22 + scTy,	1,
								px2 + scRx,	py5 - scBy,	1,
								px2 + scRx,	py6 - scBy,	1,
								px2 + scRx,	py3 - scBy,	1,
								px1,	py4,	1,

								px1,	py1,	gs_trim_thk_in,
								px2,	py2,	gs_trim_thk_in,
								px2,	py22,	gs_trim_thk_in,
								px2,	py5,	gs_trim_thk_in,
								px2,	py6,	gs_trim_thk_in,
								px2,	py3,	gs_trim_thk_in,
								px1,	py4,	gs_trim_thk_in

							lin_ px2 + scRx, py2 + scTy, 0, px2 + scRx, py3 - scBy, 0
							lin_ px1, py1 + scTy * bTrimovtoprightin, 0, px1, py4, 0
							lin_ px1, py1 + scTy * bTrimovtoprightin, gs_trim_thk_in, px1, py4, gs_trim_thk_in
						else
							cprism_{2} gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
								7, gs_trim_thk_in,
								px1,	py1,	0, s1, gs_trim_in_mat,
								px2,	py2,	0, s2, gs_trim_in_mat,
								px2,	py22, 	0, s22, gs_trim_in_mat,
								px2,	py5,	0, s5, gs_trim_in_mat,
								px2,	py6,	0, s3*not(bTrimovbotrightin)+bTrimovbotrightin*15, gs_trim_in_mat,
								px2,	py3,	0, (s3+5*not(gs_tw_bottom_in))*not(bTrimovbotrightin)+bTrimovbotrightin*(15-7*gs_stack_bottom), gs_trim_in_mat,
								px1,	py4,	0, s4, gs_trim_in_mat
						endif
					else
						if iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE_SPLAYED then
							ruled{2} 6, 1+2+4,
								px1,	py1 + scTy * bTrimovtoprightin,	0,
								px2 + scRx,	py2 + scTy,	1,
								px2 + scRx,	py22 + scTy,	1,
								px2 + scRx,	py3 + gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron) + gs_trimov_bot_right_in * bTrimovbotrightin,	1,
								px2 + scRx,	py3 + gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron),	1,
								px1,	py3 + gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron),	1,

								px1,	py1,	gs_trim_thk_in,
								px2,	py2,	gs_trim_thk_in,
								px2,	py22,	gs_trim_thk_in,
								px2,	py3 + gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron) + gs_trimov_bot_right_in * bTrimovbotrightin,	gs_trim_thk_in,
								px2,	py3 + gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron),	gs_trim_thk_in,
								px1,	py3 + gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron),	gs_trim_thk_in

							lin_ px2 + scRx,	py2 + scTy,						0,				px2 + scRx, py3 + gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron) + gs_trimov_bot_right_in * bTrimovbotrightin, 0
							lin_ px1, 			py1 + scTy * bTrimovtoprightin, 0,				px1,		py3 + gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron), 0
							lin_ px1,			py1 + scTy * bTrimovtoprightin, gs_trim_thk_in, px1,		py3 + gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron), gs_trim_thk_in
						else
							cprism_{2} gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
								6, gs_trim_thk_in,
								px1,	py1,	0, s1, gs_trim_in_mat,
								px2,	py2,	0, s2, gs_trim_in_mat,
								px2,    py22,   0, s22, gs_trim_in_mat,
								px2,	py3+gs_tw_bottom_in*bTrimovbotrightin* not(gs_apron)+gs_trimov_bot_right_in*bTrimovbotrightin,	0, 15-6*gs_stack_bottom, gs_trim_in_mat,
								px2,	py3+gs_tw_bottom_in*bTrimovbotrightin* not(gs_apron),	0, 15-7*gs_stack_bottom, gs_trim_in_mat,
								px1,	py3+gs_tw_bottom_in*bTrimovbotrightin* not(gs_apron),	0, s4, gs_trim_in_mat
						endif
					endif
					gosub "TextCoord_Vert"
				endif

				! --- Draw Door's Right side Trim ---
				py1 = -overSizeBottomIn
				py2 = -overSizeBottomIn
				py3 = py4 + gs_trimov_bot_right_in
				py4 = py3 + gs_tw_bottom_in

				if	bPShapedRightOpening & gs_trim_below_boardRight then
					px1 = rightRevealPnts[idxBoardEndRevealright][1] - gs_sidelight_WHole_width_right - trinR + gs_trim_offs_in  !- tolerOffsetRightIn
					px2 = px1 + gs_tw_right_in

					prism_ 	4, gs_trim_thk_in,
						px1,	py1,	15,
						px2,	py2,	s4,
						px2,	py3,	s3,
						px1,	py4,	s2
					gosub "TextCoord_Vert"

					! --- Draw Right lower Trim in Straight Wall ---

					px1 = rightRevealPnts[idxBoardEndRevealRight][1] - not(gs_stack_right) * (tolerOffsetRightIn - gs_trim_offs_in - gs_tw_right_in * not(bTrimovbotrightin)) - trinR * not(gs_stack_right)
					px2 = rightRevealPnts[idxBoardEndRevealRight][1] - not(gs_stack_right) * (tolerOffsetRightIn - gs_trim_offs_in) - trinR * not(gs_stack_right)
					px3 = rightRevealPnts[idxBoardEndRevealRight][1] - gs_sidelight_WHole_width_right - trinR + gs_trim_offs_in  !- tolerOffsetRightIn
					px4 = px3 + gs_tw_right_in * gs_trim_below_boardRight

					if (not(gs_apron) & not(bDrawRightSLBoard)) | gs_trim_below_boardRight then
						addz (WIDO_FRAME_THICKNESS - WALL_THICKNESS + WIDO_SILL) * gs_trim_atframe_in

						if abs(gs_trim_thk_in - gs_apron_thk) < EPS | (not(gs_apron) & not(bDrawRightSLBoard)) | gs_trim_below_boardRight then
							prism_ 	4, bBottomtriminthk,
								px1,	py3,	10,
								px2,	py4,	mask - 2 * gs_stack_right,
								px3,	py4,	10 + 5 * not(gs_trim_below_boardRight),
								px4,	py3,	15
						else
							addz gs_trim_thk_in - gs_apron_thk
							prism_ 4, bBottomtriminthk,
								px1,	py3, 	8 + 7 * not(gs_stack_right),
								px1,	py4,	13 + 2 * not(gs_stack_right),
								px4,	py4,	8 + 7 * not(gs_stack_left),
								px4,	py3, 	13 + 2 * not(gs_stack_left)
							del 1
						endif
						gosub "TextCoord_Hor"
						del 1
					endif
					pxWCutBotRightIn = px4
				endif

				pyWCutBotRightIn = py1


				! --- Draw lower Trim/Apron in Straight Wall ---

				py1 = -overSizeBottomIn + tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) - gs_tw_bottom_in) - sjBy
				py2 = -overSizeBottomIn + tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawBoard) - gs_trim_offs_in * not(gs_trim_atframe_in)) - sjBy

				px1 = leftRevealPnts[idxBoardEndRevealLeft][1] + not(gs_stack_left) * (tolerOffsetLeftIn - gs_trim_offs_in - gs_tw_left_in * not(bTrimovbotleftin)) + trinL * not(gs_stack_left| bLeftCornerFunction)
				px2 = leftRevealPnts[idxBoardEndRevealLeft][1] + not(gs_stack_left) * (tolerOffsetLeftIn - gs_trim_offs_in - gs_tw_left_in * (bLeftCornerFunction)) + trinL * not(gs_stack_left| bLeftCornerFunction)
				px3 = rightRevealPnts[idxBoardEndRevealright][1] + not(gs_stack_right) * (- tolerOffsetRightIn + gs_trim_offs_in + gs_tw_right_in * (bRightCornerFunction)) - trinR * not(gs_stack_right | bRightCornerFunction)
				px4 = rightRevealPnts[idxBoardEndRevealright][1] + not(gs_stack_right) * (- tolerOffsetRightIn + gs_trim_offs_in + gs_tw_right_in * not(bTrimovbotrightin)) - trinR * not(gs_stack_right | bRightCornerFunction)

				if bDrawLeftTrimatGangingIn * not(bGangedCasingonFrame) then
					px2 = leftRevealPnts[2][1] + tolerOffsStackCasLeftIn + trinL - gs_trim_offs_in
				endif
				if bDrawRightTrimatGangingIn * not(bGangedCasingonFrame) then
					px3 = rightRevealPnts[2][1] - tolerOffsStackCasRightIn - trinR + gs_trim_offs_in
				endif

				if not(gs_stack_bottom | not(isWindow)) & bShapeEnablesStraightBottomTrim & abs(gs_tw_bottom_in) > EPS & not(bInclinedWall) then
					if (not(gs_apron) & not(bDrawBoard)) then
						material bBottomtriminmat

						addz (WIDO_FRAME_THICKNESS - WALL_THICKNESS + WIDO_SILL) * gs_trim_atframe_in

						if abs(gs_trim_thk_in - gs_apron_thk) < EPS | (not(gs_apron) & not(bDrawBoard)) then
							if iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE_SPLAYED then
								ruled{2} 6, 1+2+4,
									px1,	py1, 	0,
									px1,	py1 + gs_tw_bottom_in*bDrawBoard, 	0,
									px2 - not(gs_stack_left) * scLx,	py2 - scBy,	0,
									px3 + not(gs_stack_right) * scRx,	py2 - scBy,	0,
									px4,	py1 + gs_tw_bottom_in*bDrawBoard, 	0,
									px4,	py1, 	0,

									px1,	py1, 	bBottomtriminthk,
									px1,	py1 + gs_tw_bottom_in*bDrawBoard, 	bBottomtriminthk,
									px2,	py2,	bBottomtriminthk,
									px3,	py2,	bBottomtriminthk,
									px4,	py1 + gs_tw_bottom_in*bDrawBoard, 	bBottomtriminthk,
									px4,	py1, 	bBottomtriminthk

								lin_ px2 - not(gs_stack_left) * scLx, py2 - scBy, 0, px3 + not(gs_stack_right) * scRx, py2 - scBy, 0
								lin_ px1, py1, 0, px4, py1, 0
								lin_ px1, py1, bBottomtriminthk, px4, py1, bBottomtriminthk
							else
								cprism_{2} gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
									4+2, bBottomtriminthk,
									px1,	py1, 																0, maskLeft*not(bDrawBoard)+maskLeft2*bDrawBoard, gs_trim_in_mat,
									px1,	py1 + gs_tw_bottom_in * (bDrawBoard | bDrawLeftTrimatGangingIn), 	0, maskLeft, gs_trim_in_mat,						! 15 or 8
									px2,	py2,																0, bitset (mask, 1, not(gs_stack_left)), gs_trim_in_mat,
									px3,	py2,																0, maskRight, gs_trim_in_mat,						! 15 or 8
									px4,	py1 + gs_tw_bottom_in * (bDrawBoard | bDrawRightTrimatGangingIn), 	0, maskRight*not(bDrawBoard)+maskRight2*bDrawBoard, gs_trim_in_mat,
									px4,	py1,																0, 13 + 2 * not(gs_stack_right), gs_trim_in_mat	! 15 or 13
							endif
						else
							addz gs_trim_thk_in - gs_apron_thk
							prism_ 4, bBottomtriminthk,
								px1,	py1, 	8 + 7 * not(gs_stack_left),
								px1,	py2,	13 + 2 * not(gs_stack_left),
								px4,	py2,	8 + 7 * not(gs_stack_right),
								px4,	py1, 	13 + 2 * not(gs_stack_right)
							del 1
						endif

						del 1
						material gs_trim_in_mat
					endif
					gosub "TextCoord_Hor"
				endif


				! --- Draw lower Trim/Apron in Inclined Wall ---

				px2 = (gs_trim_width_in - gs_trim_offs_in) / cos(wallIncl)
				px1 = px2 - gs_tw_left_in * not(bTrimovbotleftin)
				px3 = -px2
				px4 = px3 + gs_tw_right_in * not(bTrimovbotrightin)
				pxL = -(leftWidth  + overSizeLeftIn)  / cos(wallIncl) + bBottomtriminthk * tan(wallIncl)
				pxR =  (rightWidth + overSizeRightIn) / cos(wallIncl) + bBottomtriminthk * tan(wallIncl)

				py1 = -overSizeBottomIn + not(gs_stack_bottom) * (gs_trim_width_in*not(bDrawBoard) - gs_trim_offs_in * not(gs_trim_atframe_in)- gs_tw_bottom_in)
				py2 = -overSizeBottomIn + not(gs_stack_bottom) * (gs_trim_width_in*not(bDrawBoard) - gs_trim_offs_in * not(gs_trim_atframe_in))

				if not(gs_stack_bottom | not(isWindow)) & bShapeEnablesStraightBottomTrim & abs(gs_tw_bottom_in) > EPS & bInclinedWall then
					if (not(gs_apron) & not(bDrawBoard)) then
						material bBottomtriminmat

						addz (WIDO_FRAME_THICKNESS - WALL_THICKNESS + WIDO_SILL) * gs_trim_atframe_in + gs_trim_thk_in
						roty wallIncl
						addz -gs_trim_thk_in

						if abs(gs_trim_thk_in - gs_apron_thk) < EPS | (not(gs_apron) & not(bDrawBoard)) then
							croof_ bBottomtriminmat, bBottomtriminmat, bBottomtriminmat,
								4+2, 0,0, 1,0, 0, 0, -bBottomtriminthk,
								pxL + not(gs_stack_left)  * px1,	py1, 	-gs_stack_left * wallIncl*not(bTrimovbotleftin),	maskLeft*not(bDrawBoard)+maskLeft2*bDrawBoard,
								pxL + not(gs_stack_left)  * px1,	py1 + gs_tw_bottom_in*bDrawBoard, 	-wallIncl*(bTrimovbotleftin), maskLeft,						! 15 or 8
								pxL + not(gs_stack_left)  * px2,	py2,				0,				bitset (mask, 1, not(gs_stack_left)),
								pxR + not(gs_stack_right) * px3,	py2,				gs_stack_right * wallIncl*not(bTrimovbotrightin),	maskRight,				! 15 or 8
								pxR + not(gs_stack_right) * px4,	py1 + gs_tw_bottom_in*bDrawBoard, 	wallIncl*bTrimovbotrightin, maskRight*not(bDrawBoard)+maskRight2*bDrawBoard,
								pxR + not(gs_stack_right) * px4,	py1, 	0,				13 + 2 * not(gs_stack_right)	! 15 or 13
						else
							addz gs_trim_thk_in - gs_apron_thk
							croof_ bBottomtriminmat, bBottomtriminmat, bBottomtriminmat,
								4, 0,0, 1,0, 0, 0, -bBottomtriminthk,
								pxL + not(gs_stack_left)  * px1,	py1, 	-wallIncl*bTrimovbotleftin,	8 + 7 * not(gs_stack_left),
								pxL + not(gs_stack_left)  * px1,	py2, 	0, 9 + 2 * not(gs_stack_left),
								pxR + not(gs_stack_right) * px4,	py2, 	wallIncl*bTrimovbotrightin, 8 + 7 * not(gs_stack_right),
								pxR + not(gs_stack_right) * px4,	py1, 	0,	13 + 2 * not(gs_stack_right)
							del 1
						endif

						del 3
						material gs_trim_in_mat
					endif
					gosub "TextCoord_Hor"
				endif

				! --- Draw upper Trim ---

				if gs_stack_left then
					px1 = leftRevealPnts[idxBoardEndRevealLeft-1][1] - gs_trim_thk_in * tan(alfaLeft)
					px2 = leftRevealPnts[idxBoardEndRevealLeft-1][1] - gs_trim_thk_in * tan(alfaLeft)
					px22 = leftRevealPnts[idxBoardEndRevealLeft-1][1]
					px3 = leftRevealPnts[idxBoardEndRevealLeft-1][1] - gs_trim_thk_in * tan(alfaLeft)
					px4 = leftRevealPnts[idxBoardEndRevealLeft-1][1] + gs_tw_left_in /2

					s1 = 8
					s2 = 8 + 5 * not(gs_trim_stack_left)
					s3 = maskLeft + 1 * not(gs_trim_atframe_in)
					s4 = bitset (mask, 1, not(gs_stack_left)) + 4 * gs_trim_atframe_in
				else
					px1 = leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn + not(bLeftCornerFunction) * trinL - gs_trim_offs_in - gs_tw_left_in - gs_trimov_top_left_in * bTrimovtopleftin
					px2 = leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn + not(bLeftCornerFunction) * trinL - gs_trim_offs_in - (gs_tw_left_in + gs_trimov_top_left_in) * (bTrimovtopleftin | bLeftCornerFunction)
					px22 = 0
					px3 = leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn + not(bLeftCornerFunction) * trinL - gs_trim_offs_in - gs_tw_left_in * bTrimovtopleftin
					px4 = leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn + not(bLeftCornerFunction) * trinL - gs_trim_offs_in

					s1 = 8 + 7 * bTrimovtopleftin
					s2 = 13 + 2 * bTrimovtopleftin
					s3 = maskLeft
					s4 = bitset (mask, 1, not(gs_stack_left))
				endif

				if gs_stack_right then
					px5 = rightRevealPnts[idxBoardEndRevealRight-1][1] - gs_tw_right_in /2
					px6 = rightRevealPnts[idxBoardEndRevealRight-1][1] + gs_trim_thk_in * tan(alfaRight)
					px77 = rightRevealPnts[idxBoardEndRevealRight-1][1]
					px7 = rightRevealPnts[idxBoardEndRevealRight-1][1] + gs_trim_thk_in * tan(alfaRight)
					px8 = rightRevealPnts[idxBoardEndRevealRight-1][1] + gs_trim_thk_in * tan(alfaRight)

					s5 = maskRight + 1 * not(gs_trim_atframe_in) !- 2
					s6 = 8 + 5 * not(gs_trim_stack_right)
					s7 = 8
					s8 = 13
				else
					px5 = rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn - not(bRightCornerFunction) * trinR + gs_trim_offs_in
					px6 = rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn - not(bRightCornerFunction) * trinR + gs_trim_offs_in + gs_tw_right_in * bTrimovtoprightin
					px7 = rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn - not(bRightCornerFunction) * trinR + gs_trim_offs_in + (gs_tw_right_in + gs_trimov_top_right_in) * (bTrimovtoprightin | bRightCornerFunction)
					px8 = rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn - not(bRightCornerFunction) * trinR + gs_trim_offs_in + gs_tw_right_in + gs_trimov_top_right_in * bTrimovtoprightin

					s5 = maskRight
					s6 = 15
					s7 = 8 + 7 * bTrimovtoprightin
					s8 = 15
				endif

				py2 = B + overSizeTopIn - tolerOffsetUpperIn - trinT + gs_trim_offs_in + sjTy
				py1 = py2 + gs_tw_top_in

				pyWCutTopOHIn = py1

				if bDrawLeftTrimatGangingIn * not(bGangedCasingonFrame) then
					px3 = leftRevealPnts[2][1] + tolerOffsStackCasLeftIn + trinL - gs_trim_offs_in
					px4 = leftRevealPnts[2][1] + tolerOffsStackCasLeftIn + trinL - gs_trim_offs_in
				endif
				if bDrawRightTrimatGangingIn * not(bGangedCasingonFrame) then
					px6 = rightRevealPnts[2][1] - tolerOffsStackCasRightIn - trinR + gs_trim_offs_in
				endif

				if bShapeEnablesStraightTopTrim & not(gs_stack_top) then

					add px22, 0, gs_trim_thk_in
					roty  alfaLeft * ySign - 90
					if gs_stack_left then cutplane 1, 1, 0
					del 2

					if iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE_SPLAYED then
						if gs_trimtype_in_int = CASING_NORMAL then				! Rectangular casing type
							ruled{2} 8, 1+2+4,
								px1,	py1,	0,
								px2 - scLx * not(bTrimovtopleftin),	py2 + scTy,	0,
								px3 - scLx * not(bTrimovtopleftin),	py2 + scTy,	0,
								px4 - scLx,	py2 + scTy,	1,
								px5 + scRx,	py2 + scTy,	1,
								px6 + scRx * not(bTrimovtoprightin),	py2 + scTy, 	0,
								px7 + scRx * not(bTrimovtoprightin),	py2 + scTy, 	0,
								px8,	py1, 	0,

								px1,	py1,	gs_trim_thk_in,
								px2,	py2,	gs_trim_thk_in,
								px3,	py2,	gs_trim_thk_in,
								px4,	py2,	gs_trim_thk_in,
								px5,	py2,	gs_trim_thk_in,
								px6,	py2, 	gs_trim_thk_in,
								px7,	py2, 	gs_trim_thk_in,
								px8,	py1, 	gs_trim_thk_in

							if bTrimovtopleftin & not(gs_stack_left) then lin_ px2, py2 + scTy, 0, px3, py2 + scTy, 0
							if bTrimovtopleftin then lin_ px2, py2, gs_trim_thk_in, px3, py2, gs_trim_thk_in
							if bTrimovtopleftin & not(gs_stack_left) then lin_ px1, py1, 0, px1, py2 + scTy, 0
							if bTrimovtopleftin & not(gs_stack_left) then lin_ px1, py1, gs_trim_thk_in, px1, py2, gs_trim_thk_in
							if bTrimovtoprightin then lin_ px7, py2 + scTy, 0, px6, py2 + scTy, 0
							if bTrimovtoprightin then lin_ px7, py2, gs_trim_thk_in, px6, py2, gs_trim_thk_in
							if bTrimovtoprightin then lin_ px8, py1, 0, px8, py2 + scTy, 0
							if bTrimovtoprightin then lin_ px8, py1, gs_trim_thk_in, px8, py2, gs_trim_thk_in
						endif
						if gs_trimtype_in_int = CASING_OVERHANG then				! SWE traditional casing type
							ruled{2} 10, 1+2+4,
								px1,	py1,	0,
								px1,	py1-0.04 + scTy,	0,
								px3 + (px1 - px3)/2 - scLx * not(bTrimovtopleftin),	py2 + scTy,	0,
								px3 - scLx * not(bTrimovtopleftin),	py2 + scTy,	0,
								px4 - scLx,	py2 + scTy,	1,
								px5 + scRx,	py2 + scTy,	1,
								px6 + scRx * not(bTrimovtoprightin),	py2 + scTy, 	0,
								px6 + (px8 - px6)/2 + scRx * not(bTrimovtoprightin),	py2 + scTy, 	0,
								px8,	py1-0.04 + scTy, 	0,
								px8,	py1, 	0,

								px1,	py1,	gs_trim_thk_in,
								px1,	py1-0.04,	gs_trim_thk_in,
								px3 + (px1 - px3)/2,	py2,	gs_trim_thk_in,
								px3,	py2,	gs_trim_thk_in,
								px4,	py2,	gs_trim_thk_in,
								px5,	py2,	gs_trim_thk_in,
								px6,	py2, 	gs_trim_thk_in,
								px6 + (px8 - px6)/2,	py2, 	gs_trim_thk_in,
								px8,	py1-0.04, 	gs_trim_thk_in,
								px8,	py1, 	gs_trim_thk_in


							if bTrimovtopleftin & not(gs_stack_left) then lin_ px3 + (px1 - px3)/2, py2 + scTy, 0, px3, py2 + scTy, 0
							if bTrimovtopleftin then lin_ px3 + (px1 - px3)/2, py2, gs_trim_thk_in, px3, py2, gs_trim_thk_in
							if bTrimovtopleftin & not(gs_stack_left) then lin_ px1, py1-0.04 + scTy, 0, px3 + (px1 - px3)/2, py2 + scTy, 0
							if bTrimovtopleftin & not(gs_stack_left) then lin_ px1, py1-0.04, gs_trim_thk_in, px3 + (px1 - px3)/2, py2, gs_trim_thk_in
							if bTrimovtopleftin & not(gs_stack_left) then lin_ px1, py1-0.04 + scTy, 0, px1, py1, 0
							if bTrimovtopleftin & not(gs_stack_left) then lin_ px1, py1-0.04, gs_trim_thk_in, px1, py1, gs_trim_thk_in

							if bTrimovtoprightin then lin_ px6 + (px8 - px6)/2, py2 + scTy, 0, px6, py2 + scTy, 0
							if bTrimovtoprightin then lin_ px6 + (px8 - px6)/2, py2, gs_trim_thk_in, px6, py2, gs_trim_thk_in
							if bTrimovtoprightin then lin_ px8, py1-0.04 + scTy, 0, px6 + (px8 - px6)/2, py2 + scTy, 0
							if bTrimovtoprightin then lin_ px8, py1-0.04, gs_trim_thk_in, px6 + (px8 - px6)/2, py2, gs_trim_thk_in
							if bTrimovtoprightin then lin_ px8, py1-0.04 + scTy, 0, px8, py1, 0
							if bTrimovtoprightin then lin_ px8, py1-0.04, gs_trim_thk_in, px8, py1, gs_trim_thk_in
						endif

							lin_ px4 - not(gs_stack_left) * scLx, py2 + scTy, 0, px5 + not(gs_stack_right) * scRx, py2 + scTy, 0
	!						lin_ px1, py2 + scTy, 0, px8, py2 + scTy, 0
							lin_ px1, py1, 0, px8, py1, 0
							lin_ px1, py1, gs_trim_thk_in, px8, py1, gs_trim_thk_in

					else
						if gs_trimtype_in_int = CASING_NORMAL then				! Rectangular casing type
							cprism_{2} gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
								8, gs_trim_thk_in,
								px1,	py1,	0, s1, gs_trim_in_mat,
								px2,	py2,	0, s2, gs_trim_in_mat,
								px3,	py2,	0, s3, gs_trim_in_mat,
								px4,	py2,	0, s4, gs_trim_in_mat,
								px5,	py2,	0, s5, gs_trim_in_mat,
								px6,	py2, 	0, s6, gs_trim_in_mat,
								px7,	py2, 	0, s7, gs_trim_in_mat,
								px8,	py1, 	0, s8, gs_trim_in_mat
						endif
						if gs_trimtype_in_int = CASING_OVERHANG then				! SWE traditional casing type
							cprism_{2} gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
								10, gs_trim_thk_in,
								px1,	py1,			0, s1, gs_trim_in_mat,
								px1,	py1-0.04,		0, s1, gs_trim_in_mat,
								px3 + (px1 - px3)/2,py2,0, s2, gs_trim_in_mat,
								px3,	py2,			0, s3, gs_trim_in_mat,
								px4,	py2,			0, s4, gs_trim_in_mat,
								px5,	py2,			0, s5, gs_trim_in_mat,
								px6,	py2, 			0, s6, gs_trim_in_mat,
								px6 + (px8 - px6)/2,py2,0, s7, gs_trim_in_mat,
								px8,	py1-0.04, 		0, s7, gs_trim_in_mat,
								px8,	py1, 			0, s8, gs_trim_in_mat
						endif
					endif

					if gs_stack_left then cutend
				endif

				if	bShapeEnablesArchedTopTrim then

					resol nArchResolution
					addy B - archHeight - tolerOffsetUpperIn

					px1 = -leftWidth  - overSizeLeftIn  + tolerOffsetLeftIn  - gs_trim_offs_in + gs_trim_width_in
					px2 =  rightWidth + overSizeRightIn - tolerOffsetRightIn + gs_trim_offs_in - gs_trim_width_in

					if bHalfCircle then
						cprism_{2} gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							11, gs_trim_thk_in,
							px1,					0,		0, 8 + 7 * gs_stack_left, gs_trim_in_mat,
							px1 - gs_tw_right_in,	-EPS,	0, 8 + 7 * gs_stack_left, gs_trim_in_mat,
							px1 - gs_tw_right_in,	0,		0, 79,	gs_trim_in_mat,
							0,						0,		0, 900,	gs_trim_in_mat,
							0, archHeight + gs_trim_offs_in - gs_trim_width_in + gs_tw_right_in, 0, 3079, gs_trim_in_mat,
							px2 + gs_tw_right_in,	0,		0, 3079, gs_trim_in_mat,
							px2 + gs_tw_right_in,	-EPS,	0, 8 + 7 * gs_stack_right, gs_trim_in_mat,
							px2,					0,		0, 62 + mask, gs_trim_in_mat,
							0, archHeight + gs_trim_offs_in - gs_trim_width_in, 0, 3062 + mask, gs_trim_in_mat,
							px1,					0,		0, 3013 + 2 * gs_stack_left, gs_trim_in_mat,
							px1,					0,		0, -1, gs_trim_in_mat

						! --- Draw missing lines ---
						if gs_stack_left  then lin_ px1 - gs_tw_right_in,0,0, px1 - gs_tw_right_in,0,gs_trim_thk_in
						if gs_stack_right then lin_ px2,0,0, px2,0,gs_trim_thk_in
					else
						ta = leftWidth + overSizeTopIn - tolerOffsetLeftIn - gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in
						tc = arcR + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in
						py1L = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight - tolerOffsetUpper

						ta = ta - gs_tw_right_in
						tc = tc - gs_tw_right_in
						py2L = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight - tolerOffsetUpper

						ta = rightWidth + overSizeTopIn - tolerOffsetRightIn - gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in
						tc = arcR + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in
						py1R = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight - tolerOffsetUpper

						ta = ta - gs_tw_right_in
						tc = tc - gs_tw_right_in
						py2R = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight - tolerOffsetUpper

						cprism_{2} gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							8, gs_trim_thk_in,
							0,						archHeight - arcR, 0, 900, gs_trim_in_mat,
							px1,					py2L,		0, 8 + 7 * gs_stack_left, gs_trim_in_mat,
							px1 - gs_tw_right_in,	py1L,		0, 79, gs_trim_in_mat,
							0,						archHeight + gs_trim_offs_in - gs_trim_width_in + gs_tw_right_in,	0, 3079, gs_trim_in_mat,
							px2 + gs_tw_right_in,	py1R,		0, 3010 + 5 * gs_stack_right, gs_trim_in_mat,
							px2,					py2R,		0, 62 + mask, gs_trim_in_mat,
							0,						archHeight + gs_trim_offs_in - gs_trim_width_in,	0, 3062 + mask, gs_trim_in_mat,
							px1,					py2L,		0, 3015, gs_trim_in_mat

						lin_ px2,py2R,0, px2,py2R,gs_trim_thk_in
					endif

					del 1
				endif

				if iWindowShape = SHAPE_ELLIPSEARCH then

					resol nArchResolution

					px1 = -leftWidth - overSizeLeftIn + tolerOffsetLeftIn - gs_trim_offs_in + gs_trim_width_in
					px2 =  rightWidth + overSizeLeftIn - tolerOffsetRightIn + gs_trim_offs_in - gs_trim_width_in
					px3 = -leftWidth - overSizeLeftIn + tolerOffsetLeftIn
					px4 = rightWidth + overSizeLeftIn - tolerOffsetRightIn

					pxcL = -leftWidth + smallRadiusEllips
					pxcR = rightWidth - smallRadiusEllips

					py1 = B - tolerOffsetUpperIn

					s1 = 9 + 4 * (abs(gs_trim_offs_in) > EPS | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS)

					cprism_{2} gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
						13,gs_trim_thk_in,
						px2,					py1 - archHeight,			0, s1, gs_trim_in_mat,
						pxcR,					py1 - archHeight,			0, 900+s1, gs_trim_in_mat,
						0,		 				alphaSide,					0, 4000+s1, gs_trim_in_mat,
						0,						py1 - middleRadiusEllips, 	0, 900+s1, gs_trim_in_mat,
						0,		 				alphaMiddle,				0, 4000+s1, gs_trim_in_mat,
						pxcL,					py1 - archHeight,			0, 900+s1, gs_trim_in_mat,
						0,		 				alphaSide,					0, 4008, gs_trim_in_mat,
						px1 - gs_tw_right_in,	py1 - archHeight,			0, 13+64, gs_trim_in_mat,
						0,		 				-alphaSide,					0, 4015+64, gs_trim_in_mat,
						0,						py1 - middleRadiusEllips, 	0, 915+64, gs_trim_in_mat,
						0,		 				-alphaMiddle,				0, 4015+64, gs_trim_in_mat,
						pxcR,					py1 - archHeight,			0, 908+64, gs_trim_in_mat,
						0,		 				-alphaSide,					0, 4008+64, gs_trim_in_mat
				endif
				gosub "TextCoord_Hor"

				del 1


				if bCutWall then
					pen WALL_VIEW_PEN
					material matWallIn

					if	bShapeEnablesArchedTopTrim | \
						iWindowShape = SHAPE_ELLIPSEARCH then

						if iWindowShape = SHAPE_ELLIPSEARCH then
							put	pxWCutTopRightIn, pyWCutTopRightIn, 79,
								pxcR,				pyWCutTopRightIn,			979,
								0,		 			alphaSide,					4079,
								0,					py1 - middleRadiusEllips, 	979,
								0,		 			alphaMiddle,				4079,
								pxcL,				py1 - archHeight,			979,
								0,		 			alphaSide,					4079
						else
							if bHalfCircle then
								put	pxWCutTopRightIn, pyWCutTopRightIn, 79,
									0, B - tolerOffsetUpperIn - archHeight, 900,
									pxWCutTopLeftIn, pyWCutTopLeftIn, 3079
							else
								put pxWCutTopRightIn, pyWCutTopRightIn-EPS, 31,
									pxWCutTopRightIn, pyWCutTopRightIn, 79,
									0, B - tolerOffsetUpperIn - arcR, 900,
									pxWCutTopLeftIn, pyWCutTopLeftIn, 3031,
									pxWCutTopLeftIn, pyWCutTopLeftIn-EPS, 31
							endif
						endif
					else
						put pxWCutTopRightIn, pyWCutTopRightIn, 31
						if gs_trimtype_in_int = CASING_OVERHANG then
							put	pxWCutTopRightIn	+ gs_trimov_top_right_in/2, pyWCutTopRightIn, 31,
								pxWCutTopRightIn	+ gs_trimov_top_right_in,	pyWCutTopOHIn - 0.04, 31,
								pxWCutTopRightIn	+ gs_trimov_top_right_in,	pyWCutTopOHIn, 31,
								pxWCutTopLeftIn	- gs_trimov_top_left_in,	pyWCutTopOHIn, 31,
								pxWCutTopLeftIn	- gs_trimov_top_left_in,	pyWCutTopOHIn - 0.04, 31,
								pxWCutTopLeftIn	- gs_trimov_top_left_in/2, pyWCutTopRightIn, 31
						endif
						put	pxWCutTopLeftIn,	pyWCutTopLeftIn,	31
					endif

					put	pxWCutMidLeftIn, pyWCutMidLeftIn, 31

					if gs_trimtype_in_int = CASING_OVERHANG then
						put	pxWCutMidOHLeftIn, pyWCutMidLeftIn, 31,
							pxWCutMidOHLeftIn, pyWCutMidLeftIn + gs_trimov_bot_left_in, 31
					endif
					if not(isWindow) & bPShapedLeftOpening then
						put	pxWCutBotLeftIn, pyWCutMidLeftIn + gs_trimov_bot_left_in, 31,
							pxWCutBotLeftIn, pyWCutBotLeftIn, 31
					endif
					if not(isWindow) & bPShapedRightOpening then
						put	pxWCutBotRightIn, pyWCutBotRightIn, 31,
							pxWCutBotRightIn, pyWCutMidRightIn + gs_trimov_bot_right_in, 31
					endif
					if gs_trimtype_in_int = CASING_OVERHANG then
						put	pxWCutMidOHRightIn, pyWCutMidRightIn + gs_trimov_bot_right_in, 31,
							pxWCutMidOHRightIn, pyWCutMidRightIn, 31
					endif

					put	pxWCutMidRightIn, pyWCutMidRightIn, 31

!					prism_ nsp/3,-1,
!						use(nsp)

					wallniche nsp/3,1,16,
						0,0,1,0,
						get(nsp)

					pen gs_frame_pen
					material gs_trim_in_mat
				endif

			endif ! bInclinedWall
		endif

		del 1

	else	! not(curvedWall)
		if iRevealType <> REVEAL_SLANTED & iRevealType <> REVEAL_SPLAYED & iRevealType <> REVEAL_HISTORIC & iRevealType <> REVEAL_DOUBLE_SPLAYED then

			! ======================================
			! Inside Trim - Curved Walls
			! ======================================

			resol WALL_RESOL

			offsArc = iHolePosSign * AC_Hole_Position_Angle / 180 * PI * rBoard

			matTrim = gs_trim_in_mat

			material gs_trim_in_mat
			sect_fill gs_trim_fill_in, gs_trim_pen_bg_in, gs_trim_pen_fg_in, gs_trim_pen_cont_in

			if gs_IsCurved then
				thk = WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS
			else
				thk = WALL_THICKNESS

				addz -WIDO_FRAME_THICKNESS

				material matTrim

				cutplane
				del 1
				numCutsFrame = 1
			endif

			if wallIsLeft then
				mask = 14 + (gs_trim_offs_in > EPS | not(bShowJambExtension) | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS)
			else
				mask = 11 + 4 * (gs_trim_offs_in > EPS | not(bShowJambExtension) | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS)
			endif

			if gs_trim_width_in > EPS & thk > EPS & bShowJambExtension then

				! ===== Inside Trim - Curved Walls - Jamb Extensions =====

				addz -WOD
				bCondition = WIDO_REVEAL_SIDE exor SYMB_MIRRORED
				roty (not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) + not(wallIsLeft) * 180
				addz rBoard

				! --- Draw Left side Jamb Extension ---

				if	isWindow then
					py4 = -overSizeBottomIn + not(gs_stack_bottom | bDrawBoard) * (gs_trim_width_in + tolerOffsetLowerIn) * bParalellInCurvedWalls
					py3 = py4 + not(gs_stack_bottom | bDrawBoard) * gs_trim_width_in * not(bParalellInCurvedWalls)
					py3l = py3
					py4l = py4
					py3r = py3
					py4r = py4

					s3 = 8 + 2 * not(gs_stack_bottom)		! 15 or 8
					s4 = 13 + 2 * not(gs_stack_bottom)		! 15 or 13
				else
					if	bPShapedLeftOpening then
						py4l = -overSizeBottomIn + not(bDrawLeftSLBoard) * (gs_trim_width_in + tolerOffsetLowerIn) * bParalellInCurvedWalls \
								+ gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + overSizeBottomIn
						py3l = py4l + not(bDrawLeftSLBoard) * gs_trim_below_boardLeft * gs_trim_width_in * not(bParalellInCurvedWalls)
					else
						py4l = -overSizeBottomIn
						py3l = -overSizeBottomIn
					endif
					if	bPShapedRightOpening then
						py4r = -overSizeBottomIn + not(bDrawLRightSLBoard) * (gs_trim_width_in + tolerOffsetLowerIn) * bParalellInCurvedWalls \
								 + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + overSizeBottomIn
						py3r = py4r + not(bDrawRightSLBoard) * gs_trim_below_boardRight * gs_trim_width_in * not(bParalellInCurvedWalls)
					else
						py4r = -overSizeBottomIn
						py3r = -overSizeBottomIn
					endif

					s3 = 15
					s4 = 15
				endif

				px1 = signWallIsLeft * (offsArc - rBoard * alfaLeftIn * DegRad) - leftWidth * bParalellInCurvedWalls
				px2 = px1 + signWallIsLeft * gs_trim_width_in + 2 * leftWidth * bParalellInCurvedWalls

				if	bShapeEnablesStraightTopTrim then
					py1 = B + overSizeTopIn - not(gs_stack_top) * gs_trim_width_in * bParalellInCurvedWalls - tolerOffsetUpperIn
					py2 = py1 - not(gs_stack_top) * gs_trim_width_in * not(bParalellInCurvedWalls)

					s1 = 8 + 2 * not(gs_stack_top)		! 15 or 8
					s2 = bitset (mask, 1, not(gs_stack_top))
				endif
				if	bShapeEnablesArchedTopTrim then
					ta = leftWidth
					tc = arcR + tolerOffsetUpper
					if tc > ta then
						py1 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))
					else
						py1 = B - arcR - tolerOffsetUpper
					endif

					ta = ta - gs_trim_width_in
					tc = tc - gs_trim_width_in
					if tc > ta then
						py2 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))
					else
						py2 = B - arcR - tolerOffsetUpper
					endif
					s1 = 8
					s2 = mask - 2
				endif
				if iWindowShape = SHAPE_ELLIPSEARCH then
					py1 = B - archHeight - tolerOffsetUpper
					py2 = B - archHeight - tolerOffsetUpper

					s1 = 8
					s2 = mask - 2
				endif

				if not(gs_stack_left | bLeftCornerFunction) & bShapeEnablesStraightLeftTrim then
					if bParalellInCurvedWalls then
						addz -rBoard
						roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

						cutpolya 4, 1, 0,
							-leftWidth + tolerOffsetLeftIn - overSizeLeftIn,  -overSizeBottomIn,  0,
							-leftWidth * 3,  -overSizeBottomIn,  0,
							-leftWidth * 3, B + overSizeTopIn, 0,
							-leftWidth + tolerOffsetLeftIn - overSizeLeftIn,  B + overSizeTopIn,  5

						cutpolya 4, 1, 0,
							-leftWidth + tolerOffsetLeftIn - overSizeLeftIn + gs_trim_width_in,  -overSizeBottomIn,  7,
							rightWidth,  -overSizeBottomIn,  7,
							rightWidth, B + overSizeTopIn, 7,
							-leftWidth + tolerOffsetLeftIn - overSizeLeftIn + gs_trim_width_in,  B + overSizeTopIn,  4! * not(bHalfCircle)
						del 2
					endif

					body -1
					bprism_ matTrim, matTrim, matTrim,
						4, signWallIsLeft * thk, rBoard,
						px1,	py1,	s1,
						px2,	py2,	s2,
						px2,	py3l,	s3,
						px1,	py4l,	s4
					gosub "TextCoord_Vert"

					if bParalellInCurvedWalls then
						cutend
						cutend
					endif
				endif

				! --- Draw Right side Jamb Extension ---

				px1 = signWallIsLeft * (offsArc + rBoard * alfaRightIn * DegRad) + rightWidth * bParalellInCurvedWalls
				px2 = px1 - signWallIsLeft * gs_trim_width_in - rightWidth * bParalellInCurvedWalls * 2

				if	bShapeEnablesStraightTopTrim then
					py1 = B + overSizeTopIn - not(gs_stack_top) * gs_trim_width_in * bParalellInCurvedWalls - tolerOffsetUpperIn
					py2 = py1 - not(gs_stack_top) * gs_trim_width_in * not(bParalellInCurvedWalls)

					s1 = 8 + 2 * not(gs_stack_top)		! 15 or 8
					s2 = bitset (mask, 1, not(gs_stack_top))
				endif
				if	bShapeEnablesArchedTopTrim then
					ta = rightWidth
					tc = arcR + tolerOffsetUpper
					if tc > ta then
						py1 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))
					else
						py1 = B - arcR - tolerOffsetUpper
					endif
					ta = ta - gs_trim_width_in
					tc = tc - gs_trim_width_in
					if tc > ta then
						py2 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))
					else
						py2 = B - arcR - tolerOffsetUpper
					endif
					s1 = 8
					s2 = mask - 2
				endif

				if not(gs_stack_right | bRightCornerFunction) & bShapeEnablesStraightRightTrim then
					if bParalellInCurvedWalls then
						addz -rBoard
						roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

						cutpolya 4, 1, 0,
							rightWidth - tolerOffsetRightIn + overSizeRightIn,  -overSizeBottomIn,  0,
							rightWidth * 3,  -overSizeBottomIn,  0,
							rightWidth * 3, B + overSizeTopIn, 0,
							rightWidth - tolerOffsetRightIn + overSizeRightIn,  B + overSizeTopIn,  5

						cutpolya 4, 1, 0,
							rightWidth - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in,  -overSizeBottomIn,  7,
							-leftWidth,  -overSizeBottomIn,  7,
							-leftWidth, B + overSizeTopIn, 7,
							rightWidth - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in,  B + overSizeTopIn,  4
						del 2
					endif

					body -1
					bprism_ matTrim, matTrim, matTrim,
						4, signWallIsLeft * thk, rBoard,
						px1,	py1,	s1,
						px2,	py2,	s2,
						px2,	py3r,	s3,
						px1,	py4r,	s4
					gosub "TextCoord_Vert"

					if bParalellInCurvedWalls then
						cutend
						cutend
					endif
				endif

				if	bTShapedOpening then

					del 3

					alphaLeft = abs(asn(leftRevealPnts[idxBoardEndRevealLeft][1]  / radBoard)) + 10
					alphaRight = abs(asn(rightRevealPnts[idxBoardEndRevealright][1] / radBoard)) + 10

					alfaEnd		= alphaRight
					alfaStart	= -alphaLeft
					arcRadius	= radBoard
					bMiddlePoints = 1
					firstStatus	= 31
					midStatus	= 10 + 5 * (gs_trim_offs_in > EPS) + 64 + 16
					lastStatus	= 31
					if abs(alfaStart - alfaEnd) > EPS then
						gosub 110

						rotx 90
						muly -1
						addz -overSizeBottomIn

						cutDepth = MAX(py3l, py3r)
						if wallIsLeft then
!								prism_ NSP/3 + 2,-cutDepth,
!									radBoard * sin(alphaRight), 2*WOD, 15,
!									-radBoard * sin(alphaLeft), 2*WOD, 15,
!									use(nsp)
							cutpolya NSP/3 + 2,1,0,
								radBoard * sin(alphaRight), 2*WOD, 15,
								-radBoard * sin(alphaLeft), 2*WOD, 15,
								get(nsp)
						else
!								prism_ NSP/3 + 2,-cutDepth,
!									 radBoard * sin(alphaRight) + 3, radBoard * cos(alphaRight) + WOD + 2, 15,
!									-radBoard * sin(alphaLeft) - 3,  radBoard * cos(alphaLeft)  + WOD + 2, 15,
!									use(nsp)
							cutpolya NSP/3 + 2,1,0,
								radBoard * sin(alphaRight) + 3, radBoard * cos(alphaRight) + WOD + 2, 31,
								-radBoard * sin(alphaLeft) - 3,  radBoard * cos(alphaLeft)  + WOD + 2, 31,
								get(nsp)
						endif
						del 3
					endif

					if	bPShapedLeftOpening & gs_trim_below_boardLeft then
						! --- Draw Door's Left side Jamb Extension ---

						px1lP = -leftWidth - overSizeLeftIn + gs_sidelight_WHole_width_left ! + tolerOffsetLeftIn
						px2lP = px1lP + gs_trim_width_in
						py1 = -overSizeBottomIn
						py2 = -overSizeBottomIn

						addz -thk - 1
						body -1
						sprism_ matTrim, matTrim, matTrim,
							4, 0,0, 0,1, thk - pocketThkLeft + 1, wallIncl,
							 px1lP,	py1,	s1,
							 px2lP,	py2,	mask,
							 px2lP,	py3l,	s3,
							 px1lP,	py4l,	s4
						gosub "TextCoord_Vert"
						del 1

						if	not(bDrawLeftSLBoard) then
							! --- Draw Left Sidelight lower side Jamb Extension ---

							if not(bParalellInCurvedWalls) then
								addz -WOD
								roty -alfaLeftIn * signWallIsLeft
								addz rBoard * signWallIsLeft
								addy py4l
								roty 90
								rotx 180 + 45 * not(gs_stack_left)

								!rect 1,1
								cutplane

								del 6
							endif

							addz -thk - 1

							px1l = -leftWidth - overSizeLeftIn - 1 * not(bParalellInCurvedWalls)
							px2l = px1l + gs_trim_width_in

							sprism_ matTrim, matTrim, matTrim,
								4, 0,0, 0,1, thk - pocketThkLeft + 1, wallIncl,
								px2lP,	py3l,	15,
								px1lP,	py4l,	15,
								px1l,	py4l,	15,
								px2l,	py3l,	mask
							gosub "TextCoord_Hor"

							del 1

							if not(bParalellInCurvedWalls) then cutend

						endif
					endif

					if	bPShapedRightOpening & gs_trim_below_boardRight then
						! --- Draw Door's Right side Jamb Extension ---

						px1rP = rightWidth + overSizeRightIn - gs_sidelight_WHole_width_right
						px2rP = px1rP - gs_trim_width_in
						py1 = -overSizeBottomIn
						py2 = -overSizeBottomIn

						addz -thk - 1

						body -1
						sprism_ matTrim, matTrim, matTrim,
							4, 0,0, 0,1, thk - pocketThkRight + 1, wallIncl,
							 px1rP,	py1,	s1,
							 px2rP,	py2,	mask,
							 px2rP,	py3r,	s3,
							 px1rP,	py4r,	s4
						gosub "TextCoord_Vert"
						del 1

						if	not(bDrawRightSLBoard) then
							! --- Draw Right Sidelight lower side Jamb Extension ---

							if not(bParalellInCurvedWalls) then
								addz -WOD
								roty alfaRightIn * signWallIsLeft
								addz rBoard * signWallIsLeft

								addy py4r
								roty 90
								rotx 360 - 45 * not(gs_stack_right)

								!rect 1,1
								cutplane

								del 6
							endif

							addz -thk - 1

							px1r = rightWidth + 1 * not(bParalellInCurvedWalls)
							px2r = px1r - gs_trim_width_in

							sprism_ matTrim, matTrim, matTrim,
								4, 0,0, 0,1, thk - pocketThkLeft + 1, wallIncl,
								px2rP,	py3r,	15,
								px1rP,	py4r,	15,
								px1r,	py4r,	15,
								px2r,	py3r,	mask
							gosub "TextCoord_Hor"

							del 1

							if not(bParalellInCurvedWalls) then cutend

						endif
					endif

					if abs(alfaStart - alfaEnd) > EPS then cutend

					addz -WOD
					roty (not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) + not(wallIsLeft) * 180
					addz rBoard
				endif

				if not(bParalellInCurvedWalls) then
					px1 = signWallIsLeft * (offsArc - rBoard * alfaLeftIn * DegRad)
					px2 = px1 + signWallIsLeft * not(gs_stack_left) * gs_trim_width_in
					px4 = signWallIsLeft * (offsArc + rBoard * alfaRightIn * DegRad)
					px3 = px4 - signWallIsLeft * not(gs_stack_right) * gs_trim_width_in
				else
					px1 = signWallIsLeft * (offsArc - rBoard * alfaLeftIn * DegRad - (leftWidth - tolerOffsetLeftIn) * not(gs_stack_left))
					px2 = px1
					px4 = signWallIsLeft * (offsArc + rBoard * alfaRightIn * DegRad + (rightWidth - tolerOffsetRightIn) * not(gs_stack_right))
					px3 = px4
				endif

				if not(gs_stack_bottom | bDrawBoard | not(isWindow)) & bShapeEnablesStraightBottomTrim then
					if bParalellInCurvedWalls then
						addz -rBoard
						roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

						if not(gs_stack_left) then
							cutpolya 4, 1, 0,
								-leftWidth + tolerOffsetLeftIn - overSizeLeftIn,  -overSizeBottomIn,  7,
								-leftWidth * 3,  -overSizeBottomIn,  7,
								-leftWidth * 3, B + overSizeTopIn, 7,
								-leftWidth + tolerOffsetLeftIn - overSizeLeftIn,  B + overSizeTopIn,  7
						endif

						if not(gs_stack_right) then
							cutpolya 4, 1, 0,
								rightWidth - tolerOffsetRightIn + overSizeRightIn,  -overSizeBottomIn,  7,
								rightWidth * 3,  -overSizeBottomIn,  7,
								rightWidth * 3, B + overSizeTopIn, 7,
								rightWidth - tolerOffsetRightIn + overSizeRightIn,  B + overSizeTopIn,  4
						endif
						del 2
					endif

					py1 = -overSizeBottomIn + tolerOffsetLowerIn
					py2 = py1 + gs_trim_width_in

					bprism_ matTrim, matTrim, matTrim,
						4, signWallIsLeft * thk, rBoard,
						px1,	py1, 	8 + 2 * not(gs_stack_left),		! 15 or 8
						px2,	py2,	bitset (mask, 1, not(gs_stack_left)),
						px3,	py2,	8 + 2 * not(gs_stack_right),		! 15 or 8
						px4,	py1,	13 + 2 * not(gs_stack_right)		! 15 or 13
					gosub "TextCoord_Hor"

					if bParalellInCurvedWalls then
						if not(gs_stack_left) then cutend
						if not(gs_stack_right) then cutend
					endif
				endif



				if bShapeEnablesStraightTopTrim & not(gs_stack_top) then

					if bParalellInCurvedWalls then
						addz -rBoard
						roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

						if not(gs_stack_left) then
							cutpolya 4, 1, 0,
								-leftWidth + tolerOffsetLeftIn - overSizeLeftIn,  -overSizeBottomIn,  7,
								-leftWidth * 3,  -overSizeBottomIn,  7,
								-leftWidth * 3, B + overSizeTopIn, 7,
								-leftWidth + tolerOffsetLeftIn - overSizeLeftIn,  B + overSizeTopIn,  7
						endif

						if not(gs_stack_right) then
							cutpolya 4, 1, 0,
								rightWidth - tolerOffsetRightIn + overSizeRightIn,  -overSizeBottomIn,  7,
								rightWidth * 3,  -overSizeBottomIn,  7,
								rightWidth * 3, B + overSizeTopIn, 7,
								rightWidth - tolerOffsetRightIn + overSizeRightIn,  B + overSizeTopIn,  4
						endif
						del 2
					endif

					py1 = B + overSizeTopIn - tolerOffsetUpperIn
					py2 = py1 - gs_trim_width_in

					bprism_ matTrim, matTrim, matTrim,
						4, signWallIsLeft * thk, rBoard,
						px1,	py1,	8 + 2 * not(gs_stack_left),		! 15 or 8
						px2,	py2,	bitset (mask, 1, not(gs_stack_left)),
						px3,	py2,	8 + 2 * not(gs_stack_right),		! 15 or 8
						px4,	py1,	13 + 2 * not(gs_stack_right)		! 15 or 13

					if bParalellInCurvedWalls then
						if not(gs_stack_left) then cutend
						if not(gs_stack_right) then cutend
					endif
				endif

				if	bShapeEnablesArchedTopTrim then

					resol WALL_RESOL

					px1 = signWallIsLeft * (offsArc - rBoard * alfaLeftIn * DegRad)
					px2 = px1 + signWallIsLeft * gs_trim_width_in
					px4 = signWallIsLeft * (offsArc + rBoard * alfaRightIn * DegRad)
					px3 = px4 - signWallIsLeft * gs_trim_width_in

					mulRatio = (leftWidth + rightWidth + overSizeLeftIn + overSizeRightIn - tolerOffsetLeft - tolerOffsetRight) / abs(px1 - px4)
					addy B - archHeight - tolerOffsetUpper
					muly mulRatio

					if bHalfCircle then
						if not(bParalellInCurvedWalls) then
							bprism_ matTrim, matTrim, matTrim,
								8, signWallIsLeft * thk, rBoard,
								px1,	0, 	   8 + 7 * gs_stack_left,		! 15 or 8
								px2,	0,	  62 + mask,
								0,		1,	 800,
								px3,	0,	1008 + 7 * gs_stack_right,		! 1015 or 1008
								px4,	-EPS,  8 + 7 * gs_stack_right,		! 15 or 8
								px4,	0,	  79,
								0,		1,	 800,
								px1,	0, 	1015
						else

							px1_grbody = signWallIsLeft * (offsArc - rBoard * PI/2)
							px4_grbody = signWallIsLeft * (offsArc + rBoard * PI/2)

							addz -rBoard
							roty -1*(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180
							addz WOD

							cutpolya 3, 1, 0,
								-leftWidth + tolerOffsetLeft + gs_trim_width_in,	0,	  62 + mask,
								0,		1,	 800,
								rightWidth - tolerOffsetRight - gs_trim_width_in,	0,	1008 + 7 * gs_stack_right

							cutpolya 7, 1, 0,
								rBoard + WALL_THICKNESS + 1, 0, 15,
								rBoard + WALL_THICKNESS + 1, rightWidth, 15,
								-rBoard - WALL_THICKNESS - 1, rightWidth, 15,
								-rBoard - WALL_THICKNESS - 1, 0, 15,
								-leftWidth + tolerOffsetLeft,	0,	  62 + mask,
								0,		1,	 800,
								rightWidth - tolerOffsetRight,	0,	1008 + 7 * gs_stack_right

							del 3

							bprism_ matTrim, matTrim, matTrim,
								4, signWallIsLeft * thk, rBoard,
								px1_grbody,0,8,
								px4_grbody, 0, 8,
								px4_grbody, rightWidth,8,
								px1_grbody, rightWidth,8

							cutend
							cutend

						endif
					else

						ta = (leftWidth + rightWidth) / 2
						tc = arcR
						py1 = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

						ta = ta - gs_trim_width_in
						tc = tc - gs_trim_width_in
						py2 = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

						bprism_ matTrim, matTrim, matTrim,
							6, signWallIsLeft * thk, rBoard,
							(px2 + px3) / 2,		(archHeight - arcR) / mulRatio, 900,
							px2,	py2, 	   8 + 7 * gs_stack_left,	! 15 or 8
							px1,	py1,	  79,
							px4,	py1,	3010 + 5 * gs_stack_right,	! 15 or 8
							px3,	py2,	  62 + mask,
							px2,	py2, 	3015
					endif

					del 2
				endif

				if iWindowShape = SHAPE_ELLIPSEARCH then

					px1 = offsArc - rBoard * alfaLeft * DegRad
					px4 = offsArc + rBoard * alfaRight * DegRad

					offs = (leftWidth + overSizeLeftIn - (rBoard * alfaLeft * DegRad))
					if wallIsLeft then
						s3 = 12 + 1 * (abs(gs_trim_offs_in) > EPS | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS) - 2 * gs_stack_right
					else
						s3 = 9 + 4 * (abs(gs_trim_offs_in) > EPS | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS) - 2 * gs_stack_right
					endif
					mulRatio = (archHeight / (archHeight + overSizeLeftIn - offs))

					addy B - tolerOffsetUpper + ((archHeight * mulRatio) - archHeight)
					muly mulRatio

					bprism_ matTrim, matTrim, matTrim,
						13, signWallIsLeft * thk, rBoard,
						signWallIsLeft * offsArc + leftWidth + overSizeLeftIn - tolerOffsetLeft - offs,						-archHeight,			13,
						signWallIsLeft * offsArc + leftWidth - smallRadiusEllips,											-archHeight,			913,
						0,		 																							 alphaSide,				4013,
						signWallIsLeft * offsArc - (leftWidth - rightWidth)/2,												-middleRadiusEllips, 	913,
						0,		 																							 alphaMiddle,			4013,
						signWallIsLeft * offsArc - rightWidth + smallRadiusEllips, 											-archHeight,			913,
						0,		 																							 alphaSide,				4008,
						signWallIsLeft * offsArc - rightWidth - overSizeLeftIn - tolerOffsetLeft + offs + gs_trim_width_in,	-archHeight,			s3,
						0,		 																							-alphaSide,				4000+s3,
						signWallIsLeft * offsArc - (leftWidth - rightWidth)/2,												-middleRadiusEllips, 	900+s3,
						0,		 																							-alphaMiddle,			4000+s3,
						signWallIsLeft * offsArc + leftWidth - smallRadiusEllips,											-archHeight,			900+s3,
						0,		 																							-alphaSide,				4000+s3

					del 2
				endif
				gosub "TextCoord_Hor"

				del 3
			endif

			if numCutsFrame then
				cutend
				numCutsFrame = 0
			endif

			if not(gs_stack_left) then
				alfaLeftParallelIn = abs (asn ( (leftRevealPnts[idxBoardEndRevealLeft][1] + gs_trim_width_in) / rBoard))
			else
				alfaLeftParallelIn = alfaLeft
			endif
			if not(gs_stack_right) then
				alfaRightParallelIn = abs (asn ( (rightRevealPnts[idxBoardEndRevealRight][1] - gs_trim_width_in) / rBoard))
			else
				alfaRightParallelIn = alfaRight
			endif

			if gs_trim_thk_in > EPS & gs_trim_show_cover_in then

				material gs_trim_in_mat
				sect_fill gs_trim_fill_in, gs_trim_pen_bg_in, gs_trim_pen_fg_in, gs_trim_pen_cont_in

				! ===== Inside Trim - Curved Walls - Casing =====

				if wallIsLeft then
					mask = 11 + 4 * (gs_trim_offs_in > EPS)
				else
					mask = 14 + (gs_trim_offs_in > EPS)
				endif

				maskTop		= 8 + 2 * not(gs_stack_top) * not(bParalellInCurvedWalls)
				maskBottom	= 8 + 2 * not(gs_stack_bottom)
				maskLeft	= 8 + (2 + 5 * bParalellInCurvedWalls) * not(gs_stack_left)
				maskRight	= 8 + 2 * not(gs_stack_right)

				maskLeft2	= bDrawBoard*(not(bTrimovbotleftin)*(15-7*gs_stack_left)+bTrimovbotleftin*(10-2*gs_stack_left))
				maskRight2	= bDrawBoard*(not(bTrimovbotrightin)*(15-7*gs_stack_right)+bTrimovbotrightin*(10-2*gs_stack_right))

				if	iWindowShape = SHAPE_RECTANGULAR | \
					bPShapedLeftOpening then

					if gs_stack_left then
						pxL = leftRevealPnts[idxBoardEndRevealLeft][1]
					else
						pxL = leftRevealPnts[idxBoardEndRevealLeft][1] + gs_trim_width_in + not(gs_stack_left) * (-gs_trim_offs_in + tolerOffsetLeftIn)
						alphaLeft = abs(asn(pxL / rBoard)) + ArcLengthBoardToAngle * gs_tw_left_in
						pxL = -rBoard * sin(alphaLeft)
						pyL = -sqr(rBoard^2 - pxL^2) - WOD
					endif
					if gs_stack_right then
						pxR = rightRevealPnts[idxBoardEndRevealright][1]
					else
						pxR = rightRevealPnts[idxBoardEndRevealright][1] - gs_trim_width_in - not(gs_stack_right) * (-gs_trim_offs_in + tolerOffsetRightIn)
						alphaRight = abs(asn(pxR / rBoard)) + ArcLengthBoardToAngle * gs_tw_right_in
						pxR = rBoard * sin(alphaRight)
						pyR = -sqr(rBoard^2 - pxR^2) - WOD
					endif
					if isWindow then
						pyB = -overSizeBottomIn - not(gs_stack_bottom) * (-tolerOffsetLowerIn - trinB + gs_trim_offs_in + gs_tw_bottom_in*not(bTrimovbotleftin)) - sjby
					else
						pyB = 0
					endif
					pyT = B + overSizeTopIn + not(gs_stack_top) * (- tolerOffsetUpperIn - trinT + gs_trim_offs_in + gs_tw_top_in*not(bTrimovtopleftin)) + sjty

					if bCutWall then
						pen WALL_VIEW_PEN
						material matWallIn

						alfaEnd		= alphaRight
						alfaStart	= -alphaLeft
						arcRadius	= radBoard
						bMiddlePoints = 1
						firstStatus	= 31
						midStatus	= 95
						lastStatus	= 31
						if abs(alfaStart - alfaEnd) > EPS then
							gosub 110

							rotx 90
							muly -1
							addz -pyB

							cutDepth = pyT - pyB
							if wallIsLeft then
!								prism_ NSP/3 + 1,-cutDepth,
!									0,WOD,15,
!									use(nsp)
								wallniche NSP/3 + 1,1,0,
									0,0,-cutDepth,cutDepth,
									0,WOD,31,
									get(nsp)
							else
!								prism_ NSP/3 + 2,-cutDepth,
!									 (rBoard + WALL_THICKNESS) * sin(alphaLeft),  (rBoard + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 15,
!									-(rBoard + WALL_THICKNESS) * sin(alphaRight), (rBoard + WALL_THICKNESS) * cos(alphaRight) + WOD, 15,
!									use(nsp)
								wallniche NSP/3 + 2,1,0,
									0,0,-cutDepth,cutDepth,
									 (rBoard + WALL_THICKNESS) * sin(alphaLeft),  (rBoard + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 31,
									-(rBoard + WALL_THICKNESS) * sin(alphaRight), (rBoard + WALL_THICKNESS) * cos(alphaRight) + WOD, 31,
								get(nsp)
							endif
							del 3
						endif

						pen gs_frame_pen
						material gs_trim_in_mat
					endif
				endif

				if bShapeEnablesStraightTopTrim & not(gs_stack_top) & gs_trimtype_in_int = CASING_NORMAL & (bTrimovtopleftin | bTrimovtoprightin) then
					if gs_stack_left then
						pxL = leftRevealPnts[idxBoardEndRevealLeft][1]
					else
						pxL = leftRevealPnts[idxBoardEndRevealLeft][1] + gs_trim_width_in + not(gs_stack_left) * (-gs_trim_offs_in + tolerOffsetLeftIn)
						alphaLeft = abs(asn(pxL / rBoard)) + ArcLengthBoardToAngle * (gs_tw_left_in + gs_trimov_top_left_in)
						pxL = -rBoard * sin(alphaLeft)
						pyL = -sqr(rBoard^2 - pxL^2) - WOD
					endif
					if gs_stack_right then
						pxR = rightRevealPnts[idxBoardEndRevealright][1]
					else
						pxR = rightRevealPnts[idxBoardEndRevealright][1] - gs_trim_width_in - not(gs_stack_right) * (-gs_trim_offs_in + tolerOffsetRightIn)
						alphaRight = abs(asn(pxR / rBoard)) + ArcLengthBoardToAngle * (gs_tw_right_in + gs_trimov_top_right_in)
						pxR = rBoard * sin(alphaRight)
						pyR = -sqr(rBoard^2 - pxR^2) - WOD
					endif
					pyB = B + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in - tolerOffsetUpperIn
					pyT = pyB + gs_tw_top_in

					if bCutWall then
						pen WALL_VIEW_PEN
						material matWallIn

						alfaEnd		= alphaRight
						alfaStart	= -alphaLeft
						arcRadius	= radBoard
						bMiddlePoints = 1
						firstStatus	= 31
						midStatus	= 95
						lastStatus	= 31
						if abs(alfaStart - alfaEnd) > EPS then
							gosub 110

							rotx 90
							muly -1
							addz -pyB

							cutDepth = pyT - pyB
							if wallIsLeft then
!								prism_ NSP/3 + 1,-cutDepth,
!									0,WOD,15,
!									use(nsp)
								wallniche NSP/3 + 1,1,0,
									0,0,-cutDepth,cutDepth,
									0,WOD,31,
									get(nsp)
							else
!								prism_ NSP/3 + 2,-cutDepth,
!									 (rBoard + WALL_THICKNESS) * sin(alphaLeft),  (rBoard + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 15,
!									-(rBoard + WALL_THICKNESS) * sin(alphaRight), (rBoard + WALL_THICKNESS) * cos(alphaRight) + WOD, 15,
!									use(nsp)
								wallniche NSP/3 + 2,1,0,
									0,0,-cutDepth,cutDepth,
									 (rBoard + WALL_THICKNESS) * sin(alphaLeft),  (rBoard + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 31,
									-(rBoard + WALL_THICKNESS) * sin(alphaRight), (rBoard + WALL_THICKNESS) * cos(alphaRight) + WOD, 31,
									get(nsp)
							endif
							del 3
						endif

						pen gs_frame_pen
						material gs_trim_in_mat
					endif
				endif


				pxL = leftRevealPnts[idxBoardEndRevealLeft][1] + gs_trim_width_in + not(gs_stack_left) * (-gs_trim_offs_in + tolerOffsetLeftIn)
				alphaLeft = abs(asn(pxL / rBoard)) + ArcLengthBoardToAngle * gs_tw_left_in
				pxL = -rBoard * sin(alphaLeft)
				pyL = -sqr(rBoard^2 - pxL^2) - WOD

				pxR = leftRevealPnts[idxBoardEndRevealLeft][1] + gs_trim_width_in + not(gs_stack_left) * (-gs_trim_offs_in + tolerOffsetLeftIn)
				alphaRight = abs(asn(pxR / rBoard))
				pxR = -rBoard * sin(alphaRight)
				pyR = -sqr(rBoard^2 - pxR^2) - WOD

				pyB = B + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in - tolerOffsetUpperIn
				if isWindow then
					pyB = -overSizeBottomIn + not(bDrawBoard) * tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawBoard)\
						 - not(bDrawBoard) * gs_trim_offs_in * not(gs_trim_atframe_in) - gs_trimov_bot_left_in - gs_tw_bottom_in*(not(bDrawBoard) or (bDrawBoard and bTrimovbotleftin)) * not(gs_apron) - gs_apron_width * bTrimovbotleftin * gs_apron) - sjby
				else
					pyB = 0
				endif

				pyT = B + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in - tolerOffsetUpperIn + gs_tw_top_in

				if not(gs_stack_left | bLeftCornerFunction) & bShapeEnablesStraightLeftTrim & gs_trimtype_in_int = CASING_NORMAL & bTrimovtopleftin then
					if bCutWall then
						pen WALL_VIEW_PEN
						material matWallIn

						alfaEnd		= -alphaRight
						alfaStart	= -alphaLeft
						arcRadius	= radBoard
						bMiddlePoints = 1
						firstStatus	= 31
						midStatus	= 95
						lastStatus	= 31
						if abs(alfaStart - alfaEnd) > EPS then
							gosub 110

							rotx 90
							muly -1
							addz -pyB

							cutDepth = pyT - pyB
							if wallIsLeft then
!								prism_ NSP/3 + 1,-cutDepth,
!									0,WOD,15,
!									use(nsp)
								wallniche NSP/3 + 1,1,0,
									0,0,-cutDepth,cutDepth,
									0,WOD,31,
									get(nsp)
							else
!								prism_ NSP/3 + 2,-cutDepth,
!									-(rBoard + WALL_THICKNESS) * sin(alphaRight), (rBoard + WALL_THICKNESS) * cos(alphaRight) + WOD, 15,
!									-(rBoard + WALL_THICKNESS) * sin(alphaLeft),  (rBoard + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 15,
!									use(nsp)
								wallniche NSP/3 + 2,1,0,
									0,0,-cutDepth,cutDepth,
									-(rBoard + WALL_THICKNESS) * sin(alphaRight), (rBoard + WALL_THICKNESS) * cos(alphaRight) + WOD, 31,
									-(rBoard + WALL_THICKNESS) * sin(alphaLeft),  (rBoard + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 31,
									get(nsp)
							endif
							del 3
						endif

						pen gs_frame_pen
						material gs_trim_in_mat
					endif
				endif


				pxR = rightRevealPnts[idxBoardEndRevealRight][1] - gs_trim_width_in - not(gs_stack_right) * (-gs_trim_offs_in + tolerOffsetRightIn)
				alphaRight = abs(asn(pxR / rBoard)) + ArcLengthBoardToAngle * gs_tw_right_in
				pxR = -rBoard * sin(alphaRight)
				pyR = -sqr(rBoard^2 - pxR^2) - WOD

				pxL = rightRevealPnts[idxBoardEndRevealRight][1] - gs_trim_width_in - not(gs_stack_right) * (-gs_trim_offs_in + tolerOffsetRightIn)
				alphaLeft = abs(asn(pxL / rBoard))
				pxL = -rBoard * sin(alphaLeft)
				pyL = -sqr(rBoard^2 - pxL^2) - WOD

				pyB = B + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in - tolerOffsetUpperIn
				if isWindow then
					pyB = -overSizeBottomIn + not(bDrawBoard) * tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawBoard)\
						 - not(bDrawBoard) * gs_trim_offs_in * not(gs_trim_atframe_in) - gs_trimov_bot_right_in - gs_tw_bottom_in*(not(bDrawBoard) or (bDrawBoard and bTrimovbotrightin)) * not(gs_apron) - gs_apron_width * bTrimovbotrightin * gs_apron) - sjby
				else
					pyB = 0
				endif

				pyT = B + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in - tolerOffsetUpperIn + gs_tw_top_in

				if not(gs_stack_right | bRightCornerFunction) & bShapeEnablesStraightRightTrim & gs_trimtype_in_int = CASING_NORMAL & bTrimovtoprightin then
					if bCutWall then
						pen WALL_VIEW_PEN
						material matWallIn

						alfaEnd		= alphaRight
						alfaStart	= alphaLeft
						arcRadius	= radBoard
						bMiddlePoints = 1
						firstStatus	= 31
						midStatus	= 95
						lastStatus	= 31
						if abs(alfaStart - alfaEnd) > EPS then
							gosub 110

							rotx 90
							muly -1
							addz -pyB

							cutDepth = pyT - pyB
							if wallIsLeft then
!								prism_ NSP/3 + 1,-cutDepth,
!									0,WOD,15,
!									use(nsp)
								wallniche NSP/3 + 1,1,0,
									0,0,-cutDepth,cutDepth,
									0,WOD,31,
									get(nsp)
							else
!								prism_ NSP/3 + 2,-cutDepth,
!									(rBoard + WALL_THICKNESS) * sin(alphaRight), (rBoard + WALL_THICKNESS) * cos(alphaRight) + WOD, 15,
!									(rBoard + WALL_THICKNESS) * sin(alphaLeft),  (rBoard + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 15,
!									use(nsp)
								wallniche NSP/3 + 2,1,0,
									0,0,-cutDepth,cutDepth,
									(rBoard + WALL_THICKNESS) * sin(alphaRight), (rBoard + WALL_THICKNESS) * cos(alphaRight) + WOD, 31,
									(rBoard + WALL_THICKNESS) * sin(alphaLeft),  (rBoard + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 31,
									get(nsp)
							endif
							del 3
						endif

						pen gs_frame_pen
						material gs_trim_in_mat
					endif
				endif

				addz -WOD
				bCondition = WIDO_REVEAL_SIDE exor SYMB_MIRRORED
				roty (not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) + not(wallIsLeft) * 180
				addz rBoard


				! ===== Inside Trim - Curved Walls - Casing - Top and Bottom Sides =====

				if not(gs_stack_bottom | not(isWindow)) & bShapeEnablesStraightBottomTrim & abs(gs_tw_bottom_in) > EPS then
					if not(bParalellInCurvedWalls) then
						px1 = signWallIsLeft * (offsArc - rBoard * alfaLeftIn * DegRad + not(gs_stack_left) * (gs_trim_width_in - gs_trim_offs_in - gs_tw_left_in*not(bTrimovbotleftin)))

						px2 = px1
						px3 = signWallIsLeft * (offsArc - rBoard * alfaLeftIn * DegRad + not(gs_stack_left) * (gs_trim_width_in - gs_trim_offs_in))
						px4 = signWallIsLeft * (offsArc + rBoard * alfaRightIn * DegRad + not(gs_stack_right) * (-gs_trim_width_in + gs_trim_offs_in))
						px5 = signWallIsLeft * (offsArc + rBoard * alfaRightIn * DegRad + not(gs_stack_right) * (-gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in*not(bTrimovbotrightin)))
						px6 = px5

						py1 = -overSizeBottomIn + not(gs_stack_bottom) * (gs_trim_width_in*not(bDrawBoard) - gs_trim_offs_in - gs_tw_bottom_in)
						py2 = py1 + gs_tw_bottom_in*bDrawBoard
						py3 = -overSizeBottomIn + not(gs_stack_bottom) * (gs_trim_width_in*not(bDrawBoard) - gs_trim_offs_in)
						py4 = py3
						py5 = py2
						py6 = py1

						s1 = maskLeft*not(bDrawBoard)+maskLeft2*bDrawBoard
						s2 = maskLeft
						s3 = bitset (mask, 1, not(gs_stack_left))
						s4 = maskRight
						s5 = maskRight*not(bDrawBoard)+maskRight2*bDrawBoard
						s6 = 13 + 2 * not(gs_stack_right)
					else
						px1 = signWallIsLeft * (offsArc - rBoard * alfaLeftParallelIn * DegRad + not(gs_stack_left) * (gs_trim_width_in*0 - gs_trim_offs_in - gs_tw_left_in + tolerOffsetLeftIn))
						px2 = px1
						px3 = signWallIsLeft * (offsArc - rBoard * alfaLeftParallelIn * DegRad + not(gs_stack_left) * (gs_trim_width_in*0 - gs_trim_offs_in - gs_tw_left_in + tolerOffsetLeftIn))
						px4 = signWallIsLeft * (offsArc + rBoard * alfaRightParallelIn * DegRad + not(gs_stack_right) * (-gs_trim_width_in*0 + gs_trim_offs_in + gs_tw_right_in - tolerOffsetRightIn))
						px5 = signWallIsLeft * (offsArc + rBoard * alfaRightParallelIn * DegRad + not(gs_stack_right) * (-gs_trim_width_in*0 + gs_trim_offs_in + gs_tw_right_in - tolerOffsetRightIn))
						px6 = px5

						py1 = -overSizeBottomIn + not(gs_stack_bottom) * ((gs_trim_width_in + tolerOffsetLowerIn)*not(bDrawBoard) - gs_trim_offs_in - gs_tw_bottom_in)
						py2 = py1 + gs_tw_bottom_in * bDrawBoard
						py3 = -overSizeBottomIn + not(gs_stack_bottom) * ((gs_trim_width_in + tolerOffsetLowerIn)*not(bDrawBoard) - gs_trim_offs_in) + EPS
						py4 = py3 + EPS
						py5 = py2
						py6 = py1

						s1 = maskLeft * not(bDrawBoard) + maskLeft2 * bDrawBoard
						s2 = maskLeft
						s3 = bitset (mask, 1, not(gs_stack_left))
						s4 = 13	+ 2 * bDrawBoard
						s5 = maskRight * not(bDrawBoard) + maskRight2 * bDrawBoard
						s6 = 13 + 2 * not(gs_stack_right)
					endif

					if not(gs_apron) & not(bDrawBoard) then
						if bParalellInCurvedWalls then
							addz -rBoard
							roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

							cutpolya 4, 1, 0,
								-leftWidth + tolerOffsetLeftIn - overSizeLeftIn + gs_trim_width_in + gs_trim_offs_in,  py3 - EPS - gs_tw_bottom_in * bTrimovbotleftin,  0,
								-leftWidth * 3,  py3 - EPS - gs_tw_bottom_in * bTrimovbotleftin,  7,
								-leftWidth * 3, B + overSizeTopIn, 7,
								-leftWidth + tolerOffsetLeftIn - overSizeLeftIn + gs_trim_width_in + gs_trim_offs_in,  B + overSizeTopIn,  1 * not(bTrimovbotleftin)

							cutpolya 4, 1, 0,
								-leftWidth + tolerOffsetLeftIn - overSizeLeftIn + gs_trim_width_in - gs_trim_offs_in,  py3 - EPS,  3,
								rightWidth - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in - gs_trim_offs_in,  py3 - EPS,  7,
								rightWidth - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in - gs_trim_offs_in, B + overSizeTopIn, 7,
								-leftWidth + tolerOffsetLeftIn - overSizeLeftIn + gs_trim_width_in - gs_trim_offs_in,  B + overSizeTopIn,  1

							cutpolya 4, 1, 0,
								rightWidth - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in - gs_trim_offs_in,  py3 - EPS - gs_tw_bottom_in * bTrimovbotrightin,  0,
								rightWidth * 3,  py3 - EPS - gs_tw_bottom_in * bTrimovbotrightin,  7,
								rightWidth * 3, B + overSizeTopIn, 7,
								rightWidth - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in - gs_trim_offs_in,  B + overSizeTopIn,  1 * not(bTrimovbotrightin)

							del 2
						endif

						bprism_ bBottomtriminmat, bBottomtriminmat, bBottomtriminmat,
							4+2, -signWallIsLeft * bBottomtriminthk, rBoard,
							px1,	py1, 	s1,
							px2,	py2, 	s2,
							px3,	py3,	s3,
							px4,	py4,	s4,
							px5,	py5, 	s5,
							px6,	py6, 	s6
						gosub "TextCoord_Hor"

						if bParalellInCurvedWalls then
							cutend
							cutend
							cutend
						endif
						material gs_trim_in_mat
					endif
				endif

				if bShapeEnablesStraightTopTrim & not(gs_stack_top) then

					if not(bParalellInCurvedWalls) then
						px1 = signWallIsLeft * (offsArc - rBoard * alfaLeftIn * DegRad + not(gs_stack_left) * (gs_trim_width_in - gs_trim_offs_in - gs_tw_left_in - gs_trimov_top_left_in * bTrimovtopleftin))
						px2 = signWallIsLeft * (offsArc - rBoard * alfaLeftIn * DegRad + not(gs_stack_left) * (gs_trim_width_in - gs_trim_offs_in - (gs_tw_left_in + gs_trimov_top_left_in) * bTrimovtopleftin))
						px3 = signWallIsLeft * (offsArc - rBoard * alfaLeftIn * DegRad + not(gs_stack_left) * (gs_trim_width_in - gs_trim_offs_in - gs_tw_left_in * bTrimovtopleftin))
						px4 = signWallIsLeft * (offsArc - rBoard * alfaLeftIn * DegRad + not(gs_stack_left) * (gs_trim_width_in - gs_trim_offs_in))
						px5 = signWallIsLeft * (offsArc + rBoard * alfaRightIn * DegRad + not(gs_stack_right) * (-gs_trim_width_in + gs_trim_offs_in))
						px6 = signWallIsLeft * (offsArc + rBoard * alfaRightIn * DegRad + not(gs_stack_right) * (-gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in * bTrimovtoprightin))
						px7 = signWallIsLeft * (offsArc + rBoard * alfaRightIn * DegRad + not(gs_stack_right) * (-gs_trim_width_in + gs_trim_offs_in + (gs_tw_right_in + gs_trimov_top_right_in) * bTrimovtoprightin))
						px8 = signWallIsLeft * (offsArc + rBoard * alfaRightIn * DegRad + not(gs_stack_right) * (-gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in + gs_trimov_top_right_in * bTrimovtoprightin))

						py2 = B + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in
						py1 = py2 + gs_tw_top_in
						py3 = py2
						py4 = py2
						py5 = py2
						py6 = py2
						py7 = py2
						py8 = py1

						s1 = 8 + 7 * not(gs_stack_left) * bTrimovtopleftin
						s2 = 15
						s3 = maskLeft
						s4 = bitset (mask, 1, not(gs_stack_left))
						s5 = maskRight
						s6 = 15
						s7 = 8 + 7 * not(gs_stack_right) * bTrimovtoprightin
						s8 = 13 + 2 * not(gs_stack_right)
					else
						px1 = signWallIsLeft * (offsArc - rBoard * alfaLeftParallelIn * DegRad + not(gs_stack_left) * (- gs_trim_offs_in - gs_tw_left_in - gs_trimov_top_left_in * bTrimovtopleftin + tolerOffsetLeftIn))
						px2 = signWallIsLeft * (offsArc - rBoard * alfaLeftParallelIn * DegRad + not(gs_stack_left) * (- gs_trim_offs_in - gs_tw_left_in - gs_trimov_top_left_in * bTrimovtopleftin + tolerOffsetLeftIn))
						px3 = signWallIsLeft * (offsArc - rBoard * alfaLeftParallelIn * DegRad + not(gs_stack_left) * (- gs_trim_offs_in - gs_tw_left_in + tolerOffsetLeftIn))
						px4 = signWallIsLeft * (offsArc - rBoard * alfaLeftParallelIn * DegRad + not(gs_stack_left) * (- gs_trim_offs_in - gs_tw_left_in + tolerOffsetLeftIn))

						px5 = signWallIsLeft * (offsArc + rBoard * alfaRightParallelIn * DegRad + not(gs_stack_right) * (gs_trim_offs_in + gs_tw_right_in - tolerOffsetRightIn))
						px6 = signWallIsLeft * (offsArc + rBoard * alfaRightParallelIn * DegRad + not(gs_stack_right) * (gs_trim_offs_in + gs_tw_right_in - tolerOffsetRightIn))
						px7 = signWallIsLeft * (offsArc + rBoard * alfaRightParallelIn * DegRad + not(gs_stack_right) * (gs_trim_offs_in + gs_tw_right_in + gs_trimov_top_right_in * bTrimovtoprightin - tolerOffsetRightIn))
						px8 = signWallIsLeft * (offsArc + rBoard * alfaRightParallelIn * DegRad + not(gs_stack_right) * (gs_trim_offs_in + gs_tw_right_in + gs_trimov_top_right_in * bTrimovtoprightin - tolerOffsetRightIn))

						py2 = B + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in - EPS - tolerOffsetUpperIn
						py1 = py2 + gs_tw_top_in + EPS
						py3 = py2
						py4 = py2
						py5 = py2
						py6 = py2 + EPS
						py7 = py2 + EPS
						py8 = py1

						s1 = 8 + 7 * not(gs_stack_left)
						s2 = 15
						s3 = maskLeft
						s4 = 10	!bitset (mask, 1, not(gs_stack_left))
						s5 = maskRight
						s6 = 15
						s7 = 8 + 7 * not(gs_stack_right)
						s8 = 13 + 2 * not(gs_stack_right)
					endif

					if bParalellInCurvedWalls then
						add 0, 0, -rBoard
						roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

!						cutpolya 4, 1, 0,
!							-leftWidth + tolerOffsetLeftIn - overSizeLeftIn + gs_trim_width_in + gs_trim_offs_in,  py3 - EPS - gs_tw_bottom_in * bTrimovbotleftin,  0,
!							-leftWidth * 3,  py3 - EPS - gs_tw_bottom_in * bTrimovbotleftin,  7,
!							-leftWidth * 3, py2 + EPS, 2,
!							-leftWidth + tolerOffsetLeftIn - overSizeLeftIn + gs_trim_width_in + gs_trim_offs_in,  py2 + EPS,  1 * not(bTrimovbotleftin)

						cutpolya 4, 1, 0,
							-leftWidth + tolerOffsetLeftIn - overSizeLeftIn + gs_trim_width_in - gs_trim_offs_in,  0,  3,
							rightWidth - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in - gs_trim_offs_in,  0,  7,
							rightWidth - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in - gs_trim_offs_in, py2 + EPS, 1 + 2 * not(gs_stack_right),
							-leftWidth + tolerOffsetLeftIn - overSizeLeftIn + gs_trim_width_in - gs_trim_offs_in,  py2 + EPS,  2 * not(gs_stack_left)

						cutpolya 4, 1, 0,
							rightWidth - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in - gs_trim_offs_in,  py3 - EPS - gs_tw_bottom_in * bTrimovbotrightin,  0,
							rightWidth * 3,  py3 - EPS - gs_tw_bottom_in * bTrimovbotrightin,  7,
							rightWidth * 3, py2 + EPS, 2,
							rightWidth - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in - gs_trim_offs_in,  py2 + EPS,  1 * not(bTrimovbotrightin)
						del 2
					endif

					if gs_trimtype_in_int = CASING_NORMAL then				! Rectangular casing type
						bprism_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							8, -signWallIsLeft * gs_trim_thk_in, rBoard,
								px1, py1, s1,
								px2, py2, s2,
								px3, py3, s3,
								px4, py4, s4,
								px5, py5, s5,
								px6, py6, s6,
								px7, py7, s7,
								px8, py8, s8
					endif

					if gs_trimtype_in_int = CASING_OVERHANG then				! SWE traditional casing type
						bprism_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							10, -signWallIsLeft * gs_trim_thk_in, rBoard,
								px1, py1, s1,
								px1, py1-0.04, s1,
								px3 + (px1 - px3)/2, py2, s2,
								px3, py3, s3,
								px4, py4, s4,
								px5, py5, s5,
								px6, py6, s6,
								px6 + (px8 - px6)/2, py7, s7,
								px8, py8-0.04, s7,
								px8, py8, s8
					endif

					if bParalellInCurvedWalls then
!						cutend
						cutend
						cutend
					endif
				endif

				if	bShapeEnablesArchedTopTrim then

					resol WALL_RESOL


					px1 = signWallIsLeft * (offsArc - rBoard * alfaLeftParallelIn * DegRad - gs_trim_offs_in - gs_tw_left_in + tolerOffsetLeftIn)
					px2 = signWallIsLeft * (offsArc - rBoard * alfaLeftParallelIn * DegRad - gs_trim_offs_in + tolerOffsetLeftIn)

					px3 = signWallIsLeft * (offsArc + rBoard * alfaRightParallelIn * DegRad + gs_trim_offs_in - tolerOffsetRightIn)
					px4 = signWallIsLeft * (offsArc + rBoard * alfaRightParallelIn * DegRad + gs_tw_right_in + gs_trim_offs_in - tolerOffsetRightIn)



					mulRatio = (leftWidth + rightWidth - tolerOffsetLeft - tolerOffsetRight) / (2 * abs(signWallIsLeft * rBoard * alfaLeft * DegRad))
					addy B - archHeight - tolerOffsetUpper
					muly mulRatio

					if bHalfCircle then
						bprism_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							9, -signWallIsLeft * gs_trim_thk_in, rBoard,
							px1,	-EPS, 	   8 + 7 * gs_stack_left,		! 15 or 8
							px1,	0, 	   8 + 7 * gs_stack_left,		! 15 or 8
							px2,	0,	  62 + mask,
							0,		1,	 800,
							px3,	0,	1008 + 7 * gs_stack_right,		! 1015 or 1008
							px4,	-EPS,  8 + 7 * gs_stack_right,		! 15 or 8
							px4,	0,	  79,
							0,		1,	 800,
							px1,	0, 	1079
					else

						ta = (leftWidth + rightWidth) / 2 - gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in
						tc = arcR - gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in
						py1 = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

						ta = ta - gs_tw_right_in
						tc = tc - gs_tw_right_in
						py2 = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

						bprism_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							6, -signWallIsLeft * gs_trim_thk_in, rBoard,
							(px2 + px3) / 2,		(archHeight - arcR) / mulRatio, 900,
							px2,	py2, 	   8 + 7 * gs_stack_left,	! 15 or 8
							px1,	py1,	  79,
							px4,	py1,	3010 + 5 * gs_stack_right,	! 15 or 8
							px3,	py2,	  62 + mask,
							px2,	py2, 	3015
					endif

					del 2
				endif

				if iWindowShape = SHAPE_ELLIPSEARCH then

					px1 = offsArc - rBoard * alfaLeftParallelIn * DegRad - gs_trim_offs_in - gs_tw_left_in + tolerOffsetLeftIn
					px4 = offsArc + rBoard * alfaRightParallelIn * DegRad + gs_tw_right_in + gs_trim_offs_in - tolerOffsetRightIn

					s3 = 9 + 4 * (abs(gs_trim_offs_in) > EPS | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS) - 2 * gs_stack_right

					offs = (leftWidth + overSizeLeftIn - (rBoard * alfaLeft * DegRad))
					if wallIsLeft then
						s3 = 9 + 4 * (abs(gs_trim_offs_in) > EPS | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS) - 2 * gs_stack_right
					else
						s3 = 12 + 1 * (abs(gs_trim_offs_in) > EPS | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS) - 2 * gs_stack_right
					endif
					mulRatio = (archHeight / (archHeight + overSizeLeftIn - offs))

					addy B - tolerOffsetUpper + ((archHeight * mulRatio) - archHeight)
					muly mulRatio
					offs = (leftWidth + overSizeLeftIn - (rBoard * alfaLeft * DegRad + gs_trim_offs_in - gs_trim_width_in))

					bprism_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
						13, -signWallIsLeft * gs_trim_thk_in, rBoard,
						signWallIsLeft * offsArc + leftWidth + overSizeLeftIn - offs - tolerOffsetLeft,					-archHeight,			s3,
						signWallIsLeft * offsArc + leftWidth - smallRadiusEllips,										-archHeight,			900+s3,
						0,		 																						 alphaSide,				4000+s3,
						signWallIsLeft * offsArc - (leftWidth - rightWidth)/2,											-middleRadiusEllips, 	900+s3,
						0,		 																						 alphaMiddle,			4000+s3,
						signWallIsLeft * offsArc - rightWidth + smallRadiusEllips, 										-archHeight,			900+s3,
						0,		 																						 alphaSide,				4008,
						signWallIsLeft * offsArc - rightWidth - overSizeLeftIn + tolerOffsetRight + offs - gs_tw_left_in,-archHeight,			79,
						0,		 																						-alphaSide,				4079,
						signWallIsLeft * offsArc - (leftWidth - rightWidth)/2,											-middleRadiusEllips, 	979,
						0,		 																						-alphaMiddle,			4079,
						signWallIsLeft * offsArc + leftWidth - smallRadiusEllips,										-archHeight,			979,
						0,		 																						-alphaSide,				4008

					del 2

				endif
				gosub "TextCoord_Hor"


				! ===== Inside Trim - Curved Walls - Casing - Sides =====


				if not(bParalellInCurvedWalls) then
					px2 = signWallIsLeft * (offsArc - rBoard * alfaLeftIn * DegRad + gs_trim_width_in - gs_trim_offs_in)
					px1 = px2 - signWallIsLeft * gs_tw_left_in
				else
					px2 = signWallIsLeft * (offsArc - rBoard * alfaLeftParallelIn * DegRad + gs_trim_width_in - gs_trim_offs_in + tolerOffsetLeftIn)
					px1 = signWallIsLeft * (offsArc - rBoard * alfaLeftParallelIn * DegRad - gs_trim_offs_in - gs_tw_left_in + tolerOffsetLeftIn)
				endif
				if gs_stack_left then
					px1LUp = px2 - gs_trim_width_in + gs_trim_offs_in
					px2LUp = px1LUp
				else
					px1LUp = px1 * not(bTrimovbotleftin) + px2 * bTrimovbotleftin
					px2LUp = px2
				endif


				py3 = 0
				py4 = 0
				if	isWindow  | \
					bTShapedOpening then

					s3 = maskBottom						! 15 or 10 or 8
					if not(bParalellInCurvedWalls) then
						s4 = 13 + 2 * (not(gs_stack_bottom)) 	! 15 or 13
					else
						s4 = 13 + 2 * (not(gs_stack_bottom)) * bDrawLeftSLBoard
					endif
				else
					s3 = 15
					s4 = 15
				endif


				if	isWindow | \
					(bPShapedLeftOpening & gs_trim_below_boardLeft) then
					py3l = -overSizeBottomIn + not(bDrawLeftSLBoard) * tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawLeftSLBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawLeftSLBoard)\
					  - gs_trimov_bot_left_in - gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron) - gs_apron_width * bTrimovbotleftin * gs_apron) - sjby
					py4l = -overSizeBottomIn + not(bDrawLeftSLBoard) * tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawLeftSLBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawLeftSLBoard)\
					 - gs_trimov_bot_left_in - gs_tw_bottom_in * (not(bDrawLeftSLBoard) | (bDrawLeftSLBoard & (bTrimovbotleftin | gs_trim_below_boardLeft))) * not(gs_apron) - gs_apron_width * bTrimovbotleftin * gs_apron) - sjby

					s3 = maskBottom						! 15 or 10 or 8
					s4 = 13 + 2 * not(gs_stack_bottom)	! 15 or 13
				else
					py3l = 0
					py4l = 0

					s3 = 15-7*gs_stack_bottom
					s4 = 15
				endif

				py5 = py3l + not(gs_stack_bottom) * bTrimovbotleftin * (gs_trimov_bot_left_in + gs_tw_bottom_in * not(gs_apron) + gs_apron_width * gs_apron) + gs_stack_bottom * gs_trim_stack_bottom * gs_tw_bottom_in / 2
				py6 = py3l + not(gs_stack_bottom) * bTrimovbotleftin * gs_trimov_bot_left_in

				if iWindowShape = SHAPE_ARCHED then py22 = py5

				if	bPShapedLeftOpening then
					py3l = py3l + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + overSizeBottomIn
					py4l = py4l + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + overSizeBottomIn
					py5 = py5 + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + overSizeBottomIn
					py6 = py6 + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + overSizeBottomIn
				endif


				if	bShapeEnablesStraightTopTrim then
					py2 = B + overSizeTopIn + not(gs_stack_top) * (-gs_trim_width_in + gs_trim_offs_in - tolerOffsetUpperIn)
					if not(bParalellInCurvedWalls) then
						py1 = B + overSizeTopIn + not(gs_stack_top) * (-gs_trim_width_in + gs_trim_offs_in + gs_tw_top_in*not(bTrimovtoprightin))
					else
						py1 = py2
					endif

					s1 = maskTop
					s2 = bitset (mask, 1, not(gs_stack_top))
					s5 = 8
				endif
				if	bShapeEnablesArchedTopTrim then
					ta = leftWidth - gs_trim_width_in
					tc = arcR + tolerOffsetUpper - gs_trim_width_in
					if tc > ta then
						py = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))
					else
						py = B - arcR - tolerOffsetUpper
					endif

					ta = ta + gs_trim_offs_in
					tc = tc + gs_trim_offs_in
					if tc > ta then
						py2 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))
					else
						py2 = B - arcR - tolerOffsetUpper
					endif


					ta = ta + gs_tw_right_in
					tc = tc + gs_tw_right_in
					if tc > ta then
						py1 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))
					else
						py1 = B - arcR - tolerOffsetUpper
					endif


					py1 = py1 - (py1 - py) * (1 - mulRatio)		! Correct y coords with mulRatio
					py2 = py2 - (py2 - py) * (1 - mulRatio)

					s1 = 8
					s2 = mask - 2
					s5 = 8
				endif
				if iWindowShape = SHAPE_ELLIPSEARCH then
					py1 = B - archHeight - tolerOffsetUpper
					py2 = B - archHeight - tolerOffsetUpper

					s1 = 8
					s2 = mask - 2
				endif

				if not(gs_stack_left | bLeftCornerFunction) & bShapeEnablesStraightLeftTrim then
					if bParalellInCurvedWalls then
						add 0, 0, -rBoard
						roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

						cutpolya 6, 1, 0,
							-leftWidth + tolerOffsetLeftIn - overSizeLeftIn + gs_trim_width_in - gs_trim_offs_in,  py5,  2,
							-leftWidth + tolerOffsetLeftIn - overSizeLeftIn + gs_trim_width_in - gs_trim_offs_in,  py6,  7 - 2 * ( not(gs_apron) & bDrawLeftSLBoard),
							-leftWidth + tolerOffsetLeftIn - overSizeLeftIn + gs_trim_width_in - gs_trim_offs_in,  -overSizeBottomIn - (gs_trimov_bot_left_in + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron) + gs_apron_width * bTrimovbotleftin * gs_apron),  7,
							rightWidth - tolerOffsetRightIn + overSizeRightIn, -overSizeBottomIn - (gs_trimov_bot_left_in + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron) + gs_apron_width * bTrimovbotleftin * gs_apron),  7,
							rightWidth - tolerOffsetRightIn + overSizeRightIn, B + overSizeTopIn, 1,
							-leftWidth + tolerOffsetLeftIn - overSizeLeftIn + gs_trim_width_in - gs_trim_offs_in,  B + overSizeTopIn,  1
						del 2
					endif

					body -1
					if (gs_apron & abs(gs_trim_thk_in - gs_apron_thk) < EPS) | (not(gs_apron) & (not(bDrawLeftSLBoard) | gs_trim_below_boardLeft)) then
						if bTrimovbotleftin then
							s6 = 15 - 7*gs_stack_bottom
						else
							if gs_tw_bottom_in then
								s6 = s3
							else
								s6 = bitset(s3, 0)
								s6 = bitset(s6, 2)
							endif
						endif
						bprism_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							4, -signWallIsLeft * gs_trim_thk_in, rBoard,
							px1,	py1,	s1,
							px2,	py2,	s2,
!							px2,	py5,	s5,
!							px2,	py6,	s3*not(bTrimovbotleftin)+bTrimovbotleftin*15,
							px2,	py3l,	s6,
							px1,	py4l,	s4
					else
						bprism_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							4+1, -signWallIsLeft * gs_trim_thk_in, rBoard,
							px1,	py1,	s1,
							px2,	py2,	s2,
							px2,	py3l+gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron) + gs_apron_width * bTrimovbotleftin * gs_apron + gs_trimov_bot_left_in,	15-6*gs_stack_bottom,
							px2,	py3l+gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron) + gs_apron_width * bTrimovbotleftin * gs_apron,	15-7*gs_stack_bottom,
							px1,	py3l+gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron) + gs_apron_width * bTrimovbotleftin * gs_apron,	s4

					endif
					gosub "TextCoord_Vert"

					if bParalellInCurvedWalls then
						cutend
					endif
				endif


				if not(bParalellInCurvedWalls) then
					px2 = signWallIsLeft * (offsArc + rBoard * alfaRightIn * DegRad - gs_trim_width_in + gs_trim_offs_in)
					px1 = px2 + signWallIsLeft * gs_tw_right_in
				else
					px2 = signWallIsLeft * (offsArc + rBoard * alfaRightParallelIn * DegRad + gs_trim_offs_in - gs_trim_width_in - tolerOffsetRightIn)
					px1 = signWallIsLeft * (offsArc + rBoard * alfaRightParallelIn * DegRad + gs_trim_offs_in + gs_tw_right_in - tolerOffsetRightIn)
				endif
				if gs_stack_right then
					px1RUp = px2 + gs_trim_width_in - gs_trim_offs_in
					px2RUp = px1RUp
				else
					px1RUp = px1 * not(bTrimovbotrightin) + px2 * bTrimovbotrightin
					px2RUp = px2
				endif

				if	isWindow | \
					(bPShapedRightOpening & gs_trim_below_boardRight) then
					py3r = -overSizeBottomIn + not(bDrawRightSLBoard) * tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawRightSLBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawRightSLBoard)\
					 - gs_trimov_bot_right_in - gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron) - gs_apron_width*bTrimovbotrightin * gs_apron) - sjBy
					py4r = -overSizeBottomIn + not(bDrawRightSLBoard) * tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawRightSLBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawRightSLBoard)\
					 - gs_trimov_bot_right_in - gs_tw_bottom_in * (not(bDrawRightSLBoard) | (bDrawRightSLBoard & (bTrimovbotrightin | gs_trim_below_boardRight))) * not(gs_apron) - gs_apron_width * bTrimovbotleftin * gs_apron) - sjBy

					s3 = maskBottom						! 15 or 10 or 8
					s4 = 13 + 2 * not(gs_stack_bottom)	! 15 or 13
				else
					py3r = 0
					py4r = 0

					s3 = 15-7*gs_stack_bottom
					s4 = 15
				endif

				py5 = py3r + not(gs_stack_bottom) * bTrimovbotrightin * (gs_trimov_bot_right_in + gs_tw_bottom_in * not(gs_apron) + gs_apron_width * gs_apron) + gs_stack_bottom * gs_trim_stack_bottom * gs_tw_bottom_in / 2
				py6 = py3r + not(gs_stack_bottom) * bTrimovbotrightin  * gs_trimov_bot_right_in

				if iWindowShape = SHAPE_ARCHED then py22 = py5

				if	bPShapedRightOpening then
					py3r = py3r + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + overSizeBottomIn
					py4r = py4r + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + overSizeBottomIn
					py5 = py5 + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + overSizeBottomIn
					py6 = py6 + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + overSizeBottomIn
				endif



				if	bShapeEnablesStraightTopTrim then
					py2 = B + overSizeTopIn + not(gs_stack_top) * (-gs_trim_width_in + gs_trim_offs_in - tolerOffsetUpperIn)
					if not(bParalellInCurvedWalls) then
						py1 = B + overSizeTopIn + not(gs_stack_top) * (-gs_trim_width_in + gs_trim_offs_in + gs_tw_top_in*not(bTrimovtoprightin))
					else
						py1 = py2
					endif

					s1 = maskTop
					s2 = bitset (mask, 1, not(gs_stack_top))
					s5 = 8
				endif
				if	bShapeEnablesArchedTopTrim then
					ta = rightWidth - gs_trim_width_in
					tc = arcR + tolerOffsetUpper - gs_trim_width_in
					if tc > ta then
						py = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))
					else
						py = B - arcR - tolerOffsetUpper
					endif

					ta = ta + gs_trim_offs_in
					tc = tc + gs_trim_offs_in
					if tc > ta then
						py2 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))
					else
						py2 = B - arcR - tolerOffsetUpper
					endif

					ta = ta + gs_tw_right_in
					tc = tc + gs_tw_right_in
					if tc > ta then
						py1 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))
					else
						py1 = B - arcR - tolerOffsetUpper
					endif

					py1 = py1 - (py1 - py) * (1 - mulRatio)		! Correct y coords with mulRatio
					py2 = py2 - (py2 - py) * (1 - mulRatio)

					s1 = 8
					s2 = mask - 2
					s5 = 8
				endif

				if not(gs_stack_right | bRightCornerFunction) & bShapeEnablesStraightRightTrim then
					if bParalellInCurvedWalls then
						add 0, 0, -rBoard
						roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

						cutpolya 6, 1, 0,
							rightWidth - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in + gs_trim_offs_in,  py5,  2,
							rightWidth - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in + gs_trim_offs_in,  py6,  7 - 2 * ( not(gs_apron) & bDrawRightSLBoard),
							rightWidth - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in + gs_trim_offs_in,  -overSizeBottomIn - (gs_trimov_bot_right_in + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron) + gs_apron_width * bTrimovbotleftin * gs_apron),  7,
							-leftWidth + tolerOffsetLeftIn, -overSizeBottomIn - (gs_trimov_bot_right_in + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron) + gs_apron_width * bTrimovbotleftin * gs_apron),  7,
							-leftWidth + tolerOffsetLeftIn, B + overSizeTopIn, 1,
							rightWidth - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in + gs_trim_offs_in,  B + overSizeTopIn,  1
						del 2
					endif

					body -1
					if (gs_apron & abs(gs_trim_thk_in - gs_apron_thk) < EPS) | (not(gs_apron) & (not(bDrawRightSLBoard) | gs_trim_below_boardRight)) then
						if bTrimovbotrightin then
							s6 = 15 - 7*gs_stack_bottom
						else
							if gs_tw_bottom_in then
								s6 = s3
							else
								s6 = bitset(s3, 0)
								s6 = bitset(s6, 2)
							endif
						endif
						bprism_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							4, -signWallIsLeft * gs_trim_thk_in, rBoard,
							px1,	py1,	s1,
							px2,	py2,	s2,
!							px2,	py5,	s5,
!							px2,	py6,	s3*not(bTrimovbotrightin)+bTrimovbotrightin*15,
							px2,	py3r,	s6,
							px1,	py4r,	s4
					else
						bprism_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							4+1, -signWallIsLeft * gs_trim_thk_in, rBoard,
							px1,	py1,	s1,
							px2,	py2,	s2,
							px2,	py3r+gs_tw_bottom_in * bTrimovbotrightin* not(gs_apron)+gs_trimov_bot_right_in,	15-6*gs_stack_bottom,
							px2,	py3r+gs_tw_bottom_in * bTrimovbotrightin* not(gs_apron),	15-7*gs_stack_bottom,
							px1,	py3r+gs_tw_bottom_in * bTrimovbotrightin* not(gs_apron),	s4
					endif
					gosub "TextCoord_Vert"

					if bParalellInCurvedWalls then
						cutend
					endif
				endif


				if	bTShapedOpening then

					py1 = -overSizeBottomIn
					py2 = -overSizeBottomIn

					px1l = 0
					px2l = 0
					if bPShapedLeftOpening then
						px1l = signWallIsLeft * (offsArc - leftWidth - overSizeLeftIn + gs_sidelight_WHole_width_left + trinL - gs_trim_offs_in)
						px2l = px1l - signWallIsLeft * gs_trim_below_boardLeft * gs_tw_left_in
						py3l = py4l + gs_trimov_bot_left_in
						py4l = py3l + gs_tw_bottom_in
					endif
					px1r = 0
					px2r = 0
					if bPShapedRightOpening then
						px1r = signWallIsLeft * (offsArc + rightWidth + overSizeRightIn - gs_sidelight_WHole_width_right - trinR + gs_trim_offs_in)
						px2r = px1r + signWallIsLeft * gs_trim_below_boardRight * gs_tw_right_in
						py3r = py4r + gs_trimov_bot_right_in
						py4r = py3r + gs_tw_bottom_in
					endif

					add 0, -gs_tw_bottom_in, -rBoard
					roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

!						prism_ 4,7,
!							- leftWidth - overSizeLeftIn + gs_sidelight_WHole_width_left + gs_trim_width_in - gs_trim_offs_in,  py1,  15,
!							rightWidth + overSizeRightIn - gs_sidelight_WHole_width_right - gs_trim_width_in + gs_trim_offs_in,  py1,  (11 + 4 * (gs_trim_offs_in > EPS))*bCondition + (14 + (gs_trim_offs_in > EPS))*not(bCondition),
!							rightWidth + overSizeRightIn - gs_sidelight_WHole_width_right - gs_trim_width_in + gs_trim_offs_in,  MAX(py4l, py4r) + gs_tw_bottom_in,  15,
!							- leftWidth - overSizeLeftIn + gs_sidelight_WHole_width_left + gs_trim_width_in - gs_trim_offs_in, MAX(py4l, py4r) + gs_tw_bottom_in,  (11 + 4 * (gs_trim_offs_in > EPS))*bCondition + (14 + (gs_trim_offs_in > EPS))*not(bCondition)

					cutpolya 4, 1, 0,
						-leftWidth - overSizeLeftIn + gs_sidelight_WHole_width_left + gs_trim_width_in - gs_trim_offs_in,  py1,  15,
						rightWidth + overSizeRightIn - gs_sidelight_WHole_width_right - gs_trim_width_in + gs_trim_offs_in,  py1,  (11 + 4 * (gs_trim_offs_in > EPS))*not(WIDO_REVEAL_SIDE) + (14 + (gs_trim_offs_in > EPS))*WIDO_REVEAL_SIDE,
						rightWidth + overSizeRightIn - gs_sidelight_WHole_width_right - gs_trim_width_in + gs_trim_offs_in,  MAX(py4l, py4r) + gs_tw_bottom_in,  15,
						-leftWidth - overSizeLeftIn + gs_sidelight_WHole_width_left + gs_trim_width_in - gs_trim_offs_in, MAX(py4l, py4r) + gs_tw_bottom_in,  (11 + 4 * (gs_trim_offs_in > EPS))*not(WIDO_REVEAL_SIDE) + (14 + (gs_trim_offs_in > EPS))*WIDO_REVEAL_SIDE

					del 2

					if bPShapedLeftOpening & gs_trim_below_boardLeft then
						! --- Draw Door's Left side Trim  Curved Wall---
						bprism_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							4, -signWallIsLeft * gs_trim_thk_in, rBoard,
							px1l,	py1,	15,
							px2l,	py2,	s4,
							px2l,	py3l,	10,
							px1l,	py4l,	s2
						gosub "TextCoord_Vert"
					endif

					if bPShapedRightOpening & gs_trim_below_boardRight then
						! --- Draw Door's Right side Trim  Curved Wall---
						bprism_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							4, -signWallIsLeft * gs_trim_thk_in, rBoard,
							px1r,	py1,	15,
							px2r,	py2,	s4,
							px2r,	py3r,	10,
							px1r,	py4r,	s2
						gosub "TextCoord_Vert"
					endif

					if bPShapedLeftOpening & gs_trim_below_boardLeft then
						! --- Draw Left lower Trim  Curved Wall---
						bprism_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							4, -signWallIsLeft * gs_trim_thk_in, rBoard,
							px2LUp,	py4l,	10 - 2 * gs_stack_left,
							px1LUp,	py3l,	15,
							px2l,	py3l,	10 + 5 * not(gs_trim_below_boardLeft),
							px1l,	py4l,	mask
						gosub "TextCoord_Hor"
					endif

					if bPShapedRightOpening & gs_trim_below_boardRight then
						! --- Draw Right lower Trim  Curved Wall---
						bprism_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							4, -signWallIsLeft * gs_trim_thk_in, rBoard,
							px2RUp,	py4r,	10 - 2 * gs_stack_left,
							px1RUp,	py3r,	15,
							px2r,	py3r,	10 + 5 * not(gs_trim_below_boardRight),
							px1r,	py4r,	mask
						gosub "TextCoord_Hor"
					endif

					cutend
				endif

				del 3
			endif
		endif
	endif	! not(curvedWall)


	if bDrawLeftTrimatGangingIn then
		! --- Draw left side Trim at Ganging ---

		px2 = leftRevealPnts[idxBoardEndRevealLeft-1][1] + tolerOffsStackCasLeftIn + trinL - gs_trim_offs_in
		px1 = leftRevealPnts[idxBoardEndRevealLeft-1][1]
		px3 = leftRevealPnts[idxBoardEndRevealLeft-1][1] - gs_trim_thk_in * tan(alfaLeft)

		if iWindowShape = SHAPE_RECTANGULAR then

			if gs_stack_top then
				py1 = B + overSizeTopIn + sjTy
				py2 = py1
				py5 = py2 - ( tolerOffsStackCasUpperIn + trinT - gs_trim_offs_in) * gs_trim_stack_top
			else
				py1 = B + overSizeTopIn - tolerOffsetUpperIn - trinT + (gs_trim_offs_in* not(gs_trim_atframe_in) * (ABS(thk)<EPS)) + sjTy
				py2 = py1
				py5 = py2
			endif

			py = -overSizeBottomIn + tolerOffsStackCasLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * (ABS(thk)<EPS)) - sjBy

			if gs_stack_bottom then
				py3 = py
				py4 = py
				py6 = py3 + ( tolerOffsStackCasLowerIn + trinB - gs_trim_offs_in) * gs_trim_stack_bottom
			else
				py3 = py
				py4 = py3
				py6 = py3
			endif

			s1 = 8 + 5 * (not(gs_stack_top) & bGangedCasingonFrame)
			s2 = 8
			s5 = 13 + 2 * (gs_trim_stack_top | (not(gs_trim_stack_top) & not(gs_trim_atframe_in)))
			s3 = 8 + 7 * (not(gs_stack_bottom) & bGangedCasingonFrame)
			s4 = 8
			s6 = 8 + 7 * (not(gs_stack_bottom) & bGangedCasingonFrame)
		endif

		addz - WIDO_FRAME_THICKNESS - gs_trim_thk_in

		add px1, 0, gs_trim_thk_in
		roty  alfaLeft * ySign - 90
		cutplane 1, 1, 0
		del 2

		body -1

		prism_ 	6, gs_trim_thk_in,
			px3,	py1,	s1,
			px2,	py2,	s2,
			px2,	py5,	s5,
			px2,	py6,	s6,
			px2,	py3,	s3,
			px3,	py4,	s4

		gosub "TextCoord_Vert"

		cutend

		del 1
	endif

	if bDrawRightTrimatGangingIn then
		! --- Draw right side Trim at Ganging ---

		px2 = rightRevealPnts[idxBoardEndRevealRight-1][1]  - tolerOffsStackCasRightIn - trinR + gs_trim_offs_in
		px1 = rightRevealPnts[idxBoardEndRevealRight-1][1]
		px3 = rightRevealPnts[idxBoardEndRevealRight-1][1] + gs_trim_thk_in * tan(alfaRight)

		if iWindowShape = SHAPE_RECTANGULAR then
			if gs_stack_top then
				py1 = B + overSizeTopIn  + sjTy
				py2 = py1
				py5 = py2 - ( tolerOffsStackCasUpperIn  + trinT - gs_trim_offs_in) * gs_trim_stack_top
			else
				py1 = B + overSizeTopIn - tolerOffsetUpperIn - trinT + (gs_trim_offs_in * not(gs_trim_atframe_in) * (ABS(thk)<EPS)) + sjTy
				py2 = py1
				py5 = py2
			endif

			py = -overSizeBottomIn + tolerOffsStackCasLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawBoard)- gs_trim_offs_in * not(gs_trim_atframe_in) * (ABS(thk)<EPS)) - sjBy

			if gs_stack_bottom then
				py3 = py
				py4 = py
				py6 = py3 + ( tolerOffsStackCasLowerIn + trinB - gs_trim_offs_in) * gs_trim_stack_bottom
			else
				py3 = py
				py4 = py3
				py6 = py3
			endif

			s1 = 8 + 5 * (not(gs_stack_top) & bGangedCasingonFrame)
			s2 = 8
			s5 = 13 + 2 * (gs_trim_stack_top | (not(gs_trim_stack_top) & not(gs_trim_atframe_in)))
			s3 = 8 + 7 * (not(gs_stack_bottom) & bGangedCasingonFrame)
			s4 = 8
			s6 = 8 + 7 * (not(gs_stack_bottom) & bGangedCasingonFrame)
		endif

		addz - WIDO_FRAME_THICKNESS - gs_trim_thk_in

		add px1, 0, gs_trim_thk_in
		roty  90 - alfaRight * ySign
		cutplane 1, 1, 0
		del 2

		body -1

		prism_ 	6, gs_trim_thk_in,
			px3,	py1,	s1,
			px2,	py2,	s2,
			px2,	py5,	s5,
			px2,	py6,	s6,
			px2,	py3,	s3,
			px3,	py4,	s4

		gosub "TextCoord_Vert"

		cutend

		del 1
	endif

	if bDrawBottTrimatGangingIn then
	! --- Draw lower Trim at Ganging ---

		if not(gs_stack_left) then
			px1 = leftRevealPnts[idxBoardEndRevealLeft][1]  + tolerOffsetLeftIn + trinL - gs_trim_offs_in * (ABS(thk)<EPS)
			px11 = leftRevealPnts[idxBoardEndRevealLeft-1][1]
		else
			px1 = leftRevealPnts[idxBoardEndRevealLeft-1][1] + (tolerOffsStackCasLeftIn + trinL - gs_trim_offs_in) * gs_trim_stack_left - (gs_trim_thk_in) * tan(alfaLeft) * not(gs_trim_stack_left)
			px11 = leftRevealPnts[idxBoardEndRevealLeft-1][1]
		endif

		if not(gs_stack_right) then
			px2 = rightRevealPnts[idxBoardEndRevealright][1] - tolerOffsetRightIn - trinR + gs_trim_offs_in * (ABS(thk)<EPS)
			px22 = rightRevealPnts[idxBoardEndRevealRight-1][1]
		else
			px2 = rightRevealPnts[idxBoardEndRevealRight-1][1] - (tolerOffsStackCasRightIn + trinR - gs_trim_offs_in) * gs_trim_stack_right  + (gs_trim_thk_in) * tan(alfaRight) * not(gs_trim_stack_right)
			px22 = rightRevealPnts[idxBoardEndRevealRight-1][1]
		endif

		py2 = -overSizeBottomIn
		py1 = py2 + tolerOffsStackCasLowerIn + trinB - gs_trim_offs_in

		s1 = 15 - 2 * (gs_stack_right & not(gs_trim_stack_right))
		s2 = 10 + 5 * (not(gs_stack_right) & bGangedCasingonFrame) - 2 * (gs_stack_right & not(gs_trim_stack_right))
		s3 = 8
		s4 = 8 + 5 * (not(gs_stack_left) & bGangedCasingonFrame)

		addz - WIDO_FRAME_THICKNESS - gs_trim_thk_in

		add px11, 0, gs_trim_thk_in
		roty  alfaLeft * ySign - 90
		cutplane 1, 1, 0
		del 2

		add px22, 0, gs_trim_thk_in
		roty  90 - alfaRight * ySign
		cutplane 1, 1, 0
		del 2

		prism_ 4, gs_trim_thk_in,
			px1,	py1, 	s1,
			px2,	py1, 	s2,
			px2,	py2,	s3,
			px1,	py2,	s4
		gosub "TextCoord_Hor"

		cutend
		cutend

		del 1
	endif

	if bDrawTopTrimatGangingIn then
		! --- Draw upper Trim at Ganging ---

		if not(gs_stack_left) then
			px1 = leftRevealPnts[idxBoardEndRevealLeft][1]  + tolerOffsetLeftIn + trinL - gs_trim_offs_in * (ABS(thk)<EPS)
			px11 = leftRevealPnts[idxBoardEndRevealLeft-1][1]
		else
			px1 = leftRevealPnts[idxBoardEndRevealLeft-1][1] + (tolerOffsStackCasLeftIn + trinL - gs_trim_offs_in) * gs_trim_stack_left - (gs_trim_thk_in) * tan(alfaLeft) * not(gs_trim_stack_left)
			px11 = leftRevealPnts[idxBoardEndRevealLeft-1][1]
		endif

		if not(gs_stack_right) then
			px2 = rightRevealPnts[idxBoardEndRevealright][1] - tolerOffsetRightIn - trinR + gs_trim_offs_in * (ABS(thk)<EPS)
			px22 = rightRevealPnts[idxBoardEndRevealRight-1][1]
		else
			px2 = rightRevealPnts[idxBoardEndRevealRight-1][1] - (tolerOffsStackCasRightIn + trinR - gs_trim_offs_in) * gs_trim_stack_right + (gs_trim_thk_in) * tan(alfaRight) * not(gs_trim_stack_right)
			px22 = rightRevealPnts[idxBoardEndRevealRight-1][1]
		endif


		py2 = B + overSizeTopIn
		py1 = py2  - tolerOffsStackCasUpperIn - trinT + gs_trim_offs_in

		s1 = 15 - 2 * (gs_stack_right & not(gs_trim_stack_right))
		s2 = 10 + 5 * (not(gs_stack_right) & bGangedCasingonFrame) - 2 * (gs_stack_right & not(gs_trim_stack_right))
		s3 = 8
		s4 = 8 + 5 * (not(gs_stack_left) & bGangedCasingonFrame)

		addz - WIDO_FRAME_THICKNESS - gs_trim_thk_in

		add px11, 0, gs_trim_thk_in
		roty  alfaLeft * ySign - 90
		cutplane 1, 1, 0
		del 2

		add px22, 0, gs_trim_thk_in
		roty  90 - alfaRight * ySign
		cutplane 1, 1, 0
		del 2

		prism_ 4, gs_trim_thk_in,
			px1,	py1, 	s1,
			px2,	py1, 	s2,
			px2,	py2,	s3,
			px1,	py2,	s4
		gosub "TextCoord_Hor"

		cutend
		cutend

		del 1
	endif

	del 1

	for i=1 to numCutsCornerColumn
		cutend
	next i
return


2000:
! ==============================================================================
!	Draw Outside Trim
! ==============================================================================

	pen gs_frame_pen

	numCutsCornerColumn = 0

	if gs_corner_column then
		matTrim = gs_trim_out_mat

		material gs_trim_out_mat
		sect_fill gs_trim_fill_out, gs_trim_pen_bg_out, gs_trim_pen_fg_out, gs_trim_pen_cont_out

		gosub 100
	endif

	if not(curvedWall) | (curvedWall & gs_trim_atframe_out) then

		! ======================================
		! Outside Trim - Straight Walls
		! ======================================

		if gs_sectgar = 0 then thk = WIDO_SILL + gs_trim_jambext_nosing_out
		if gs_sectgar = 1 then thk = WALL_THICKNESS - WIDO_SILL

		mask = 10 +\
				1 * bShowEdgesAtFrame +\
				4 * (gs_trim_offs_out > EPS | not(bShowJambExtension) | abs(WIDO_SILL) < EPS | not(gs_trim_show_cover_out) | abs(gs_trim_thk_out) < EPS)

		rotx 180
		addz WIDO_SILL * (gs_trim_atframe_out = 0)
		mulz -1

		if gs_trim_width_out > EPS & thk > EPS & bShowJambExtension & (gs_trim_atframe_out = 0 |\
			(gs_trim_atframe_out = 1 & gs_sectgar)) then

			matTrim = gs_trim_out_mat

			material gs_trim_out_mat
			sect_fill gs_trim_fill_out, gs_trim_pen_bg_out, gs_trim_pen_fg_out, gs_trim_pen_cont_out

			! ===== Outside Trim - Straight Walls - Jamb Extensions =====

			addz thk - gs_trim_jambext_nosing_out
			mulz -1

			if not(gs_stack_left | gs_stack_right | gs_stack_top | gs_stack_bottom | not(bCasingBottomOutside) | bDrawSill | bLeftCornerFunction | bRightCornerFunction | iWindowShape <> SHAPE_RECTANGULAR | not(isWindow)) then
				! --- Not Stacked Window ---
				px1 = -leftWidth - overSizeLeft  + widoLeftJamb + tolerOffsetLeftOut
				px2 = rightWidth + overSizeRight - widoRightJamb - tolerOffsetRightOut
				px3 = px1 + gs_trim_width_out
				px4 = px2 - gs_trim_width_out

				py1 = -overSizeBottom + widoThresDepth + tolerOffsetLowerOut
				py2 = B + overSizeTop - widoHeadDepth - tolerOffsetUpperOut
				py3 = py1 + gs_trim_width_out
				py4 = py2 - gs_trim_width_out

				cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
					10, thk,
					px1,	py1, 0, 15, gs_trim_out_mat,
					px1,	py2, 0, 15, gs_trim_out_mat,
					px2,	py2, 0, 15, gs_trim_out_mat,
					px2,	py1, 0, 15, gs_trim_out_mat,
					px1,	py1, 0, -1, gs_trim_out_mat,
					px3,	py3, 0, mask, gs_trim_out_mat,
					px3,	py4, 0, mask, gs_trim_out_mat,
					px4,	py4, 0, mask, gs_trim_out_mat,
					px4,	py3, 0, mask, gs_trim_out_mat,
					px3,	py3, 0, -1, gs_trim_out_mat
			else
				! --- Stacked Window or Window with Sill or Corner Window ---

				if	isWindow | \
					(bPShapedLeftOpening & gs_trim_below_sillLeft) then
					py4 = -overSizeBottomLeft + not(gs_stack_bottom) * widoThresDepth + tolerOffsetLowerOut
					py3 = py4 + not(gs_stack_bottom | not(bCasingBottomOutside) | bDrawLeftSLSill) * gs_trim_width_out

					s3 = 8 + 2 * not(gs_stack_bottom)	! 15 or 8
					s4 = 13 + 2 * not(gs_stack_bottom)	! 15 or 13
				else
					py3 = -overSizeBottomLeft + bDrawSill * widoThresDepth
					py4 = -overSizeBottomLeft + bDrawSill * widoThresDepth

					s3 = 15
					s4 = 15
				endif

				! --- Draw Left Side Jamb extension ---
				px1 = -leftWidth
				if not(gs_sectgar) then
					px1 = px1 + widoLeftJamb + tolerOffsetLeftOut
				else
					if bCasingTolerance then
						px1 = px1 + gs_tolerance_left
					endif
				endif
				px2 = px1 + gs_trim_width_out * not(gs_stack_left)


				if	bShapeEnablesStraightTopTrim then
					py1 = B
					if not(gs_sectgar) then
						py1 = py1 + overSizeTop - not(gs_stack_top) * widoHeadDepth - tolerOffsetUpperOut
					else
						py1 = py1 - bCasingTolerance * gs_tolerance_upper
					endif
					py2 = py1 - not(gs_stack_top) * gs_trim_width_out

					s1 = 8 + 2 * not(gs_stack_top)		! 15 or 8
					s2 = bitset (mask, 1, not(gs_stack_top))
				endif

				if	bShapeEnablesArchedTopTrim then
					ta = leftWidth - not(bHalfCircle) * widoHeadDepth
					tc = arcR - not(bHalfCircle) * widoHeadDepth
					py1 = B - arcR + sqr(max(0, (tc * tc - ta * ta)))

					ta = ta - gs_trim_width_out
					tc = tc - gs_trim_width_out
					py2 = B - arcR + sqr(max(0, (tc * tc - ta * ta)))

					s1 = 8
					s2 = mask - 2
				endif

				if iWindowShape = SHAPE_ELLIPSEARCH then
					py1 = B + overSizeTopOut - tolerOffsetUpperOut - archHeight
					py2 = py1

					s1 = 8
					s2 = mask - 2
				endif

				if	bPShapedLeftOpening then
					py3 = py3 + gs_sidelight_parapet_hgt_left + gs_reveal_bottom_sL - gs_reveal_bottom
					py4 = py4 + gs_sidelight_parapet_hgt_left + gs_reveal_bottom_sL - gs_reveal_bottom
				endif

				if bShapeEnablesStraightLeftTrim & not(gs_stack_left | bLeftCornerFunction) then
					cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						4, thk,
						px1,	py1, 	0, s1, gs_trim_out_mat,
						px2,	py2, 	0, s2, gs_trim_out_mat,
						px2,	py3,	0, s3, gs_trim_out_mat,
						px1,	py4, 	0, s4, gs_trim_out_mat
					gosub "TextCoord_Vert"
				endif

				if	bPShapedLeftOpening & gs_trim_below_sillLeft then
					! --- Draw Door's Left side Jamb Extension ---
					px1LSL = leftRevealPnts[idxSillStartRevealLeft][1] + gs_sidelight_WHole_width_left
					px2LSL = px1LSL + gs_trim_width_out
					px1LSLW = leftRevealPnts[idxSillStartRevealLeft][1] + tolerOffsetLeftIn
					px2LSLW = leftRevealPnts[idxSillStartRevealLeft][1] + tolerOffsetLeftIn + gs_trim_width_out * not(gs_stack_left)

					py1 = widoThresDepth
					py2 = widoThresDepth

					cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						4, thk,
						px1LSL,	py1, 	0, 15, gs_trim_out_mat,
						px2LSL,	py2, 	0, mask, gs_trim_out_mat,
						px2LSL,	py3,	0, s3, gs_trim_out_mat,
						px1LSL,	py4, 	0, s4, gs_trim_out_mat
					gosub "TextCoord_Vert"

					if	not(bDrawLeftSLSill) then
						! --- Draw Left Sidelight lower side Jamb Extension ---
						cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
							4, thk,
							 px2LSL,	py3,	0, 15, gs_trim_out_mat,
							 px1LSL,	py4,	0, 15, gs_trim_out_mat,
							 px1LSLW,	py4,	0, 15, gs_trim_out_mat,
							 px2LSLW,	py3,	0, mask - 2 * gs_stack_left, gs_trim_out_mat
					gosub "TextCoord_Hor"
					endif
				endif

				! --- Draw Right Side Jamb extension ---
				if	isWindow | \
					(bPShapedRightOpening & gs_trim_below_sillRight) then
					py4 = -overSizeBottomRight + not(gs_stack_bottom) * widoThresDepth + tolerOffsetLowerOut
					py3 = py4 + not(gs_stack_bottom | not(bCasingBottomOutside) | bDrawRightSLSill) * gs_trim_width_out
				else
					py3 = -overSizeBottomRight + bDrawSill * widoThresDepth
					py4 = -overSizeBottomRight + bDrawSill * widoThresDepth
				endif


				px1 = rightWidth - (widoRightJamb + tolerOffsetRightOut) * not(gs_sectgar) - bCasingTolerance * gs_tolerance_right * gs_sectgar
				px2 = px1 - gs_trim_width_out * not(gs_stack_right)

				if	bShapeEnablesStraightTopTrim then
					py1 = B + (overSizeTop - not(gs_stack_top) * widoHeadDepth - tolerOffsetUpperOut) * not(gs_sectgar) - bCasingTolerance * gs_tolerance_upper * gs_sectgar
					py2 = py1 - not(gs_stack_top) * gs_trim_width_out

					s1 = 8 + 2 * not(gs_stack_top)		! 15 or 8
					s2 = bitset (mask, 1, not(gs_stack_top))
				endif
				if	bShapeEnablesArchedTopTrim then
					ta = rightWidth - not(bHalfCircle) * widoHeadDepth
					tc = arcR - not(bHalfCircle) * widoHeadDepth
					py1 = B - arcR + sqr(max(0, (tc * tc - ta * ta)))

					ta = ta - gs_trim_width_out
					tc = tc - gs_trim_width_out
					py2 = B - arcR + sqr(max(0, (tc * tc - ta * ta)))

					s1 = 8
					s2 = mask - 2
				endif

				if	bPShapedRightOpening then
					py3 = py3 + gs_sidelight_parapet_hgt_right + gs_reveal_bottom_sR - gs_reveal_bottom
					py4 = py4 + gs_sidelight_parapet_hgt_right + gs_reveal_bottom_sR - gs_reveal_bottom
				endif

				if bShapeEnablesStraightRightTrim & not(gs_stack_right | bRightCornerFunction) then
					cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						4, thk,
						 px1,	py1,	0, s1, gs_trim_out_mat,
						 px2,	py2,	0, s2, gs_trim_out_mat,
						 px2,	py3,	0, s3, gs_trim_out_mat,
						 px1,	py4, 	0, s4, gs_trim_out_mat
					gosub "TextCoord_Vert"
				endif
				if	bPShapedRightOpening & gs_trim_below_sillRight then
					! --- Draw Door's Right side Jamb Extension ---
					px1RSL = rightRevealPnts[idxSillStartRevealRight][1] - gs_sidelight_WHole_width_right
					px2RSL = px1RSL - gs_trim_width_out
					px1RSLW = rightRevealPnts[idxSillStartRevealRight][1] - tolerOffsetRightIn
					px2RSLW = rightRevealPnts[idxSillStartRevealRight][1] - tolerOffsetRightIn - gs_trim_width_out * not(gs_stack_right)

					py1 = widoThresDepth
					py2 = widoThresDepth

					cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						4, thk,
						px1RSL,	py1, 	0, 15, gs_trim_out_mat,
						px2RSL,	py2, 	0, mask, gs_trim_out_mat,
						px2RSL,	py3,	0, s3, gs_trim_out_mat,
						px1RSL,	py4, 	0, s4, gs_trim_out_mat
					gosub "TextCoord_Vert"

					if	not(bDrawRightSLSill) then
						! --- Draw Right Sidelight lower side Jamb Extension ---
						cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
							4, thk,
							 px2RSL,	py3,	0, 15, gs_trim_out_mat,
							 px1RSL,	py4,	0, 15, gs_trim_out_mat,
							 px1RSLW,	py4,	0, 15, gs_trim_out_mat,
							 px2RSLW,	py3,	0, mask - 2 * gs_stack_right, gs_trim_out_mat
						gosub "TextCoord_Hor"
					endif
				endif
				! --- Draw Bottom Jamb extension ---
				if bLeftCornerFunction then
					px1 = -leftWidth - overSizeLeft + widoLeftJamb + tolerOffsetLeftOut - 1.0
				else
					px1 = -leftWidth + (widoLeftJamb + tolerOffsetLeftOut) * not(gs_sectgar) + bCasingTolerance * gs_tolerance_left * gs_sectgar
				endif
				if bRightCornerFunction then
					px2 = rightWidth + overSizeRight - widoRightJamb - tolerOffsetRightOut + 1.0
				else
					px2 = rightWidth - (widoRightJamb + tolerOffsetRightOut) * not(gs_sectgar) - bCasingTolerance * gs_tolerance_right * gs_sectgar
				endif

				if bShapeEnablesStraightBottomTrim & not(gs_stack_bottom | not(bCasingBottomOutside) | not(isWindow)) & not(bDrawSill) then
					py1 = -overSizeBottom + widoThresDepth + tolerOffsetLowerOut
					py2 = py1 + gs_trim_width_out

					cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						4, thk,
						px1,																	py1,	0, 8 + 2 * not(gs_stack_left), gs_trim_out_mat,
						px1 + not(gs_stack_left  | bLeftCornerFunction)  * gs_trim_width_out,	py2,	0, bitset(bitset (mask, 1, not(gs_stack_left)), 0, (bShowEdgesAtFrame & (not(bRightCornerFunction) | not(bFitModeRight)))), gs_trim_out_mat,
						px2 - not(gs_stack_right | bRightCornerFunction) * gs_trim_width_out,	py2,	0, 8 + 2 * not(gs_stack_right), gs_trim_out_mat,
						px2,																	py1,	0, 13 + 2 * not(gs_stack_right), gs_trim_out_mat
					gosub "TextCoord_Hor"
				endif
				! --- Draw Top Jamb extension ---
				if	(bShapeEnablesStraightTopTrim) & \
					not(gs_stack_top) then

					py1 = B + (overSizeTop - widoHeadDepth - tolerOffsetUpperOut) * not(gs_sectgar) - bCasingTolerance * gs_tolerance_upper * gs_sectgar
					py2 = py1 - gs_trim_width_out

					cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						4, thk,
						px1,																	py1,	0, 8 + 2 * not(gs_stack_left), gs_trim_out_mat,
						px1 + not(gs_stack_left  | bLeftCornerFunction)  * gs_trim_width_out,	py2,	0, bitset(bitset (mask, 1, not(gs_stack_left)), 0, (bShowEdgesAtFrame & (not(bRightCornerFunction) | not(bFitModeRight)))), gs_trim_out_mat,
						px2 - not(gs_stack_right | bRightCornerFunction) * gs_trim_width_out,	py2,	0, 8 + 2 * not(gs_stack_right), gs_trim_out_mat,
						px2,																	py1,	0, 13 + 2 * not(gs_stack_right), gs_trim_out_mat
				endif
				if	bShapeEnablesArchedTopTrim then

					resol nArchResolution

					px1L = leftWidth - widoRightJamb
					px2L = px1L - gs_trim_width_out

					px1R = leftWidth - widoRightJamb
					px2R = px1R - gs_trim_width_out

					if bHalfCircle then
						addy B - archHeight

						cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
							9, thk,
							-px1L,	0,			0,    8 + 7 * gs_stack_left, gs_trim_out_mat,
							-px2L,	0,			0,   62 + mask, gs_trim_out_mat,
							 0,		0,			0,  900, gs_trim_out_mat,
							 0,		archHeight - gs_trim_width_out,	0, 3062 + mask, gs_trim_out_mat,
							 px2R,	0,			0, 3008 + 7 * gs_stack_right, gs_trim_out_mat,
							 px1R,	-EPS,		0,    8 + 7 * gs_stack_right, gs_trim_out_mat,
							 px1R,	0,			0,   79, gs_trim_out_mat,
							 0,		archHeight, 0, 3079, gs_trim_out_mat,
							-px1L,	0,			0, 1015, gs_trim_out_mat

						! --- Draw missing lines ---
						if gs_stack_left then lin_ -px2L,0,0, -px2L,0,thk
					else
						addy B - archHeight

						ta = leftWidth - widoHeadDepth
						tc = arcR - widoHeadDepth
						py1L = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

						ta = ta - gs_trim_width_out
						tc = tc - gs_trim_width_out
						py2L = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

						ta = rightWidth - widoHeadDepth
						tc = arcR - widoHeadDepth
						py1R = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

						ta = ta - gs_trim_width_out
						tc = tc - gs_trim_width_out
						py2R = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

						cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
							8, thk,
							 0,		archHeight - arcR, 0, 900, gs_trim_out_mat,
							-px1L,	py1L, 	0,  8 + 7 * gs_stack_left, gs_trim_out_mat,
							-px2L,	py2L,	0,  62 + mask, gs_trim_out_mat,
							 0,		archHeight - widoHeadDepth - gs_trim_width_out,	0, 3062 + mask, gs_trim_out_mat,
							 px2R,	py2R,	0,3010 + 5 * gs_stack_right, gs_trim_out_mat,
							 px1R,	py1R,	0,  79, gs_trim_out_mat,
							 0,		archHeight - widoHeadDepth,	0, 3079, gs_trim_out_mat,
							-px1L,	py1L, 	0,3015, gs_trim_out_mat

						lin_ -px2L,py2L,0, -px2L,py2L,thk
					endif

					del 1
				endif

				if iWindowShape = SHAPE_ELLIPSEARCH then
					resol nArchResolution

					px1 = -leftWidth + widoRightJamb + tolerOffsetLeftOut
					px2 = px1 + not(gs_stack_left) * gs_trim_width_Out
					px4 = rightWidth - widoRightJamb - tolerOffsetRightOut
					px3 = px4 - not(gs_stack_right) * gs_trim_width_out

					pxcL = -leftWidth + smallRadiusEllips
					pxcR = rightWidth - smallRadiusEllips

					py1 = B + overSizeTopOut - tolerOffsetUpperOut

					s3 = 9 + 4 * (abs(gs_trim_offs_out) > EPS | not(gs_trim_show_cover_out) | abs(gs_trim_thk_out) < EPS) - 2 * gs_stack_right

					cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						13,thk,
						px4,	py1 - archHeight,			0, 13,		gs_trim_out_mat,
						pxcR,	py1 - archHeight,			0, 913,		gs_trim_out_mat,
						0,		alphaSide,					0, 4013,	gs_trim_out_mat,
						0,		py1 - middleRadiusEllips, 	0, 913,		gs_trim_out_mat,
						0,		alphaMiddle,				0, 4013,	gs_trim_out_mat,
						pxcL,	py1 - archHeight,			0, 913,		gs_trim_out_mat,
						0,		alphaSide,					0, 4008,	gs_trim_out_mat,
						px2,	py1 - archHeight,			0, s3,		gs_trim_out_mat,
						0,		-alphaSide,					0, 4000+s3,	gs_trim_out_mat,
						0,		py1 - middleRadiusEllips, 	0, 900+s3,	gs_trim_out_mat,
						0,		-alphaMiddle,				0, 4000+s3,	gs_trim_out_mat,
						pxcR,	py1 - archHeight,			0, 900+s3,	gs_trim_out_mat,
						0,		-alphaSide,					0, 4000+s3,	gs_trim_out_mat
				endif
				gosub "TextCoord_Hor"
			endif

			del 2
		endif

		mask = 11 + 4 * (gs_trim_offs_out > EPS | not(bShowJambExtension) | abs(WIDO_SILL) < EPS | not(gs_trim_show_cover_out) | abs(gs_trim_thk_out) < EPS)

		if gs_trim_thk_out > EPS & gs_trim_show_cover_out & (gs_trimtype_out_int <> CASING_COMPLEX) then

			material gs_trim_out_mat
			pen gs_frame_pen
			sect_fill gs_trim_fill_out, gs_trim_pen_bg_out, gs_trim_pen_fg_out, gs_trim_pen_cont_out

			! ===== Outside Trim - Straight Walls - Casing =====

			maskTop		= 8 + 2 * not(gs_stack_top)
			maskBottom	= 8 + 2 * not(gs_stack_bottom)
			maskLeft	= 8 + 2 * not(gs_stack_left)
			maskRight	= 8 + 2 * not(gs_stack_right)

			maskLeft2	= bDrawSill*(not(bTrimovbotleftout)*(15-7*gs_stack_left)+bTrimovbotleftout*(10-2*gs_stack_left))
			maskRight2	= bDrawSill*(not(bTrimovbotrightout)*(15-7*gs_stack_right)+bTrimovbotrightout*(10-2*gs_stack_right))

			addz -gs_trim_thk_out
			! --- Stacked Window or Window with Sill or Corner Window ---

			if	isWindow | \
				bTShapedOpening then
				py = -overSizeBottomLeft + not(gs_stack_bottom) * widoThresDepth + gs_trim_offs_out_bottom * bCasingBottomOutside

				s3 = maskBottom						! 15 or 10 or 8
				s4 = 13 + 2 * not(gs_stack_bottom)	! 15 or 13
			else
				py	= -overSizeBottomLeft + bDrawSill * widoThresDepth
				py3 = -overSizeBottomLeft + bDrawSill * widoThresDepth
				py4 = -overSizeBottomLeft + bDrawSill * widoThresDepth

				s3 = 15
				s4 = 15
			endif

			! --- Draw left side Trim ---
			py3l = py
			py4l = py

			px2 = -leftWidth + gs_trim_width_out - gs_trim_offs_out + widoLeftJamb + tolerOffsetLeftOut
			px1 = px2 - gs_tw_left_out

			if gs_stack_bottom then
				py3l = -overSizeBottom
				py4l = py3l
				py5 = py3l
				py6 = py3l
			else
				if not(bCasingBottomOutside) then
					py3l = py
					py4l = py3l
					py5 = py3l
					py6 = py3l
				else
					if	isWindow | \
						(bPShapedLeftOpening & gs_trim_below_sillLeft) then
						py3l = py \
								+ gs_trim_width_out * not(bDrawLeftSLSill) \
								- gs_trim_offs_out * not(gs_trim_atframe_out) * not(bDrawLeftSLSill) \
								- gs_tw_bottom_out * bTrimovbotleftout \
								- gs_trimov_bot_left_out

						if not(gs_trim_atframe_out) then
							py4l = py \
									+ gs_trim_width_out * not(bDrawLeftSLSill) \
									- gs_trim_offs_out * not(gs_trim_atframe_out) * not(bDrawLeftSLSill) \
									- gs_tw_bottom_out * (not(bDrawLeftSLSill) | (bDrawLeftSLSill & (bTrimovbotleftout | gs_trim_below_sillLeft))) \
									- gs_trimov_bot_left_out

						else
							py4l = py3l - (gs_trimov_bot_left_out + gs_tw_bottom_out * (bTrimovbotleftout=0) * gs_trimb_atframe_out * not(bDrawLeftSLSill))
						endif
					endif

					py5 = py3l + (gs_trimov_bot_left_out + gs_tw_bottom_out) * bTrimovbotleftout
					py6 = py3l + gs_trimov_bot_left_out * bTrimovbotleftout
				endif
			endif

			if	bPShapedLeftOpening then
				py3l = py3l + gs_sidelight_parapet_hgt_left + gs_reveal_bottom_sL - gs_reveal_bottom
				py4l = py4l + gs_sidelight_parapet_hgt_left + gs_reveal_bottom_sL - gs_reveal_bottom
				py5 = py5 + gs_sidelight_parapet_hgt_left + gs_reveal_bottom_sL - gs_reveal_bottom
				py6 = py6 + gs_sidelight_parapet_hgt_left + gs_reveal_bottom_sL - gs_reveal_bottom
			endif

			if	bShapeEnablesStraightTopTrim then
				py1 = B + overSizeTop + not(gs_stack_top) * (-widoHeadDepth - tolerOffsetUpperOut - gs_trim_width_out + gs_trim_offs_out + gs_trim_offs_out_top + gs_tw_top_out*not(bTrimovtopleftout))
				py2 = B + overSizeTop + not(gs_stack_top) * (-widoHeadDepth - tolerOffsetUpperOut - gs_trim_width_out + gs_trim_offs_out + gs_trim_offs_out_top)

				if	isWindow | \
					(bPShapedLeftOpening & gs_trim_below_sillLeft) then
					s6 = maskBottom*not(bTrimovbotleftout)+(15-2*not(gs_tw_bottom_out))*bTrimovbotleftout
					if gs_stack_bottom then
						s3 = 8
					else
						if not(bCasingBottomOutside) then
							s3 = 15
						else
							s3 = (maskBottom+5*(not(gs_tw_bottom_out) | gs_trim_atframe_out))*not(bTrimovbotleftout)+bTrimovbotleftout*15-5*gs_trim_atframe_out*not(bDrawLeftSLSill)*not(gs_stack_bottom)\
							+5*not(bTrimovbotleftout)*(WIDO_SILL>0) * (gs_trim_atframe_out) * not(gs_trimb_atframe_out)
						endif
					endif
				else
					s6 = 15
					s3 = 15
				endif

				s1 = maskTop				! 15 or 10 or 8
				s2 = bitset (mask, 1, not(gs_stack_top)) + 4 * gs_trim_atframe_out * (WIDO_SILL>0)
				s5 = 8
			endif
			if	bShapeEnablesArchedTopTrim then
				ta = leftWidth - gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out - not(bHalfCircle) * widoHeadDepth - tolerOffsetUpperOut * not(bHalfCircle)
				tc = arcR - gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out - not(bHalfCircle) * widoHeadDepth - tolerOffsetUpperOut * not(bHalfCircle)
				py1 = B - arcR + sqr(max(0, tc * tc - ta * ta))

				ta = ta - gs_tw_right_out
				tc = tc - gs_tw_right_out
				py2 = B - arcR + sqr(max(0, tc * tc - ta * ta))

				if	isWindow | \
					(bPShapedLeftOpening & gs_trim_below_sillLeft) then
					s6 = maskBottom*not(bTrimovbotleftout)+(15-2*not(gs_tw_bottom_out))*bTrimovbotleftout
					if gs_stack_bottom then
						s3 = 8
					else
						if not(bCasingBottomOutside) then
							s3 = 15
						else
							s3 = (maskBottom+5*(not(gs_tw_bottom_out) | gs_trim_atframe_out))*not(bTrimovbotleftout)+bTrimovbotleftout*(15-7*gs_stack_bottom)-5*gs_trim_atframe_out*not(bDrawLeftSLSill)*not(gs_stack_bottom)\
							+5*not(bTrimovbotleftout)*(WIDO_SILL>0) * (gs_trim_atframe_out) * not(gs_trimb_atframe_out)
						endif
					endif
				else
					s6 = 15
					s3 = 15
				endif

				s1 = 8
				s2 = mask - 2 + 4 * gs_trim_atframe_out * (WIDO_SILL>0)
				s5 = 8
			endif

			if iWindowShape = SHAPE_ELLIPSEARCH then
				py1 = B + overSizeTopOut - archHeight
				py2 = B + overSizeTopOut - archHeight

				s1 = 8
				s2 = mask - 2
				s5 = 9 + 4 * gs_trim_atframe_out
			endif

			pxWCutTopLeftOut	= px1
			pxWCutTopOHLeftOut	= px1
			pxWCutMidLeftOut	= px1
			pxWCutMidOHLeftOut	= px2
			pxWCutBotLeftOut	= px1
			pyWCutTopLeftOut	= py1
			pyWCutTopOHOut		= py1
			pyWCutMidLeftOut	= py4l

			if bShapeEnablesStraightLeftTrim & not(gs_stack_left | bLeftCornerFunction) then
				body -1
				if bDrawBottTrimatGangingOut then
					py6 = py6 + tolerOffsStackCasLowerOut + trim_offs_out_modify - gs_trim_offs_out
					py5 = py2
					s5 = 13
				endif
				if bDrawTopTrimatGangingOut then
					py5 = py2 - tolerOffsStackCasUpperOut - trim_offs_out_modify + gs_trim_offs_out
					s2 = 10
					s5 = 13
				endif
				cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
					6, gs_trim_thk_out,
					px1,	py1,	0, s1, gs_trim_out_mat,
					px2,	py2,	0, s2, gs_trim_out_mat,
					px2,	py5,	0, s5, gs_trim_out_mat,
					px2,	py6,	0, s6, gs_trim_out_mat,
					px2,	py3l,	0, s3, gs_trim_out_mat,
					px1,	py4l,	0, s4, gs_trim_out_mat
				gosub "TextCoord_Vert"
			endif

			! --- Draw Door's Left side Trim ---
			py1 = widoThresDepth
			py2 = widoThresDepth
			py3l = py4l + gs_trimov_bot_left_out
			py4l = py3l + gs_tw_bottom_out

			if	bPShapedLeftOpening & gs_trim_below_sillLeft then
				px1 = leftRevealPnts[idxSillStartRevealLeft][1] + gs_sidelight_WHole_width_left  + gs_trim_width_out - gs_trim_offs_out
				px2 = px1 - gs_tw_left_out

				cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
					4, gs_trim_thk_out,
					px1,	py1,	0, 15, gs_trim_out_mat,
					px2,	py2,	0, s4, gs_trim_out_mat,
					px2,	py3l,	0, s5, gs_trim_out_mat,
					px1,	py4l,	0, s2, gs_trim_out_mat
				gosub "TextCoord_Vert"

				pxWCutBotLeftOut = px2
			endif

			pyWCutBotLeftOut = py1


			! --- Draw right side Trim ---

			if	isWindow | \
				bPShapedRightOpening then
				py = -overSizeBottomRight + not(gs_stack_bottom) * widoThresDepth + gs_trim_offs_out_bottom * bCasingBottomOutside
			else
				py	= -overSizeBottomRight + bDrawSill * widoThresDepth
				py3 = -overSizeBottomRight + bDrawSill * widoThresDepth
				py4 = -overSizeBottomRight + bDrawSill * widoThresDepth
			endif
			py3r = py
			py4r = py

			px2 = rightWidth - gs_trim_width_out + gs_trim_offs_out - widoRightJamb - tolerOffsetRightOut
			px1 = px2 + gs_tw_right_out

			if gs_stack_bottom then
				py3r = -overSizeBottom
				py4r = py3r
				py5 = py3r
				py6 = py3r
			else
				if not(bCasingBottomOutside) then
					py3l = py
					py4l = py3l
					py5 = py3l
					py6 = py3l
				else
					if	isWindow | \
						(bPShapedRightOpening & gs_trim_below_sillRight) then
						py3r = py \
								+ gs_trim_width_out * not(bDrawRightSLSill) \
								- gs_trim_offs_out * not(gs_trim_atframe_out) * not(bDrawRightSLSill) \
								- gs_tw_bottom_out * bTrimovbotrightout \
!!!									- 1 * (iSillType > 1 & bDrawBoard) \
								- gs_trimov_bot_right_out
						if not(gs_trim_atframe_out) then
							py4r = py \
									+ gs_trim_width_out * not(bDrawRightSLSill) \
									- gs_trim_offs_out * not(gs_trim_atframe_out) * not(bDrawRightSLSill) \
									- gs_tw_bottom_out*(not(bDrawRightSLSill) | (bDrawRightSLSill & (bTrimovbotrightout | gs_trim_below_sillRight))) \
!!!										- 1 * (iSillType > 1 & bDrawBoard) \
									- gs_trimov_bot_right_out
						else
							py4r = py3r - (gs_trimov_bot_left_out + gs_tw_bottom_out * (bTrimovbotleftout=0) * gs_trimb_atframe_out * not(bDrawRightSLSill))
						endif
					endif

					py5 = py3r + (gs_trimov_bot_right_out + gs_tw_bottom_out) * bTrimovbotrightout
					py6 = py3r + gs_trimov_bot_right_out * bTrimovbotrightout
				endif
			endif

			if	bPShapedRightOpening then
				py3r = py3r + gs_sidelight_parapet_hgt_right + gs_reveal_bottom_sR - gs_reveal_bottom
				py4r = py4r + gs_sidelight_parapet_hgt_right + gs_reveal_bottom_sR - gs_reveal_bottom
				py5 = py5 + gs_sidelight_parapet_hgt_right + gs_reveal_bottom_sR - gs_reveal_bottom
				py6 = py6 + gs_sidelight_parapet_hgt_right + gs_reveal_bottom_sR - gs_reveal_bottom
			endif

			if	bShapeEnablesStraightTopTrim then
				py1 = B + overSizeTop + not(gs_stack_top) * (-widoHeadDepth - tolerOffsetUpperOut - gs_trim_width_out + gs_trim_offs_out + gs_trim_offs_out_top + gs_tw_top_out*not(bTrimovtoprightout))
				py2 = B + overSizeTop + not(gs_stack_top) * (-widoHeadDepth - tolerOffsetUpperOut - gs_trim_width_out + gs_trim_offs_out + gs_trim_offs_out_top)

				if	isWindow | \
					(bPShapedRightOpening & gs_trim_below_sillRight) then
					s6 = maskBottom*not(bTrimovbotrightout)+(15-2*not(gs_tw_bottom_out))*bTrimovbotrightout
					if gs_stack_bottom = 1 then
						s3 = 8
					else
						if not(bCasingBottomOutside) then
							s3 = 15
						else
							s3 = (maskBottom+5*(not(gs_tw_bottom_out) | gs_trim_atframe_out))*not(bTrimovbotrightout)+bTrimovbotrightout*(15-7*gs_stack_bottom)-5*gs_trim_atframe_out*not(bDrawRightSLSill)*not(gs_stack_bottom)\
							+5*not(bTrimovbotleftout)*(WIDO_SILL>0) * (gs_trim_atframe_out) * not(gs_trimb_atframe_out)
						endif
					endif
				else
					s6 = 15
					s3 = 15
				endif

				s1 = maskTop				! 15 or 10 or 8
				s2 = bitset (mask, 1, not(gs_stack_top)) + 4 * gs_trim_atframe_out * (WIDO_SILL>0)
				s5 = 8
			endif
			if	bShapeEnablesArchedTopTrim then
				ta = rightWidth - gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out - not(bHalfCircle) * widoHeadDepth - tolerOffsetUpperOut * not(bHalfCircle)
				tc = arcR - gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out - not(bHalfCircle) * widoHeadDepth - tolerOffsetUpperOut * not(bHalfCircle)
				py1 = B - arcR + sqr(max(0, tc * tc - ta * ta))

				ta = ta - gs_tw_right_out
				tc = tc - gs_tw_right_out
				py2 = B - arcR + sqr(max(0, tc * tc - ta * ta))

				if	isWindow | \
					(bPShapedRightOpening & gs_trim_below_sillRight) then
					s6 = maskBottom*not(bTrimovbotrightout)+(15-2*not(gs_tw_bottom_out))*bTrimovbotrightout
					if gs_stack_bottom = 1 then
						s3 = 8
					else
						if not(bCasingBottomOutside) then
							s3 = 15
						else
							s3 = (maskBottom+5*(not(gs_tw_bottom_out) | gs_trim_atframe_out))*not(bTrimovbotrightout)+bTrimovbotrightout*(15-7*gs_stack_bottom)-5*gs_trim_atframe_out*not(bDrawRightSLSill)*not(gs_stack_bottom)\
							+5*not(bTrimovbotleftout)*(WIDO_SILL>0) * gs_trim_atframe_out * not(gs_trimb_atframe_out)
						endif
					endif
				else
					s6 = 15
					s3 = 15
				endif

				s1 = 8
				s2 = mask - 2 + 4 * gs_trim_atframe_out * (WIDO_SILL>0)
				s5 = 8
			endif

			if iWindowShape = SHAPE_ELLIPSEARCH then
				py1 = B + overSizeTopOut - archHeight
				py2 = B + overSizeTopOut - archHeight

				s1 = 8
				s2 = mask - 2
				s5 = 9 + 4 * gs_trim_atframe_out
			endif

			pxWCutTopRightOut	= px1
			pxWCutBotRightOut	= px1
			pxWCutMidRightOut	= px1
			pxWCutMidOHRightOut	= px2
			pyWCutTopRightOut 	= py1
			pyWCutMidRightOut	= py4r

			if bShapeEnablesStraightRightTrim & not(gs_stack_right | bRightCornerFunction) then
				body -1
				if bDrawBottTrimatGangingOut then
					py6 = py6 + tolerOffsStackCasLowerOut + trim_offs_out_modify - gs_trim_offs_out
					py5 = py2
					s5 = 13
				endif
				if bDrawTopTrimatGangingOut then
					py5 = py2 - tolerOffsStackCasUpperOut - trim_offs_out_modify + gs_trim_offs_out
					s2 = 10
					s5 = 13
				endif

				cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
					4+2, gs_trim_thk_out,
					px1,	py1,	0, s1, gs_trim_out_mat,
					px2,	py2,	0, s2, gs_trim_out_mat,
					px2,	py5,	0, s5, gs_trim_out_mat,
					px2,	py6,	0, s6, gs_trim_out_mat,
					px2,	py3r,	0, s3, gs_trim_out_mat,
					px1,	py4r,	0, s4, gs_trim_out_mat
				gosub "TextCoord_Vert"
			endif

			! --- Draw Door's Right side Trim ---
			py1 = widoThresDepth
			py2 = widoThresDepth
			py3r = py4r + gs_trimov_bot_right_out
			py4r = py3r + gs_tw_bottom_out

			if	bPShapedRightOpening & gs_trim_below_sillRight then
				px1 = rightRevealPnts[idxSillStartRevealRight][1] - gs_sidelight_WHole_width_right  - gs_trim_width_out + gs_trim_offs_out
				px2 = px1 + gs_tw_right_out

				cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
					4, gs_trim_thk_out,
					px1,	py1,	0, 15, gs_trim_out_mat,
					px2,	py2,	0, s4, gs_trim_out_mat,
					px2,	py3r,	0, s5, gs_trim_out_mat,
					px1,	py4r,	0, s2, gs_trim_out_mat
				gosub "TextCoord_Vert"

				pxWCutBotRightOut = px2
			endif

			pyWCutBotRightOut = py1

			if bPShapedLeftOpening & gs_trim_below_sillLeft then
				! --- Draw Left lower Trim in Straight Wall ---
				px = -leftWidth - overSizeLeft + widoLeftJamb + tolerOffsetLeftOut
				px1 = px + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out - gs_tw_left_out*not(bTrimovbotleftout))
				px2 = px + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out)
				px3 = leftRevealPnts[idxSillStartRevealLeft][1] + gs_sidelight_WHole_width_left  + gs_trim_width_out - gs_trim_offs_out
				px4 = px3 - gs_tw_left_out * gs_trim_below_sillLeft

				if not(bDrawLeftSLSill) | gs_trim_below_sillLeft then
					cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						4, gs_trim_thk_out,
						px1,	py3l,	0, 10, gs_trim_out_mat,
						px2,	py4l,	0, mask - 2 * gs_stack_left, gs_trim_out_mat,
						px3,	py4l,	0, 10 + 5 * not(gs_trim_below_sillLeft), gs_trim_out_mat,
						px4,	py3l,	0, 15, gs_trim_out_mat
					gosub "TextCoord_Hor"
				endif
			endif

			if bPShapedRightOpening & gs_trim_below_sillRight then
				! --- Draw Right lower Trim in Straight Wall ---
				px = rightWidth - overSizeRight - widoRightJamb - tolerOffsetRightOut
				px1 = px - not(gs_stack_right) * (gs_trim_width_out - gs_trim_offs_out - gs_tw_right_out*not(bTrimovbotrightout))
				px2 = px - not(gs_stack_right) * (gs_trim_width_out - gs_trim_offs_out)
				px3 = rightRevealPnts[idxSillStartRevealRight][1] - gs_sidelight_WHole_width_right  - gs_trim_width_out + gs_trim_offs_out
				px4 = px3 + gs_tw_right_out * gs_trim_below_sillRight

				if not(bDrawRightSLSill) | gs_trim_below_sillRight then
					cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						4, gs_trim_thk_out,
						px1,	py3r,	0, 10, gs_trim_out_mat,
						px2,	py4r,	0, mask - 2 * gs_stack_right, gs_trim_out_mat,
						px3,	py4r,	0, 10 + 5 * not(gs_trim_below_sillRight), gs_trim_out_mat,
						px4,	py3r,	0, 15, gs_trim_out_mat
					gosub "TextCoord_Hor"
				endif
			endif

			if bShapeEnablesStraightBottomTrim & not(gs_stack_bottom | not(bCasingBottomOutside) | not(isWindow)) & abs(gs_tw_bottom_out) > EPS \
			& (not(curvedWall) | (curvedWall & gs_trimb_atframe_out)) then
				! --- Draw lower Trim ---

				px = -leftWidth - overSizeLeft + widoLeftJamb + tolerOffsetLeftOut
				px1 = px + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out - gs_tw_left_out*not(bTrimovbotleftout))
				px2 = px + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out)
				px = rightWidth + overSizeRight - widoRightJamb - tolerOffsetRightOut
				px3 = px + not(gs_stack_right) * (-gs_trim_width_out + gs_trim_offs_out)
				px4 = px + not(gs_stack_right) * (-gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out*not(bTrimovbotrightout))

				if not(bParalellInCurvedWalls) then		! not USA type
					py = -overSizeBottom + widoThresDepth + gs_trim_offs_out_bottom !!+ BrickSillTrimOffs

					py1 = py + not(gs_stack_bottom) * (gs_trim_width_out*not(bDrawSill) - gs_trim_offs_out * not(gs_trim_atframe_out) * not(bDrawSill) - gs_tw_bottom_out)
					py2 = py1 + gs_tw_bottom_out * ((bDrawSill & not(bCasingBottomOutside)) | (gs_trim_atframe_out & not(gs_trimb_atframe_out) & (WIDO_SILL>0)))
					py3 = py + not(gs_stack_bottom) * (gs_trim_width_out*not(bDrawSill) - gs_trim_offs_out * not(gs_trim_atframe_out) * not(bDrawSill))
				else
					py = -overSizeBottom + widoThresDepth + gs_trim_offs_out_bottom !!+ BrickSillTrimOffs

					if bDrawSill then
						py1 = py + not(gs_stack_bottom) * (-gs_trim_offs_out_bottom * not(gs_trim_atframe_out) - gs_tw_bottom_out)
						py3 = py + not(gs_stack_bottom) * (-gs_trim_offs_out_bottom * not(gs_trim_atframe_out))
					else
						py1 = py + not(gs_stack_bottom) * (gs_trim_width_out - gs_trim_offs_out * not(gs_trim_atframe_out) - gs_tw_bottom_out)
						py3 = py + not(gs_stack_bottom) * (gs_trim_width_out - gs_trim_offs_out * not(gs_trim_atframe_out))
					endif
					py2 = py1 + gs_tw_bottom_out * (bDrawSill | (gs_trim_atframe_out & not(gs_trimb_atframe_out) & (WIDO_SILL>0)))
				endif
				py4 = py3
				py5 = py2
				py6 = py1

				s1 = not(gs_trim_atframe_out) * (maskLeft*not(bDrawSill)+maskLeft2*bDrawSill) + gs_trim_atframe_out * (8 + 7 * not(gs_stack_left))
				s2 = not(gs_trim_atframe_out) * maskLeft + gs_trim_atframe_out * (15 - 5 * not(bDrawSill) * gs_trimb_atframe_out)
				s3 = not(gs_trim_atframe_out) * bitset (mask, 1, not(gs_stack_left)) + gs_trim_atframe_out * 13
				s4 = not(gs_trim_atframe_out) * maskRight + gs_trim_atframe_out * (13 - 5 * not(bDrawSill) * gs_trimb_atframe_out)
				s5 = not(gs_trim_atframe_out) * (maskRight*not(bDrawSill)+maskRight2*bDrawSill) + gs_trim_atframe_out * (8 + 7 * not(gs_stack_right))
				s6 = 13 + 2 * not(gs_stack_right)

				addz -WIDO_SILL * gs_trim_atframe_out * not(gs_trimb_atframe_out)

				if gs_fsill then
					add 0, 0, gs_trim_thk_out
					cutplane 270 - gs_sill_angle
					del 1
				endif

				if bDrawLeftTrimatGangingOut then
					px2 = leftRevealPnts[2][1] + tolerOffsStackCasLeftOut + trim_offs_out_modify - gs_trim_offs_out
					py2 = py3
				endif
				if bDrawRightTrimatGangingOut then
					px3 = rightRevealPnts[2][1] - tolerOffsStackCasRightOut - trim_offs_out_modify + gs_trim_offs_out
					py5 = py4
				endif

				cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
					4+2, gs_trim_thk_out,
					px1,	py1,	0, s1, gs_trim_out_mat,
					px1,	py2, 	0, s2, gs_trim_out_mat,
					px2,	py3,	0, s3, gs_trim_out_mat,
					px3,	py4,	0, s4, gs_trim_out_mat,
					px4,	py5, 	0, s5, gs_trim_out_mat,
					px4,	py6, 	0, s6, gs_trim_out_mat
				gosub "TextCoord_Hor"

				if gs_fsill then cutend

				del 1
			endif


			if bShapeEnablesStraightTopTrim & not(gs_stack_top) & abs(gs_tw_top_out) > EPS then
				! --- Draw upper Trim ---

				px = -leftWidth - overSizeLeft + widoLeftJamb + tolerOffsetLeftOut
				px1 = px + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out - gs_tw_left_out)
				px2 = px + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out)
				px = rightWidth + overSizeRight - widoRightJamb - tolerOffsetRightOut
				px3 = px + not(gs_stack_right) * (-gs_trim_width_out + gs_trim_offs_out)
				px4 = px + not(gs_stack_right) * (-gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out)

				py2 = B + overSizeTop - tolerOffsetUpperOut - gs_trim_width_out + gs_trim_offs_out - widoHeadDepth + gs_trim_offs_out_top
				py1 = py2 + gs_tw_top_out

				pyWCutTopOHOut = py1

				if bDrawLeftTrimatGangingOut then
					px2 = leftRevealPnts[2][1] + tolerOffsStackCasLeftOut + trim_offs_out_modify - gs_trim_offs_out
				endif
				if bDrawRightTrimatGangingOut then
					px3 = rightRevealPnts[2][1] - tolerOffsStackCasRightOut - trim_offs_out_modify + gs_trim_offs_out
				endif

				if not(bTrimovtopleftout | bDrawLeftTrimatGangingOut) & not(bTrimovtoprightout | bDrawRightTrimatGangingOut) then
					cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						4, gs_trim_thk_out,
						px1,	py1,	0, maskLeft, gs_trim_out_mat,
						px2,	py2,	0, 13 + 2 * not(gs_stack_left), gs_trim_out_mat,
						px3,	py2,	0, maskRight, gs_trim_out_mat,
						px4,	py1, 	0, 13 + 2 * not(gs_stack_right), gs_trim_out_mat
				endif
				if (bTrimovtopleftout | bDrawLeftTrimatGangingOut) & not(bTrimovtoprightout | bDrawRightTrimatGangingOut) then
					cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						6, gs_trim_thk_out,
						px1-gs_trimov_top_left_out*not(gs_stack_left),	py1,	0, 8 + 7 * not(gs_stack_left), gs_trim_out_mat,
						px1-gs_trimov_top_left_out*not(gs_stack_left),	py2,	0, 15, gs_trim_out_mat,
						px1,	py2,	0, maskLeft, gs_trim_out_mat,
						px2,	py2,	0, 13, gs_trim_out_mat, !bitset (mask, 1, not(gs_stack_left)), gs_trim_out_mat,
						px3,	py2,	0, maskRight, gs_trim_out_mat,
						px4,	py1, 	0, 13 + 2 * not(gs_stack_right), gs_trim_out_mat
				endif
				if not(bTrimovtopleftout | bDrawLeftTrimatGangingOut) & (bTrimovtoprightout | bDrawRightTrimatGangingOut) then
					cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						6, gs_trim_thk_out,
						px1,	py1,	0, maskLeft, gs_trim_out_mat,
						px2,	py2,	0, 13, gs_trim_out_mat, !bitset (mask, 1, not(gs_stack_left)), gs_trim_out_mat,
						px3,	py2,	0, maskRight, gs_trim_out_mat,
						px4,	py2, 	0, 15, gs_trim_out_mat,
						px4+gs_trimov_top_right_out*not(gs_stack_right),	py2, 	0, 8 + 7 * not(gs_stack_right), gs_trim_out_mat,
						px4+gs_trimov_top_right_out*not(gs_stack_right),	py1, 	0, 15, gs_trim_out_mat
				endif
				if (bTrimovtopleftout | bDrawLeftTrimatGangingOut) & (bTrimovtoprightout | bDrawRightTrimatGangingOut) then
					if gs_trimtype_out_int = CASING_NORMAL then				! Rectangular casing type
						cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
							8, gs_trim_thk_out,
							px1-gs_trimov_top_left_out*not(gs_stack_left),	py1,	0, 8 + 7 * not(gs_stack_left), gs_trim_out_mat,
							px1-gs_trimov_top_left_out*not(gs_stack_left),	py2,	0, 15, gs_trim_out_mat,
							px1,	py2,	0, maskLeft, gs_trim_out_mat,
							px2,	py2,	0, 13, gs_trim_out_mat, !bitset (mask, 1, not(gs_stack_left)), gs_trim_out_mat,
							px3,	py2,	0, maskRight, gs_trim_out_mat,
							px4,	py2, 	0, 15, gs_trim_out_mat,
							px4+gs_trimov_top_right_out*not(gs_stack_right),	py2, 	0, 8 + 7 * not(gs_stack_right), gs_trim_out_mat,
							px4+gs_trimov_top_right_out*not(gs_stack_right),	py1, 	0, 15, gs_trim_out_mat
					endif
					if gs_trimtype_out_int = CASING_OVERHANG then				! SWE traditional casing type
						cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
							10, gs_trim_thk_out,
							px1-gs_trimov_top_left_out*not(gs_stack_left),	py1,		0, 8 + 7 * not(gs_stack_left), gs_trim_out_mat,
							px1-gs_trimov_top_left_out*not(gs_stack_left),	py1-0.04,	0, 8 + 7 * not(gs_stack_left), gs_trim_out_mat,
							px1-gs_trimov_top_left_out*not(gs_stack_left)/2,py2,		0, 15, gs_trim_out_mat,
							px1,	py2,	0, maskLeft, gs_trim_out_mat,
							px2,	py2,	0, bitset (mask, 1, not(gs_stack_left)), gs_trim_out_mat,
							px3,	py2,	0, maskRight, gs_trim_out_mat,
							px4,	py2, 	0, 15, gs_trim_out_mat,
							px4+gs_trimov_top_right_out*not(gs_stack_right)/2,	py2, 		0, 8 + 7 * not(gs_stack_right), gs_trim_out_mat,
							px4+gs_trimov_top_right_out*not(gs_stack_right),	py1-0.04, 	0, 8 + 7 * not(gs_stack_right), gs_trim_out_mat,
							px4+gs_trimov_top_right_out*not(gs_stack_right),	py1, 		0, 15, gs_trim_out_mat
					endif
				endif
			endif



			if	bShapeEnablesArchedTopTrim then

				resol nArchResolution

				px1 = -leftWidth + tolerOffsetLeftOut + gs_trim_width_out - gs_trim_offs_out + widoRightJamb
				px2 = rightWidth - tolerOffsetRightOut - gs_trim_width_out + gs_trim_offs_out - widoRightJamb



				if bHalfCircle then
					addy B - archHeight - tolerOffsetUpperIn

					cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						11, gs_trim_thk_out,
						px1,					0, 	 0,   8 + 7 * gs_stack_left, gs_trim_out_mat,
						px1 - gs_tw_right_out,	-EPS,0,   8 + 7 * gs_stack_left, gs_trim_out_mat,
						px1 - gs_tw_right_out,	0,	 0,  79, gs_trim_out_mat,
						0,						0,	 0, 900, gs_trim_out_mat,
						0,						archHeight - gs_tw_right_out,	0, 3079, gs_trim_out_mat,
						px2 + gs_tw_right_out,	0,	0, 3079, gs_trim_out_mat,
						px2 + gs_tw_right_out,	-EPS,  0, 8 + 7 * gs_stack_right, gs_trim_out_mat,
						px2,					0,	 0, 64 + mask - 2 + 4 * gs_trim_atframe_out * (WIDO_SILL>0), gs_trim_out_mat,
						0,						archHeight, 	0, 3064 + mask - 2 + 4 * gs_trim_atframe_out * (WIDO_SILL>0), gs_trim_out_mat,
						px1,					0, 	0, 3013 + 2 * gs_stack_left, gs_trim_out_mat,
						px1,					0, 	 0,   -1, gs_trim_out_mat

					! --- Draw missing lines ---
					if gs_stack_left  then lin_ px1 - gs_tw_right_out,0,0, px1 - gs_tw_right_out,0,gs_trim_thk_out
					if gs_stack_right then lin_ px2,0,0, px2,0,gs_trim_thk_out
				else
					addy B - archHeight

					ta = leftWidth - gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out - widoHeadDepth - tolerOffsetUpperOut
					tc = arcR - gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out - widoHeadDepth - tolerOffsetUpperOut
					py1L = sqr(max(0, tc * tc - ta * ta)) - arcR + archHeight

					ta = ta - gs_tw_right_out
					tc = tc - gs_tw_right_out
					py2L = sqr(max(0, tc * tc - ta * ta)) - arcR + archHeight

					ta = rightWidth - gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out - widoHeadDepth - tolerOffsetUpperOut
					tc = arcR - gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out - widoHeadDepth - tolerOffsetUpperOut
					py1R = sqr(max(0, tc * tc - ta * ta)) - arcR + archHeight

					ta = ta - gs_tw_right_out
					tc = tc - gs_tw_right_out
					py2R = sqr(max(0, tc * tc - ta * ta)) - arcR + archHeight

					if arcR - (A / 2 / archHeight) * widoHeadDepth < archHeight + EPS then
						cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
							8, gs_trim_thk_out,
							px1,					py2L, 		0,    8 + 7 * gs_stack_left, gs_trim_out_mat,
							px1 - gs_tw_right_out,	py1L,		0,   79, gs_trim_out_mat,
							0,						0,			0,  900, gs_trim_out_mat,
							0,						archHeight - gs_tw_right_out,	 0, 3079, gs_trim_out_mat,
							px2 + gs_tw_right_out,	py1R,		0, 3010 + 5 * gs_stack_right, gs_trim_out_mat,
							px2,					py2R,		0,   62 + mask, gs_trim_out_mat,
							0,						archHeight,	0, 3062 + mask, gs_trim_out_mat,
							px1,					py2L,		0, 3015, gs_trim_out_mat
					else
						cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
							8, gs_trim_thk_out,
							0,						archHeight - arcR, 0, 900, gs_trim_out_mat,
							px1,					py2L,	0,    8 + 7 * gs_stack_left, gs_trim_out_mat,
							px1 - gs_tw_right_out,	py1L,	0,   79, gs_trim_out_mat,
							0,						archHeight - widoHeadDepth - tolerOffsetUpperOut + gs_trim_offs_out - gs_trim_width_out + gs_tw_right_out,	0, 3079, gs_trim_out_mat,
							px2 + gs_tw_right_out,	py1R,	0, 3010 + 5 * gs_stack_right, gs_trim_out_mat,
							px2,					py2R,	0,   62 + mask, gs_trim_out_mat,
							0,						archHeight - widoHeadDepth - tolerOffsetUpperOut + gs_trim_offs_out - gs_trim_width_out, 	0, 3062 + mask, gs_trim_out_mat,
							px1,					py2L, 	0, 3015, gs_trim_out_mat
					endif

					lin_ px2,py2R,0,
						 px2,py2R,gs_trim_thk_out
					lin_ px1 - gs_tw_right_out,py1L,0,
						 px1 - gs_tw_right_out,py1L,gs_trim_thk_out
				endif

				del 1
			endif

			if iWindowShape = SHAPE_ELLIPSEARCH then

				resol nArchResolution

				px1 = -leftWidth + widoRightJamb + tolerOffsetLeftOut - gs_trim_offs_out + gs_trim_width_out
				px2 =  rightWidth - widoRightJamb - tolerOffsetRightOut + gs_trim_offs_out - gs_trim_width_out
				px3 = -leftWidth + widoRightJamb + tolerOffsetLeftOut
				px4 = rightWidth - widoRightJamb - tolerOffsetRightOut

				pxcL = -leftWidth + smallRadiusEllips
				pxcR = rightWidth - smallRadiusEllips

				py1 = B + overSizeTopOut - tolerOffsetUpperOut

				s1 = 9 + 4 * (abs(gs_trim_offs_out) > EPS | not(gs_trim_show_cover_out) | abs(gs_trim_thk_out) < EPS)

				cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
					13,gs_trim_thk_out,
					px2,					py1 - archHeight,			0, s1,		gs_trim_out_mat,
					pxcR,					py1 - archHeight,			0, 900+s1,	gs_trim_out_mat,
					0,		 				alphaSide,					0, 4000+s1,	gs_trim_out_mat,
					0,						py1 - middleRadiusEllips, 	0, 900+s1,	gs_trim_out_mat,
					0,		 				alphaMiddle,				0, 4000+s1,	gs_trim_out_mat,
					pxcL,					py1 - archHeight,			0, 900+s1,	gs_trim_out_mat,
					0,		 				alphaSide,					0, 4008,	gs_trim_out_mat,
					px1 - gs_tw_right_out,	py1 - archHeight,			0, 13+64,	gs_trim_out_mat,
					0,		 				-alphaSide,					0, 4015+64,	gs_trim_out_mat,
					0,						py1 - middleRadiusEllips, 	0, 915+64,	gs_trim_out_mat,
					0,		 				-alphaMiddle,				0, 4015+64,	gs_trim_out_mat,
					pxcR,					py1 - archHeight,			0, 908+64,	gs_trim_out_mat,
					0,		 				-alphaSide,					0, 4008+64,	gs_trim_out_mat
			endif
			gosub "TextCoord_Hor"

			del 1


			if bCutWall then
				pen WALL_VIEW_PEN
				material matWallOut

				if	bShapeEnablesArchedTopTrim | \
					iWindowShape = SHAPE_ELLIPSEARCH then

					if iWindowShape = SHAPE_ELLIPSEARCH then
						put	pxWCutTopRightOut, pyWCutTopRightOut, 79,
							pxcR,				pyWCutTopRightOut,			979,
							0,		 			alphaSide,					4079,
							0,					py1 - middleRadiusEllips, 	979,
							0,		 			alphaMiddle,				4079,
							pxcL,				py1 - archHeight,			979,
							0,		 			alphaSide,					4079
					else
						if bHalfCircle then
							put	pxWCutTopRightOut, pyWCutTopRightOut, 79,
								0, B - tolerOffsetUpperIn - archHeight, 900,
								pxWCutTopLeftOut, pyWCutTopLeftOut, 3079
						else
							put pxWCutTopRightOut, pyWCutTopRightOut-EPS, 31,
								pxWCutTopRightOut, pyWCutTopRightOut, 79,
								0, B - tolerOffsetUpperIn - arcR, 900,
								pxWCutTopLeftOut, pyWCutTopLeftOut, 3031,
								pxWCutTopLeftOut, pyWCutTopLeftOut-EPS, 31
						endif
					endif
				else
					put pxWCutTopRightOut, pyWCutTopRightOut, 31
					if gs_trimtype_out_int = CASING_OVERHANG then
						put	pxWCutTopRightOut	+ gs_trimov_top_right_out/2, pyWCutTopRightOut, 31,
							pxWCutTopRightOut	+ gs_trimov_top_right_out,	pyWCutTopOHOut - 0.04, 31,
							pxWCutTopRightOut	+ gs_trimov_top_right_out,	pyWCutTopOHOut, 31,
							pxWCutTopLeftOut	- gs_trimov_top_left_out,	pyWCutTopOHOut, 31,
							pxWCutTopLeftOut	- gs_trimov_top_left_out,	pyWCutTopOHOut - 0.04, 31,
							pxWCutTopLeftOut	- gs_trimov_top_left_out/2, pyWCutTopRightOut, 31
					endif
					put	pxWCutTopLeftOut,	pyWCutTopLeftOut,	31
				endif

				put	pxWCutMidLeftOut, pyWCutMidLeftOut, 31

				if gs_trimtype_out_int = CASING_OVERHANG then
					put	pxWCutMidOHLeftOut, pyWCutMidLeftOut, 31,
						pxWCutMidOHLeftOut, pyWCutMidLeftOut + gs_trimov_bot_left_out, 31
				endif
				if not(isWindow) & bPShapedLeftOpening then
					put	pxWCutBotLeftOut, pyWCutMidLeftOut + gs_trimov_bot_left_out, 31,
						pxWCutBotLeftOut, pyWCutBotLeftOut, 31
				endif
				if not(isWindow) & bPShapedRightOpening then
					put	pxWCutBotRightOut, pyWCutBotRightOut, 31,
						pxWCutBotRightOut, pyWCutMidRightOut + gs_trimov_bot_right_out, 31
				endif
				if gs_trimtype_out_int = CASING_OVERHANG then
					put	pxWCutMidOHRightOut, pyWCutMidRightOut + gs_trimov_bot_right_out, 31,
						pxWCutMidOHRightOut, pyWCutMidRightOut, 31
				endif

				put	pxWCutMidRightOut, pyWCutMidRightOut, 31

!				prism_ nsp/3,-1,
!					use(nsp)

				wallniche nsp/3,1,16,
					0,0,1,0,
					get(nsp)

				pen gs_frame_pen
				material gs_trim_out_mat
			endif
		endif

		del 3
	else
		! ======================================
		! Outside Trim - Curved Walls
		! ======================================

		resol WALL_RESOL

		offsArc = iHolePosSign * AC_Hole_Position_Angle / 180 * PI * rSill

		if gs_IsCurved then
			thk = WIDO_SILL
		else
			thk = WALL_THICKNESS * 2
			rotx -180
			cutplane 180
			del 1
			numCutsFrame = 1
		endif

		if wallIsLeft then
			mask = 11 + 4 * (gs_trim_offs_out > EPS | not(bShowJambExtension) | not(gs_trim_show_cover_out))
		else
			mask = 14 + (gs_trim_offs_out > EPS | not(bShowJambExtension) | not(gs_trim_show_cover_out))
		endif

		if gs_trim_width_out > EPS & thk > EPS & bShowJambExtension then

			matTrim = gs_trim_out_mat

			material gs_trim_out_mat
			sect_fill gs_trim_fill_out, gs_trim_pen_bg_out, gs_trim_pen_fg_out, gs_trim_pen_cont_out

			! ===== Outside Trim - Curved Walls - Jamb Extensions =====

			rotx -180
			addz -WOD
			bCondition = WIDO_REVEAL_SIDE exor SYMB_MIRRORED
			roty (not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) + not(wallIsLeft) * 180
			addz rSill

			if	isWindow then
				py4 = -overSizeBottom + not(gs_stack_bottom) * (widoThresDepth * not(bTShapedOpening) + gs_trim_width_out * bParalellInCurvedWalls)
				py3 = py4 + not(gs_stack_bottom | not(bCasingBottomOutside) | bDrawLeftSLSill) * gs_trim_width_out * not(bParalellInCurvedWalls)
				py3l = py3
				py4l = py4
				py3r = py3
				py4r = py4

				s3 = 8 + 2 * not(gs_stack_bottom)	! 15 or 8
				s4 = 13 + 2 * not(gs_stack_bottom)	! 15 or 13
			else
				if	(bPShapedLeftOpening & gs_trim_below_sillLeft) then
					py4l = -overSizeBottomLeft + gs_trim_width_out * bParalellInCurvedWalls
					py3l = py4l + not(bDrawLeftSLSill) * gs_trim_width_out * not(bParalellInCurvedWalls)
				else
					py3l = -overSizeBottomLeft + bDrawLeftSLSill * widoThresDepth
					py4l = -overSizeBottomLeft + bDrawLeftSLSill * widoThresDepth
				endif
				if	(bPShapedRightOpening & gs_trim_below_sillRight) then
					py4r = -overSizeBottomRight + gs_trim_width_out * bParalellInCurvedWalls
					py3r = py4r + not(bDrawRightSLSill) * gs_trim_width_out * not(bParalellInCurvedWalls)
				else
					py3r = -overSizeBottomRight + bDrawRightSLSill * widoThresDepth
					py4r = -overSizeBottomRight + bDrawRightSLSill * widoThresDepth
				endif

				s3 = 15
				s4 = 15
			endif

			! --- Draw Left side Jamb Extension ---
			if bParalellInCurvedWalls then
				addz -rSill
				roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

				cutpolya 4, 1, 0,
					-leftWidth + widoLeftJamb,  -overSizeBottom + widoThresDepth,  0,
					-leftWidth * 3,  -overSizeBottom + widoThresDepth,  0,
					-leftWidth * 3, B + overSizeTop - widoHeadDepth, 0,
					-leftWidth + widoLeftJamb,  B + overSizeTop - widoHeadDepth,  5

				cutpolya 4, 1, 0,
					-leftWidth + widoLeftJamb + gs_trim_width_out,  -overSizeBottom + widoThresDepth,  7,
					rightWidth,  -overSizeBottom + widoThresDepth,  7,
					rightWidth, B + overSizeTop - widoHeadDepth, 7,
					-leftWidth + widoLeftJamb + gs_trim_width_out,  B + overSizeTop - widoHeadDepth,  1
				del 2
			endif

			px1 = signWallIsLeft * (offsArc - rSill * alfaLeft * DegRad + widoLeftJamb) - leftWidth * bParalellInCurvedWalls
			px2 = px1 + signWallIsLeft * gs_trim_width_out + 2 * leftWidth * bParalellInCurvedWalls

			if	bShapeEnablesStraightTopTrim then
				py1 = B + overSizeTop - not(gs_stack_top) * widoHeadDepth
				py2 = py1 - not(gs_stack_top) * gs_trim_width_out

				s1 = 8 + 2 * not(gs_stack_top)		! 15 or 8
				s2 = bitset (mask, 1, not(gs_stack_top))
			endif
			if	bShapeEnablesArchedTopTrim then
				ta = leftWidth - tolerOffsetLeftIn
				tc = arcR
				py1 = B - arcR + sqr(max(0, (tc * tc - ta * ta)))

				ta = ta - gs_trim_width_out
				tc = tc - gs_trim_width_out
				py2 = B - arcR + sqr(max(0, (tc * tc - ta * ta)))

				s1 = 8
				s2 = mask - 2
			endif

			if iWindowShape = SHAPE_ELLIPSEARCH then
				py1 = B - archHeight - tolerOffsetUpper
				py2 = B - archHeight - tolerOffsetUpper

				s1 = 8
				s2 = mask - 2
			endif

			if	bPShapedLeftOpening then
				py3l = py3l + gs_sidelight_parapet_hgt_left + gs_reveal_bottom_sL
				py4l = py4l + gs_sidelight_parapet_hgt_left + gs_reveal_bottom_sL
			endif

			if not(gs_stack_left | bLeftCornerFunction) then
				body -1
				bprism_ matTrim, matTrim, matTrim,
					4, -signWallIsLeft * thk, rSill,
					px1,	py1,	s1,
					px2,	py2,	s2,
					px2,	py3l,	s3,
					px1,	py4l,	s4
				gosub "TextCoord_Vert"
			endif

			if bParalellInCurvedWalls then
				cutend
				cutend
			endif

			! --- Draw Right side Jamb Extension ---
			if bParalellInCurvedWalls then
				addz -rSill
				roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

				cutpolya 4, 1, 0,
					rightWidth - widoRightJamb,  -overSizeBottom + widoThresDepth,  0,
					rightWidth * 3,  -overSizeBottom + widoThresDepth,  0,
					rightWidth * 3, B + overSizeTop - widoHeadDepth, 0,
					rightWidth - widoRightJamb,  B + overSizeTop - widoHeadDepth,  5

				cutpolya 4, 1, 0,
					rightWidth - widoRightJamb - gs_trim_width_out,  -overSizeBottom + widoThresDepth,  7,
					-leftWidth,  -overSizeBottom + widoThresDepth,  7,
					-leftWidth, B + overSizeTop - widoHeadDepth, 7,
					rightWidth - widoRightJamb - gs_trim_width_out,  B + overSizeTop - widoHeadDepth,  1
				del 2
			endif

			px1 = signWallIsLeft * (offsArc + rSill * alfaRight * DegRad - widoRightJamb) + rightWidth * bParalellInCurvedWalls
			px2 = px1 - signWallIsLeft * gs_trim_width_out - rightWidth * bParalellInCurvedWalls * 2

			if	bShapeEnablesStraightTopTrim then
				py1 = B + overSizeTop - not(gs_stack_top) * (widoHeadDepth + gs_trim_width_out * bParalellInCurvedWalls)
				py2 = py1 - not(gs_stack_top) * gs_trim_width_out * not(bParalellInCurvedWalls)

				s1 = 8 + 2 * not(gs_stack_top)		! 15 or 8
				s2 = bitset (mask, 1, not(gs_stack_top))
			endif
			if	bShapeEnablesArchedTopTrim then
				ta = rightWidth - tolerOffsetRightIn
				tc = arcR
				py1 = B - arcR + sqr(max(0, (tc * tc - ta * ta)))

				ta = ta - gs_trim_width_out
				tc = tc - gs_trim_width_out
				py2 = B - arcR + sqr(max(0, (tc * tc - ta * ta)))

				s1 = 8
				s2 = mask - 2
			endif
			if iWindowShape = SHAPE_ELLIPSEARCH then
				py1 = B - archHeight - tolerOffsetUpper
				py2 = B - archHeight - tolerOffsetUpper

				s1 = 8
				s2 = mask - 2
			endif

			if	bPShapedRightOpening then
				py3r = py3r + gs_sidelight_parapet_hgt_right + gs_reveal_bottom_sR
				py4r = py4r + gs_sidelight_parapet_hgt_right + gs_reveal_bottom_sR
			endif

			if not(gs_stack_right | bRightCornerFunction) then
				body -1
				bprism_ matTrim, matTrim, matTrim,
					4, -signWallIsLeft * thk, rSill,
					 px1,	py1, 	s1,
					 px2,	py2, 	s2,
					 px2,	py3r,	s3,
					 px1,	py4r, 	s4
				gosub "TextCoord_Vert"
			endif

			if bParalellInCurvedWalls then
				cutend
				cutend
			endif

			if bTShapedOpening then

				del 3

				alphaLeft = abs(asn(leftRevealPnts[idxSillEndRevealLeft][1]  / radSill)) + 10
				alphaRight = abs(asn(rightRevealPnts[idxSillEndRevealright][1] / radSill)) + 10


				alfaEnd		= alphaRight + 10
				alfaStart	= -alphaLeft - 10
				arcRadius	= radSill
				bMiddlePoints = 1
				firstStatus	= 31
				midStatus	= 10 + 5 * (gs_trim_offs_out > EPS) + 64 + 16
				lastStatus	= 31
				if abs(alfaStart - alfaEnd) > EPS then
					gosub 110

					rotx 180
					rotx -90
					muly -1


					cutDepth = MAX(py3l, py3r)
					if not(wallIsLeft) then
!						prism_ NSP/3 + 2,-cutDepth,
!							radSill * sin(alphaRight), 2*WOD, 15,
!							-radSill * sin(alphaLeft), 2*WOD, 15,
!							use(nsp)
						cutpolya NSP/3 + 2,1,0,
							radSill * sin(alphaRight), 2*WOD, 15,
							-radSill * sin(alphaLeft), 2*WOD, 15,
							get(nsp)
					else
!							prism_ NSP/3 + 2,-cutDepth,
!								 radSill * sin(alphaLeft) + 2,  -radSill * cos(alphaLeft)  + WOD - 2, 15,
!								-radSill * sin(alphaRight) - 2, -radSill * cos(alphaRight) + WOD - 2, 15,
!								use(nsp)
						cutpolya NSP/3 + 2,1,0,
							 radSill * sin(alphaLeft) + 2,  -radSill * cos(alphaLeft)  + WOD - 2, 31,
							-radSill * sin(alphaRight) - 2, -radSill * cos(alphaRight) + WOD - 2, 31,
							get(nsp)
					endif
					del 3
				endif

				if	bPShapedLeftOpening & gs_trim_below_sillLeft then
					! --- Draw Door's Left side Jamb Extension ---

					px1lP = -leftWidth + gs_reveal_left_sL + gs_sidelight_WHole_width_left ! + tolerOffsetLeftIn
					px2lP = px1lP + gs_trim_width_out
					py1 = widoThresDepth
					py2 = widoThresDepth

					body -1
					sprism_ matTrim, matTrim, matTrim,
						4, 0,0, 0,1, thk - pocketThkLeft, wallIncl,
						 px1lP,	py1,	s1,
						 px2lP,	py2,	s2,
						 px2lP,	py3l,	s3,
						 px1lP,	py4l,	s4
					gosub "TextCoord_Vert"

					if	not(bDrawLeftSLSill) then
						! --- Draw Left Sidelight lower side Jamb Extension ---

						if not(bParalellInCurvedWalls) then

							addz -WOD
							roty -alfaLeftOut * signWallIsLeft  !+ atn((widoLeftJamb)  / WOD) * signWallIsLeft
							addz rBoard * signWallIsLeft
							addy py4l
							roty 90
							rotx 180 + 45 * not(gs_stack_left)

							!rect 1,1
							cutplane

							del 6
						endif

						px1l = -leftWidth - overSizeLeftOut - 1 * not(bParalellInCurvedWalls)
						px2l = px1l + gs_trim_width_out

						sprism_ matTrim, matTrim, matTrim,
							4, 0,0, 0,1, thk - pocketThkLeft, wallIncl,
							px2lP,	py3l,	15,
							px1lP,	py4l,	15,
							px1l,	py4l,	15,
							px2l,	py3l,	mask - 2 * gs_stack_left
						gosub "TextCoord_Hor"

						if not(bParalellInCurvedWalls) then cutend

					endif
				endif

				if	bPShapedRightOpening & gs_trim_below_sillRight then
					! --- Draw Door's Right side Jamb Extension ---

					px1rP = rightWidth - gs_reveal_right_sR - gs_sidelight_WHole_width_right ! + tolerOffsetLeftIn
					px2rP = px1rP - gs_trim_width_out
					py1 = widoThresDepth
					py2 = widoThresDepth

					body -1
					sprism_ matTrim, matTrim, matTrim,
						4, 0,0, 0,1, thk - pocketThkLeft, wallIncl,
						 px1rP,	py1,	s1,
						 px2rP,	py2,	s2,
						 px2rP,	py3r,	s3,
						 px1rP,	py4r,	s4
					gosub "TextCoord_Vert"

					if	not(bDrawRightSLSill) then
						! --- Draw Right Sidelight lower side Jamb Extension ---

						if not(bParalellInCurvedWalls) then
							addz -WOD
							roty alfaRightOut * signWallIsLeft
							addz rBoard * signWallIsLeft
							addy py4r
							roty 90
							rotx 360 - 45 * not(gs_stack_right)

							!rect 1,1
							cutplane

							del 6
						endif

						px1r = rightWidth + overSizeRightOut + 1 * not(bParalellInCurvedWalls)
						px2r = px1r - gs_trim_width_out

						sprism_ matTrim, matTrim, matTrim,
							4, 0,0, 0,1, thk - pocketThkLeft, wallIncl,
							px2rP,	py3r,	15,
							px1rP,	py4r,	15,
							px1r,	py4r,	15,
							px2r,	py3r,	mask - 2 * gs_stack_right
						gosub "TextCoord_Hor"

						if not(bParalellInCurvedWalls) then cutend

					endif
				endif

				if abs(alfaStart - alfaEnd) > EPS then cutend

				addz -WOD
				roty (not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) + not(wallIsLeft) * 180
				addz rSill
			endif


			if not(bParalellInCurvedWalls) then
				px1 = signWallIsLeft * (offsArc - rSill * alfaLeft * DegRad + widoLeftJamb)
				px2 = px1 + signWallIsLeft * (not(gs_stack_left) * gs_trim_width_out)
				px4 = signWallIsLeft * (offsArc + rSill * alfaRight * DegRad - widoRightJamb)
				px3 = px4 - signWallIsLeft * (not(gs_stack_right) * gs_trim_width_out)
			else
				px1 = signWallIsLeft * (offsArc - rSill * alfaLeft * DegRad - leftWidth * not(gs_stack_left))
				px2 = px1
				px4 = signWallIsLeft * (offsArc + rSill * alfaRight * DegRad + rightWidth * not(gs_stack_right))
				px3 = px4
			endif

			if not(gs_stack_bottom | not(bCasingBottomOutside) | bDrawSill | not(isWindow)) then
				if bParalellInCurvedWalls then
					addz -rSill
					roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

					if not(gs_stack_left) then
						cutpolya 4, 1, 0,
							-leftWidth + widoLeftJamb,  -overSizeBottom + widoThresDepth,  7,
							-leftWidth * 3,  -overSizeBottom + widoThresDepth,  7,
							-leftWidth * 3, B + overSizeTop - widoHeadDepth, 7,
							-leftWidth + widoLeftJamb,  B + overSizeTop - widoHeadDepth,  7
					endif

					if not(gs_stack_right) then
						cutpolya 4, 1, 0,
							rightWidth - widoRightJamb,  -overSizeBottom + widoThresDepth,  7,
							rightWidth * 3,  -overSizeBottom + widoThresDepth,  7,
							rightWidth * 3, B + overSizeTop - widoHeadDepth, 7,
							rightWidth - widoRightJamb,  B + overSizeTop - widoHeadDepth,  4
					endif
					del 2
				endif

				py1 = -overSizeBottom + widoThresDepth
				py2 = py1 + gs_trim_width_out

				bprism_ matTrim, matTrim, matTrim,
					4, -signWallIsLeft * thk, rSill,
					px1,	py1,	8 + 2 * not(gs_stack_left),			! 15 or 8
					px2,	py2,	bitset (mask, 1, not(gs_stack_left)),
					px3,	py2,	8 + 2 * not(gs_stack_right),		! 15 or 8
					px4,	py1,	13 + 2 * not(gs_stack_right)		! 15 or 13
				gosub "TextCoord_Hor"

				if bParalellInCurvedWalls then
					if not(gs_stack_left) then cutend
					if not(gs_stack_right) then cutend
				endif
			endif

			if bShapeEnablesStraightTopTrim & not(gs_stack_top) then
				! --- Draw upper Trim ---

				if bParalellInCurvedWalls then
					addz -rSill
					roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

					if not(gs_stack_left) then
						cutpolya 4, 1, 0,
							-leftWidth + widoLeftJamb,  -overSizeBottom + widoThresDepth,  7,
							-leftWidth * 3,  -overSizeBottom + widoThresDepth,  7,
							-leftWidth * 3, B + overSizeTop - widoHeadDepth, 7,
							-leftWidth + widoLeftJamb,  B + overSizeTop - widoHeadDepth,  7
					endif

					if not(gs_stack_right) then
						cutpolya 4, 1, 0,
							rightWidth - widoRightJamb,  -overSizeBottom + widoThresDepth,  7,
							rightWidth * 3,  -overSizeBottom + widoThresDepth,  7,
							rightWidth * 3, B + overSizeTop - widoHeadDepth, 7,
							rightWidth - widoRightJamb,  B + overSizeTop - widoHeadDepth,  4
					endif
					del 2
				endif

				py1 = B + overSizeTop - widoHeadDepth
				py2 = py1 - gs_trim_width_out

				bprism_ matTrim, matTrim, matTrim,
					4, -signWallIsLeft * thk, rSill,
					px1,	py1,	8 + 2 * not(gs_stack_left),			! 15 or 8
					px2,	py2,	bitset (mask, 1, not(gs_stack_left)),
					px3,	py2,	8 + 2 * not(gs_stack_right),		! 15 or 8
					px4,	py1,	13 + 2 * not(gs_stack_right)		! 15 or 13

				if bParalellInCurvedWalls then
					if not(gs_stack_left) then cutend
					if not(gs_stack_right) then cutend
				endif
			endif

			if	bShapeEnablesArchedTopTrim then

				resol WALL_RESOL

				px1 = signWallIsLeft * (offsArc - rSill * alfaLeft * DegRad + widoLeftJamb)
				px2 = px1 + signWallIsLeft * gs_trim_width_out
				px4 = signWallIsLeft * (offsArc + rSill * alfaRight * DegRad - widoRightJamb)
				px3 = px4 - signWallIsLeft * gs_trim_width_out


				mulRatio = (leftWidth + rightWidth - widoLeftJamb - widoRightJamb) / abs(px1 - px4)
				addy B - archHeight
				muly mulRatio

				if bHalfCircle then
					bprism_ matTrim, matTrim, matTrim,
						8, -signWallIsLeft * thk, rSill,
						px1,	0, 	   8 + 7 * gs_stack_left,		! 15 or 8
						px2,	0,	  62 + mask,
						0,		1,	 800,
						px3,	0,	1008 + 7 * gs_stack_right,		! 1015 or 1008
						px4,	-EPS,  8 + 7 * gs_stack_right,		! 15 or 8
						px4,	0,	  79,
						0,		1,	 800,
						px1,	0, 	1015
				else

					ta = leftWidth
					tc = arcR
					py1 = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

					ta = ta - gs_trim_width_out
					tc = tc - gs_trim_width_out
					py2 = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

					bprism_ matTrim, matTrim, matTrim,
						6, -signWallIsLeft * thk, rSill,
						(px2 + px3) / 2,		(archHeight - arcR) / mulRatio, 900,
						px2,	py2, 	   8 + 7 * gs_stack_left,	! 15 or 8
						px1,	py1,	  79,
						px4,	py1,	3010 + 5 * gs_stack_right,	! 15 or 8
						px3,	py2,	  62 + mask,
						px2,	py2, 	3015
				endif

				del 2
			endif

			if iWindowShape = SHAPE_ELLIPSEARCH then

				offs = (leftWidth + overSizeLeftOut - (rSill * alfaLeft * DegRad))
				if wallIsLeft then
					s3 = 9 + 4 * (abs(gs_trim_offs_out) > EPS | not(gs_trim_show_cover_out) | abs(gs_trim_thk_out) < EPS) - 2 * gs_stack_right
				else
					s3 = 12 + 1 * (abs(gs_trim_offs_out) > EPS | not(gs_trim_show_cover_out) | abs(gs_trim_thk_out) < EPS) - 2 * gs_stack_right
				endif
				mulRatio = (archHeight / (archHeight + overSizeLeftOut - offs))

				addy B + ((archHeight * mulRatio) - archHeight)
				muly mulRatio

				bprism_ matTrim, matTrim, matTrim,
					13, -signWallIsLeft * thk, rSill,
					signWallIsLeft * offsArc + leftWidth + overSizeLeftOut - offs - widoLeftJamb,							-archHeight,			13,
					signWallIsLeft * offsArc + leftWidth - smallRadiusEllips,												-archHeight,			913,
					0,		 																								 alphaSide,			4013,
					signWallIsLeft * offsArc - (leftWidth - (rightWidth))/2,												-middleRadiusEllips, 	913,
					0,		 																								 alphaMiddle,			4013,
					signWallIsLeft * offsArc - rightWidth + smallRadiusEllips, 												-archHeight,			913,
					0,		 																								 alphaSide,			4008,
					signWallIsLeft * offsArc - rightWidth - overSizeLeftOut + widoRightJamb + offs + gs_trim_width_out,		-archHeight,			s3,
					0,		 																								-alphaSide,			4000+s3,
					signWallIsLeft * offsArc - (leftWidth - rightWidth)/2,													-middleRadiusEllips, 	900+s3,
					0,		 																								-alphaMiddle,			4000+s3,
					signWallIsLeft * offsArc + leftWidth - smallRadiusEllips,												-archHeight,			900+s3,
					0,		 																								-alphaSide,			4000+s3

				del 2
			endif
			gosub "TextCoord_Hor"

			del 4
		endif


		if numCutsFrame then
			cutend
			numCutsFrame = 0
		endif

		if not(gs_stack_left) then
			alfaLeftParallelOut = abs (asn ( (leftRevealPnts[idxSillStartRevealLeft][1] + tolerOffsetLeftOut + gs_trim_width_out) / rSill))
		else
			alfaLeftParallelOut = alfaLeft
		endif
		if not(gs_stack_right) then
			alfaRightParallelOut = abs (asn ( (rightRevealPnts[idxSillStartRevealRight][1] - tolerOffsetRightOut - gs_trim_width_out) / rSill))
		else
			alfaRightParallelOut = alfaRight
		endif

		if gs_trim_thk_out > EPS & gs_trim_show_cover_out & (gs_trimtype_out_int <> CASING_COMPLEX) then

			if iWindowShape = SHAPE_RECTANGULAR then

				if gs_stack_left then
					pxL = leftRevealPnts[idxSillEndRevealLeft][1]
				else
					pxL = leftRevealPnts[idxSillEndRevealLeft][1] + gs_trim_width_out + not(gs_stack_left) * (-gs_trim_offs_out + tolerOffsetLeftOut)
					alphaLeft = abs(asn(pxL / rSill)) + ArcLengthSillToAngle * gs_tw_left_out
					pxL = -rSill * sin(alphaLeft)
					pyL = -sqr(rSill^2 - pxL^2) - WOD
				endif
				if gs_stack_right then
					pxR = rightRevealPnts[idxSillEndRevealright][1]
				else
					pxR = rightRevealPnts[idxSillEndRevealright][1] - gs_trim_width_out - not(gs_stack_right) * (-gs_trim_offs_out + tolerOffsetRightOut)
					alphaRight = abs(asn(pxR / rSill)) + ArcLengthSillToAngle * gs_tw_right_out
					pxR = rSill * sin(alphaRight)
					pyR = -sqr(rSill^2 - pxR^2) - WOD
				endif
				if not(bParalellInCurvedWalls) then		! not USA type
					if isWindow & (not(bDrawSill) | bCasingBottomOutside) then
						if (bDrawSill) * bCasingBottomOutside & not(gs_stack_bottom) then
							pyB = sillBottomOutside - gs_tw_bottom_out
						else
							pyB = -overSizeBottom + not(gs_stack_bottom | not(bCasingBottomOutside)) * (widoThresDepth - gs_trim_offs_out + gs_trim_width_out - gs_tw_bottom_out)
						endif
					else
						pyB = (isWindow & bDrawSill) * (sillBottom + SillSideHeight)
					endif
				else
					if isWindow then
						if bDrawSill then
							pyB = -overSizeBottom + widoThresDepth + gs_trim_offs_out_bottom + not(gs_stack_bottom | not(bCasingBottomOutside)) * (-gs_trim_offs_out_bottom * not(gs_trim_atframe_out) - gs_tw_bottom_out)
						else
							pyB = -overSizeBottom + widoThresDepth + gs_trim_offs_out_bottom + not(gs_stack_bottom | not(bCasingBottomOutside)) * (gs_trim_width_out - gs_trim_offs_out * not(gs_trim_atframe_out) - gs_tw_bottom_out)
						endif
					else
						pyB = 0
					endif
				endif
				pyT = B + overSizeTop - tolerOffsetUpperOut - gs_trim_width_out + gs_trim_offs_out - widoHeadDepth + gs_trim_offs_out_top + gs_tw_top_out

				if bCutWall then
					pen WALL_VIEW_PEN
					material matWallOut

					alfaEnd		= alphaRight
					alfaStart	= -alphaLeft
					arcRadius	= radSill
					bMiddlePoints = 1
					firstStatus	= 31
					midStatus	= 95
					lastStatus	= 31
					if abs(alfaStart - alfaEnd) > EPS then
						gosub 110

						rotx -90
						muly -1
						addz -pyB

						cutDepth = pyT - pyB
						if not(wallIsLeft) then
!							prism_ NSP/3 + 1,-cutDepth,
!								0,WOD,15,
!								use(nsp)
							wallniche NSP/3 + 1,1,0,
								0,0,-cutDepth,cutDepth,
								0,WOD,31,
								get(nsp)
						else
!							prism_ NSP/3 + 2,-cutDepth,
!								 (rSill + WALL_THICKNESS) * sin(alphaLeft),  -(rSill + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 15,
!								-(rSill + WALL_THICKNESS) * sin(alphaRight), -(rSill + WALL_THICKNESS) * cos(alphaRight) + WOD, 15,
!								use(nsp)
							wallniche NSP/3 + 2,1,0,
								0,0,-cutDepth,cutDepth,
								 (rSill + WALL_THICKNESS) * sin(alphaLeft),  -(rSill + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 31,
								-(rSill + WALL_THICKNESS) * sin(alphaRight), -(rSill + WALL_THICKNESS) * cos(alphaRight) + WOD, 31,
								get(nsp)
						endif
						del 3
					endif

					pen gs_frame_pen
					material gs_trim_out_mat
				endif
			endif

			if gs_trimtype_out_int = CASING_NORMAL & not(gs_stack_top) & iWindowShape = SHAPE_RECTANGULAR & (bTrimovtopleftout | bTrimovtoprightout) then

				if gs_stack_left then
					pxL = leftRevealPnts[idxSillEndRevealLeft][1]
				else
					pxL = leftRevealPnts[idxSillEndRevealLeft][1] + gs_trim_width_out + not(gs_stack_left) * (-gs_trim_offs_out + tolerOffsetLeftOut)
					alphaLeft = abs(asn(pxL / rSill)) + ArcLengthSillToAngle * (gs_tw_left_out + gs_trimov_top_left_out)
					pxL = -rSill * sin(alphaLeft)
					pyL = -sqr(rSill^2 - pxL^2) - WOD
				endif
				if gs_stack_right then
					pxR = rightRevealPnts[idxSillEndRevealright][1]
				else
					pxR = rightRevealPnts[idxSillEndRevealright][1] - gs_trim_width_out - not(gs_stack_right) * (-gs_trim_offs_out + tolerOffsetRightOut)
					alphaRight = abs(asn(pxR / rSill)) + ArcLengthSillToAngle * (gs_tw_right_out + gs_trimov_top_right_out)
					pxR = rSill * sin(alphaRight)
					pyR = -sqr(rSill^2 - pxR^2) - WOD
				endif
				pyB = B + overSizeTopOut - gs_trim_width_out + gs_trim_offs_out - tolerOffsetUpperOut
				pyT = pyB + gs_tw_top_out

				if bCutWall then
					pen WALL_VIEW_PEN
					material matWallOut

					alfaEnd		= alphaRight
					alfaStart	= -alphaLeft
					arcRadius	= radSill
					bMiddlePoints = 1
					firstStatus	= 31
					midStatus	= 95
					lastStatus	= 31
					if abs(alfaStart - alfaEnd) > EPS then
						gosub 110

						rotx -90
						muly -1
						addz -pyB

						cutDepth = pyT - pyB
						if not(wallIsLeft) then
!							prism_ NSP/3 + 1,-cutDepth,
!								0,WOD,15,
!								use(nsp)
							wallniche NSP/3 + 1,1,0,
								0,0,-cutDepth,cutDepth,
								0,WOD,31,
								get(nsp)
						else
!							prism_ NSP/3 + 2,-cutDepth,
!								 (rSill + WALL_THICKNESS) * sin(alphaLeft),  -(rSill + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 15,
!								-(rSill + WALL_THICKNESS) * sin(alphaRight), -(rSill + WALL_THICKNESS) * cos(alphaRight) + WOD, 15,
!								use(nsp)
							wallniche NSP/3 + 2,1,0,
								0,0,-cutDepth,cutDepth,
								 (rSill + WALL_THICKNESS) * sin(alphaLeft),  -(rSill + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 31,
								-(rSill + WALL_THICKNESS) * sin(alphaRight), -(rSill + WALL_THICKNESS) * cos(alphaRight) + WOD, 31,
								get(nsp)
						endif
						del 3
					endif

					pen gs_frame_pen
					material gs_trim_out_mat
				endif
			endif

			if isWindow & not(gs_stack_left) & iWindowShape = SHAPE_RECTANGULAR & bTrimovbotleftout then

				pxL = leftRevealPnts[idxSillEndRevealLeft][1] + gs_trim_width_out + not(gs_stack_left) * (-gs_trim_offs_out + tolerOffsetLeftOut)
				alphaLeft = abs(asn(pxL / rSill)) + ArcLengthSillToAngle * gs_tw_left_out
				pxL = -rSill * sin(alphaLeft)
				pyL = -sqr(rSill^2 - pxL^2) - WOD

				pxR = leftRevealPnts[idxSillEndRevealLeft][1] + gs_trim_width_out + not(gs_stack_left) * (-gs_trim_offs_out + tolerOffsetLeftOut)
				alphaRight = abs(asn(pxR / rSill))
				pxR = -rSill * sin(alphaRight)
				pyR = -sqr(rSill^2 - pxR^2) - WOD

				pyB = -overSizeBottom + not(gs_stack_bottom | not(bCasingBottomOutside)) * widoThresDepth + gs_trim_offs_out_bottom \
						+ gs_trim_width_out * not(bDrawSill) \
						- gs_trim_offs_out * not(gs_trim_atframe_out) \
						- gs_tw_bottom_out * bTrimovbotleftout \
			!!!			- 1 * (iSillType > 1 & bDrawBoard) \
						- gs_trimov_bot_left_out
				pyT = B + overSizeTop - tolerOffsetUpperOut - gs_trim_width_out + gs_trim_offs_out - widoHeadDepth + gs_trim_offs_out_top + gs_tw_top_out

				if bCutWall then
					pen WALL_VIEW_PEN
					material matWallOut

					alfaEnd		= -alphaRight
					alfaStart	= -alphaLeft
					arcRadius	= radSill
					bMiddlePoints = 1
					firstStatus	= 31
					midStatus	= 95
					lastStatus	= 31
					if abs(alfaStart - alfaEnd) > EPS then
						gosub 110

						rotx -90
						muly -1
						addz -pyB

						cutDepth = pyT - pyB
						if not(wallIsLeft) then
!							prism_ NSP/3 + 1,-cutDepth,
!								0,WOD,15,
!								use(nsp)
							wallniche NSP/3 + 1,1,0,
								0,0,-cutDepth,cutDepth,
								0,WOD,31,
								get(nsp)
						else
!							prism_ NSP/3 + 2,-cutDepth,
!								-(rSill + WALL_THICKNESS) * sin(alphaRight), -(rSill + WALL_THICKNESS) * cos(alphaRight) + WOD, 15,
!								-(rSill + WALL_THICKNESS) * sin(alphaLeft),  -(rSill + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 15,
!								use(nsp)
							wallniche NSP/3 + 2,1,0,
								0,0,-cutDepth,cutDepth,
								-(rSill + WALL_THICKNESS) * sin(alphaRight), -(rSill + WALL_THICKNESS) * cos(alphaRight) + WOD, 31,
								-(rSill + WALL_THICKNESS) * sin(alphaLeft),  -(rSill + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 31,
								get(nsp)
						endif
						del 3
					endif

					pen gs_frame_pen
					material gs_trim_out_mat
				endif
			endif

			if isWindow & not(gs_stack_right) & iWindowShape = SHAPE_RECTANGULAR & bTrimovbotrightout then

				pxL = rightRevealPnts[idxSillEndRevealRight][1] - gs_trim_width_out - not(gs_stack_right) * (-gs_trim_offs_out + tolerOffsetRightOut)
				alphaLeft = abs(asn(pxL / rSill)) + ArcLengthSillToAngle * gs_tw_left_out
				pxL = -rSill * sin(alphaLeft)
				pyL = -sqr(rSill^2 - pxL^2) - WOD

				pxR = rightRevealPnts[idxSillEndRevealRight][1] - gs_trim_width_out - not(gs_stack_right) * (-gs_trim_offs_out + tolerOffsetRightOut)
				alphaRight = abs(asn(pxR / rSill))
				pxR = -rSill * sin(alphaRight)
				pyR = -sqr(rSill^2 - pxR^2) - WOD

				pyB = -overSizeBottom + not(gs_stack_bottom | not(bCasingBottomOutside)) * widoThresDepth + gs_trim_offs_out_bottom \
						+ gs_trim_width_out * not(bDrawSill) \
						- gs_trim_offs_out * not(gs_trim_atframe_out) \
						- gs_tw_bottom_out * bTrimovbotleftout \
			!!!			- 1 * (iSillType > 1 & bDrawBoard) \
						- gs_trimov_bot_left_out
				pyT = B + overSizeTop - tolerOffsetUpperOut - gs_trim_width_out + gs_trim_offs_out - widoHeadDepth + gs_trim_offs_out_top + gs_tw_top_out

				if bCutWall then
					pen WALL_VIEW_PEN
					material matWallOut

					alfaEnd		= alphaRight
					alfaStart	= alphaLeft
					arcRadius	= radSill
					bMiddlePoints = 1
					firstStatus	= 31
					midStatus	= 95
					lastStatus	= 31
					if abs(alfaStart - alfaEnd) > EPS then
						gosub 110

						rotx -90
						muly -1
						addz -pyB

						cutDepth = pyT - pyB
						if not(wallIsLeft) then
!							prism_ NSP/3 + 1,-cutDepth,
!								0,WOD,15,
!								use(nsp)
							wallniche NSP/3 + 1,1,0,
								0,0,-cutDepth,cutDepth,
								0,WOD,31,
								get(nsp)
						else
!							prism_ NSP/3 + 2,-cutDepth,
!								(rSill + WALL_THICKNESS) * sin(alphaRight), -(rSill + WALL_THICKNESS) * cos(alphaRight) + WOD, 15,
!								(rSill + WALL_THICKNESS) * sin(alphaLeft),  -(rSill + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 15,
!								use(nsp)
							wallniche NSP/3 + 2,1,0,
								0,0,-cutDepth,cutDepth,
								(rSill + WALL_THICKNESS) * sin(alphaRight), -(rSill + WALL_THICKNESS) * cos(alphaRight) + WOD, 31,
								(rSill + WALL_THICKNESS) * sin(alphaLeft),  -(rSill + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 31,
								get(nsp)
						endif
						del 3
					endif

					pen gs_frame_pen
					material gs_trim_out_mat
				endif
			endif

			material gs_trim_out_mat
			sect_fill gs_trim_fill_out, gs_trim_pen_bg_out, gs_trim_pen_fg_out, gs_trim_pen_cont_out

			! ===== Outside Trim - Curved Walls - Casing =====

			if wallIsLeft then
				mask = 14 + (gs_trim_offs_out > EPS)
			else
				mask = 11 + 4 * (gs_trim_offs_out > EPS)
			endif

			maskTop		= 8 + 2 * not(gs_stack_top)
			maskBottom	= 8 + 2 * not(gs_stack_bottom)
			maskLeft	= 8 + (2 + 5 * bParalellInCurvedWalls) * not(gs_stack_left)
			maskRight	= 8 + 2 * not(gs_stack_right)

			maskLeft2	= bDrawSill*(not(bTrimovbotleftout)*(15-7*gs_stack_left)+bTrimovbotleftout*(10-2*gs_stack_left))
			maskRight2	= bDrawSill*(not(bTrimovbotrightout)*(15-7*gs_stack_right)+bTrimovbotrightout*(10-2*gs_stack_right))

			rotx -180
			addz -WOD
			bCondition = WIDO_REVEAL_SIDE exor SYMB_MIRRORED
			roty (not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) + not(wallIsLeft) * 180
			addz rSill


			if bShapeEnablesStraightTopTrim & not(gs_stack_top) then
				! --- Draw upper Trim ---

				if not(bParalellInCurvedWalls) then
					px1 = signWallIsLeft * (offsArc - rSill * alfaLeft * DegRad + widoLeftJamb + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out - gs_tw_left_out - gs_trimov_top_left_out * bTrimovtopleftout))
					px2 = signWallIsLeft * (offsArc - rSill * alfaLeft * DegRad + widoLeftJamb + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out - (gs_tw_left_out + gs_trimov_top_left_out) * bTrimovtopleftout))
					px3 = signWallIsLeft * (offsArc - rSill * alfaLeft * DegRad + widoLeftJamb + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out - gs_tw_left_out * bTrimovtopleftout))
					px4 = signWallIsLeft * (offsArc - rSill * alfaLeft * DegRad + widoLeftJamb + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out))
					px5 = signWallIsLeft * (offsArc + rSill * alfaRight * DegRad - widoRightJamb + not(gs_stack_right) * (-gs_trim_width_out + gs_trim_offs_out))
					px6 = signWallIsLeft * (offsArc + rSill * alfaRight * DegRad - widoRightJamb + not(gs_stack_right) * (-gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out * bTrimovtoprightout))
					px7 = signWallIsLeft * (offsArc + rSill * alfaRight * DegRad - widoRightJamb + not(gs_stack_right) * (-gs_trim_width_out + gs_trim_offs_out + (gs_tw_right_out + gs_trimov_top_right_out) * bTrimovtoprightout))
					px8 = signWallIsLeft * (offsArc + rSill * alfaRight * DegRad - widoRightJamb + not(gs_stack_right) * (-gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out + gs_trimov_top_right_out * bTrimovtoprightout))

					py2 = B + overSizeTop + not(gs_stack_top) * (-widoHeadDepth - gs_trim_width_out + gs_trim_offs_out)
					py1 = py2 + gs_tw_top_out
					py3 = py2
					py4 = py2
					py5 = py2
					py6 = py2
					py7 = py2
					py8 = py1

					s1 = 8 + 7 * not(gs_stack_left) * bTrimovtopleftout
					s2 = 15
					s3 = maskLeft
					s4 = bitset (mask, 1, not(gs_stack_left))
					s5 = maskRight
					s6 = 15
					s7 = 8 + 7 * not(gs_stack_right) * bTrimovtoprightout
					s8 = 13 + 2 * not(gs_stack_right)
				else
					px1 = signWallIsLeft * (offsArc - rSill * alfaLeftParallelout * DegRad + not(gs_stack_left) * (- gs_trim_offs_out - gs_tw_left_out - gs_trimov_top_left_out * bTrimovtopleftout))
					px2 = signWallIsLeft * (offsArc - rSill * alfaLeftParallelout * DegRad + not(gs_stack_left) * (- gs_trim_offs_out - gs_tw_left_out - gs_trimov_top_left_out * bTrimovtopleftout))
					px3 = signWallIsLeft * (offsArc - rSill * alfaLeftParallelout * DegRad + not(gs_stack_left) * (- gs_trim_offs_out - gs_tw_left_out))
					px4 = signWallIsLeft * (offsArc - rSill * alfaLeftParallelout * DegRad + not(gs_stack_left) * (- gs_trim_offs_out - gs_tw_left_out))

					px5 = signWallIsLeft * (offsArc + rSill * alfaRightParallelout * DegRad + not(gs_stack_right) * (gs_trim_offs_out + gs_tw_right_out))
					px6 = signWallIsLeft * (offsArc + rSill * alfaRightParallelout * DegRad + not(gs_stack_right) * (gs_trim_offs_out + gs_tw_right_out))
					px7 = signWallIsLeft * (offsArc + rSill * alfaRightParallelout * DegRad + not(gs_stack_right) * (gs_trim_offs_out + gs_tw_right_out + gs_trimov_top_right_out * bTrimovtoprightout))
					px8 = signWallIsLeft * (offsArc + rSill * alfaRightParallelout * DegRad + not(gs_stack_right) * (gs_trim_offs_out + gs_tw_right_out + gs_trimov_top_right_out * bTrimovtoprightout))

					py2 = B + overSizeTop + not(gs_stack_top) * (-widoHeadDepth - tolerOffsetUpperOut - gs_trim_width_out + gs_trim_offs_out - EPS)
					py1 = py2 + gs_tw_top_out + EPS
					py3 = py2
					py4 = py2
					py5 = py2
					py6 = py2 + EPS
					py7 = py2 + EPS
					py8 = py1

					s1 = 8 + 7 * not(gs_stack_left)
					s2 = 15
					s3 = maskLeft
					s4 = 10	!bitset (mask, 1, not(gs_stack_left))
					s5 = maskRight
					s6 = 15
					s7 = 8 + 7 * not(gs_stack_right)
					s8 = 13 + 2 * not(gs_stack_right)
				endif

				if bParalellInCurvedWalls then
					add 0, 0, -rSill
					roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

!					cutpolya 4, 1, 0,
!						-leftWidth + widoLeftJamb + gs_trim_width_out + gs_trim_offs_out,  py3 - EPS - gs_tw_bottom_out * bTrimovbotleftout,  0,
!						-leftWidth * 3,  py3 - EPS - gs_tw_bottom_out * bTrimovbotleftout, 7,
!						-leftWidth * 3, py2 + EPS, 2,
!						-leftWidth + widoLeftJamb + gs_trim_width_out + gs_trim_offs_out,  py2 + EPS,  4 * not(bTrimovbotleftout)

					cutpolya 4, 1, 0,
						-leftWidth + widoLeftJamb + gs_trim_width_out - gs_trim_offs_out,  0,  6,
						rightWidth - widoRightJamb - gs_trim_width_out - gs_trim_offs_out,  0,  7,
						rightWidth - widoRightJamb - gs_trim_width_out - gs_trim_offs_out, py2 + EPS, 4 + 2 * not(gs_stack_right),
						-leftWidth + widoLeftJamb + gs_trim_width_out - gs_trim_offs_out,  py2 + EPS,  2 * not(gs_stack_left)

					cutpolya 4, 1, 0,
						rightWidth - widoRightJamb - gs_trim_width_out - gs_trim_offs_out,  py3 - EPS - gs_tw_bottom_out * bTrimovbotrightout,  0,
						rightWidth * 3,  py3 - EPS - gs_tw_bottom_out * bTrimovbotrightout,  7,
						rightWidth * 3, py2 + EPS, 2,
						rightWidth - widoRightJamb - gs_trim_width_out - gs_trim_offs_out,  py2 + EPS,  4 * not(bTrimovbotrightout)
					del 2
				endif

				if gs_trimtype_out_int = CASING_NORMAL then				! Rectangular casing type
					bprism_ gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						8, signWallIsLeft * gs_trim_thk_out, rSill,
							px1, py1, s1,
							px2, py2, s2,
							px3, py3, s3,
							px4, py4, s4,
							px5, py5, s5,
							px6, py6, s6,
							px7, py7, s7,
							px8, py8, s8
				endif

				if gs_trimtype_out_int = CASING_OVERHANG then				! SWE traditional casing type
					bprism_ gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						10, signWallIsLeft * gs_trim_thk_out, rSill,
							px1, py1, s1,
							px1, py1-0.04, s1,
							px3 + (px1 - px3)/2, py2, s2,
							px3, py3, s3,
							px4, py4, s4,
							px5, py5, s5,
							px6, py6, s6,
							px6 + (px8 - px6)/2, py7, s7,
							px8, py8-0.04, s7,
							px8, py8, s8
				endif

				if bParalellInCurvedWalls then
!					cutend
					cutend
					cutend
				endif
			endif

			if	bShapeEnablesArchedTopTrim then

				resol WALL_RESOL


				if not(bParalellInCurvedWalls) then
					px = signWallIsLeft * (offsArc - rSill * alfaLeft * DegRad + widoLeftJamb)
					px1 = px + signWallIsLeft * (gs_trim_width_out - gs_trim_offs_out - gs_tw_left_out)
					px2 = px + signWallIsLeft * (gs_trim_width_out - gs_trim_offs_out)
					px = signWallIsLeft * (offsArc + rSill * alfaRight * DegRad - widoRightJamb)
					px3 = px + signWallIsLeft * (-gs_trim_width_out + gs_trim_offs_out)
					px4 = px + signWallIsLeft * (-gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out)
				else
					px2 = signWallIsLeft * (offsArc - rSill * alfaLeftParallelOut * DegRad + gs_trim_width_out - gs_trim_offs_out)
					px1 = signWallIsLeft * (offsArc - rSill * alfaLeftParallelOut * DegRad - gs_trim_offs_out) - signWallIsLeft * gs_tw_left_out
					px3 = signWallIsLeft * (offsArc + rSill * alfaRightParallelOut * DegRad - gs_trim_width_out + gs_trim_offs_out)
					px4 = signWallIsLeft * (offsArc + rSill * alfaRightParallelOut * DegRad + gs_trim_offs_out) + signWallIsLeft * gs_tw_right_out
				endif


				mulRatio = (leftWidth + rightWidth - tolerOffsetLeftIn - tolerOffsetRightIn) / (2 * abs(signWallIsLeft * rSill * alfaLeft * DegRad))
				addy B - archHeight - tolerOffsetUpperIn
				muly mulRatio

				if bHalfCircle then
					bprism_ gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						9, signWallIsLeft * gs_trim_thk_out, rSill,
						px1,	-EPS, 	   8 + 7 * gs_stack_left,	! 15 or 8
						px1,	0, 	   8 + 7 * gs_stack_left,		! 15 or 8
						px2,	0,	  62 + mask,
						0,		1,	 800,
						px3,	0,	1008 + 7 * gs_stack_right,		! 1015 or 1008
						px4,	-EPS,  8 + 7 * gs_stack_right,		! 15 or 8
						px4,	0,	  79,
						0,		1,	 800,
						px1,	0, 	1079
				else

					ta = (leftWidth + rightWidth) / 2 - gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out
					tc = arcR - gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out
					py1 = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

					ta = ta - gs_tw_right_out
					tc = tc - gs_tw_right_out
					py2 = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

					bprism_ gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						6, signWallIsLeft * gs_trim_thk_out, rSill,
						(px2 + px3) / 2,		(archHeight - arcR) / mulRatio, 900,
						px2,	py2, 	   8 + 7 * gs_stack_left,	! 15 or 8
						px1,	py1,	  79,
						px4,	py1,	3010 + 5 * gs_stack_right,	! 15 or 8
						px3,	py2,	  62 + mask,
						px2,	py2, 	3015
				endif

				del 2
			endif

			if iWindowShape = SHAPE_ELLIPSEARCH then

				offs = (leftWidth + overSizeLeftOut - (rSill * alfaLeft * DegRad))
				if wallIsLeft then
					s3 = 12 + 1 * (abs(gs_trim_offs_out) > EPS | not(gs_trim_show_cover_out) | abs(gs_trim_thk_out) < EPS) - 2 * gs_stack_right
				else
					s3 = 9 + 4 * (abs(gs_trim_offs_out) > EPS | not(gs_trim_show_cover_out) | abs(gs_trim_thk_out) < EPS) - 2 * gs_stack_right
				endif
				mulRatio = (archHeight / (archHeight + overSizeLeftOut - offs))

				addy B - tolerOffsetUpper + ((archHeight * mulRatio) - archHeight)
				muly mulRatio
				offs = (leftWidth + overSizeLeftOut - (rSill * alfaLeft * DegRad + gs_trim_offs_out - gs_trim_width_out))

				bprism_ gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
					13, signWallIsLeft * gs_trim_thk_out, rSill,
					signWallIsLeft * offsArc + leftWidth + overSizeLeftOut - offs - widoLeftJamb,						-archHeight,		s3,
					signWallIsLeft * offsArc + leftWidth - smallRadiusEllips,											-archHeight,		900+s3,
					0,		 																							 alphaSide,		4000+s3,
					signWallIsLeft * offsArc - (leftWidth - rightWidth)/2,												-middleRadiusEllips, 	900+s3,
					0,		 																							 alphaMiddle,		4000+s3,
					signWallIsLeft * offsArc - rightWidth + smallRadiusEllips, 											-archHeight,		900+s3,
					0,		 																							 alphaSide,		4008,
					signWallIsLeft * offsArc - rightWidth - overSizeLeftOut + widoRightJamb + offs - gs_tw_left_out,	-archHeight,		79,
					0,		 																							-alphaSide,		4079,
					signWallIsLeft * offsArc - (leftWidth - rightWidth)/2,												-middleRadiusEllips, 	979,
					0,		 																							-alphaMiddle,		4079,
					signWallIsLeft * offsArc + leftWidth - smallRadiusEllips,											-archHeight,		979,
					0,		 																							-alphaSide,		4008

				del 2
			endif
			gosub "TextCoord_Hor"


			! ===== Outside Trim - Curved Walls - Casing - Sides =====

			if	isWindow | \
				bTShapedOpening then
				py = -overSizeBottomLeft + not(gs_stack_bottom) * widoThresDepth + gs_trim_offs_out_bottom

				s3 = maskBottom						! 15 or 10 or 8
				if not(bParalellInCurvedWalls) then
					s4 = 13 + 2 * (not(gs_stack_bottom)) 	! 15 or 13
				else
					s4 = 13 + 2 * (not(gs_stack_bottom)) * bDrawSill
				endif
			else
				py	= -overSizeBottomLeft + bDrawSill * widoThresDepth
				py3 = -overSizeBottomLeft + bDrawSill * widoThresDepth
				py4 = -overSizeBottomLeft + bDrawSill * widoThresDepth

				s3 = 15
				s4 = 15
			endif
			py3l = py
			py4l = py

			! --- Draw left side Trim ---

			if not(bParalellInCurvedWalls) then
				px2 = signWallIsLeft * (offsArc - rSill * alfaLeft * DegRad + gs_trim_width_out - gs_trim_offs_out + widoLeftJamb)
				px1 = px2 - signWallIsLeft * gs_tw_left_out
			else
				px2 = signWallIsLeft * (offsArc - rSill * alfaLeftParallelOut * DegRad + gs_trim_width_out - gs_trim_offs_out)
				px1 = signWallIsLeft * (offsArc - rSill * alfaLeftParallelOut * DegRad - gs_trim_offs_out) - signWallIsLeft * gs_tw_left_out
			endif


!			if	(isWindow | \
!				(bPShapedLeftOpening & gs_trim_below_sillLeft)) & ABS(gs_trimov_bot_left_out) < EPS then
!				py3l = py + not(gs_stack_bottom | not(bCasingBottomOutside) | (bDrawLeftSLSill & not(gs_trim_below_sillLeft))) * (gs_trim_width_out - gs_trim_offs_out)
!				py4l = py + not(gs_stack_bottom | not(bCasingBottomOutside) | (bDrawLeftSLSill & not(gs_trim_below_sillLeft))) * (gs_trim_width_out - gs_trim_offs_out - gs_tw_bottom_out)
!			endif

			if gs_stack_bottom then
				py3l = -overSizeBottom
				py4l = py3l
				py5 = py3l
				py6 = py3l
			else
				if not(bCasingBottomOutside) then
					py3l = py
					py4l = py3l
					py5 = py3l
					py6 = py3l
				else
					if	isWindow | \
						(bPShapedLeftOpening & gs_trim_below_sillLeft) then
						py3l = py \
								+ gs_trim_width_out * not(bDrawLeftSLSill) \
								- gs_trim_offs_out * not(gs_trim_atframe_out) * not(bDrawLeftSLSill) \
								- gs_tw_bottom_out * bTrimovbotleftout \
								- gs_trimov_bot_left_out

						if not(gs_trim_atframe_out) then
							py4l = py \
									+ gs_trim_width_out * not(bDrawLeftSLSill) \
									- gs_trim_offs_out * not(gs_trim_atframe_out) * not(bDrawLeftSLSill) \
									- gs_tw_bottom_out * (not(bDrawLeftSLSill) | (bDrawLeftSLSill & (bTrimovbotleftout | gs_trim_below_sillLeft))) \
									- gs_trimov_bot_left_out

						else
							py4l = py3l - (gs_trimov_bot_left_out + gs_tw_bottom_out * (bTrimovbotleftout=0) * gs_trimb_atframe_out * not(bDrawLeftSLSill))
						endif
					endif

					py5 = py3l + (gs_trimov_bot_left_out + gs_tw_bottom_out) * bTrimovbotleftout
					py6 = py3l + gs_trimov_bot_left_out * bTrimovbotleftout
				endif
			endif

			if	bPShapedLeftOpening then
				py3l = py3l + gs_sidelight_parapet_hgt_left + gs_reveal_bottom_sL - gs_reveal_bottom
				py4l = py4l + gs_sidelight_parapet_hgt_left + gs_reveal_bottom_sL - gs_reveal_bottom
				py5 = py5 + gs_sidelight_parapet_hgt_left + gs_reveal_bottom_sL - gs_reveal_bottom
				py6 = py6 + gs_sidelight_parapet_hgt_left + gs_reveal_bottom_sL - gs_reveal_bottom
			endif

			if	bShapeEnablesStraightTopTrim then
				py2 = B + overSizeTop + not(gs_stack_top) * (-widoHeadDepth - tolerOffsetUpperOut - gs_trim_width_out + gs_trim_offs_out)
				if not(bParalellInCurvedWalls) then
					py1 = B + overSizeTop + not(gs_stack_top) * (-widoHeadDepth - gs_trim_width_out + gs_trim_offs_out + gs_tw_top_out*not(bTrimovtoprightout))
				else
					py1 = py2
				endif


				if	isWindow | \
					(bPShapedLeftOpening & gs_trim_below_sillLeft) then
					s6 = maskBottom*not(bTrimovbotleftout)+(15-2*not(gs_tw_bottom_out))*bTrimovbotleftout
					if not(gs_stack_bottom) & not(bCasingBottomOutside) then
						s3 = 15
					else
						s3 = (maskBottom+5*not(gs_tw_bottom_out))*not(bTrimovbotleftout)+bTrimovbotleftout*(15-7*gs_stack_bottom)
					endif
				else
					s6 = 15
					s3 = 15
				endif

				s1 = maskTop				! 15 or 10 or 8
				s2 = bitset (mask, 1, not(gs_stack_top))
				s5 = 8
			endif
			if	bShapeEnablesArchedTopTrim then
				ta = leftWidth - gs_trim_width_out + gs_trim_offs_out
				tc = arcR + tolerOffsetUpperIn - gs_trim_width_out + gs_trim_offs_out
				py2 = B - arcR - tolerOffsetUpperIn + sqr(max(0, (tc * tc - ta * ta)))


				ta = ta + gs_tw_right_out
				tc = tc + gs_tw_right_out
				py1 = B - arcR - tolerOffsetUpperIn + sqr(max(0, (tc * tc - ta * ta)))


				if	isWindow | \
					(bPShapedLeftOpening & gs_trim_below_sillLeft) then
					s6 = maskBottom*not(bTrimovbotleftout)+(15-2*not(gs_tw_bottom_out))*bTrimovbotleftout
					if not(gs_stack_bottom) & not(bCasingBottomOutside) then
						s3 = 15
					else
						s3 = (maskBottom+5*not(gs_tw_bottom_out))*not(bTrimovbotleftout)+bTrimovbotleftout*(15-7*gs_stack_bottom)
					endif
				else
					s6 = 15
					s3 = 15
				endif

				s1 = 8
				s2 = mask - 2
				s5 = 8
			endif

			if iWindowShape = SHAPE_ELLIPSEARCH then
				py1 = B - archHeight - tolerOffsetUpper
				py2 = B - archHeight - tolerOffsetUpper

				s1 = 8
				s2 = mask - 2
			endif

			if gs_stack_left then
				px1LUp = px2 - gs_trim_width_out + gs_trim_offs_out
				px2LUp = px1LUp
			else
				px1LUp = px1 * not(bTrimovbotleftout) + px2 * bTrimovbotleftout
				px2LUp = px2
			endif

			if not(gs_stack_left | bLeftCornerFunction) then
				if bParalellInCurvedWalls then
					add 0, 0, -rSill
					roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

					cutpolya 6, 1, 0,
						leftRevealPnts[idxSillStartRevealLeft][1] + tolerOffsetLeftOut + gs_trim_width_out - gs_trim_offs_out,  py5,  2,
						leftRevealPnts[idxSillStartRevealLeft][1] + tolerOffsetLeftOut + gs_trim_width_out - gs_trim_offs_out,  py6,  7,
						leftRevealPnts[idxSillStartRevealLeft][1] + tolerOffsetLeftOut + gs_trim_width_out - gs_trim_offs_out,  -overSizeBottom - (gs_trimov_bot_left_out + gs_tw_bottom_out),  7,
						rightRevealPnts[idxSillStartRevealRight][1], -overSizeBottom - (gs_trimov_bot_left_out + gs_tw_bottom_out),  7,
						rightRevealPnts[idxSillStartRevealRight][1], B + overSizeTop - widoHeadDepth, 4,
						leftRevealPnts[idxSillStartRevealLeft][1] + tolerOffsetLeftOut + gs_trim_width_out - gs_trim_offs_out,  B + overSizeTop - widoHeadDepth,  1
					del 2
				endif

				body -1
				bprism_ gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
					4+2, signWallIsLeft * gs_trim_thk_out, rSill,
					px1,	py1,	s1,
					px2,	py2,	s2,
					px2,	py5,	s5,
					px2,	py6,	s6,
					px2,	py3l,	s3,
					px1,	py4l,	s4
				gosub "TextCoord_Vert"

				if bParalellInCurvedWalls then
					cutend
				endif
			endif

			! --- Draw right side Trim ---

			if	isWindow | \
				bTShapedOpening then
				py = -overSizeBottomRight + not(gs_stack_bottom) * widoThresDepth + gs_trim_offs_out_bottom
			else
				py	= -overSizeBottomRight + bDrawSill * widoThresDepth
				py3 = -overSizeBottomRight + bDrawSill * widoThresDepth
				py4 = -overSizeBottomRight + bDrawSill * widoThresDepth
			endif
			py3r = py
			py4r = py

			if not(bParalellInCurvedWalls) then
				px2 = signWallIsLeft * (offsArc + rSill * alfaRight * DegRad - gs_trim_width_out + gs_trim_offs_out - widoRightJamb)
				px1 = px2 + signWallIsLeft * gs_tw_right_out
			else
				px2 = signWallIsLeft * (offsArc + rSill * alfaRightParallelOut * DegRad - gs_trim_width_out + gs_trim_offs_out)
				px1 = signWallIsLeft * (offsArc + rSill * alfaRightParallelOut * DegRad + gs_trim_offs_out) + signWallIsLeft * gs_tw_right_out
			endif

!!			if	(isWindow | \
!!				(bPShapedRightOpening & gs_trim_below_sillRight)) & ABS(gs_trimov_bot_right_out) < EPS then
!!				py3r = py + not(gs_stack_bottom | not(bCasingBottomOutside) | (bDrawRightSLSill & not(gs_trim_below_sillRight))) * (gs_trim_width_out - gs_trim_offs_out)
!!				py4r = py + not(gs_stack_bottom | not(bCasingBottomOutside) | (bDrawRightSLSill & not(gs_trim_below_sillRight))) * (gs_trim_width_out - gs_trim_offs_out - gs_tw_bottom_out)
!!			endif

			if gs_stack_bottom then
				py3r = -overSizeBottom
				py4r = py3r
				py5 = py3r
				py6 = py3r
			else
				if not(bCasingBottomOutside) then
					py3r = py
					py4r = py3r
					py5 = py3r
					py6 = py3r
				else
					if	isWindow | \
						(bPShapedRightOpening & gs_trim_below_sillRight) then
						py3r = py \
								+ gs_trim_width_out * not(bDrawRightSLSill) \
								- gs_trim_offs_out * not(gs_trim_atframe_out) * not(bDrawRightSLSill) \
								- gs_tw_bottom_out * bTrimovbotrightout \
								- gs_trimov_bot_right_out
						if not(gs_trim_atframe_out) then
							py4r = py \
									+ gs_trim_width_out * not(bDrawRightSLSill) \
									- gs_trim_offs_out * not(gs_trim_atframe_out) * not(bDrawRightSLSill) \
									- gs_tw_bottom_out*(not(bDrawRightSLSill) | (bDrawRightSLSill & (bTrimovbotrightout | gs_trim_below_sillRight))) \
									- gs_trimov_bot_right_out
						else
							py4r = py3r - (gs_trimov_bot_left_out + gs_tw_bottom_out * (bTrimovbotleftout=0) * gs_trimb_atframe_out * not(bDrawRightSLSill))
						endif
					endif

					py5 = py3r + (gs_trimov_bot_right_out + gs_tw_bottom_out) * bTrimovbotrightout
					py6 = py3r + gs_trimov_bot_right_out * bTrimovbotrightout
				endif
			endif

			if	bPShapedRightOpening then
				py3r = py3r + gs_sidelight_parapet_hgt_right + gs_reveal_bottom_sR - gs_reveal_bottom
				py4r = py4r + gs_sidelight_parapet_hgt_right + gs_reveal_bottom_sR - gs_reveal_bottom
				py5 = py5 + gs_sidelight_parapet_hgt_right + gs_reveal_bottom_sR - gs_reveal_bottom
				py6 = py6 + gs_sidelight_parapet_hgt_right + gs_reveal_bottom_sR - gs_reveal_bottom
			endif

			if	bShapeEnablesStraightTopTrim then
				py2 = B + overSizeTop + not(gs_stack_top) * (-widoHeadDepth - tolerOffsetUpperOut - gs_trim_width_out + gs_trim_offs_out)
				if not(bParalellInCurvedWalls) then
					py1 = B + overSizeTop + not(gs_stack_top) * (-widoHeadDepth - gs_trim_width_out + gs_trim_offs_out + gs_tw_top_out * not(bTrimovtoprightout))
				else
					py1 = py2
				endif

				if	isWindow | \
					(bPShapedRightOpening & gs_trim_below_sillRight) then
					s6 = maskBottom*not(bTrimovbotrightout)+(15-2*not(gs_tw_bottom_out))*bTrimovbotrightout
					if not(gs_stack_bottom) & not(bCasingBottomOutside) then
						s3 = 15
					else
						s3 = (maskBottom+5*not(gs_tw_bottom_out))*not(bTrimovbotrightout)+bTrimovbotrightout*(15-7*gs_stack_bottom)
					endif
				else
					s6 = 15
					s3 = 15
				endif

				s1 = maskTop				! 15 or 10 or 8
				s2 = bitset (mask, 1, not(gs_stack_top))
				s5 = 8
			endif
			if	bShapeEnablesArchedTopTrim then
				ta = rightWidth - gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out
				tc = arcR + tolerOffsetUpperIn - gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out
				py1 = B - arcR - tolerOffsetUpperIn + sqr(max(0, (tc * tc - ta * ta)))


				ta = ta - gs_tw_right_out
				tc = tc - gs_tw_right_out
				py2 = B - arcR - tolerOffsetUpperIn + sqr(max(0, (tc * tc - ta * ta)))


				if	isWindow | \
					(bPShapedRightOpening & gs_trim_below_sillRight) then
					s6 = maskBottom*not(bTrimovbotrightout)+(15-2*not(gs_tw_bottom_out))*bTrimovbotrightout
					if not(gs_stack_bottom) & not(bCasingBottomOutside) then
						s3 = 15
					else
						s3 = (maskBottom+5*not(gs_tw_bottom_out))*not(bTrimovbotrightout)+bTrimovbotrightout*(15-7*gs_stack_bottom)
					endif
				else
					s6 = 15
					s3 = 15
				endif

				s1 = 8
				s2 = mask - 2
				s5 = 8
			endif

			if iWindowShape = SHAPE_ELLIPSEARCH then
				py1 = B - archHeight - tolerOffsetUpper
				py2 = B - archHeight - tolerOffsetUpper

				s1 = 8
				s2 = mask - 2
			endif

			if gs_stack_right then
				px1RUp = px2 + gs_trim_width_out - gs_trim_offs_out
				px2RUp = px1RUp
			else
				px1RUp = px1 * not(bTrimovbotrightout) + px2 * bTrimovbotrightout
				px2RUp = px2
			endif

			if not(gs_stack_right | bRightCornerFunction) then
				if bParalellInCurvedWalls then
					add 0, 0, -rSill
					roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

					cutpolya 6, 1, 0,
						rightRevealPnts[idxSillStartRevealRight][1] - tolerOffsetRightOut - gs_trim_width_out + gs_trim_offs_out,  py5,  2,
						rightRevealPnts[idxSillStartRevealRight][1] - tolerOffsetRightOut - gs_trim_width_out + gs_trim_offs_out,  py6,  7,
						rightRevealPnts[idxSillStartRevealRight][1] - tolerOffsetRightOut - gs_trim_width_out + gs_trim_offs_out,  -overSizeBottom - (gs_trimov_bot_right_out + gs_tw_bottom_out),  7,
						leftRevealPnts[idxSillStartRevealLeft][1], -overSizeBottom - (gs_trimov_bot_right_out + gs_tw_bottom_out),  7,
						leftRevealPnts[idxSillStartRevealLeft][1], B + overSizeTop - widoHeadDepth, 4,
						rightRevealPnts[idxSillStartRevealRight][1] - tolerOffsetRightOut - gs_trim_width_out + gs_trim_offs_out,  B + overSizeTop - widoHeadDepth,  1
					del 2
				endif

				body -1
				bprism_ gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
					4+2, signWallIsLeft * gs_trim_thk_out, rSill,
					px1,	py1,	s1,
					px2,	py2,	s2,
					px2,	py5,	s5,
					px2,	py6,	s6,
					px2,	py3r,	s3,
					px1,	py4r,	s4
				gosub "TextCoord_Vert"

				if bParalellInCurvedWalls then
					cutend
				endif
			endif


			if	bTShapedOpening then

				py1 = widoThresDepth
				py2 = widoThresDepth

				px1l = 0
				px2l = 0
				if bPShapedLeftOpening then
					px1l = signWallIsLeft * (offsArc + rSill * alfaLeftLSL * DegRad + gs_trim_thk_out)							!gs_trim_thk_out is a safety
					px2l = px1l - signWallIsLeft * gs_trim_below_sillLeft * gs_tw_left_out - signWallIsLeft * gs_trim_thk_out	!gs_trim_thk_out is a safety

					py3l = py4l + gs_trimov_bot_left_out
					py4l = py3l + gs_tw_bottom_out
				endif
				px1r = 0
				px2r = 0
				if bPShapedRightOpening then
					px1r = signWallIsLeft * (offsArc + rSill * alfaRightRSL * DegRad - gs_trim_thk_out)							!gs_trim_thk_out is a safety
					px2r = px1r + signWallIsLeft * gs_trim_below_sillRight * gs_tw_right_out + signWallIsLeft * gs_trim_thk_out	!gs_trim_thk_out is a safety
					py3r = py4r + gs_trimov_bot_right_out
					py4r = py3r + gs_tw_bottom_out
				endif

				add 0, -gs_tw_bottom_out, -rSill
				roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180


!					prism_ 4,7,
!						-leftWidth + gs_reveal_left_sL + gs_sidelight_WHole_width_left + gs_trim_width_out - gs_trim_offs_out,  py1,  15,
!						rightWidth - gs_reveal_right_sR - gs_sidelight_WHole_width_right - gs_trim_width_out + gs_trim_offs_out,  py1,  (11 + 4 * (gs_trim_offs_out > EPS))*WIDO_REVEAL_SIDE + (14 + (gs_trim_offs_out > EPS))*not(WIDO_REVEAL_SIDE),
!						rightWidth - gs_reveal_right_sR - gs_sidelight_WHole_width_right - gs_trim_width_out + gs_trim_offs_out,  MAX(py4l, py4r) + gs_tw_bottom_out,  15,
!						-leftWidth + gs_reveal_left_sL + gs_sidelight_WHole_width_left + gs_trim_width_out - gs_trim_offs_out, MAX(py4l, py4r) + gs_tw_bottom_out,  (11 + 4 * (gs_trim_offs_out > EPS))*WIDO_REVEAL_SIDE + (14 + (gs_trim_offs_out > EPS))*not(WIDO_REVEAL_SIDE)

				cutpolya 4, 1, 0,
					-leftWidth + gs_reveal_left_sL + gs_sidelight_WHole_width_left + gs_trim_width_out - gs_trim_offs_out,  py1,  15,
					rightWidth - gs_reveal_right_sR - gs_sidelight_WHole_width_right - gs_trim_width_out + gs_trim_offs_out,  py1,  (11 + 4 * (gs_trim_offs_out > EPS))*WIDO_REVEAL_SIDE + (14 + (gs_trim_offs_out > EPS))*not(WIDO_REVEAL_SIDE),
					rightWidth - gs_reveal_right_sR - gs_sidelight_WHole_width_right - gs_trim_width_out + gs_trim_offs_out,  MAX(py4l, py4r) + gs_tw_bottom_out,  15,
					-leftWidth + gs_reveal_left_sL + gs_sidelight_WHole_width_left + gs_trim_width_out - gs_trim_offs_out, MAX(py4l, py4r) + gs_tw_bottom_out,  (11 + 4 * (gs_trim_offs_out > EPS))*WIDO_REVEAL_SIDE + (14 + (gs_trim_offs_out > EPS))*not(WIDO_REVEAL_SIDE)


				del 2

				if bPShapedLeftOpening & gs_trim_below_sillLeft then
					! --- Draw Door's Left side Trim  Curved Wall---
					bprism_ gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						4, signWallIsLeft * gs_trim_thk_out, rSill,
						px1l,	py1,	15,
						px2l,	py2,	s4,
						px2l,	py3l,	s5,
						px1l,	py4l,	s2
					gosub "TextCoord_Vert"
				endif
				if bPShapedRightOpening & gs_trim_below_sillRight then
					! --- Draw Door's Right side Trim  Curved Wall---
					bprism_ gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						4, signWallIsLeft * gs_trim_thk_out, rSill,
						px1r,	py1,	15,
						px2r,	py2,	s4,
						px2r,	py3r,	s5,
						px1r,	py4r,	s2
					gosub "TextCoord_Vert"
				endif

				if bPShapedLeftOpening & gs_trim_below_sillLeft then
					! --- Draw Left lower Trim  Curved Wall---
					bprism_ gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						4, signWallIsLeft * gs_trim_thk_out, rSill,
						px2LUp,	py4l,	10 - 2 * gs_stack_left,
						px1LUp,	py3l,	15,
						px2l,	py3l,	10 + 5 * not(gs_trim_below_sillLeft),
						px1l,	py4l,	mask - 2 * gs_stack_left
					gosub "TextCoord_Hor"
				endif

				if bPShapedRightOpening & gs_trim_below_sillRight then
					! --- Draw Right lower Trim  Curved Wall---
					bprism_ gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						4, signWallIsLeft * gs_trim_thk_out, rSill,
						px2RUp,	py4r,	10 - 2 * gs_stack_right,
						px1RUp,	py3r,	15,
						px2r,	py3r,	10 + 5 * not(gs_trim_below_sillRight),
						px1r,	py4r,	mask - 2 * gs_stack_right
					gosub "TextCoord_Hor"
				endif

				cutend
			endif

			del 4
		endif

	endif	! not(curvedWall)

	! ===== Outside Trim - Curved Walls - Casing - Bottom Side =====
	if curvedWall  & (gs_trimtype_out_int <> CASING_COMPLEX) then
		resol WALL_RESOL

		offsArc = iHolePosSign * AC_Hole_Position_Angle / 180 * PI * rSill

		if gs_IsCurved then
			thk = WIDO_SILL + gs_trim_jambext_nosing_out
		else
			thk = WALL_THICKNESS + gs_trim_jambext_nosing_out
			rotx -180
			cutplane 180
			del 1
			numCutsFrame = 1
		endif


		if numCutsFrame then
			cutend
			numCutsFrame = 0
		endif

		if not(gs_stack_left) then
			alfaLeftParallelOut = abs (asn ( (leftRevealPnts[idxSillStartRevealLeft][1] + tolerOffsetLeftOut + gs_trim_width_out) / rSill))
		else
			alfaLeftParallelOut = alfaLeft
		endif
		if not(gs_stack_right) then
			alfaRightParallelOut = abs (asn ( (rightRevealPnts[idxSillStartRevealRight][1] - tolerOffsetRightOut - gs_trim_width_out) / rSill))
		else
			alfaRightParallelOut = alfaRight
		endif

		if gs_trim_thk_out > EPS & gs_trim_show_cover_out then

			material gs_trim_out_mat
			sect_fill gs_trim_fill_out, gs_trim_pen_bg_out, gs_trim_pen_fg_out, gs_trim_pen_cont_out

			! ===== Outside Trim - Curved Walls - Casing =====

			if wallIsLeft then
				mask = 14 + (gs_trim_offs_out > EPS)
			else
				mask = 11 + 4 * (gs_trim_offs_out > EPS)
			endif

			maskTop		= 8 + 2 * not(gs_stack_top)
			maskBottom	= 8 + 2 * not(gs_stack_bottom)
			maskLeft	= 8 + (2 + 5 * bParalellInCurvedWalls) * not(gs_stack_left)
			maskRight	= 8 + 2 * not(gs_stack_right)

			maskLeft2	= bDrawSill*(not(bTrimovbotleftout)*(15-7*gs_stack_left)+bTrimovbotleftout*(10-2*gs_stack_left))
			maskRight2	= bDrawSill*(not(bTrimovbotrightout)*(15-7*gs_stack_right)+bTrimovbotrightout*(10-2*gs_stack_right))

			rotx -180
			addz -WOD
			bCondition = WIDO_REVEAL_SIDE exor SYMB_MIRRORED
			roty (not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) + not(wallIsLeft) * 180
			addz rSill


			! ===== Outside Trim - Curved Walls - Casing - Top and Bottom Sides =====

			if not(gs_stack_bottom | not(bCasingBottomOutside) | not(isWindow)) & abs(gs_tw_bottom_out) > EPS & not(gs_trimb_atframe_out) then
				! --- Draw lower Trim ---

				if not(bParalellInCurvedWalls) then
					px1 = signWallIsLeft * (offsArc - rSill * alfaLeft * DegRad + widoLeftJamb + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out - gs_tw_left_out*not(bTrimovbotleftout)))
					px2 = px1
					px3 = signWallIsLeft * (offsArc - rSill * alfaLeft * DegRad + widoLeftJamb + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out))
					px4 = signWallIsLeft * (offsArc + rSill * alfaRight * DegRad - widoRightJamb + not(gs_stack_right) * (-gs_trim_width_out + gs_trim_offs_out))
					px5 = signWallIsLeft * (offsArc + rSill * alfaRight * DegRad - widoRightJamb + not(gs_stack_right) * (-gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out*not(bTrimovbotrightout)))
					px6 = px5

					py1 = -overSizeBottom + not(gs_stack_bottom | not(bCasingBottomOutside)) * (widoThresDepth + gs_trim_width_out*not(bDrawSill) - gs_trim_offs_out * not(bDrawSill) - gs_tw_bottom_out)
					py2 = py1 + gs_tw_bottom_out * (bDrawSill & not(bCasingBottomOutside))
					py3 = -overSizeBottom + not(gs_stack_bottom | not(bCasingBottomOutside)) * (widoThresDepth + gs_trim_width_out*not(bDrawSill) - gs_trim_offs_out * not(bDrawSill))
					py4 = py3
					py5 = py2
					py6 = py1

					s1 = maskLeft*not(bDrawSill)+maskLeft2*bDrawSill
					s2 = maskLeft
					s3 = bitset (mask, 1, not(gs_stack_left))
					s4 = maskRight
					s5 = maskRight*not(bDrawSill)+maskRight2*bDrawSill
					s6 = 13 + 2 * not(gs_stack_right)
				else
					px1 = signWallIsLeft * (offsArc - rSill * alfaLeftParallelOut * DegRad + not(gs_stack_left) * (gs_trim_width_out*0 - gs_trim_offs_out - gs_tw_left_out))
					px2 = px1
					px3 = signWallIsLeft * (offsArc - rSill * alfaLeftParallelOut * DegRad + not(gs_stack_left) * (gs_trim_width_out*0 - gs_trim_offs_out - gs_tw_left_out))
					px4 = signWallIsLeft * (offsArc + rSill * alfaRightParallelOut * DegRad + not(gs_stack_right) * (-gs_trim_width_out*0 + gs_trim_offs_out + gs_tw_right_out ))
					px5 = px4
					px6 = px5

					py1 = -overSizeBottom + not(gs_stack_bottom | not(bCasingBottomOutside)) * (widoThresDepth + gs_trim_width_out * (not(bDrawSill) & not(gs_trim_atframe_out)) - gs_tw_bottom_out)
					py2 = py1 + gs_tw_bottom_out * bDrawSill
					py3 = -overSizeBottom + not(gs_stack_bottom | not(bCasingBottomOutside)) * (widoThresDepth + gs_trim_width_out * (not(bDrawSill) & not(gs_trim_atframe_out))) + EPS
					py4 = py3 + EPS
					py5 = py2
					py6 = py1

					s1 = maskLeft * not(bDrawSill) + maskLeft2 * bDrawSill
					s2 = maskLeft
					s3 = bitset (mask, 1, not(gs_stack_left))
					s4 = 13	+ 2 * (bDrawSill | gs_trim_atframe_out) * not(gs_stack_right) - 5 * gs_stack_right
					s5 = maskRight * not(bDrawSill) + maskRight2 * bDrawSill
					s6 = 13 + 2 * not(gs_stack_right)
				endif

				if bParalellInCurvedWalls then
					addz -rSill
					roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

					maskOutCasatFrame = 0
					if gs_trim_atframe_out then maskOutCasatFrame = 15


					cutpolya 4, 1, 0,
						-leftWidth + widoLeftJamb + gs_trim_width_out + gs_trim_offs_out,  py3 - EPS - gs_tw_bottom_out * bTrimovbotleftout,  maskOutCasatFrame,
						-leftWidth * 3,  py3 - EPS - gs_tw_bottom_out * bTrimovbotleftout,  7,
						-leftWidth * 3, B + overSizeTop, 7,
						-leftWidth + widoLeftJamb + gs_trim_width_out + gs_trim_offs_out,  B + overSizeTop,  1 * not(bTrimovbotleftout) + bTrimovbotleftout * maskOutCasatFrame

					cutpolya 4, 1, 0,
						rightWidth - widoRightJamb - gs_trim_width_out - gs_trim_offs_out,  py3 - EPS - gs_tw_bottom_out * bTrimovbotrightout,  4 * gs_stack_right,
						rightWidth * 3,  py3 - EPS - gs_tw_bottom_out * bTrimovbotrightout,  7,
						rightWidth * 3, B + overSizeTop, 7,
						rightWidth - widoRightJamb - gs_trim_width_out - gs_trim_offs_out,  B + overSizeTop,  1 * not(bTrimovbotrightout) + bTrimovbotleftout * maskOutCasatFrame

					del 2
				endif

				if gs_fsill then
					addz -rSill
					roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180
					addz WOD
					cutplane gs_sill_angle - 90
					del 3
				endif

				bprism_ gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
					4+2, signWallIsLeft * gs_trim_thk_out, rSill,
						px1,	py1, 	s1,
						px2,	py2, 	s2,
						px3,	py3,	s3,
						px4,	py4,	s4,
						px5,	py5, 	s5,
						px6,	py6, 	s6
				gosub "TextCoord_Hor"

				if gs_fsill then cutend

				if bParalellInCurvedWalls then
					cutend
					cutend
				endif
			endif

			del 4
		endif
	endif


	! ===== Outside Trim on Wall Face at Complex Casing =====

	if (gs_trimtype_out_int = CASING_COMPLEX) & (gs_trim_thk_out > EPS) then

		material gs_trim_out_mat
		pen gs_frame_pen
		sect_fill gs_trim_fill_out, gs_trim_pen_bg_out, gs_trim_pen_fg_out, gs_trim_pen_cont_out

		rotx 180
		addz WIDO_SILL
		mulz -1

		_casingOverhangTopSideOut = gs_trimov_top_right_out

		_casingLeftPosX		= -leftWidth + gs_trim_width_out - gs_trim_offs_out + widoLeftJamb + tolerOffsetLeftOut
		_casingRightPosX 	= rightWidth - gs_trim_width_out + gs_trim_offs_out - widoRightJamb - tolerOffsetRightOut
		_casingTopPosY		= B + overSizeTop + not(gs_stack_top) * (-widoHeadDepth - tolerOffsetUpperOut - gs_trim_width_out + gs_trim_offs_out + gs_trim_offs_out_top)
		_trimThick	= gs_trim_thk_out

		! --- Architrave capital ---

		group "capital"

			if bArchitraveCapital & not(gs_stack_top) then

				if not(gs_stack_left | bLeftCornerFunction) then
					_trimWidth	= gs_tw_left_out

					add  _casingLeftPosX - gs_tw_left_out*not(_bArchitraveCapitalOnSide), _casingTopPosY + gs_tw_top_out - min(gs_trim_thk_out, (gs_tw_top_out)/8), -gs_trim_thk_out
					roty 90
					mulz -1
					gosub "architrave capital type"
					del 3
				endif

				if not(gs_stack_right | bRightCornerFunction) then
					_trimWidth	= gs_tw_right_out

					add  _casingRightPosX + gs_tw_right_out*not(_bArchitraveCapitalOnSide), _casingTopPosY + gs_tw_top_out - min(gs_trim_thk_out, (gs_tw_top_out)/8), -gs_trim_thk_out
					roty 90
					gosub "architrave capital type"
					del 2
				endif

			endif

		endgroup


		group "sidehead"

			! --- Draw upper Trim ---

			if not(gs_stack_top) then

				m1 = not(gs_stack_left)
				m2 = not(gs_stack_right)

				_casingHeadLeftPosX		= -leftWidth - overSizeLeft + widoLeftJamb + tolerOffsetLeftOut + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out - gs_tw_left_out - _casingOverhangTopSideOut)
				_casingHeadRightPosX 	= rightWidth + overSizeRight - widoRightJamb - tolerOffsetRightOut - not(gs_stack_right) * (gs_trim_width_out - gs_trim_offs_out - gs_tw_right_out - _casingOverhangTopSideOut)

				_trimWidth	= gs_tw_top_out
				_trimLength	= abs(_casingHeadLeftPosX - _casingHeadRightPosX)

				add  _casingHeadLeftPosX, _casingTopPosY, 0
				rotx -90
				roty 90

				gosub "casing head type"

				del 3
			endif


			addz -gs_trim_thk_out

			! Calculate status codes to left and right casing shape
			s1 = 8 + 7*not(gs_stack_top)
			s2 = 13 + 2*not(gs_stack_top)
			s3 = 8 + 7*not(gs_stack_bottom)
			s4 = 13 + 2*not(gs_stack_bottom)

			! --- Draw left side Trim ---

			if (isWindow | bPShapedLeftOpening) & not(gs_stack_bottom | not(bCasingBottomOutside)) then
				_casingLeftBottomPosY = -overSizeBottomLeft + widoThresDepth + gs_trim_width_out * not(bDrawLeftSLSill) - gs_trim_offs_out * not(gs_trim_atframe_out) * not(bDrawLeftSLSill)
			else
				_casingLeftBottomPosY = -overSizeBottomLeft
			endif

			if bPShapedLeftOpening then
				_casingLeftBottomPosY = _casingLeftBottomPosY + gs_sidelight_parapet_hgt_left + gs_reveal_bottom_sL - gs_reveal_bottom
			endif

			if not(gs_stack_left | bLeftCornerFunction) then
				body -1

				cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
					4, _trimThick,
					_casingLeftPosX,					_casingTopPosY,			0, s1, gs_trim_out_mat,
					_casingLeftPosX - gs_tw_left_out,	_casingTopPosY,			0, s2, gs_trim_out_mat,
					_casingLeftPosX - gs_tw_left_out,	_casingLeftBottomPosY,	0, s3, gs_trim_out_mat,
					_casingLeftPosX,					_casingLeftBottomPosY,	0, s4, gs_trim_out_mat
				gosub "TextCoord_Vert"

			endif


			! --- Draw right side Trim ---

			if (isWindow | bTShapedOpening) & not(gs_stack_bottom | not(bCasingBottomOutside)) then
				_casingRightBottomPosY	= -overSizeBottomRight + widoThresDepth + gs_trim_width_out * not(bDrawRightSLSill) - gs_trim_offs_out * not(gs_trim_atframe_out) * not(bDrawRightSLSill)
			else
				_casingRightBottomPosY	= -overSizeBottomRight
			endif

			if bPShapedRightOpening then
				_casingRightBottomPosY = _casingRightBottomPosY + gs_sidelight_parapet_hgt_right + gs_reveal_bottom_sL - gs_reveal_bottom
			endif

			if not(gs_stack_right | bRightCornerFunction) then
				body -1

				cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
					4, _trimThick,
					_casingRightPosX,					_casingTopPosY,			0, s1, gs_trim_out_mat,
					_casingRightPosX + gs_tw_right_out,	_casingTopPosY,			0, s2, gs_trim_out_mat,
					_casingRightPosX + gs_tw_right_out,	_casingRightBottomPosY,	0, s3, gs_trim_out_mat,
					_casingRightPosX,					_casingRightBottomPosY,	0, s4, gs_trim_out_mat
				gosub "TextCoord_Vert"

			endif

			del 1

		endgroup

		placegroup "sidehead"
		placegroup subgroup("capital", "sidehead")

		killgroup "sidehead"
		killgroup "capital"


		! --- T and P shape's extra casing pieces ---

		if bPShapedLeftOpening & gs_trim_below_sillLeft then
			_casingDoorLeftPosX 		= leftRevealPnts[idxSillStartRevealLeft][1] + gs_sidelight_WHole_width_left  + gs_trim_width_out - gs_trim_offs_out
			_casingDoorLeftTopPosY		= _casingLeftBottomPosY - gs_tw_bottom_out
			_casingDoorLeftBottomPosY	= _widoThresDepth
			_casingParapetLeftPosX		= -leftWidth - overSizeLeft + widoLeftJamb + tolerOffsetLeftOut + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out - gs_tw_left_out - casingOverhangBottomSideOut)

			! --- Draw Door's Left side Trim ---

			addz -gs_trim_thk_out

			body -1

			cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
				4, _trimThick,
				_casingDoorLeftPosX ,					_casingDoorLeftTopPosY,		0, 15, gs_trim_out_mat,
				_casingDoorLeftPosX - gs_tw_left_out,	_casingDoorLeftTopPosY,		0, 15, gs_trim_out_mat,
				_casingDoorLeftPosX - gs_tw_left_out,	_casingDoorLeftBottomPosY,	0, 15, gs_trim_out_mat,
				_casingDoorLeftPosX ,					_casingDoorLeftBottomPosY,	0, 15, gs_trim_out_mat
			gosub "TextCoord_Vert"

			del 1

			! --- Draw Left lower Trim in Straight Wall ---

			_trimWidth	= gs_tw_bottom_out
			_trimLength	= abs(_casingParapetLeftPosX - _casingDoorLeftPosX)

			add  _casingParapetLeftPosX, _casingLeftBottomPosY - _trimWidth, 0
			rotx -90
			roty 90

			m1 = not(gs_stack_left)
			m2 = 1

			gosub "casing head type"

			del 3

		endif


		if	bPShapedRightOpening & gs_trim_below_sillRight then
			_casingDoorRightPosX 		= rightRevealPnts[idxSillStartRevealRight][1] - gs_sidelight_WHole_width_right  - gs_trim_width_out + gs_trim_offs_out
			_casingDoorRightTopPosY		= _casingRightBottomPosY - gs_tw_bottom_out
			_casingDoorRightBottomPosY	= _widoThresDepth
			_casingParapetRightPosX		= rightWidth + overSizeRight - widoRightJamb - tolerOffsetRightOut - not(gs_stack_right) * (gs_trim_width_out - gs_trim_offs_out - gs_tw_right_out - casingOverhangBottomSideOut)

			! --- Draw Door's Right side Trim ---

			addz -gs_trim_thk_out

			body -1

			cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
				4, _trimThick,
				_casingDoorRightPosX,					_casingDoorRightTopPosY,	0, 15, gs_trim_out_mat,
				_casingDoorRightPosX + gs_tw_right_out,	_casingDoorRightTopPosY,	0, 15, gs_trim_out_mat,
				_casingDoorRightPosX + gs_tw_right_out,	_casingDoorRightBottomPosY,	0, 15, gs_trim_out_mat,
				_casingDoorRightPosX,					_casingDoorRightBottomPosY,	0, 15, gs_trim_out_mat
			gosub "TextCoord_Vert"

			del 1

			! --- Draw Right lower Trim in Straight Wall ---

			_trimWidth	= gs_tw_bottom_out
			_trimLength	= abs(_casingParapetRightPosX - _casingDoorRightPosX)

			add  _casingDoorRightPosX, _casingRightBottomPosY - _trimWidth, 0
			rotx -90
			roty 90

			m1 = 1
			m2 = not(gs_stack_right)

			gosub "casing head type"

			del 3

		endif


		! --- Draw lower Trim ---

		if not(gs_stack_bottom | not(bCasingBottomOutside) | not(isWindow)) then
			_casingHeadLeftPosX		= -leftWidth - overSizeLeft + widoLeftJamb + tolerOffsetLeftOut + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out - gs_tw_left_out - casingOverhangBottomSideOut)
			_casingHeadRightPosX 	= rightWidth + overSizeRight - widoRightJamb - tolerOffsetRightOut - not(gs_stack_right) * (gs_trim_width_out - gs_trim_offs_out - gs_tw_right_out - casingOverhangBottomSideOut)
			_casingBottomPosY		= -overSizeBottom + widoThresDepth + gs_trim_width_out*not(bDrawSill) - gs_trim_offs_out * not(gs_trim_atframe_out) * not(bDrawSill)

			_trimWidth	= gs_tw_bottom_out
			_trimLength	= abs(_casingHeadLeftPosX - _casingHeadRightPosX)

			add  _casingHeadLeftPosX, _casingBottomPosY - _trimWidth, 0
			rotx -90
			roty 90

			m1 = not(gs_stack_left)
			m2 = not(gs_stack_right)

			gosub "casing head type"

			del 3
		endif

		del 3
	endif


	! ===== Outside Trim at Ganging =====

	if bDrawLeftTrimatGangingOut then
		if isWindow then
			py = -overSizeBottom + not(gs_stack_bottom) * widoThresDepth

			s3 = maskBottom						! 15 or 10 or 8
			s4 = 13 + 2 * not(gs_stack_bottom)	! 15 or 13
		else
			py3 = -overSizeBottom
			py4 = -overSizeBottom

			s3 = 15
			s4 = 15
		endif

		! --- Draw left side Trim at Ganging ---

		px2 = leftRevealPnts[2][1] + tolerOffsStackCasLeftOut + trim_offs_out_modify - gs_trim_offs_out
		px1 = leftRevealPnts[2][1]
		px3 = leftRevealPnts[2][1] - gs_trim_thk_out * tan(alfaLeft)

		if iWindowShape = SHAPE_RECTANGULAR then
			py1 = B + overSizeTop + not(gs_stack_top) * (- tolerOffsetUpperOut - widoHeadDepth - gs_trim_width_out + gs_trim_offs_out)
			py2 = py1

			py = -overSizeBottom + not(gs_stack_bottom) * (widoThresDepth + gs_trim_offs_out_bottom)

			if bDrawSill then
				py3 = py + not(gs_stack_bottom) * (-gs_trim_offs_out_bottom * not(gs_trim_atframe_out))
			else
				py3 = py + not(gs_stack_bottom) * (gs_trim_width_out - gs_trim_offs_out * not(gs_trim_atframe_out))
			endif

			py4 = py3
			py5 = py2 - (tolerOffsStackCasUpperOut + trim_offs_out_modify - gs_trim_offs_out) * gs_trim_stack_top * gs_trim_stack_top
			py6 = py3 + (tolerOffsStackCasLowerOut + trim_offs_out_modify - gs_trim_offs_out) * gs_trim_stack_bottom * gs_trim_stack_bottom

			s1 = 8
			s2 = 8
			s5 = 13 + 2 * (gs_trim_stack_top | (not(gs_trim_stack_top) & not(gs_trim_atframe_out)))
			s3 = 8
			s4 = 8
			s6 = 8
		endif

		rotx 180
		mulz -1
		add 0, 0, -gs_trim_thk_out

		add px1, 0, gs_trim_thk_out
		roty - alfaLeft * ySign - 90
		cutplane 1, 1, 0
		del 2

		body -1

		prism_ 	6, gs_trim_thk_out,
			px3,	py1,	s1,
			px2,	py2,	s2,
			px2,	py5,	s5,
			px2,	py6,	s6,
			px2,	py3,	s3,
			px3,	py4,	s4
		gosub "TextCoord_Vert"

		cutend

		del 3
	endif

	if bDrawRightTrimatGangingOut then
		if isWindow then
			py = -overSizeBottom + not(gs_stack_bottom) * widoThresDepth

			s3 = maskBottom						! 15 or 10 or 8
			s4 = 13 + 2 * not(gs_stack_bottom)	! 15 or 13
		else
			py3 = -overSizeBottom
			py4 = -overSizeBottom

			s3 = 15
			s4 = 15
		endif

		! --- Draw right side Trim at Ganging ---

		px2 = rightRevealPnts[2][1] - tolerOffsStackCasRightOut - trim_offs_out_modify + gs_trim_offs_out
		px1 = rightRevealPnts[2][1]
		px3 = rightRevealPnts[2][1] + gs_trim_thk_out * tan(alfaright)

		if iWindowShape = SHAPE_RECTANGULAR then
			py1 = B + overSizeTop + not(gs_stack_top) * (- tolerOffsetUpperOut - widoHeadDepth - gs_trim_width_out + gs_trim_offs_out)
			py2 = py1

			py = -overSizeBottom + not(gs_stack_bottom) * (widoThresDepth + gs_trim_offs_out_bottom)

			if bDrawSill then
				py3 = py + not(gs_stack_bottom) * (-gs_trim_offs_out_bottom * not(gs_trim_atframe_out))
			else
				py3 = py + not(gs_stack_bottom) * (gs_trim_width_out - gs_trim_offs_out * not(gs_trim_atframe_out))
			endif

			py4 = py3
			py5 = py2 - (tolerOffsStackCasUpperOut + trim_offs_out_modify - gs_trim_offs_out) * gs_trim_stack_top * gs_trim_stack_top
			py6 = py3 + (tolerOffsStackCasLowerOut + trim_offs_out_modify - gs_trim_offs_out) * gs_trim_stack_bottom * gs_trim_stack_bottom


			s1 = 8
			s2 = 8
			s5 = 13 + 2 * (gs_trim_stack_top | (not(gs_trim_stack_top) & not(gs_trim_atframe_out)))
			s3 = 8
			s4 = 8
			s6 = 8
		endif

		rotx 180
		mulz -1
		add 0, 0, -gs_trim_thk_out

		add px1, 0, gs_trim_thk_out
		roty alfaright * ySign + 90
		cutplane 1, 1, 0
		del 2

		body -1

		prism_ 	6, gs_trim_thk_out,
			px3,	py1,	s1,
			px2,	py2,	s2,
			px2,	py5,	s5,
			px2,	py6,	s6,
			px2,	py3,	s3,
			px3,	py4,	s4
		gosub "TextCoord_Vert"

		cutend

		del 3
	endif


	if bDrawBottTrimatGangingOut then
		! --- Draw lower Trim at Ganging ---

		if gs_stack_left then
			px1 = -leftWidth + tolerOffsStackCasLeftOut + trim_offs_out_modify - gs_trim_offs_out
		else
			px1 = -leftWidth + gs_trim_width_out - gs_trim_offs_out + widoLeftJamb + tolerOffsetLeftOut
		endif

		if gs_stack_right then
			px2 = rightWidth - tolerOffsStackCasRightOut - trim_offs_out_modify + gs_trim_offs_out
		else
			px2 = rightWidth - gs_trim_width_out + gs_trim_offs_out - widoRightJamb - tolerOffsetRightOut
		endif

		py2 = -overSizeBottom
		py1 = py2 + tolerOffsStackCasLowerOut + trim_offs_out_modify - gs_trim_offs_out

		s1 = 15
		s2 = 10
		s3 = 8
		s4 = 8

		rotx 180
		mulz -1
		add 0, 0, -gs_trim_thk_out

		addz WIDO_SILL * (gs_trim_atframe_out = 0)

		prism_ 4, gs_trim_thk_out,
			px1,	py1, 	s1,
			px2,	py1, 	s2,
			px2,	py2,	s3,
			px1,	py2,	s4
		gosub "TextCoord_Hor"

		del 4
	endif

	if bDrawTopTrimatGangingOut then
		! --- Draw upper Trim at Ganging ---

		if gs_stack_left then
			px1 = -leftWidth + tolerOffsStackCasLeftOut + trim_offs_out_modify - gs_trim_offs_out
		else
			px1 = -leftWidth + gs_trim_width_out - gs_trim_offs_out + widoLeftJamb + tolerOffsetLeftOut
		endif

		if gs_stack_right then
			px2 = rightWidth - tolerOffsStackCasRightOut - trim_offs_out_modify + gs_trim_offs_out
		else
			px2 = rightWidth - gs_trim_width_out + gs_trim_offs_out - widoRightJamb - tolerOffsetRightOut
		endif

		py2 = B + overSizeTop
		py1 = py2 - tolerOffsStackCasUpperOut - trim_offs_out_modify + gs_trim_offs_out

		s1 = 15
		s2 = 10
		s3 = 8
		s4 = 8

		rotx 180
		mulz -1
		add 0, 0, -gs_trim_thk_out

		addz WIDO_SILL * (gs_trim_atframe_out = 0)

		prism_ 4, gs_trim_thk_out,
			px1,	py1, 	s1,
			px2,	py1, 	s2,
			px2,	py2,	s3,
			px1,	py2,	s4
		gosub "TextCoord_Hor"

		del 4
	endif

	for i=1 to numCutsCornerColumn
		cutend
	next i
return


3000:
! ==============================================================================
!	Draw Apron
! ==============================================================================

	pen gs_frame_pen

	rotx 180

	if not(curvedWall) then

		! ======================================
		! Straight Walls
		! ======================================

		addz (-WALL_THICKNESS + WIDO_SILL) * not(gs_trim_atframe_in) - WIDO_FRAME_THICKNESS * gs_trim_atframe_in

		thk = WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS
		wallIncl = iDir * WALL_INCL

		mask = 11 + 4 * (gs_trim_offs_in > EPS | not(bShowJambExtension) | abs(WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS) < EPS)

		if gs_trim_thk_in > EPS then

			material gs_apron_mat
			sect_fill gs_trim_fill_in, gs_trim_pen_bg_in, gs_trim_pen_fg_in, gs_trim_pen_cont_in

			! ===== Inside Trim - Straight Walls - Casing =====

			maskTop		= 8 + 2 * not(gs_stack_top)
			maskBottom	= 8 + 2 * not(gs_stack_bottom)
			maskLeft	= 8 + 2 * not(gs_stack_left) + 5 * (gs_trim_in_mat <> gs_apron_mat)
			maskRight	= 8 + 2 * not(gs_stack_right) + 5 * (gs_trim_in_mat <> gs_apron_mat)

			maskLeft2	= not(bTrimovbotleftin)*(15-7*gs_stack_left)+bTrimovbotleftin*(10-2*gs_stack_left + 5 * (gs_trim_in_mat <> gs_apron_mat) * not(gs_stack_left))
			maskRight2	= not(bTrimovbotrightin)*(15-7*gs_stack_right)+bTrimovbotrightin*(10-2*gs_stack_right + 5 * (gs_trim_in_mat <> gs_apron_mat) * not(gs_stack_right))

			! --- Stacked Window or Window with Board or Corner Window ---

			if bInclinedWall & not(gs_trim_atframe_in) then
				roty wallIncl
				addz -gs_trim_thk_in

				if not(gs_stack_bottom | not(isWindow)) & bShapeEnablesStraightBottomTrim & abs(gs_apron_width) > EPS then
					px2 = (gs_trim_width_in - gs_trim_offs_in) / cos(wallIncl)
					px1 = px2 - gs_tw_left_in * not(bTrimovbotleftin)
					px3 = -px2
					px4 = px3 + gs_tw_right_in * not(bTrimovbotrightin)

					py1 = -overSizeBottomIn + not(gs_stack_bottom) * ((gs_trim_width_in + tolerOffsetLowerIn - gs_trim_offs_in) * not(bDrawBoard) - gs_apron_width)
					py2 = -overSizeBottomIn + not(gs_stack_bottom) * ((gs_trim_width_in + tolerOffsetLowerIn - gs_trim_offs_in) * not(bDrawBoard))
					material gs_apron_mat

					if abs(gs_trim_thk_in - gs_apron_thk) < EPS then
						pxL = -(leftWidth - tolerOffsetLeftIn + overSizeLeft)  / cos(wallIncl) + bBottomtriminthk * tan(wallIncl)
						pxR =  (rightWidth - tolerOffsetRightIn + overSizeRight) / cos(wallIncl) + bBottomtriminthk * tan(wallIncl)

						croof_ gs_apron_mat, gs_apron_mat, gs_apron_mat,
							4+2, 0,0, 1,0, 0, 0, -bBottomtriminthk,
							pxL + not(gs_stack_left)  * px1,	py1, 	-gs_stack_left * wallIncl * not(bTrimovbotleftin),	maskLeft2,
							pxL + not(gs_stack_left)  * px1,	py1 + gs_apron_width, 	-wallIncl*(bTrimovbotleftin), maskLeft,						! 15 or 8
							pxL + not(gs_stack_left)  * px2,	py2,	0,	bitset (mask, 1, not(gs_stack_left)),
							pxR + not(gs_stack_right) * px3,	py2,	wallIncl * bTrimovbotrightin,	maskRight,				! 15 or 8
							pxR + not(gs_stack_right) * px4,	py1 + gs_apron_width, 	wallIncl*bTrimovbotrightin, maskRight2,
							pxR + not(gs_stack_right) * px4,	py1, 	0,	13 + 2 * not(gs_stack_right)	! 15 or 13

						lin_ pxL + not(gs_stack_left)  * px2, py2, 0, pxR + not(gs_stack_right) * px3,	py2, 0

					else
						pxL = -(leftWidth  - tolerOffsetLeftIn + overSizeLeft)  / cos(wallIncl) + (gs_trim_thk_in*not(bTrimovbotleftin)+bBottomtriminthk*bTrimovbotleftin) * tan(wallIncl)
						pxR =  (rightWidth - tolerOffsetRightIn + overSizeRight) / cos(wallIncl) + (gs_trim_thk_in*not(bTrimovbotrightin)+bBottomtriminthk*bTrimovbotrightin) * tan(wallIncl)

						addz (gs_trim_thk_in - gs_apron_thk)
						croof_ gs_apron_mat, gs_apron_mat, gs_apron_mat,
							4, 0,0, 1,0, 0, 0, -bBottomtriminthk,
							pxL + not(gs_stack_left)  * px1,	py1, 	-wallIncl*bTrimovbotleftin,	8 + 7 * not(gs_stack_left),
							pxL + not(gs_stack_left)  * px1,	py2, 	0, 13 + 2 * not(gs_stack_left),
							pxR + not(gs_stack_right) * px4,	py2, 	wallIncl*bTrimovbotrightin, 8 + 7 * not(gs_stack_right),
							pxR + not(gs_stack_right) * px4,	py1, 	0,	13 + 2 * not(gs_stack_right)
						del 1
					endif
					material gs_trim_in_mat
				endif

				del 2
			else		! Straight wall
				addz -gs_trim_thk_in

				if not(gs_stack_bottom | not(isWindow)) & bShapeEnablesStraightBottomTrim & abs(gs_apron_width) > EPS & not(bInclinedWall) then
					! --- Draw lower Trim/Apron in Straight Wall ---

					py1 = -overSizeBottomIn + not(gs_stack_bottom) * ((gs_trim_width_in + tolerOffsetLowerIn - gs_trim_offs_in * not(gs_trim_atframe_in)) * not(bDrawBoard) - gs_apron_width)
					py2 = -overSizeBottomIn + not(gs_stack_bottom) * ((gs_trim_width_in + tolerOffsetLowerIn - gs_trim_offs_in * not(gs_trim_atframe_in)) * not(bDrawBoard))

					px1 = -leftWidth + tolerOffsetLeftIn - overSizeLeft + not(gs_stack_left) * (gs_trim_width_in - gs_trim_offs_in - gs_tw_left_in*not(bTrimovbotleftin))
					px2 = -leftWidth + tolerOffsetLeftIn - overSizeLeft + not(gs_stack_left) * (gs_trim_width_in - gs_trim_offs_in)
					px3 =  rightWidth - tolerOffsetRightIn + overSizeRight + not(gs_stack_right) * (-gs_trim_width_in + gs_trim_offs_in)
					px4 =  rightWidth - tolerOffsetRightIn + overSizeRight + not(gs_stack_right) * (-gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in*not(bTrimovbotrightin))

					if bDrawLeftTrimatGangingIn then
						px2 = leftRevealPnts[2][1] + tolerOffsStackCasLeftIn + trinL - gs_trim_offs_in
					endif
					if bDrawRightTrimatGangingIn then
						px3 = rightRevealPnts[2][1] - tolerOffsStackCasRightIn - trinR + gs_trim_offs_in
					endif

					material gs_apron_mat

					addz (WIDO_FRAME_THICKNESS - WALL_THICKNESS + WIDO_SILL) * gs_trim_atframe_in

					if abs(gs_trim_thk_in - gs_apron_thk) < EPS then
						prism_ 4+2, bBottomtriminthk,
							px1,	py1,					maskLeft2,
							px1,	py1 + gs_apron_width, 	maskLeft,						! 15 or 8
							px2,	py2,					bitset (mask, 1, not(gs_stack_left)),
							px3,	py2,					maskRight,						! 15 or 8
							px4,	py1 + gs_apron_width, 	maskRight2,
							px4,	py1,					13 + 2 * not(gs_stack_right)	! 15 or 13
					else
						addz gs_trim_thk_in - gs_apron_thk
						prism_ 4, bBottomtriminthk,
							px1,	py1, 	8  + 7 * not(gs_stack_left),
							px1,	py2,	13 + 2 * not(gs_stack_left),
							px4,	py2,	8  + 7 * not(gs_stack_right),
							px4,	py1, 	13 + 2 * not(gs_stack_right)
						del 1
					endif

					if bCutWall then
						pen WALL_VIEW_PEN
						material matWallIn
						wallniche 4,1,16,
							0,0,1,bBottomtriminthk + (gs_trim_thk_in - gs_apron_thk),
							px1,	py1, 	31,
							px1,	py2,	31,
							px4,	py2,	31,
							px4,	py1, 	31
						pen gs_frame_pen
						material gs_trim_in_mat
					endif

					del 1
				endif

				if not(gs_stack_bottom | not(isWindow)) & bShapeEnablesStraightBottomTrim & abs(gs_apron_width) > EPS & bInclinedWall then
					! --- Draw Apron in Inclined Wall ---

					px2 = (gs_trim_width_in - gs_trim_offs_in) / cos(wallIncl)
					px1 = px2 - gs_tw_left_in * not(bTrimovbotleftin)
					px3 = -px2
					px4 = px3 + gs_tw_right_in * not(bTrimovbotrightin)
					pxL = -(leftWidth  + overSizeLeft)  / cos(wallIncl) + bBottomtriminthk * tan(wallIncl)
					pxR =  (rightWidth + overSizeRight) / cos(wallIncl) + bBottomtriminthk * tan(wallIncl)

					py1 = -overSizeBottomIn + not(gs_stack_bottom) * (gs_trim_width_in - gs_trim_offs_in * not(gs_trim_atframe_in)) * not(bDrawBoard) - gs_apron_width
					py2 = -overSizeBottomIn + not(gs_stack_bottom) * (gs_trim_width_in - gs_trim_offs_in * not(gs_trim_atframe_in)) * not(bDrawBoard)

					material gs_apron_mat

					addz (WIDO_FRAME_THICKNESS - WALL_THICKNESS + WIDO_SILL) * gs_trim_atframe_in + gs_trim_thk_in
					roty wallIncl
					addz -gs_trim_thk_in

					if abs(gs_trim_thk_in - gs_apron_thk) < EPS then
						croof_ bBottomtriminmat, bBottomtriminmat, bBottomtriminmat,
							4+2, 0,0, 1,0, 0, 0, -bBottomtriminthk,
							pxL + not(gs_stack_left)  * px1,	py1, 	-gs_stack_left * wallIncl*not(bTrimovbotleftin),	maskLeft*not(bDrawBoard)+maskLeft2*bDrawBoard,
							pxL + not(gs_stack_left)  * px1,	py1 + gs_apron_width*bDrawBoard, 	-wallIncl*(bTrimovbotleftin), maskLeft,						! 15 or 8
							pxL + not(gs_stack_left)  * px2,	py2,				0,				bitset (mask, 1, not(gs_stack_left)),
							pxR + not(gs_stack_right) * px3,	py2,				gs_stack_right * wallIncl*not(bTrimovbotrightin),	maskRight,				! 15 or 8
							pxR + not(gs_stack_right) * px4,	py1 + gs_apron_width*bDrawBoard, 	wallIncl*bTrimovbotrightin, maskRight*not(bDrawBoard)+maskRight2*bDrawBoard,
							pxR + not(gs_stack_right) * px4,	py1, 	0,				13 + 2 * not(gs_stack_right)	! 15 or 13
					else
						addz gs_trim_thk_in - gs_apron_thk
						croof_ bBottomtriminmat, bBottomtriminmat, bBottomtriminmat,
							4, 0,0, 1,0, 0, 0, -bBottomtriminthk,
							pxL + not(gs_stack_left)  * px1,	py1, 	-wallIncl*bTrimovbotleftin,	8 + 7 * not(gs_stack_left),
							pxL + not(gs_stack_left)  * px1,	py2, 	0, 9 + 2 * not(gs_stack_left),
							pxR + not(gs_stack_right) * px4,	py2, 	wallIncl*bTrimovbotrightin, 8 + 7 * not(gs_stack_right),
							pxR + not(gs_stack_right) * px4,	py1, 	0,	13 + 2 * not(gs_stack_right)
						del 1
					endif

					del 3
					material gs_trim_in_mat
				endif

				del 1
			endif ! bInclinedWall
		endif

		del 1

	else	! not(curvedWall)

		! ======================================
		! Apron - Curved Walls
		! ======================================

		resol WALL_RESOL

		offsArc = iHolePosSign * AC_Hole_Position_Angle / 180 * PI * rBoard

		matTrim = gs_trim_in_mat

		material gs_apron_mat
		sect_fill gs_trim_fill_in, gs_trim_pen_bg_in, gs_trim_pen_fg_in, gs_trim_pen_cont_in

		if gs_IsCurved then
			thk = WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS
		else
			thk = WALL_THICKNESS

			addz -WIDO_FRAME_THICKNESS

			material matTrim

			cutplane
			del 1
			numCutsFrame = 1
		endif

		if wallIsLeft then
			mask = 14 + (gs_trim_offs_in > EPS | not(bShowJambExtension))
		else
			mask = 11 + 4 * (gs_trim_offs_in > EPS | not(bShowJambExtension))
		endif

		if numCutsFrame then
			cutend
			numCutsFrame = 0
		endif

		if not(gs_stack_left) then
			alfaLeftParallelIn = abs (asn ( (leftRevealPnts[idxBoardEndRevealLeft][1] + gs_trim_width_in) / rBoard))
		else
			alfaLeftParallelIn = alfaLeft
		endif
		if not(gs_stack_right) then
			alfaRightParallelIn = abs (asn ( (rightRevealPnts[idxBoardEndRevealRight][1] - gs_trim_width_in) / rBoard))
		else
			alfaRightParallelIn = alfaRight
		endif

		if gs_trim_thk_in > EPS then

! ------------------------------------------------------------------------------
! Apron hole in curved wall
! ------------------------------------------------------------------------------

			if iWindowShape = SHAPE_RECTANGULAR then

				if gs_stack_left then
					pxL = leftRevealPnts[idxBoardEndRevealLeft][1]
				else
					pxL = leftRevealPnts[idxBoardEndRevealLeft][1] + gs_trim_width_in + not(gs_stack_left) * (-gs_trim_offs_in + tolerOffsetLeftIn)
					alphaLeft = abs(asn(pxL / rBoard)) + ArcLengthBoardToAngle * gs_tw_left_in
					pxL = -rBoard * sin(alphaLeft)
					pyL = -sqr(rBoard^2 - pxL^2) - WOD
				endif
				if gs_stack_right then
					pxR = rightRevealPnts[idxBoardEndRevealright][1]
				else
					pxR = rightRevealPnts[idxBoardEndRevealright][1] - gs_trim_width_in - not(gs_stack_right) * (-gs_trim_offs_in + tolerOffsetRightIn)
					alphaRight = abs(asn(pxR / rBoard)) + ArcLengthBoardToAngle * gs_tw_right_in
					pxR = rBoard * sin(alphaRight)
					pyR = -sqr(rBoard^2 - pxR^2) - WOD
				endif
				if isWindow then
					pyB = -overSizeBottomIn - not(gs_stack_bottom) * (gs_apron_width)
				else
					pyB = 0
				endif
				pyT = pyB + gs_apron_width

				if bCutWall then
					pen WALL_VIEW_PEN
					material matWallIn

					alfaEnd		= alphaRight
					alfaStart	= -alphaLeft
					arcRadius	= radBoard
					bMiddlePoints = 1
					firstStatus	= 31
					midStatus	= 95
					lastStatus	= 31
					if abs(alfaStart - alfaEnd) > EPS then
						gosub 110

						rotx 90
						muly -1
						addz -pyB

						cutDepth = pyT - pyB
						if wallIsLeft then
!							prism_ NSP/3 + 1,-cutDepth,
!								0,WOD,15,
!								use(nsp)
							wallniche NSP/3 + 1,1,0,
								0,0,-cutDepth,cutDepth,
								0,WOD,31,
								get(nsp)
						else
!							prism_ NSP/3 + 2,-cutDepth,
!								 (rBoard + WALL_THICKNESS) * sin(alphaLeft),  (rBoard + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 15,
!								-(rBoard + WALL_THICKNESS) * sin(alphaRight), (rBoard + WALL_THICKNESS) * cos(alphaRight) + WOD, 15,
!								use(nsp)
							wallniche NSP/3 + 2,1,0,
									0,0,-cutDepth,cutDepth,
								 (rBoard + WALL_THICKNESS) * sin(alphaLeft),  (rBoard + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 31,
								-(rBoard + WALL_THICKNESS) * sin(alphaRight), (rBoard + WALL_THICKNESS) * cos(alphaRight) + WOD, 31,
								get(nsp)
						endif
						del 3
					endif

					pen gs_frame_pen
					material gs_trim_in_mat
				endif
			endif

			material gs_apron_mat
			sect_fill gs_trim_fill_in, gs_trim_pen_bg_in, gs_trim_pen_fg_in, gs_trim_pen_cont_in

			! ===== Inside Trim - Curved Walls - Casing =====

			if wallIsLeft then
				mask = 11 + 4 * (gs_trim_offs_in > EPS)
			else
				mask = 14 + (gs_trim_offs_in > EPS)
			endif

			maskTop		= 8 + 2 * not(gs_stack_top) * not(bParalellInCurvedWalls)
			maskBottom	= 8 + 2 * not(gs_stack_bottom)
			maskLeft	= 8 + (2 + 5 * bParalellInCurvedWalls) * not(gs_stack_left)
			maskRight	= 8 + 2 * not(gs_stack_right)

			maskLeft2	= bDrawBoard*(not(bTrimovbotleftin)*(15-7*gs_stack_left)+bTrimovbotleftin*(10-2*gs_stack_left))
			maskRight2	= bDrawBoard*(not(bTrimovbotrightin)*(15-7*gs_stack_right)+bTrimovbotrightin*(10-2*gs_stack_right))

			addz -WOD
			bCondition = WIDO_REVEAL_SIDE exor SYMB_MIRRORED
			roty (not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) + not(wallIsLeft) * 180
			addz rBoard

! ------------------------------------------------------------------------------
! Apron in curved wall
! ------------------------------------------------------------------------------

			if not(gs_stack_bottom | not(isWindow)) & bShapeEnablesStraightBottomTrim & abs(gs_apron_width) > EPS then
				if not(bParalellInCurvedWalls) then
					px1 = signWallIsLeft * (offsArc - rBoard * alfaLeft * DegRad + not(gs_stack_left) * (gs_trim_width_in - gs_trim_offs_in - gs_tw_left_in*not(bTrimovbotleftin)))
					px2 = px1
					px3 = signWallIsLeft * (offsArc - rBoard * alfaLeft * DegRad + not(gs_stack_left) * (gs_trim_width_in - gs_trim_offs_in))
					px4 = signWallIsLeft * (offsArc + rBoard * alfaRight * DegRad + not(gs_stack_right) * (-gs_trim_width_in + gs_trim_offs_in))
					px5 = signWallIsLeft * (offsArc + rBoard * alfaRight * DegRad + not(gs_stack_right) * (-gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in*not(bTrimovbotrightin)))
					px6 = px5

					py1 = -overSizeBottomIn + not(gs_stack_bottom) * (gs_trim_width_in*not(bDrawBoard) - gs_trim_offs_in * not(bDrawBoard) - gs_apron_width)
					py2 = py1 + gs_apron_width * bDrawBoard
					py3 = -overSizeBottomIn + not(gs_stack_bottom) * (gs_trim_width_in*not(bDrawBoard) - gs_trim_offs_in * not(bDrawBoard))
					py4 = py3
					py5 = py2
					py6 = py1

					s1 = maskLeft*not(bDrawBoard)+maskLeft2*bDrawBoard
					s2 = maskLeft
					s3 = bitset (mask, 1, not(gs_stack_left))
					s4 = maskRight
					s5 = maskRight*not(bDrawBoard)+maskRight2*bDrawBoard
					s6 = 13 + 2 * not(gs_stack_right)
				else
					px1 = signWallIsLeft * (offsArc - rBoard * alfaLeftParallelIn * DegRad + not(gs_stack_left) * (gs_trim_width_in*0 - gs_trim_offs_in - gs_tw_left_in + tolerOffsetLeftIn))
					px2 = px1
					px3 = signWallIsLeft * (offsArc - rBoard * alfaLeftParallelIn * DegRad + not(gs_stack_left) * (gs_trim_width_in*0 - gs_trim_offs_in - gs_tw_left_in + tolerOffsetLeftIn))
					px4 = signWallIsLeft * (offsArc + rBoard * alfaRightParallelIn * DegRad + not(gs_stack_right) * (-gs_trim_width_in*0 + gs_trim_offs_in + gs_tw_right_in - tolerOffsetRightIn ))
					px5 = signWallIsLeft * (offsArc + rBoard * alfaRightParallelIn * DegRad + not(gs_stack_right) * (-gs_trim_width_in*0 + gs_trim_offs_in + gs_tw_right_in - tolerOffsetRightIn ))
					px6 = px5

					py1 = -overSizeBottomIn + not(gs_stack_bottom) * ( (gs_trim_width_in - gs_trim_offs_in + tolerOffsetLowerIn) * not(bDrawBoard) - gs_apron_width)
					py2 = py1 + gs_apron_width * bDrawBoard
					py3 = -overSizeBottomIn + not(gs_stack_bottom) * ( (gs_trim_width_in - gs_trim_offs_in + tolerOffsetLowerIn) * not(bDrawBoard)) + EPS
					py4 = py3 + EPS
					py5 = py2
					py6 = py1

					s1 = maskLeft * not(bDrawBoard) + maskLeft2 * bDrawBoard
					s2 = maskLeft
					s3 = bitset (mask, 1, not(gs_stack_left))
					s4 = 13	+ 2 * bDrawBoard
					s5 = maskRight * not(bDrawBoard) + maskRight2 * bDrawBoard
					s6 = 13 + 2 * not(gs_stack_right)
				endif

				if bParalellInCurvedWalls then
					addz -rBoard
					roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

					maskApronNos = 0
					if abs(gs_apron_thk - gs_trim_thk_in) > EPS then
						maskApronNos = 15
					else
						maskApronNos = 15 * (gs_trim_in_mat <> gs_apron_mat)
					endif

					cutpolya 4, 1, 0,
						-leftWidth + tolerOffsetLeftIn + gs_trim_width_in + gs_trim_offs_in,  py3 - EPS - gs_apron_width * bTrimovbotleftin,  maskApronNos,
						-leftWidth * 3,  py3 - EPS - gs_apron_width * bTrimovbotleftin,  7,
						-leftWidth * 3, B + overSizeTop, 7,
						-leftWidth + tolerOffsetLeftIn + gs_trim_width_in + gs_trim_offs_in,  B + overSizeTop,  1 * not(bTrimovbotleftin) + bTrimovbotleftin * maskApronNos

					cutpolya 4, 1, 0,
						-leftWidth + tolerOffsetLeftIn + gs_trim_width_in - gs_trim_offs_in,  py3 - EPS,  3,
						rightWidth - tolerOffsetRightIn - gs_trim_width_in - gs_trim_offs_in,  py3 - EPS,  7,
						rightWidth - tolerOffsetRightIn - gs_trim_width_in - gs_trim_offs_in, B + overSizeTop, 7,
						-leftWidth + tolerOffsetLeftIn + gs_trim_width_in - gs_trim_offs_in,  B + overSizeTop,  1

					cutpolya 4, 1, 0,
						rightWidth - tolerOffsetRightIn - gs_trim_width_in - gs_trim_offs_in,  py3 - EPS - gs_apron_width * bTrimovbotrightin,  maskApronNos,
						rightWidth * 3,  py3 - EPS - gs_apron_width * bTrimovbotrightin,  7,
						rightWidth * 3, B + overSizeTop, 7,
						rightWidth - tolerOffsetRightIn - gs_trim_width_in - gs_trim_offs_in,  B + overSizeTop,  1 * not(bTrimovbotrightin) + bTrimovbotrightin * maskApronNos

					del 2
				endif

				bprism_ gs_apron_mat, gs_apron_mat, gs_apron_mat,
					4+2, -signWallIsLeft * bBottomtriminthk, rBoard,
					px1,	py1, 	s1,
					px2,	py2, 	s2,
					px3,	py3,	s3,
					px4,	py4,	s4,
					px5,	py5, 	s5,
					px6,	py6, 	s6

				if bParalellInCurvedWalls then
					cutend
					cutend
					cutend
				endif
			endif

			del 3
		endif
	endif	! not(curvedWall)

	del 1
return


"casing head type":

	toler 0.002
	if iCasingHeadTypeOut = CASING_HEAD_RECT then
		put 0,	0,	0,
			-_trimWidth,	0,			0,
			-_trimWidth,	_trimThick,	0,
			0,				_trimThick,	0,
			0,				0,			0
	endif
	
	if iCasingHeadTypeOut = CASING_HEAD_DECORATIVE_1 then
		_sizeW			= min(_trimThick, _trimWidth/8)
		_sizeT			= min(_trimThick, _thickBracket/2)
		_thickProfile	= _trimThick+_thickBracket+_offsetTop
		put 0,0,0,
			-_trimWidth,			0,					0,
			-_trimWidth+_sizeW,		_thickProfile,		0,
			-_trimWidth+_sizeW*2,	_thickProfile,		0,
			-_trimWidth+_sizeW*2,	_trimThick+_sizeT,	0,
			-_sizeW*2,				_trimThick+_sizeT,	0,
			0,						_trimThick,			0,
			0,						0,					0
	endif
	
	if iCasingHeadTypeOut = CASING_HEAD_DECORATIVE_2 then
		_sizeW			= min(_trimThick, _trimWidth/8)
		_sizeT			= min(_trimThick, _thickBracket/2)
		_thickProfile	= _trimThick+_thickBracket+_offsetTop
		_rr				= min((_thickBracket+_offsetTop)/2, _trimWidth-_sizeW*2-EPS)
	
		put 0,0,0,
			-_trimWidth,				0,				0,
			-_trimWidth+_sizeW,			_thickProfile,	0,
			-_trimWidth+_sizeW*2,		_thickProfile,	0,
			-_trimWidth+_sizeW*2,		_trimThick+rr,	1,
			-_trimWidth+_sizeW*2+_rr,	_trimThick,		1001,
			0,							_trimThick,		0,
			0,							0,				0
	endif
	
	if iCasingHeadTypeOut = CASING_HEAD_DECORATIVE_3 then
		_sizeW			= min(_trimThick, _trimWidth/8)
		_thickProfile	= _trimThick+_thickBracket+_offsetTop
	
		put 0,0,0,
			-_trimWidth,			0,				0,
			-_trimWidth+_sizeW,  	_thickProfile,	0,
			-_trimWidth+_sizeW*2,	_thickProfile,	0,
			-_trimWidth+_sizeW*2,	_trimThick,		0,
			0,     					_trimThick,		0,
			0,     					0,				0
	endif
	
	if nsp then
		extrude nsp/3, 0, 0, _trimLength, 1+2+4+16*m1+32*m2,
			get(nsp)
	endif
	
	roty 90
	base
	vert 0,0,0
	vert 0.1,0,0
	vert 0,0.1,0
	vert 0,0,0.1
	coor 258,-1,-2,-3,-4
	body -1
	del 1

return


"architrave capital type":
	if _bArchitraveCapitalOnSide then
		_capitalLength = _trimWidth
	else
		_capitalLength = architraveCapitalWidth
	endif

	if	(iArchitraveCapitalType = ARCH_CAPITAL_SQUARE_ONSIDE |\
		 iArchitraveCapitalType = ARCH_CAPITAL_SQUARE_NEXTSIDE) then

		put -_trimThick,	-0.001,		1,
			-_trimThick,	-0.2,		1,
			0.01,			-0.2,		1,
			0.06,			0,			1,
			-_trimThick,	-0.001,		-1
	endif

	if	(iArchitraveCapitalType = ARCH_CAPITAL_DECOR_ONSIDE |\
		 iArchitraveCapitalType = ARCH_CAPITAL_DECOR_NEXTSIDE) then

		put	-_trimThick,		-0.001,				1,
		  	-_trimThick,		-0.2105623924385,	1,
		  	0.0002225047733932,	-0.2105623924385,	1,
		  	0.02569480801934,	-0.2147356031753,	900,
		  	0,					-66.87864346571,	4001,
		 	0.01953034376379,	-0.1896706216084,	1,
		  	0.01364444354641,	-0.1731057357603,	900,
		  	0,					71.90421043734,		4001,
		  	0.03121820560956,	-0.1726561231749,	1,
		  	0.03757481483445,	-0.1726166802041,	1,
		  	0.02760021831745,	-0.1627083807783,	1,
		  	0.04641522481362,	-0.1412622935953,	900,
		  	0,					-93.75626129549,	4001,
		 	0.026247820758,		-0.1210827262419,	1,
		 	0.0606554624785,	-0.09478132287652,	1,
		 	0.05486053259315,	-0.0887335580581,	1,
		 	0.04784928296197,	-0.0680955002196,	900,
		  	0,					127.355665002,		4001,
			0.06,				-0.05,				1,
			0.07,				-0.05,				1,
			0.07,				0,					1,
			0,					0,					1,
			_trimThick,			-0.001,				-1
	endif

	if iArchitraveCapitalType = 0 then
		put	-_trimThick,		-0.003,				1,
			-_trimThick,		-0.141,				1,
			0,					-0.141,				1,
			-0.008015410958904,	-0.1133424657534,	900,
			0,					60.4,				4001,
			0.02,				-0.12,				1,
			0.01899107142857,	-0.1045,			900,
			0,					172.5514951168,		4001,
			0.02,				-0.089,				1,
			0.08881341911765,	-0.08749908088235,	900,
			0,					-44.8,				4001,
			0.039,				-0.04,				1,
			0.039,				0,					1,
			0,					0,					1,
			-_trimThick,		-0.003,				-1
	endif

	if nsp then
		extrude nsp/3, 0, 0, _capitalLength, 1+2+4+16+32,
			get(nsp)
	endif

	roty 90
	base
	vert 0,0,0
	vert 0.1,0,0
	vert 0,0.1,0
	vert 0,0,0.1
	coor 258,-1,-2,-3,-4
	body -1
	del 1

return


100:
! ==============================================================================
!	Cutting Corner Column
! ==============================================================================

mulz -1
rotx -90


! Draw Right Column ------------------------------------------------------------

if bRightCornerFunction & idxBoardEndRevealRight >= idxR then
	add rightRevealPnts[idxR][1], rightRevealPnts[idxR][2],0
	if bMirrorRight then muly -1

	px1		= px1R
	px2		= px2R
	px3		= px3R
	pxFrame	= pxFrameR

	cutpolya 4, 1, 0,
		px1,			-gs_cc_pr,				15,
		px2 - pxFrame,	-gs_cc_pr,				15,
		px2 - pxFrame,	-gs_cc_pr + gs_cc_thk,	15,
		px3,			-gs_cc_pr + gs_cc_thk,	15

	numCutsCornerColumn = numCutsCornerColumn + 1

	del bMirrorRight + 1
endif


! Draw Left Column -------------------------------------------------------------

if bLeftCornerFunction & idxBoardEndRevealLeft >= idxL then
	add leftRevealPnts[idxL][1], leftRevealPnts[idxL][2],0
	if bMirrorLeft then muly -1
	add offsLeftX, offsLeftY, 0
	mulx -1

	px1		= px1L
	px2		= px2L
	px3		= px3L
	pxFrame	= pxFrameL

	cutpolya 4, 1, 0,
		px1,			-gs_cc_pr,				15,
		px2 - pxFrame,	-gs_cc_pr,				15,
		px2 - pxFrame,	-gs_cc_pr + gs_cc_thk,	15,
		px3,			-gs_cc_pr + gs_cc_thk,	15

	numCutsCornerColumn = numCutsCornerColumn + 1

	del bMirrorLeft + 3
endif

del 2

return


! ==============================================================================
! Arch Segmentation
! ------------------------------------------------------------------------------
! Input parameters:
!	alfaStart:		Start angle (angle)
!	alfaEnd:		End angle (angle)
!	arcRadius:		Arc radius (length)
!	bMiddlePoints:	Generate middle points (0 / 1)
!	firstStatus:	Status of the first segment (integer)
!	midStatus:		Status of the middle segments (integer)
!	lastStatus:		Status of the last segment (integer)
! ==============================================================================

110:
	if not(wallIsLeft) then
		alfaStart = 180 - alfaStart
		alfaEnd = 180 - alfaEnd
	endif
	segmentAngle = 360 / WALL_RESOL


	! --- Point at Start Angle ---
	if WIDO_REVEAL_SIDE then
		if SYMB_ROTANGLE < EPS then
			difAngle = (AC_Hole_Position_Angle + alfaStart) mod segmentAngle
		else
			difAngle = -(AC_Hole_Position_Angle - 180 - alfaStart) mod segmentAngle
		endif
	else
		if SYMB_ROTANGLE < EPS then
			difAngle = -(AC_Hole_Position_Angle - alfaStart + 180) mod segmentAngle
		else
			difAngle = (AC_Hole_Position_Angle + alfaStart) mod segmentAngle
		endif
	endif

	difAngle2 = difAngle
	if abs(difAngle) > segmentAngle / 2 then difAngle = -segmentAngle / 2 + abs(difAngle mod (segmentAngle / 2))

	segmentR = arcRadius / cos(difAngle)
	put segmentR * sin(alfaStart), -segmentR * cos(alfaStart) + WOD, firstStatus

	if bMiddlePoints then
		! --- Middle Points ---
		segmentR = arcRadius / cos(segmentAngle / 2)

		if alfaStart > alfaEnd then
			alfaActual = alfaStart - difAngle2 + segmentAngle / 2

			if alfaActual > alfaStart then alfaActual = alfaActual - segmentAngle
			if alfaActual > alfaStart then alfaActual = alfaActual - segmentAngle

			if alfaActual < alfaEnd then alfaActual = alfaActual + segmentAngle

			if alfaActual < alfaStart & alfaActual > alfaEnd then
				do
					put segmentR * sin(alfaActual), -segmentR * cos(alfaActual) + WOD, midStatus

					alfaActual = alfaActual - segmentAngle

				while alfaActual > alfaEnd
			endif
		else
			alfaActual = alfaStart - difAngle2 + segmentAngle / 2

			if alfaActual < alfaStart then alfaActual = alfaActual + segmentAngle
			if alfaActual > alfaEnd then alfaActual = alfaActual - segmentAngle

			if alfaActual > alfaStart & alfaActual < alfaEnd then
				do
					put segmentR * sin(alfaActual), -segmentR * cos(alfaActual) + WOD, midStatus

					alfaActual = alfaActual + segmentAngle
				while alfaActual < alfaEnd
			endif
		endif
	endif


	! --- Point at End Angle ---
	if WIDO_REVEAL_SIDE then
		if SYMB_ROTANGLE < EPS then
			difAngle = (AC_Hole_Position_Angle + alfaEnd) mod segmentAngle
		else
			difAngle = -(AC_Hole_Position_Angle + 180 - alfaEnd) mod segmentAngle
		endif
	else
		if SYMB_ROTANGLE < EPS then
			difAngle = -(AC_Hole_Position_Angle - alfaEnd + 180) mod segmentAngle
		else
			difAngle = (AC_Hole_Position_Angle + alfaEnd) mod segmentAngle
		endif
	endif

	if abs(difAngle) > segmentAngle / 2 then difAngle = -segmentAngle / 2 + abs(difAngle mod (segmentAngle / 2))

	segmentR = arcRadius / cos(difAngle)
	put segmentR * sin(alfaEnd), -segmentR * cos(alfaEnd) + WOD, lastStatus

return


"TextCoord_Vert":

!********************** texture coordination, vertical

vert 0, 0, 0
vert 0, 1, 0
vert 1, 0, 0
vert 0, 0, 1
coor 2, -1, -2, -3, -4
body 1

base

return



"TextCoord_Hor":

!********************** texture coordination, horozintal

rotz 90
if not(curvedWall) then
	vert 0, 0, 0
	vert 0, 1, 0
	vert 1, 0, 0
	vert 0, 0, 1
	coor 2, -1, -2, -3, -4
else
	addz -wod
	vert 0, 0, 0
	vert 0, 1, 0
	vert 0, 0, 1
	vert 1, 0, 0
	coor 3, -1, -2, -3, -4
	del 1
endif
body 1
del 1

base

return



]]></Script_3D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_2D SectVersion="20" SectionFlags="0" SubIdent="0"><![CDATA[

! Contact person: <NJ>

! ==============================================================================
! This macro draws the Casing
! ------------------------------------------------------------------------------
! Input parameters:
! Geometry ---------------------------------------------------------------------
!	A:						wallhole width (length) (Obsolete)
!	refWidth:				reference width in curved walls (length)
!	leftWidth:				wallhole's side distance from the origin at the left side (length)
!	rightWidth:				wallhole's side distance from the origin at the right side (length)
! Functions --------------------------------------------------------------------
!	gs_IsCurved:			Does the window follow the curvature of the wall? (0 / 1)
!	bParalellInCurvedWalls:	is the wallhole parallel in curved walls (0 / 1)
!	bShowEdgeHotspots:		Show hotspots at jamb extensions inner edge - CHE request (0 / 1)
! Reveal -----------------------------------------------------------------------
!	iRevealType:
!	gs_reveal_left_angle:
!	gs_reveal_right_angle:
! Corner Function --------------------------------------------------------------
!	bLeftCornerFunction:		Turn macro in Corner Window mode at the left side (0 / 1)
!	leftCornerAngle:		Angle between connected walls in case of Corner Window (angle)
!	leftConnWallThk:		Thickness of the connected wall in case of Corner Window (length)
!	bRightCornerFunction:	Turn macro in Corner Window mode at the right side (0 / 1)
!	rightCornerAngle:		Angle between connected walls in case of Corner Window (angle)
!	rightConnWallThk:		Thickness of the connected wall in case of Corner Window (length)
! Oversize ---------------------------------------------------------------------
!	gs_left_oversize:		Left opening oversize (length)
!	gs_right_oversize:		Right opening oversize (length)
! Casing -----------------------------------------------------------------------
!	gs_trim_inside:
!	gs_trim_outside:
!	gs_trim_width_in:		Width of inside Trim. (length)
!	gs_trim_width_out:		Width of outside Trim. (length)
!	gs_trim_offs_in:		Offset of Casing inside. (length)
!	gs_trim_offs_out:		Offset of Casing outside. (length)
!	gs_trim_thk_in:			Thickness of inside Trim. (length)
!	gs_trim_thk_out:		Thickness of outside Trim. (length)
!	gs_tw_left_in:			Width of inside casing on the left (length)
!	gs_tw_right_in:			Width of inside casing on the right (length)
!	gs_tw_left_out:			Width of outside casing on the left (length)
!	gs_tw_right_out:		Width of outside casing on the right (length)
! Sill -------------------------------------------------------------------------
!	bWindowSymbolAtMiddle:	Is the window symbol appears always on the middle of the wall (CHI special) (0 / 1)
! 2D Representation ------------------------------------------------------------
!	lod2D_Casing:			Level of detail. (integer, 0..1)
!	gs_pen_2D:				Cotour pen of the Trim, Sill and Board. (pen)
!	gs_trim_pen_cont:		Cotour pen of the cutted Trim.
!								If it is zero then gs_pen_2D defines the cutted contour pen. (pen)
!	gs_bFills:				Use fills (boolean)
!	gs_wallhole_fill:		Type of the fill on the Sill and Board. (fill type)
!	gs_wallhole_pen_fg:		Fill pen on the Sill and Board. (pen)
!	gs_wallhole_pen_bg:		Fill background pen on the Sill and Board. (pen)
!	gs_trim_fill_in:		Type of the fill on the inside Trim. (fill type)
!	gs_trim_pen_fg_in:		Fill pen on the inside Trim. (pen)
!	gs_trim_pen_bg_in:		Fill background pen on the inside Trim. (pen)
!	gs_trim_fill_out:		Type of the fill on the outside Trim. (fill type)
!	gs_trim_pen_fg_out:		Fill pen on the outside Trim. (pen)
!	gs_trim_pen_bg_out:		Fill background pen on the outside Trim. (pen)
! Ganging ----------------------------------------------------------------------
!	gs_stack_left:			Align to door/window on left side (0 / 1)
!	gs_stack_right:			Align to door/window on right side (0 / 1)
!	gs_stack_bottom:		Align to door/window on bottom side (0 / 1)
!
! Related Global Variables:
!	GLOB_SCRIPT_TYPE
!	GLOB_CONTEXT
!	WALL_THICKNESS
!	WALL_INCL
!	WALL_SECT_PEN
!	WIDO_FRAME_THICKNESS
!	WIDO_SILL
!	WIDO_ORIG_DIST
!	WIDO_REVEAL_SIDE
!	SYMB_MIRRORED
!	SYMB_ROTANGLE
!
! Hotspot IDs:
!	10010:		Outside Trim's left inner
!	10011:		Outside Trim's right inner
!	10012:		Inside Trim's left inner
!	10013:		Inside Trim's right inner
!
!	10020:		Outside Wall Contour left
!	10021:		Outside Wall Contour right
!	10022:		Inside Wall Contour left
!	10023:		Inside Wall Contour right
!
!	10030:		Outside Trim's left outer
!	10031:		Outside Trim's right outer
!	10032:		Inside Trim's left outer
!	10033:		Inside Trim's right outer
! ==============================================================================


! ==============================================================================
! Showing then unID's of hotspots
!
!
! ==============================================================================


if lod2D_Casing = 0 then end
if (bInsideCasingNotAvailableByReveal |\
	bInsideCasingNotAvailableByWallType |\
	bInsideCasingNotAvailableByFrameStyle) then
	bDrawInsideTrim  = 0
endif
if (bOutsideCasingNotAvailableByReveal |\
	bOutsideCasingNotAvailableByFrameStyle) then
	bDrawOutsideTrim = 0
endif
if not(bDrawInsideTrim | bDrawOutsideTrim) then end

! Save the current parameter buffer ============================================

dim savedQueueValues[]
call "SaveQueue_WMCC" parameters returned_parameters savedQueueValues


if gs_trim_wallhole_pen_fg_in <= 0 then
	gs_trim_bFills_in			= gs_bFills
	gs_trim_wallhole_pen_fg_in	= gs_wallhole_pen_fg
	gs_trim_wallhole_pen_bg_in	= gs_wallhole_pen_bg

	gs_trim_wallhole_pen_sl_fg_in	= gs_wallhole_pen_sl_fg
	gs_trim_wallhole_pen_sl_bg_in	= gs_wallhole_pen_sl_bg
endif
if bPShapedLeftOpening | bPShapedRightOpening then
	gs_trim_wallhole_fill_in		= gs_wallhole_fill_sl
else
	gs_trim_wallhole_fill_in		= gs_wallhole_fill
endif

if gs_trim_wallhole_pen_fg_out <= 0 then
	gs_trim_bFills_out			= gs_bFills
	gs_trim_wallhole_pen_fg_out	= gs_wallhole_pen_fg
	gs_trim_wallhole_pen_bg_out	= gs_wallhole_pen_bg

	gs_trim_wallhole_pen_sl_fg_out	= gs_wallhole_pen_sl_fg
	gs_trim_wallhole_pen_sl_bg_out	= gs_wallhole_pen_sl_bg
endif
if bPShapedLeftOpening | bPShapedRightOpening then
	gs_trim_wallhole_fill_out		= gs_wallhole_fill_sl
else
	gs_trim_wallhole_fill_out		= gs_wallhole_fill
endif

if not(gs_trim_bFills_in)  then gs_trim_wallhole_fill_in  = 0
if not(gs_trim_bFills_out) then gs_trim_wallhole_fill_out = 0



gs_trim_pen_cont_out	= gs_trim_pen_cont
gs_trim_pen_cont_in		= gs_trim_pen_cont
line_type 1

if WIDO_REVEAL_SIDE then
	add2 0,-WIDO_FRAME_THICKNESS
else
	mul2 1,-1
endif

! ===== Handling 2D Detail Levels =====

if lod2D_Casing = 0 then
	bDrawOutsideTrim = 0
	bDrawInsideTrim  = 0
endif


if gs_stack_left then
	overSizeLeft = gs_left_oversize
	widoLeftJamb = 0
endif

if gs_stack_right then
	overSizeRight = gs_right_oversize
	widoRightJamb = 0
endif

if gs_trim_show_cover_in then
	gs_trim_jambext_nosing_in = 0
else
	gs_trim_thk_in = gs_trim_jambext_nosing_in
	gs_trim_offs_in = 0
endif
if gs_trim_show_cover_out then
	gs_trim_jambext_nosing_out = 0
else
	gs_trim_thk_out = gs_trim_jambext_nosing_out
	gs_trim_offs_out = 0
endif

trthL = gs_trim_thk_in / cos(trinfiL - gi1L)
trthR = gs_trim_thk_in / sin(90 - trinfiR - gi1R)

! ==============================================================================
!	Open PolyOperations Add-on Channel
! ==============================================================================
if bTShapedOpening & curvedWall & (bDrawInsideTrim | bDrawOutsideTrim) then
	ch = INITADDONSCOPE ("PolyOperations", "", "")

	PREPAREFUNCTION ch, "CreateContainer", "mySourceContainer", ""
	PREPAREFUNCTION ch, "CreateContainer", "myDestinationContainer", ""

	PREPAREFUNCTION ch, "SetSourceContainer",		"mySourceContainer", ""
	PREPAREFUNCTION ch, "SetDestinationContainer",	"myDestinationContainer", ""
endif


! ==============================================================================
!	Draw Inside Casing's Background Fill
! ==============================================================================

if bDrawInsideCasingFill & bDrawInsideTrim & isWindow & not(gs_stack_bottom) then

	set fill gs_trim_wallhole_fill_in
	line_property 0
	line_type 1
	pen gs_pen_2D

	if not(curvedWall) then
		if bLeftCornerFunction then
			bpx6 = leftRevealPnts[idxBoardEndRevealLeft][1] + gs_trim_thk_in * lx
			bpy6 = leftRevealPnts[idxBoardEndRevealLeft][2] + gs_trim_thk_in
		else
			if bInclinedWall then
				if gs_stack_left then
					bpx6 = leftRevealPnts[idxBoardEndRevealLeft][1]
					bpy6 = leftRevealPnts[idxBoardEndRevealLeft][2] + gs_trim_thk_in / incH
				else
					bpx6 = leftRevealPnts[idxBoardEndRevealLeft][1] + trin2L * incH - gs_trim_offs_in - trthL * sin(trinfiL)
!					bpy6 = leftRevealPnts[idxBoardEndRevealLeft][2] + (gs_trim_width_in - gs_trim_offs_in) * incV + (gs_trim_thk_in / incH*0 + trthL * cos(trinfiL)) * not(gs_trim_atframe_in)
					bpx60 = leftRevealPnts[idxBoardEndRevealLeft][1] + trin2L * incH - gs_trim_offs_in
					bpy6 = WALL_THICKNESS - WIDO_SILL + incX * bpx60 + trthL * cos(trinfiL)
				endif
			else
				bpx6 = leftRevealPnts[idxBoardEndRevealLeft][1] + not(gs_stack_left) * (trinL - gs_trim_offs_in - gs_trim_thk_in * tan(trinfiL) * not(gs_trim_atframe_in))
				bpy6 = leftRevealPnts[idxBoardEndRevealLeft][2] + gs_trim_thk_in * not(gs_trim_atframe_in)
			endif
		endif

		if bRightCornerFunction then
			bpx7 = rightRevealPnts[idxBoardEndRevealRight][1] - gs_trim_thk_in * rx
			bpy7 = rightRevealPnts[idxBoardEndRevealRight][2] + gs_trim_thk_in
		else
			if bInclinedWall then
				if gs_stack_right then
					bpx7 = rightRevealPnts[idxBoardEndRevealRight][1]
					bpy7 = rightRevealPnts[idxBoardEndRevealRight][2] + gs_trim_thk_in / incH
				else
					bpx7 = rightRevealPnts[idxBoardEndRevealRight][1] - trin2R * incH + gs_trim_offs_in + trthR * sin(trinfiR)	!- gs_trim_width_in + gs_trim_offs_in
!					bpy7 = rightRevealPnts[idxBoardEndRevealRight][2] - (gs_trim_width_in - gs_trim_offs_in) * incV + (gs_trim_thk_in / incH*0 + trthR * cos(trinfiR)) * not(gs_trim_atframe_in)
					bpx70 = rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn + gs_trim_width_in*0 - trin2R * incH + gs_trim_offs_in
					bpy7 = WALL_THICKNESS - WIDO_SILL + incX * bpx70 + trthR * cos(trinfiR)
				endif
			else
				bpx7 = rightRevealPnts[idxBoardEndRevealRight][1] - not(gs_stack_right) * (trinR - gs_trim_offs_in - gs_trim_thk_in * tan(trinfiR) * not(gs_trim_atframe_in))
				bpy7 = rightRevealPnts[idxBoardEndRevealRight][2] + gs_trim_thk_in * not(gs_trim_atframe_in)
			endif
		endif

	else
		if wallIsLeft then
			alfaL = -atn((-leftRevealPnts[idxBoardEndRevealLeft-1][1])  / (WOD - WIDO_FRAME_THICKNESS))
			alfaR =  atn((rightRevealPnts[idxBoardEndRevealRight-1][1]) / (WOD - WIDO_FRAME_THICKNESS))
		else
			alfaL = -atn((-leftRevealPnts[idxBoardEndRevealLeft-1][1])  / WOD)
			alfaR =  atn((rightRevealPnts[idxBoardEndRevealRight-1][1]) / WOD)
		endif

		if gs_stack_left then
			bpx6 = leftRevealPnts[idxBoardEndRevealLeft][1] - gs_trim_thk_in * sin(alfaL)
			bpy6 = leftRevealPnts[idxBoardEndRevealLeft][2] + gs_trim_thk_in * cos(alfaL)
		else
			if bParalellInCurvedWalls then
				bpx6 = leftRevealPnts[idxBoardEndRevealLeft][1] + (gs_trim_width_in - gs_trim_offs_in)
				bpy6 = -signWallIsLeft * sqr((radBoard - signWallIsLeft * gs_trim_thk_in)^2 - bpx6^2) + WOD
			else
				x = leftRevealPnts[idxBoardEndRevealLeft][1]
				y = leftRevealPnts[idxBoardEndRevealLeft][2]
				alpha = (gs_trim_width_in - gs_trim_offs_in) * ArcLengthBoardToAngle
				gosub 1000
				bpx6 = x - gs_trim_thk_in * sin(alfaL)
				bpy6 = y + gs_trim_thk_in * cos(alfaL)
			endif
		endif

		if gs_stack_right then
			bpx7 = rightRevealPnts[idxBoardEndRevealRight][1] - gs_trim_thk_in * sin(alfaR)
			bpy7 = rightRevealPnts[idxBoardEndRevealRight][2] + gs_trim_thk_in * cos(alfaR)
		else
			if bParalellInCurvedWalls then
				bpx7 = rightRevealPnts[idxBoardEndRevealRight][1] - (gs_trim_width_in - gs_trim_offs_in)
				bpy7 = -signWallIsLeft * sqr((radBoard - signWallIsLeft * gs_trim_thk_in)^2 - bpx7^2) + WOD
			else
				x = rightRevealPnts[idxBoardEndRevealRight][1]
				y = rightRevealPnts[idxBoardEndRevealRight][2]
				alpha = -(gs_trim_width_in - gs_trim_offs_in) * ArcLengthBoardToAngle
				gosub 1000
				bpx7 = x - gs_trim_thk_in * sin(alfaR)
				bpy7 = y + gs_trim_thk_in * cos(alfaR)
			endif
		endif
	endif

	bCurvedAtWindowFrame	= (curvedWall & gs_IsCurved)

	put 0,WOD,900,
		leftRevealPnts[idxBoardEndRevealLeft - 1][1],	leftRevealPnts[idxBoardEndRevealLeft - 1][2],	0,
		leftRevealPnts[idxBoardEndRevealLeft][1],		leftRevealPnts[idxBoardEndRevealLeft][2],		0,
		bpx6,											bpy6,											0,
		bpx7,											bpy7,											3000 * curvedWall,
		rightRevealPnts[idxBoardEndRevealRight][1],		rightRevealPnts[idxBoardEndRevealRight][2],		0,
		rightRevealPnts[idxBoardEndRevealRight - 1][1],	rightRevealPnts[idxBoardEndRevealRight - 1][2],	0,
		leftRevealPnts[idxBoardEndRevealLeft - 1][1],	leftRevealPnts[idxBoardEndRevealLeft - 1][2],	3000 * (bCurvedAtWindowFrame)

	poly2_b nsp/3, 2+4+64, gs_trim_wallhole_pen_fg_in, gs_trim_wallhole_pen_bg_in,
		get(nsp)

	if not(gs_trim_atframe_in) & not(gs_board_inside) then
		if curvedWall then
			R = sqr(bpx6^2 + (bpy6 - WOD)^2)

			vx = bpx6
			vy = bpy6 - WOD
			gosub 103	! Direction Angle
			alpha = angle

			vx = bpx7
			vy = bpy7 - WOD
			gosub 103	! Direction Angle
			beta = angle

			if abs(alpha - beta) > EPS then
				arc2 0,WOD, R, min(alpha,beta), max(alpha,beta)
			endif

			if bLineCasingOffset & gs_trim_offs_in > eps then
				R = sqr(bpx6^2 + (bpy6 - gs_trim_thk_in - WOD)^2)

				vx = bpx6
				vy = bpy6 - gs_trim_thk_in - WOD
				gosub 103	! Direction Angle
				alpha = angle

				vx = bpx7
				vy = bpy7 - gs_trim_thk_in - WOD
				gosub 103	! Direction Angle
				beta = angle

				if abs(alpha - beta) > EPS then
					arc2 0,WOD, R, min(alpha,beta), max(alpha,beta)
				endif

			endif
		else
			line2 bpx6, bpy6, bpx7, bpy7

			if bLineCasingOffset & gs_trim_offs_in > eps then
				line2 bpx6, bpy6 - gs_trim_thk_in, bpx7, bpy7 - gs_trim_thk_in
			endif
		endif
	endif
endif


! ==============================================================================
!	Draw Outside Casing's Background Fill
! ==============================================================================

if bDrawOutsideCasingFill & bDrawOutsideTrim & isWindow & not(gs_stack_bottom) then
	set fill gs_trim_wallhole_fill_out
	line_property 0
	line_type 1
	pen gs_pen_2D

	if not(curvedWall) then
		if bLeftCornerFunction then
			spx4 = leftRevealPnts[idxSillStartRevealLeft][1] - gs_trim_thk_out * lx
			spy4 = -WIDO_SILL - gs_trim_thk_out * not(gs_trim_atframe_out)
		else
			spx4 = leftRevealPnts[idxSillStartRevealLeft][1] + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out + tolerOffsetLeftOut)
			spy4 = -WIDO_SILL - gs_trim_thk_out * not(gs_trim_atframe_out)
		endif

		if bRightCornerFunction then
			spx5 = rightRevealPnts[idxSillStartRevealRight][1] + gs_trim_thk_out * rx
			spy5 = -WIDO_SILL - gs_trim_thk_out * not(gs_trim_atframe_out)
		else
			spx5 = rightRevealPnts[idxSillStartRevealRight][1] - not(gs_stack_right) * (gs_trim_width_out - gs_trim_offs_out + tolerOffsetRightOut)
			spy5 = -WIDO_SILL - gs_trim_thk_out * not(gs_trim_atframe_out)
		endif
	else
		if wallIsLeft then
			alfaL = -atn((leftWidth)  / (WOD - WIDO_FRAME_THICKNESS))
			alfaR =  atn((rightWidth) / (WOD - WIDO_FRAME_THICKNESS))
		else
			alfaL = -atn((leftWidth)  / WOD)
			alfaR =  atn((rightWidth) / WOD)
		endif

		if gs_stack_left then
			spx4 = leftRevealPnts[idxSillStartRevealLeft][1] + gs_trim_thk_out * sin(alfaL)
			spy4 = leftRevealPnts[idxSillStartRevealLeft][2] - gs_trim_thk_out * cos(alfaL)
		else
			if bParalellInCurvedWalls then
				spx4 = leftRevealPnts[idxSillStartRevealLeft][1] + (gs_trim_width_out - gs_trim_offs_out + tolerOffsetLeftOut)
				spy4 = -signWallIsLeft * sqr((radSill + signWallIsLeft * gs_trim_thk_out)^2 - spx4^2) + WOD
			else
				x = leftRevealPnts[idxSillStartRevealLeft][1]
				y = leftRevealPnts[idxSillStartRevealLeft][2]
				alpha = (gs_trim_width_out - gs_trim_offs_out) * ArcLengthSillToAngle
				gosub 1000
				spx4 = x + gs_trim_thk_out * sin(alfaL)
				spy4 = y - gs_trim_thk_out * cos(alfaL)
			endif
		endif

		if gs_stack_right then
			spx5 = rightRevealPnts[idxSillStartRevealRight][1] + gs_trim_thk_out * sin(alfaR)
			spy5 = rightRevealPnts[idxSillStartRevealRight][2] - gs_trim_thk_out * cos(alfaR)
		else
			if bParalellInCurvedWalls then
				spx5 = rightRevealPnts[idxSillStartRevealRight][1] - (gs_trim_width_out - gs_trim_offs_out + tolerOffsetRightOut)
				spy5 = -signWallIsLeft * sqr((radSill + signWallIsLeft * gs_trim_thk_out)^2 - spx5^2) + WOD
			else
				x = rightRevealPnts[idxSillStartRevealRight][1]
				y = rightRevealPnts[idxSillStartRevealRight][2]
				alpha = -(gs_trim_width_out - gs_trim_offs_out) * ArcLengthSillToAngle
				gosub 1000
				spx5 = x + gs_trim_thk_out * sin(alfaR)
				spy5 = y - gs_trim_thk_out * cos(alfaR)
			endif
		endif
	endif

	bCurvedAtWindowFrame	= (curvedWall & gs_IsCurved)

	put 0,WOD,900
	for i = idxSillEndPlasterLeft to idxSillStartPlasterLeft step -1
		put leftRevealPnts[i][1],	leftRevealPnts[i][2],	0
	next i
	put	spx4,	spy4,	0,
		spx5,	spy5,	3000 * curvedWall

	for i = idxSillStartPlasterRight to idxSillEndPlasterRight
		put rightRevealPnts[i][1],	rightRevealPnts[i][2],	0
	next i
	put leftRevealPnts[idxSillEndPlasterLeft][1],	leftRevealPnts[idxSillEndPlasterLeft][2],	3000 * (bCurvedAtWindowFrame)

	poly2_b nsp/3, 2+4+64, gs_trim_wallhole_pen_fg_out, gs_trim_wallhole_pen_bg_out,
		get(nsp)

	if not(gs_trim_atframe_out) & not(gs_sill_outside) then
		if curvedWall then
			R = sqr(spx4^2 + (spy4 - WOD)^2)

			vx = spx4
			vy = spy4 - WOD
			gosub 103	! Direction Angle
			alpha = angle

			vx = spx5
			vy = spy5 - WOD
			gosub 103	! Direction Angle
			beta = angle

			if abs(alpha - beta) > EPS then
				arc2 0,WOD, R, min(alpha,beta), max(alpha,beta)
			endif
		else
			line2 spx4, spy4, spx5, spy5
		endif
	endif
endif



! ==============================================================================
!	Draw Casing
! ==============================================================================

bShowJambExtHotspots = bShowAddHotspots

spx1 = leftRevealPnts[2][1]
spy1 = leftRevealPnts[2][2] - WOD

spx8 = rightRevealPnts[2][1]
spy8 = rightRevealPnts[2][2] - WOD

bpx3 = leftRevealPnts[idxBoardEndRevealLeft - 1][1]
bpy3 = leftRevealPnts[idxBoardEndRevealLeft - 1][2] - WOD

bpx10 = rightRevealPnts[idxBoardEndRevealRight - 1][1]
bpy10 = rightRevealPnts[idxBoardEndRevealRight - 1][2] - WOD


! ==============================================================================
!	Draw Inside Trim
! ==============================================================================

if bDrawInsideTrim then

	pen gs_trim_pen_cont_in

	line_property 2
	set fill gs_trim_fill_in
	if not(curvedWall) or (curvedWall & gs_trim_atframe_in = 1) then

		! ===== Inside Trim - Straight Walls =====

		py = WALL_THICKNESS - WIDO_SILL

		if not(bLeftCornerFunction) & not(gs_stack_left) then

			if gs_trim_width_in > EPS & bShowJambExtension & gs_trim_atframe_in = 0 then

				! ===== Inside Trim - Straight Walls - Jamb Extension - Left =====

				thk = WIDO_FRAME_THICKNESS

				px1 = leftRevealPnts[idxBoardEndRevealLeft-1][1] + tolerOffsetLeftIn
				px2 = leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn - gs_trim_jambext_nosing_in * tan(gs_reveal_left_angle)
				px3 = leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn - gs_trim_jambext_nosing_in * tan(gs_reveal_left_angle) + trinL * (1 - bInclinedWall) + trin2L * incH
				px4 = px1 + trinL

				py1 = thk * (gs_sectgar = 0)
				py2 = leftRevealPnts[idxBoardEndRevealLeft][2] + tolerOffsetLeftIn * incV + gs_trim_jambext_nosing_in
				py3 = leftRevealPnts[idxBoardEndRevealLeft][2] + (trin2L + tolerOffsetLeftIn) * incV + gs_trim_jambext_nosing_in
				py4 = thk * (gs_sectgar = 0)

				if bTelescopic then
					py1 = 0
					py4 = 0
					thk = 0
				endif

				! --- Casing Set Back on Sides ---
				if casingSetBackOnSides_in > EPS then
					py1 = py1 + casingSetBackOnSides_in
					py4 = py4 + casingSetBackOnSides_in
				endif

				set fill gs_trim_fill_in
				if py2 > thk & py3 > thk then
					poly2_b 4, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
						px1,	py1,	1 + 32,
						px2,	py2,	1 + 32,
						px3,	py3,	1 + 32,
						px4,	py4,	1 + 32

					if bShowEdgeHotspots | (bShowJambExtHotspots & gs_trim_offs_in > EPS) then
						hotspot2 	px3, py3, 10012
!!!						text2 		px3, py3, "10012"
					endif
				endif

				if bPShapedLeftOpening & not(bDrawLeftSLBoard) then

					! ===== Inside Trim - Straight Walls - Jamb Extension - Lower Left =====

					px1 = px3 + gs_sidelight_WHole_width_left
					px2 = px4 + gs_sidelight_WHole_width_left

					set fill gs_trim_wallhole_fill_in

					poly2_b 4, 1+2+4+64, gs_trim_wallhole_pen_sl_fg_in, gs_trim_wallhole_pen_sl_bg_in,
						px1,	py1,																1,
						px2,	py2 + incX * (gs_sidelight_WHole_width_left + gs_trim_width_in),	((gs_trim_offs_in > EPS) | not(gs_trim_show_cover_in)),
						px3,	py3,																1,
						px4,	py4,																1
				endif
			endif

			if gs_tw_left_in > EPS & gs_trim_thk_in > EPS & gs_trim_show_cover_in & gs_sectgar = 0 then

				! ===== Inside Trim - Straight Walls - Casing - Left =====

				set fill gs_trim_fill_in
				if bInclinedWall & gs_trim_atframe_in = 0 then
					px1 = leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn + gs_trim_width_in*0 + trin2L * incH - gs_trim_offs_in
					px2 = px1 - incH * gs_tw_left_in + incV * gs_trim_thk_in
					px3 = px1 - incH * gs_tw_left_in
					px4 = px1 - trthL * sin(trinfiL)

					py1 = py - incX * (-leftRevealPnts[idxBoardEndRevealLeft][1] - tolerOffsetLeftIn - gs_trim_width_in*0 + gs_trim_offs_in) + (trin2L + tolerOffsetLeftIn*0) * incV
					py2 = py1 - incV * gs_tw_left_in + incV * incX * gs_trim_thk_in
					py3 = py1 + gs_trim_thk_in / incH - incV * gs_tw_left_in
					py4 = py1 + gs_trim_thk_in / incH*0 + trthL * cos(trinfiL)

					poly2_b 4, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
						px1,	py1,	1 + 32,
						px2,	py2,	1 + 32,
						px3,	py3,	1 + 32,
						px4,	py4,	1 + 32

					if not(bShowEdgeHotspots) & bShowJambExtHotspots & gs_trim_offs_in < EPS then
						hotspot2 	px4, py4, 10012
!!!						text2 		px4, py4, "10012"
					endif
					if isWindow & bShowAddHotspots then
						hotspot2 	px3, py3, 10032
!!!						text2 		px3, py3, "10032"
					endif
					if not(isWindow) & bShowAddHotspots then
						hotspot2 	px3, py3, 10002
!!!						text2 		px3, py3, "10002"
					endif

					if bPShapedLeftOpening & not(bDrawLeftSLBoard) then
						! ===== Inside Trim - Straight Walls - Casing - Lower Left =====

						px1 = px4 + gs_sidelight_WHole_width_left

						set fill gs_trim_wallhole_fill_in

						poly2_b 4, 1+2+4+64, gs_trim_wallhole_pen_sl_fg_in, gs_trim_wallhole_pen_sl_bg_in,
							px4,	py1,	1,
							px4,	py4,	1,
							px1,	py4 + incX * gs_sidelight_WHole_width_left,	1,
							px1,	py1 + incX * gs_sidelight_WHole_width_left,	gs_trim_offs_in > EPS
					endif
				else
					px1 = leftRevealPnts[idxBoardEndRevealLeft-gs_trim_atframe_in][1] + tolerOffsetLeftIn + trinL - gs_trim_offs_in
					px2 = px1 - gs_tw_left_in
					px3 = px2
					px4 = px1 - gs_trim_thk_in * tan(trinfiL) * not(gs_trim_atframe_in)

					if gs_trim_atframe_in = 0 then
						py1 = WALL_THICKNESS - WIDO_SILL
					else
						py1 = leftRevealPnts[idxBoardEndRevealLeft-1][2]
					endif
					py2 = py1
					py3 = py1 + gs_trim_thk_in
					py4 = py1 + gs_trim_thk_in

					poly2_b 4, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
						px1,	py1,	1 + 32,
						px2,	py2,	1 + 32,
						px3,	py3,	1 + 32,
						px4,	py4,	1 + 32

					if not(bShowEdgeHotspots) & bShowJambExtHotspots & gs_trim_offs_in < EPS then
						hotspot2 	px1, py2, 10012
!!!						text2 		px1, py2, "10012"
					endif
					if isWindow & bShowAddHotspots then
						hotspot2	px3, py3, 10032
!!!						text2 		px3, py3, "10032"
					endif
					if not(isWindow) & bShowAddHotspots then
						hotspot2 	px3, py3, 10002
!!!						text2 		px3, py3, "10002"
					endif

					if bPShapedLeftOpening & not(bDrawLeftSLBoard) then
						! ===== Inside Trim - Straight Walls - Casing - Lower Left =====

						px1 = px4 + gs_sidelight_WHole_width_left

						set fill gs_trim_wallhole_fill_in

						poly2_b 4, 1+2+4+64, gs_trim_wallhole_pen_sl_fg_in, gs_trim_wallhole_pen_sl_bg_in,
							px4,	py1,	1,
							px4,	py4,	1,
							px1,	py4,	1,
							px1,	py1,	gs_trim_offs_in > EPS
					endif
				endif
			endif
		endif

		if not(bRightCornerFunction) & not(gs_stack_right)then

			set fill gs_trim_fill_in
			if gs_trim_width_in > EPS & bShowJambExtension & gs_trim_atframe_in = 0 then

				! ===== Inside Trim - Straight Walls - Jamb Extension - Right =====

				thk = WIDO_FRAME_THICKNESS

				px1 = rightRevealPnts[idxBoardEndRevealRight-1][1] - tolerOffsetRightIn
				px2 = rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn + gs_trim_jambext_nosing_in * tan(gs_reveal_right_angle)
				px3 = rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn + gs_trim_jambext_nosing_in * tan(gs_reveal_right_angle) - trinR * (1 - bInclinedWall) - trin2R * incH
				px4 = px1 - trinR

				py1 = thk * (gs_sectgar = 0)
				py2 = rightRevealPnts[idxBoardEndRevealRight][2] - tolerOffsetRightIn * incV + gs_trim_jambext_nosing_in
				py3 = rightRevealPnts[idxBoardEndRevealRight][2] - (trin2R + tolerOffsetRightIn) * incV + gs_trim_jambext_nosing_in
				py4 = thk * (gs_sectgar = 0)

				if bTelescopic then
					py1 = 0
					py4 = 0
					thk = 0
				endif

				! --- Casing Set Back on Sides ---
				if casingSetBackOnSides_in > EPS then
					py1 = py1 + casingSetBackOnSides_in
					py4 = py4 + casingSetBackOnSides_in
				endif

				if py2 > thk & py3 > thk then
					poly2_b 4, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
						px1,	py1,	1 + 32,
						px2,	py2,	1 + 32,
						px3,	py3,	1 + 32,
						px4,	py4,	1 + 32

					if bShowEdgeHotspots | (bShowJambExtHotspots & gs_trim_offs_in > EPS) then
						hotspot2 	px3, py3, 10013
!!!						text2 		px3, py3, "10013"
					endif
				endif

				if bPShapedRightOpening & not(bDrawRightSLBoard) then

					! ===== Inside Trim - Straight Walls - Jamb Extension - Lower Right =====

					px1 = px3 - gs_sidelight_WHole_width_right
					px2 = px4 - gs_sidelight_WHole_width_right

					set fill gs_trim_wallhole_fill_in

					poly2_b 4, 1+2+4+64, gs_trim_wallhole_pen_sl_fg_in, gs_trim_wallhole_pen_sl_bg_in,
						px1,	py1,																1,
						px2,	py2 - incX * (gs_sidelight_WHole_width_right + gs_trim_width_in),	((gs_trim_offs_in > EPS) | not(gs_trim_show_cover_in)),
						px3,	py3,																1,
						px4,	py4,																1
				endif
			endif

			if gs_tw_right_in > EPS & gs_trim_thk_in > EPS & gs_trim_show_cover_in & gs_sectgar = 0 then

				! ===== Inside Trim - Straight Walls - Casing - Right =====

				set fill gs_trim_fill_in
				if bInclinedWall & gs_trim_atframe_in = 0 then
					px1 = rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn + gs_trim_width_in*0 - trin2R * incH + gs_trim_offs_in
					px2 = px1 + incH * gs_tw_right_in + incV * gs_trim_thk_in
					px3 = px1 + incH * gs_tw_right_in
					px4 = px1 + trthR * sin(trinfiR)

					py1 = py + incX * px1
					py2 = py1 + incV * gs_tw_right_in + incV * incX * gs_trim_thk_in
					py3 = py1 + gs_trim_thk_in / incH + incV * gs_tw_right_in
					py4 = py1 + gs_trim_thk_in / incH*0 + trthR * cos(trinfiR)

					poly2_b 4, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
						px1,	py1,	1 + 32,
						px2,	py2,	1 + 32,
						px3,	py3,	1 + 32,
						px4,	py4,	1 + 32

					if not(bShowEdgeHotspots) & bShowJambExtHotspots & gs_trim_offs_in < EPS then
						hotspot2 	px4, py4, 10013
!!!						text2 		px4, py4, "10013"
					endif
					if isWindow & bShowAddHotspots then
						hotspot2 	px3, py3, 10033
!!!						text2 		px3, py3, "10033"
					endif
					if not(isWindow) & bShowAddHotspots then
						hotspot2 	px3, py3, 10003
!!!						text2 		px3, py3, "10003"
					endif

					if bPShapedRightOpening & not(bDrawRightSLBoard) then
						! ===== Inside Trim - Straight Walls - Casing - Lower Right =====

						px1 = px4 - gs_sidelight_WHole_width_right

						set fill gs_trim_wallhole_fill_in

						poly2_b 4, 1+2+4+64, gs_trim_wallhole_pen_sl_fg_in, gs_trim_wallhole_pen_sl_bg_in,
							px4,	py1,	1,
							px4,	py4,	1,
							px1,	py4 - incX * gs_sidelight_WHole_width_right,	1,
							px1,	py1 - incX * gs_sidelight_WHole_width_right,	gs_trim_offs_in > EPS
					endif
				else
					px1 = rightRevealPnts[idxBoardEndRevealright - gs_trim_atframe_in][1] - tolerOffsetRightIn - trinR + gs_trim_offs_in
					px2 = px1 + gs_tw_right_in
					px3 = px2
					px4 = px1 + gs_trim_thk_in * tan(trinfiR) * not(gs_trim_atframe_in)

					if gs_trim_atframe_in = 0 then
						py1 = WALL_THICKNESS - WIDO_SILL
					else
						py1 = rightRevealPnts[idxBoardEndRevealright-1][2]
					endif
					py2 = py1
					py3 = py1 + gs_trim_thk_in
					py4 = py1 + gs_trim_thk_in

					poly2_b 4, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
						px1,	py1,	1 + 32,
						px2,	py2,	1 + 32,
						px3,	py3,	1 + 32,
						px4,	py4,	1 + 32

					if not(bShowEdgeHotspots) & bShowJambExtHotspots & gs_trim_offs_in < EPS then
						hotspot2 	px1, py2, 10013
!!!						text2 		px1, py2, "10013"
					endif
					if isWindow & bShowAddHotspots then
						hotspot2 	px3, py3, 10033
!!!						text2 		px3, py3, "10033"
					endif
					if not(isWindow) & bShowAddHotspots then
						hotspot2 	px3, py3, 10003
!!!						text2 		px3, py3, "10003"
					endif

					if bPShapedRightOpening & not(bDrawRightSLBoard) then
						! ===== Inside Trim - Straight Walls - Casing - Lower Right =====

						px1 = px4 - gs_sidelight_WHole_width_right

						set fill gs_trim_wallhole_fill_in

						poly2_b 4, 1+2+4+64, gs_trim_wallhole_pen_sl_fg_in, gs_trim_wallhole_pen_sl_bg_in,
							px4,	py1,	1,
							px4,	py4,	1,
							px1,	py4,	1,
							px1,	py1,	gs_trim_offs_in > EPS
					endif
				endif
			endif
		endif

	else	! not(curvedWall)

		if bParalellInCurvedWalls = 0 then	! radial cutting in curved wall
			add2 0,WOD

			iSign = wallIsLeft - not(wallIsLeft)

			LengtToArc = iSign * 180 / rBoard / PI
			alfaTrimOffsetIn	= LengtToArc * gs_trim_offs_in
			alfaTrimWidthIn		= LengtToArc * gs_trim_width_in

			rBoardEdge = rBoard - iSign * gs_trim_thk_in
			rBoardJambNosing = rBoard - iSign * gs_trim_jambext_nosing_in

			if not(gs_stack_left) then

				if wallIsLeft then
					alfaLeftEdge = 180 + abs(alfaLeftIn)
				else
					alfaLeftEdge = -abs(alfaLeftIn)
				endif

				pyy1 = bpy3
				pyy2 = rBoard * cos(alfaLeftEdge)


				if gs_trim_show_cover_in then
					px1 = rBoard * sin(alfaLeftEdge - alfaTrimWidthIn) + tolerOffsetLeftIn
					py1 = ySign * sqr(rBoard^2 - px1^2)
				else
					px1 = rBoardJambNosing * sin(alfaLeftEdge - alfaTrimWidthIn) + tolerOffsetLeftIn
					py1 = ySign * sqr(rBoardJambNosing^2 - px1^2)
				endif

				px2 = rBoard * sin(alfaLeftEdge) + tolerOffsetLeftIn
				py2 = ySign * sqr((rBoard)^2 - px2^2)

				! --- Casing Set Back on Sides ---
				if casingSetBackOnSides_in > EPS then
					bpx3 = bpx3 + casingSetBackOnSides_in / tan(90 - alfaLeftEdge)
					pyy1 = pyy1 + casingSetBackOnSides_in
				endif

				if gs_trim_width_in > EPS & bShowJambExtension & (pyy1 < pyy2) then

					! ===== Inside Trim - Curved Walls - Jamb Extension - Left =====

					put bpx3 + tolerOffsetLeftIn, pyy1, 1 + 32

					if gs_IsCurved then
						xo = 0
						yo = 0
						ro = rBoard + iSign * (WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS)

						x1 = -iSign * gs_trim_width_in * cos(alfaLeftEdge)
						y1 =  iSign * gs_trim_width_in * sin(alfaLeftEdge)

						x2 = x1 + bpx3
						y2 = y1 + bpy3

						gosub 100

						put 0,  0,  901 + 32,
							xb, yb, 3001 + 32
					else

						! --- Casing Set Back on Sides ---
						if casingSetBackOnSides_in > EPS then
							bpy3 = bpy3 + casingSetBackOnSides_in
						endif

						put bpx3 + tolerOffsetLeftIn - iSign * gs_trim_width_in / cos(alfaLeftEdge),
							bpy3, 1 + 32
					endif

					put px1, py1, 1 + 32,
						0,0, 901 + 32,
						px2, py2, 3001 + 32

					poly2_b nsp/3, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in, get(nsp)

					if bShowEdgeHotspots | (bShowJambExtHotspots & gs_trim_offs_in > EPS) then
						hotspot2 	px1, py1, 10012
!!!						text2 		px1, py1, "10012"
					endif
				endif

				if bPShapedLeftOpening & not(bDrawLeftSLBoard) then
					! ===== Inside Trim - Curved Walls - Jamb Extension - Lower Left =====

					px1LSL = -leftWidth + gs_sidelight_WHole_width_left + gs_trim_width_in
					py1LSL = ABS(SQR(rBoard^2 - px1LSL^2))

					put px1,	py1,	gs_trim_offs_in > EPS,
						0,		0,		900,
						px1LSL, ySign * py1LSL, 3001,
						px1LSL, bpy3,	1,
						bpx3 + tolerOffsetLeftIn - iSign * gs_trim_width_in / cos(alfaLeftEdge), bpy3-1, 1,
						bpx3 + tolerOffsetLeftIn - iSign * gs_trim_width_in / cos(alfaLeftEdge), bpy3, 1

					bCasingIsInside = 1
					line2 px1LSL, bpy3, px1LSL - gs_trim_width_in, bpy3
					gosub "DrawSidelightCasingCurvedWall"
				endif


				if gs_tw_left_in > EPS & gs_trim_thk_in > EPS & gs_trim_show_cover_in then

					! ===== Inside Trim - Curved Walls - Casing - Left =====

					alfaLeftTrimWidth	= LengtToArc * gs_tw_left_in

					if wallIsLeft then
						rot2 180 - abs(alfaLeftIn) + alfaTrimWidthIn - alfaTrimOffsetIn
					else
						rot2 abs(alfaLeftIn) + alfaTrimWidthIn - alfaTrimOffsetIn
					endif

					poly2_b 6, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
						0, rBoardEdge, 1 + 32,
						0, rBoard, 1 + 32,
						0,0, 901 + 32,
						rBoard * sin(alfaLeftTrimWidth), rBoard * cos(alfaLeftTrimWidth), 3001 + 32,
						rBoardEdge * sin(alfaLeftTrimWidth), rBoardEdge * cos(alfaLeftTrimWidth), 1 + 32,
						0, rBoardEdge, 3001 + 32

					if not(bShowEdgeHotspots) & bShowJambExtHotspots & gs_trim_offs_in < EPS then
						hotspot2 	0, rBoardEdge, 10012
!!!						text2 		0, rBoardEdge, "10012"
					endif
					if isWindow & bShowAddHotspots then
						hotspot2 	rBoardEdge * sin(alfaLeftTrimWidth), rBoardEdge * cos(alfaLeftTrimWidth), 10032
!!!						text2 		rBoardEdge * sin(alfaLeftTrimWidth), rBoardEdge * cos(alfaLeftTrimWidth), "10032"
					endif
					if not(isWindow) & bShowAddHotspots then
						hotspot2 	rBoardEdge * sin(alfaLeftTrimWidth), rBoardEdge * cos(alfaLeftTrimWidth), 10002
!!!						text2 		rBoardEdge * sin(alfaLeftTrimWidth), rBoardEdge * cos(alfaLeftTrimWidth), "10002"
					endif

					del 1
				endif

				if bPShapedLeftOpening & not(bDrawLeftSLBoard) then
					! ===== Inside Trim - Curved Walls - Casing - Lower Left =====

					px1	= px1 + iSign * gs_trim_offs_in * cos(alfaLeftEdge)
					py1	= py1 + ySign * gs_trim_offs_in * sin(alfaLeftEdge)
					px2	= px1 - iSign * gs_trim_thk_in * sin(alfaLeftEdge)
					py2	= py1 + ySign * gs_trim_thk_in * cos(alfaLeftEdge)

					px1LSL = -leftWidth + gs_sidelight_WHole_width_left + gs_trim_width_in - gs_trim_offs_in
					py1LSL = SQR(rBoard^2 - px1LSL^2)
					px2LSL = px1LSL
					py2LSL = py1LSL + ySign * gs_trim_thk_in

					put px2, py2,	1,
						0,		0,		900,
						px2LSL, ySign * py2LSL, 3001,
						px1LSL, ySign * py1LSL, gs_trim_offs_in > EPS,
						px1, py1,	3001

					bCasingIsInside = 1
					gosub "DrawSidelightCasingCurvedWall"
				endif
			endif

			if not(gs_stack_right) then

				if wallIsLeft then
					alfaRightEdge = -180 - abs(alfaRightIn)
				else
					alfaRightEdge = abs(alfaRightIn)
				endif

				pyy1 = bpy10
				pyy2 = rBoard * cos(alfaRightEdge)


				if gs_trim_show_cover_in then
					px1 = rBoard * sin(alfaRightEdge + alfaTrimWidthIn)
					py1 = rBoard * cos(alfaRightEdge + alfaTrimWidthIn)
				else
					px1 = rBoardJambNosing * sin(alfaRightEdge + alfaTrimWidthIn)
					py1 = rBoardJambNosing * cos(alfaRightEdge + alfaTrimWidthIn)
				endif

				! --- Casing Set Back on Sides ---
				if casingSetBackOnSides_in > EPS then
					bpx10 = bpx10 + casingSetBackOnSides_in / tan(90 - alfaRightEdge)
					pyy1 = pyy1 + casingSetBackOnSides_in
				endif

				if gs_trim_width_in  > EPS & bShowJambExtension & (pyy1 < pyy2) then

					! ===== Inside Trim - Curved Walls - Jamb Extension - Right =====

					put bpx10,
						pyy1, 1 + 32

					if gs_IsCurved then
						xo = 0
						yo = 0
						ro = rBoard + iSign * (WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS)

						x1 = iSign * gs_trim_width_in * cos(alfaRightEdge)
						y1 = gs_trim_width_in * sin(alfaRightEdge)

						x2 = x1 + bpx10
						y2 = y1 + bpy10

						gosub 100

						put 0,  0,  901 + 32,
							xa, ya, 3001 + 32
					else
						! --- Casing Set Back on Sides ---
						if casingSetBackOnSides_in > EPS then
							bpy10 = bpy10 + casingSetBackOnSides_in
						endif

						put bpx10 + iSign * gs_trim_width_in / cos(alfaRightEdge),
							bpy10, 1 + 32
					endif


					put px1, py1, 1 + 32,
						0,0, 901 + 32,
						rBoard * sin(alfaRightEdge), pyy2, 3001 + 32

					poly2_b nsp/3, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in, get(nsp)

					if bShowEdgeHotspots | (bShowJambExtHotspots & gs_trim_offs_in > EPS) then
						hotspot2 	px1, py1, 10013
!!!						text2 		px1, py1, "10013"
					endif
				endif

				if bPShapedRightOpening & not(bDrawRightSLBoard) then
					! ===== Inside Trim - Curved Walls - Jamb Extension - Lower Right =====

					px1RSL = rightWidth - gs_sidelight_WHole_width_right - gs_trim_width_in
					py1RSL = SQR(rBoard^2 - px1RSL^2)

					put px1,	py1,	gs_trim_offs_in > EPS,
						0,		0,		900,
						px1RSL, ySign * py1RSL, 3001,
						px1RSL, pyy1,	1,
						bpx10 + iSign * gs_trim_width_in / cos(alfaRightEdge), bpy10 - 1, 1,
						bpx10 + iSign * gs_trim_width_in / cos(alfaRightEdge), bpy10, 1

					bCasingIsInside = 1
					line2 px1RSL, pyy1, px1RSL + gs_trim_width_in, pyy1
					gosub "DrawSidelightCasingCurvedWall"
				endif


				if gs_tw_right_in > EPS & gs_trim_thk_in > EPS & gs_trim_show_cover_in then

					! ===== Inside Trim - Curved Walls - Casing - Rignt =====

					alfaRightTrimWidth	= LengtToArc * gs_tw_right_in

					if wallIsLeft then
						rot2 180 + abs(alfaRightIn) - alfaTrimWidthIn + alfaTrimOffsetIn
					else
						rot2 -abs(alfaRightIn) - alfaTrimWidthIn + alfaTrimOffsetIn
					endif

					poly2_b 6, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
						0, rBoardEdge, 1 + 32,
						0, rBoard, 1 + 32,
						0,0, 901 + 32,
						rBoard * sin(-alfaRightTrimWidth), rBoard * cos(-alfaRightTrimWidth), 3001 + 32,
						rBoardEdge * sin(-alfaRightTrimWidth), rBoardEdge * cos(-alfaRightTrimWidth), 1 + 32,
						0, rBoardEdge, 3001 + 32

					if not(bShowEdgeHotspots) & bShowJambExtHotspots & gs_trim_offs_in < EPS then
						hotspot2 	0, rBoardEdge, 10013
!!!						text2 		0, rBoardEdge, "10013"
					endif
					if isWindow & bShowAddHotspots then
						hotspot2 	rBoardEdge * sin(-alfaRightTrimWidth), rBoardEdge * cos(-alfaRightTrimWidth), 10033
!!!						text2		rBoardEdge * sin(-alfaRightTrimWidth), rBoardEdge * cos(-alfaRightTrimWidth), "10033"
					endif
					if not(isWindow) & bShowAddHotspots then
						hotspot2 	rBoardEdge * sin(-alfaRightTrimWidth), rBoardEdge * cos(-alfaRightTrimWidth), 10003
!!!						text2 		rBoardEdge * sin(-alfaRightTrimWidth), rBoardEdge * cos(-alfaRightTrimWidth), "10003"
					endif

					del 1
				endif

				if bPShapedRightOpening & not(bDrawRightSLBoard) then
					! ===== Inside Trim - Curved Walls - Casing - Lower Right =====

					px1	= px1 - iSign * gs_trim_offs_in * cos(alfaRightEdge)
					py1	= py1 - ySign * gs_trim_offs_in * sin(alfaRightEdge)
					px2	= px1 - iSign * gs_trim_thk_in * sin(alfaRightEdge)
					py2	= py1 + ySign * gs_trim_thk_in * cos(alfaRightEdge)

					px1RSL = rightWidth - gs_sidelight_WHole_width_right - gs_trim_width_in + gs_trim_offs_in
					py1RSL = SQR(rBoard^2 - px1RSL^2)
					px2RSL = px1RSL
					py2RSL = py1RSL + ySign * gs_trim_thk_in

					put px2, py2,	1,
						0,		0,		900,
						px2RSL, ySign * py2RSL, 3001,
						px1RSL, ySign * py1RSL, gs_trim_offs_in > EPS,
						px1, py1,	3001

					bCasingIsInside = 1
					gosub "DrawSidelightCasingCurvedWall"
				endif
			endif

			del 1
		else	! parallel cutting in curved wall
			py = WALL_THICKNESS - WIDO_SILL

			if not(gs_stack_left) then
				if gs_trim_width_in > EPS & bShowJambExtension & gs_trim_atframe_in = 0 then

!					 ===== Inside Trim - Curved Walls - Jamb Extension - Left =====

					thk = WIDO_FRAME_THICKNESS

					px1 = leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn
					px2 = px1 + gs_trim_width_in

					py1 = ySign * sqr (rBoard^2 - (px1) ^2) + WOD
					py2 = ySign * sqr (rBoard^2 - (px1 + gs_trim_width_in) ^2) + WOD

					if py1 > WIDO_FRAME_THICKNESS & py2 > WIDO_FRAME_THICKNESS then
						poly2_b 4, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
							px1,	thk,	1 + 32,
							px1,	py1,	1 + 32,
							px2,	py2,	1 + 32,
							px2,	thk,	1 + 32

						if bShowJambExtHotspots & gs_trim_offs_in > EPS then
							hotspot2 	px2, py2, 10012
!!!							text2 		px2, py2, "10012"
						endif
					endif
				endif
			endif

			if not(gs_stack_right) then
				if gs_trim_width_in > EPS & bShowJambExtension & gs_trim_atframe_in = 0 then

!					 ===== Inside Trim - Curved Walls - Jamb Extension - Right =====

					thk = WIDO_FRAME_THICKNESS

					px1 = rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn
					px2 = px1 - gs_trim_width_in

					py1 = ySign * sqr (rBoard^2 - (px1) ^2) + WOD
					py2 = ySign * sqr (rBoard^2 - (px1 - gs_trim_width_in) ^2) + WOD

					if py1 > WIDO_FRAME_THICKNESS & py2 > WIDO_FRAME_THICKNESS then
						poly2_b 4, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
							px1,	thk,	1 + 32,
							px1,	py1,	1 + 32,
							px2,	py2,	1 + 32,
							px2,	thk,	1 + 32

						if bShowJambExtHotspots & gs_trim_offs_in > EPS then
							hotspot2 	px2, py2, 10012
!!!							text2 		px2, py2, "10012"
						endif
					endif
				endif
			endif

			add2 0,WOD

			iSign = wallIsLeft - not(wallIsLeft)

			alfaLeftParallel 	= abs (asn ( (leftRevealPnts[idxBoardEndRevealLeft][1] + gs_trim_width_in) / rBoard))
			alfaRightParallel 	= abs (asn ( (rightRevealPnts[idxBoardEndRevealRight][1] - gs_trim_width_in) / rBoard))

			LengtToArc = iSign * 180 / rBoard / PI
			alfaTrimOffsetIn	= LengtToArc * gs_trim_offs_in
			alfaTrimWidthIn		= LengtToArc * gs_trim_width_in

			rBoardEdge = rBoard - iSign * gs_trim_thk_in

			if not(gs_stack_left) then

				if wallIsLeft then
					alfaLeftEdge = 180 + abs(alfaLeft)
				else
					alfaLeftEdge = -abs(alfaLeft)
				endif

				pyy1 = bpy3
				pyy2 = rBoard * cos(alfaLeftEdge)

				if gs_tw_left_in > EPS & gs_trim_thk_in > EPS then

					! ===== Inside Trim - Curved Walls - Casing - Left =====

					alfaLeftTrimWidth	= LengtToArc * gs_tw_left_in

					if wallIsLeft then
						rot2 180
					else
						rot2 0
					endif

					px1 =  ySign * (leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn + gs_trim_width_in - gs_trim_offs_in)
					px2 = -ySign * (rBoard * sin(alfaLeftParallel - ySign * (alfaLeftTrimWidth + alfaTrimOffsetIn)) - tolerOffsetLeftIn)
					px3 = -ySign * (rBoardEdge * sin(alfaLeftParallel - ySign * (alfaLeftTrimWidth + alfaTrimOffsetIn)) - tolerOffsetLeftIn)

					py1 = sqr(rBoard^2 - px1^2)
					py2 = sqr(rBoard^2 - px2^2)
					py3 = sqr(rBoardEdge^2 - px3^2)
					py4 = sqr(rBoardEdge^2 - px1^2)

					poly2_b 6, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
						px1, py4, 1 + 32,
						px1, py1, 1 + 32,
						0, 0, 901 + 32,
						px2, py2, 3001 + 32,
						px3, py3, 1 + 32,
						px1, py4, 3001 + 32

					if bShowJambExtHotspots & gs_trim_offs_in < EPS then
						hotspot2 	px1, py4, 10012
!!!						text2 		px1, py4, "10012"
					endif
					if isWindow & bShowAddHotspots then
						hotspot2 	px2, py2, 10032
!!!						text2 		px2, py2, "10032"
					endif
					if not(isWindow) & bShowAddHotspots then
						hotspot2 	px3, py3, 10002
!!!						text2 		px3, py3, "10002"
					endif

					del 1
				endif
			endif

			if not(gs_stack_right) then

				if wallIsLeft then
					alfaRightEdge = -180 - abs(alfaRight)
				else
					alfaRightEdge = abs(alfaRight)
				endif

				pyy1 = bpy10
				pyy2 = rBoard * cos(alfaRightEdge)

				if gs_tw_right_in > EPS & gs_trim_thk_in > EPS then

					! ===== Inside Trim - Curved Walls - Casing - Rignt =====

					alfaRightTrimWidth	= LengtToArc * gs_tw_right_in

					if wallIsLeft then
						rot2 180
					else
						rot2 0
					endif

					px1 = ySign * (rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn - gs_trim_width_in + gs_trim_offs_in)
					px2 = ySign * (rBoard * sin(alfaRightParallel - ySign * (alfaRightTrimWidth + alfaTrimOffsetIn)) - tolerOffsetRightIn)
					px3 = ySign * (rBoardEdge * sin(alfaRightParallel - ySign * (alfaRightTrimWidth + alfaTrimOffsetIn)) - tolerOffsetRightIn)

					py1 = sqr(rBoard^2 - px1^2)
					py2 = sqr(rBoard^2 - px2^2)
					py3 = sqr(rBoardEdge^2 - px3^2)
					py4 = sqr(rBoardEdge^2 - px1^2)

					poly2_b 6, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
						px1, py4, 1 + 32,
						px1, py1, 1 + 32,
						0, 0, 901 + 32,
						px2, py2, 3001 + 32,
						px3, py3, 1 + 32,
						px1, py4, 3001 + 32

					if bShowJambExtHotspots & gs_trim_offs_in < EPS then
						hotspot2 	px1, py4, 10013
!!!						text2 		px1, py4, "10013"
					endif
					if isWindow & bShowAddHotspots then
						hotspot2 	px2, py2, 10033
!!!						text2 		px2, py2, "10033"
					endif
					if not(isWindow) & bShowAddHotspots then
						hotspot2 	px3, py3, 10003
!!!						text2 		px3, py3, "10003"
					endif

					del 1
				endif
			endif

			del 1
		endif
	endif	! not(curvedWall)

	if gs_stack_left & gs_trim_stack_left = 1 then
		if (tolerOffsStackCasLeftIn + trinL - gs_trim_offs_in) > EPS & gs_trim_thk_in > EPS then

			! ===== Inside Trim - Straight Walls - Casing at Ganging - Left =====
			px1 = leftRevealPnts[idxBoardEndRevealLeft-1][1] + tolerOffsStackCasLeftIn + trinL - gs_trim_offs_in
			px2 = leftRevealPnts[idxBoardEndRevealLeft-1][1]
			px3 = px2 - gs_trim_thk_in * tan(alfaLeft) * ySign

			py1 = leftRevealPnts[idxBoardEndRevealLeft-1][2]
			py2 = py1 + gs_trim_thk_in

			poly2_b 4, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
				px1,	py1,	1 + 32,
				px2,	py1,	0 + 32,
				px3,	py2,	1 + 32,
				px1,	py2,	1 + 32

			if bShowJambExtHotspots & gs_trim_offs_in < EPS then
				hotspot2 	px1, py2, 10012
!!!				text2 		px1, py2, "10012"
			endif
			if isWindow & bShowAddHotspots then
				hotspot2 	px2, py2, 10032
!!!				text2 		px2, py2, "10032"
			endif
			if not(isWindow) & bShowAddHotspots then
				hotspot2 	px2, py2, 10002
!!!				text2 		px2, py2, "10002"
			endif
		endif
	endif

	if gs_stack_right & gs_trim_stack_right = 1 then
		if (tolerOffsStackCasRightIn + trinR - gs_trim_offs_in) > EPS & gs_trim_thk_in > EPS then

			! ===== Inside Trim - Straight Walls - Casing at Ganging - Right =====

			px1 = rightRevealPnts[idxBoardEndRevealRight-1][1] - tolerOffsStackCasRightIn - trinR + gs_trim_offs_in
			px2 = rightRevealPnts[idxBoardEndRevealRight-1][1]
			px3 = px2 + gs_trim_thk_in * tan(alfaRight) * ySign

			py1 = rightRevealPnts[idxBoardEndRevealRight-1][2]
			py2 = py1 + gs_trim_thk_in

			poly2_b 4, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
				px1,	py1,	1 + 32,
				px2,	py1,	0 + 32,
				px3,	py2,	1 + 32,
				px1,	py2,	1 + 32

			if bShowJambExtHotspots & gs_trim_offs_in < EPS then
				hotspot2 	px1, py2, 10013
!!!				text2 		px1, py2, "10013"
			endif
			if isWindow & bShowAddHotspots then
				hotspot2 	px2, py2, 10033
!!!				text2 		px2, py2, "10033"
			endif
			if not(isWindow) & bShowAddHotspots then
				hotspot2 	px2, py2, 10003
!!!				text2 		px2, py2, "10003"
			endif
		endif
	endif
endif


! ==============================================================================
!	Draw Outside Trim
! ==============================================================================

if bDrawOutsideTrim then

	pen gs_trim_pen_cont_out
	set fill gs_trim_fill_out
	line_property 2

	! --- Draw Trim Outside ---
	if not(curvedWall) or (curvedWall & gs_trim_atframe_out =1) then

		if not(bLeftCornerFunction) & not(gs_stack_left) then

!			add2 widoLeftJamb,0

			if gs_trim_width_out > EPS & (((WIDO_SILL > EPS) & (gs_trim_show_cover_out)) | not(gs_trim_show_cover_out)) & bShowJambExtension & gs_trim_atframe_out = 0 then

				! ===== Outside Trim - Straight Walls - Jamb Extension - Left =====

				px1 = leftRevealPnts[idxSillStartRevealLeft][1] + tolerOffsetLeftOut
				px2 = px1 + gs_trim_width_out

				py1 = leftRevealPnts[idxSillStartRevealLeft][2] - gs_trim_jambext_nosing_out
				py2 = leftRevealPnts[idxSillEndRevealLeft][2]

				! --- Casing Set Back on Sides ---
				if casingSetBackOnSides_out > EPS then
					py2 = py2 - casingSetBackOnSides_out
				endif

				poly2_b 4, 1+2+4+32, gs_trim_pen_fg_out, gs_trim_pen_bg_out,
					px1,	py1,	1 + 32,
					px1,	py2,	1 + 32,
					px2,	py2,	1 + 32,
					px2,	py1,	1 + 32

				if bShowEdgeHotspots | (bShowJambExtHotspots & gs_trim_offs_out > EPS) then
					hotspot2 	px2, py1, 10010
!!!					text2 		px2, py1, "10010"
				endif

				if bPShapedLeftOpening & not(bDrawLeftSLSill) then

					! ===== Outside Trim - Straight Walls - Jamb Extension - Lower Left =====

					px1 = px2 + gs_sidelight_WHole_width_left

					set fill gs_trim_wallhole_fill_out

					poly2_b 4, 1+2+4+64, gs_trim_wallhole_pen_sl_fg_out, gs_trim_wallhole_pen_sl_bg_out,
						px2,	py1,	1,
						px2,	py2,	1,
						px1,	py2,	1,
						px1,	py1,	((gs_trim_offs_out > EPS) | not(gs_trim_show_cover_out))
				endif
			endif

			set fill gs_trim_fill_out
			if gs_trim_width_out > EPS & bShowJambExtension & gs_sectgar then

				! ===== Outside Trim - Straight Walls - Jamb Extension - Left - SectionGarage =====

				px1 = leftRevealPnts[idxBoardEndRevealLeft-1][1] + tolerOffsetLeftIn
				px2 = px1 + gs_trim_width_out

				py1 = leftRevealPnts[idxSillEndRevealLeft][2]
				py2 = leftRevealPnts[idxBoardEndRevealLeft][2]

				poly2_b 4, 1+2+4+32, gs_trim_pen_fg_out, gs_trim_pen_bg_out,
					px1,	py1,	1 + 32,
					px1,	py2,	1 + 32,
					px2,	py2,	1 + 32,
					px2,	py1,	1 + 32

				if bShowJambExtHotspots & gs_trim_offs_out > EPS then
					hotspot2 	px2, -WIDO_SILL, 10010
!!!					text2 		px2, -WIDO_SILL, "10010"
				endif
			endif

			if gs_tw_left_out > EPS & gs_trim_thk_out > EPS & gs_trim_show_cover_out then

				! ===== Outside Trim - Straight Walls - Casing - Left =====

				px1 = leftRevealPnts[idxSillStartRevealLeft][1] + tolerOffsetLeftOut + gs_trim_width_out - gs_trim_offs_out
				px2 = px1 - gs_tw_left_out

				if gs_trim_atframe_out = 0 then
					py1 = -WIDO_SILL
					py2 = -WIDO_SILL - gs_trim_thk_out
				else
					py1 = leftRevealPnts[2][2]
					py2 = py1 - gs_trim_thk_out
				endif

				poly2_b 4, 1+2+4+32, gs_trim_pen_fg_out, gs_trim_pen_bg_out,
					px1,	py1,	1 + 32,
					px2,	py1,	1 + 32,
					px2,	py2,	1 + 32,
					px1,	py2,	1 + 32

				if not(bShowEdgeHotspots) & bShowJambExtHotspots & gs_trim_offs_out < EPS then
					hotspot2 	px1, py2, 10010
!!!					text2 		px1, py2, "10010"
				endif
				if isWindow & bShowAddHotspots then
					hotspot2 	px2, py2, 10030
!!!					text2 		px2, py2, "10030"
				endif
				if not(isWindow) & bShowAddHotspots then
					hotspot2 	px2, py2, 10000
!!!					text2 		px2, py2, "10000"
				endif

				if bPShapedLeftOpening & not(bDrawLeftSLSill) then

					! ===== Outside Trim - Straight Walls - Casing - Lower Left =====
					px2 = px1
					px1 = px1 + gs_sidelight_WHole_width_left

					set fill gs_trim_wallhole_fill_out

					poly2_b 4, 1+2+4+64, gs_trim_wallhole_pen_sl_fg_out, gs_trim_wallhole_pen_sl_bg_out,
						px2,	py1,	1,
						px2,	py2,	1,
						px1,	py2,	1,
						px1,	py1,	gs_trim_offs_out > EPS
				endif
			endif

!			del 1
		endif

		set fill gs_trim_fill_out
		if not(bRightCornerFunction) & not(gs_stack_right) then

!			add2 -widoRightJamb,0

			if gs_trim_width_out > EPS & (((WIDO_SILL > EPS) & (gs_trim_show_cover_out)) | not(gs_trim_show_cover_out)) & bShowJambExtension & gs_trim_atframe_out = 0 then

				! ===== Outside Trim - Straight Walls - Jamb Extension - Right =====

				px1 = rightRevealPnts[idxSillStartRevealRight][1] - tolerOffsetRightOut
				px2 = px1 - gs_trim_width_out

				py1 = rightRevealPnts[idxSillStartRevealRight][2] - gs_trim_jambext_nosing_out
				py2 = rightRevealPnts[idxSillEndRevealRight][2]

				! --- Casing Set Back on Sides ---
				if casingSetBackOnSides_out > EPS then
					py2 = py2 - casingSetBackOnSides_out
				endif

				poly2_b 4, 1+2+4+32, gs_trim_pen_fg_out, gs_trim_pen_bg_out,
					px1,	py1,	1 + 32,
					px1,	py2,	1 + 32,
					px2,	py2,	1 + 32,
					px2,	py1,	1 + 32

				if bShowEdgeHotspots | (bShowJambExtHotspots & gs_trim_offs_out > EPS) then
					hotspot2 	px2, py1, 10011
!!!					text2 		px2, py1, "10011"
				endif

				if bPShapedRightOpening & not(bDrawRightSLSill) then

					! ===== Outside Trim - Straight Walls - Jamb Extension - Lower Right =====

					px1 = px2 - gs_sidelight_WHole_width_right

					set fill gs_trim_wallhole_fill_out

					poly2_b 4, 1+2+4+64, gs_trim_wallhole_pen_sl_fg_out, gs_trim_wallhole_pen_sl_bg_out,
						px2,	py1,	1,
						px2,	py2,	1,
						px1,	py2,	1,
						px1,	py1,	((gs_trim_offs_out > EPS) | not(gs_trim_show_cover_out))
				endif
			endif

			set fill gs_trim_fill_out
			if gs_trim_width_out > EPS & bShowJambExtension & gs_sectgar then

				! ===== Outside Trim - Straight Walls - Jamb Extension - Right - SectionGarage =====

				px1 = rightRevealPnts[idxBoardEndRevealright-1][1] - tolerOffsetrightIn
				px2 = px1 - gs_trim_width_out

				py1 = rightRevealPnts[idxSillEndRevealright][2]
				py2 = rightRevealPnts[idxBoardEndRevealright][2]

				poly2_b 4, 1+2+4+32, gs_trim_pen_fg_out, gs_trim_pen_bg_out,
					px1,	py1,	1 + 32,
					px1,	py2,	1 + 32,
					px2,	py2,	1 + 32,
					px2,	py1,	1 + 32

				if bShowJambExtHotspots & gs_trim_offs_out > EPS then
					hotspot2 	px2, -WIDO_SILL, 10010
!!!					text2 		px2, -WIDO_SILL, "10010"
				endif
			endif

			if gs_tw_right_out > EPS & gs_trim_thk_out > EPS & gs_trim_show_cover_out then

				! ===== Outside Trim - Straight Walls - Casing - Right =====

				px1 = rightRevealPnts[2][1] - tolerOffsetRightOut - gs_trim_width_out + gs_trim_offs_out
				px2 = px1 + gs_tw_right_out

				if gs_trim_atframe_out = 0 then
					py1 = -WIDO_SILL
					py2 = -WIDO_SILL - gs_trim_thk_out
				else
					py1 = leftRevealPnts[2][2]
					py2 = leftRevealPnts[2][2] - gs_trim_thk_out
				endif

				poly2_b 4, 1+2+4+32, gs_trim_pen_fg_out, gs_trim_pen_bg_out,
					 px1,	py1,	1 + 32,
					 px2,	py1,	1 + 32,
					 px2,	py2,	1 + 32,
					 px1,	py2,	1 + 32

				if not(bShowEdgeHotspots) & bShowJambExtHotspots & gs_trim_offs_out < EPS then
					hotspot2 	px1, py2, 10011
!!!					text2 		px1, py2, "10011"
				endif
				if isWindow & bShowAddHotspots then
					hotspot2 	px2, py2, 10031
!!!					text2 		px2, py2, "10031"
				endif
				if not(isWindow) & bShowAddHotspots then
					hotspot2 	px2, py2, 10001
!!!					text2 		px2, py2, "10001"
				endif

				if bPShapedRightOpening & not(bDrawRightSLSill) then

					! ===== Outside Trim - Straight Walls - Casing - Lower Right =====

					px2 = px1
					px1 = px1 - gs_sidelight_WHole_width_right

					set fill gs_trim_wallhole_fill_out

					poly2_b 4, 1+2+4+64, gs_trim_wallhole_pen_sl_fg_out, gs_trim_wallhole_pen_sl_bg_out,
						px2,	py1,	1,
						px2,	py2,	1,
						px1,	py2,	1,
						px1,	py1,	gs_trim_offs_out > EPS
				endif
			endif

!			del 1
		endif

	else	! not(curvedWall)

		if bParalellInCurvedWalls = 0 then		! Radial cutting
			! ===== Outside Trim - Curved Walls =====

			add2 0,WOD

			iSign = wallIsLeft - not(wallIsLeft)

			LengtToArc = iSign * 180 / rSill / PI
			alfaTrimOffsetOut	= LengtToArc * gs_trim_offs_out
			alfaTrimWidthOut	= LengtToArc * gs_trim_width_out

			alfaTolerOffsetLeftOut	= LengtToArc * tolerOffsetLeftOut
			alfaTolerOffsetRightOut	= LengtToArc * tolerOffsetRightOut

			rSillEdge = rSill + iSign * gs_trim_thk_out
			rSillJambNosing = rSill + iSign * gs_trim_jambext_nosing_out

			if not(gs_stack_left) then

				if wallIsLeft then
					alfaLeftEdge = 180 + abs(alfaLeft) - iSign * alfaLeftJamb
				else
					alfaLeftEdge = -abs(alfaLeft) - iSign * alfaLeftJamb
				endif

				pyy1 = spy1
				pyy2 = rSill * cos(alfaLeftEdge)

				if gs_trim_show_cover_out then
					px1 = rSill * sin(alfaLeftEdge - alfaTrimWidthOut)
					py1 = rSill * cos(alfaLeftEdge - alfaTrimWidthOut)
				else
					px1 = rSillJambNosing * sin(alfaLeftEdge - alfaTrimWidthOut)
					py1 = rSillJambNosing * cos(alfaLeftEdge - alfaTrimWidthOut)
				endif

				! --- Casing Set Back on Sides ---
				if casingSetBackOnSides_out > EPS then
					spx1 = spx1 - casingSetBackOnSides_out / tan(90 - alfaLeftEdge)
					pyy1 = pyy1 - casingSetBackOnSides_out
				endif

				if gs_trim_width_out > EPS & bShowJambExtension then

					! ===== Outside Trim - Curved Walls - Jamb Extension - Left =====

					put spx1,
						pyy1, 1 + 32

					if gs_IsCurved then
						xo = 0
						yo = 0
						ro = rSill - iSign * WIDO_SILL

						x1 = -iSign * gs_trim_width_out * cos(alfaLeftEdge)
						y1 =  iSign * gs_trim_width_out * sin(alfaLeftEdge)

						x2 = x1 + spx1
						y2 = y1 + spy1

						gosub 100

						put 0,0,901 + 32,
							xb, yb, 3001 + 32
					else

						! --- Casing Set Back on Sides ---
						if casingSetBackOnSides_out > EPS then
							spy1 = spy1 - casingSetBackOnSides_out
						endif

						put spx1 - iSign * gs_trim_width_out / cos(alfaLeftEdge),
							spy1, 1 + 32
					endif

					put px1, py1, 1 + 32,
						0,0, 901 + 32,
						rSill * sin(alfaLeftEdge), pyy2, 3001 + 32

					poly2_b nsp/3, 1+2+4+32, gs_trim_pen_fg_out, gs_trim_pen_bg_out, get(nsp)

					if bShowEdgeHotspots | (bShowJambExtHotspots & gs_trim_offs_out > EPS) then
						hotspot2 	px1, py1, 10010
!!!						text2 		px1, py1, "10010"
					endif
				endif

				if bPShapedLeftOpening & not(bDrawLeftSLSill) then
					! ===== Outside Trim - Curved Walls - Jamb Extension - Lower Left =====

					px1LSL = -leftWidth + gs_reveal_left_sL + gs_sidelight_WHole_width_left + gs_trim_width_out
					py1LSL = ABS(SQR(rSill^2 - px1LSL^2))

					put px1,	py1,	gs_trim_offs_out > EPS,
						0,		0,		900,
						px1LSL, ySign * py1LSL, 3001,
						px1LSL, spy1,	1,
						spx1 - tolerOffsetLeftOut - iSign * gs_trim_width_out / cos(alfaLeftEdge), spy1+1, 1,
						spx1 - tolerOffsetLeftIn - iSign * gs_trim_width_out / cos(alfaLeftEdge), spy1, 1

					bCasingIsInside = 0
					line2 px1LSL, spy1, px1LSL - gs_trim_width_out, spy1
					gosub "DrawSidelightCasingCurvedWall"
				endif


				if gs_tw_left_out > EPS & gs_trim_thk_out > EPS & gs_trim_show_cover_out then

					! ===== Outside Trim - Curved Walls - Casing - Left =====

					alfaLeftTrimWidth	= LengtToArc * gs_tw_left_out

					if wallIsLeft then
						rot2 180 - abs(alfaLeft) + alfaTrimWidthOut - alfaTrimOffsetOut + iSign * alfaLeftJamb
					else
						rot2 abs(alfaLeft) + alfaTrimWidthOut - alfaTrimOffsetOut + iSign * alfaLeftJamb
					endif

					poly2_b 6, 1+2+4+32, gs_trim_pen_fg_out, gs_trim_pen_bg_out,
						0, rSillEdge, 1 + 32,
						0, rSill, 1 + 32,
						0,0, 901 + 32,
						rSill * sin(alfaLeftTrimWidth), rSill * cos(alfaLeftTrimWidth), 3001 + 32,
						rSillEdge * sin(alfaLeftTrimWidth), rSillEdge * cos(alfaLeftTrimWidth), 1 + 32,
						0, rSillEdge, 3001 + 32

					if not(bShowEdgeHotspots) & bShowJambExtHotspots & gs_trim_offs_out < EPS then
						hotspot2 	0, rSillEdge, 10010
!!!						text2 		0, rSillEdge, "10010"
					endif
					if isWindow & bShowAddHotspots then
						hotspot2 	rSillEdge * sin(alfaLeftTrimWidth), rSillEdge * cos(alfaLeftTrimWidth), 10030
!!!						text2 		rSillEdge * sin(alfaLeftTrimWidth), rSillEdge * cos(alfaLeftTrimWidth), "10030"
					endif
					if not(isWindow) & bShowAddHotspots then
						hotspot2 	rSillEdge * sin(alfaLeftTrimWidth), rSillEdge * cos(alfaLeftTrimWidth), 10000
!!!						text2 		rSillEdge * sin(alfaLeftTrimWidth), rSillEdge * cos(alfaLeftTrimWidth), "10000"
					endif

					del 1
				endif

				if bPShapedLeftOpening & not(bDrawLeftSLSill) then
					! ===== Outside Trim - Curved Walls - Casing - Lower Left =====

					px1	= px1 + iSign * gs_trim_offs_out * cos(alfaLeftEdge)
					py1	= py1 + ySign * gs_trim_offs_out * sin(alfaLeftEdge)
					px2	= px1 + iSign * gs_trim_thk_out * sin(alfaLeftEdge)
					py2	= py1 - ySign * gs_trim_thk_out * cos(alfaLeftEdge)

					px1LSL = -leftWidth + gs_reveal_left_sL + gs_sidelight_WHole_width_left + gs_trim_width_out - gs_trim_offs_out
					py1LSL = SQR(rSill^2 - px1LSL^2)
					px2LSL = px1LSL
					py2LSL = py1LSL - ySign * gs_trim_thk_out

					put px2, py2,	1,
						0,		0,		900,
						px2LSL, ySign * py2LSL, 3001,
						px1LSL, ySign * py1LSL, gs_trim_offs_out > EPS,
						px1, py1,	3001

					bCasingIsInside = 0
					gosub "DrawSidelightCasingCurvedWall"
				endif
			endif

			if not(gs_stack_right) then

				if wallIsLeft then
					alfaRightEdge = -180 - abs(alfaRight) + iSign * alfaRightJamb
				else
					alfaRightEdge = abs(alfaRight) + iSign * alfaRightJamb
				endif

				pyy1 = spy8
				pyy2 = rSill * cos(alfaRightEdge)

				if gs_trim_show_cover_out then
					px1 = rSill * sin(alfaRightEdge + alfaTrimWidthOut)
					py1 = rSill * cos(alfaRightEdge + alfaTrimWidthOut)
				else
					px1 = rSillJambNosing * sin(alfaRightEdge + alfaTrimWidthOut)
					py1 = rSillJambNosing * cos(alfaRightEdge + alfaTrimWidthOut)
				endif

				! --- Casing Set Back on Sides ---
				if casingSetBackOnSides_out > EPS then
					spx8 = spx8 - casingSetBackOnSides_out / tan(90 - alfaRightEdge)
					pyy1 = pyy1 - casingSetBackOnSides_out
				endif

				if gs_trim_width_out > EPS & bShowJambExtension then

					! ===== Outside Trim - Curved Walls - Jamb Extension - Right =====

					put spx8,
						pyy1, 1 + 32

					if gs_IsCurved then
						xo = 0
						yo = 0
						ro = rSill - iSign * WIDO_SILL

						x1 = iSign * gs_trim_width_out * cos(alfaRightEdge)
						y1 = gs_trim_width_out * sin(alfaRightEdge)

						x2 = x1 + spx8
						y2 = y1 + spy8

						gosub 100

						put 0,0,901 + 32,
							xa, ya, 3001 + 32
					else

						! --- Casing Set Back on Sides ---
						if casingSetBackOnSides_out > EPS then
							spy8 = spy8 - casingSetBackOnSides_out
						endif

						put spx8 + iSign * gs_trim_width_out / cos(alfaRightEdge),
							spy8, 1 + 32
					endif

					put px1, py1, 1 + 32,
						0,0, 901 + 32,
						rSill * sin(alfaRightEdge), pyy2, 3001 + 32

					poly2_b nsp/3, 1+2+4+32, gs_trim_pen_fg_out, gs_trim_pen_bg_out, get(nsp)

					if bShowEdgeHotspots | (bShowJambExtHotspots & gs_trim_offs_out > EPS) then
						hotspot2 	px1, py1, 10011
!!!						text2 		px1, py1, "10011"
					endif
				endif

				if bPShapedRightOpening & not(bDrawRightSLSill) then
					! ===== Outside Trim - Curved Walls - Jamb Extension - Lower Right =====

					px1RSL = rightWidth - gs_reveal_right_sR - gs_sidelight_WHole_width_right - gs_trim_width_out
					py1RSL = ABS(SQR(rSill^2 - px1RSL^2))

					put px1,	py1,	gs_trim_offs_out > EPS,
						0,		0,		900,
						px1RSL, ySign * py1RSL, 3001,
						px1RSL, spy8,	1,
						spx8 + iSign * gs_trim_width_out / cos(alfaRightEdge), spy8+1, 1,
						spx8 + iSign * gs_trim_width_out / cos(alfaRightEdge), spy8, 1

					bCasingIsInside = 0
					line2 px1RSL, spy8, px1RSL + gs_trim_width_out, spy8
					gosub "DrawSidelightCasingCurvedWall"
				endif


				if gs_tw_right_out > EPS & gs_trim_thk_out > EPS & gs_trim_show_cover_out then

					! ===== Outside Trim - Curved Walls - Casing - Right =====

					alfaRightTrimWidth	= LengtToArc * gs_tw_right_out

					if wallIsLeft then
						rot2 180 + abs(alfaRight) - alfaTrimWidthOut + alfaTrimOffsetOut - iSign * alfaRightJamb
					else
						rot2 -abs(alfaRight) - alfaTrimWidthOut + alfaTrimOffsetOut - iSign * alfaRightJamb
					endif

					poly2_b 6, 1+2+4+32, gs_trim_pen_fg_out, gs_trim_pen_bg_out,
						0, rSillEdge, 1 + 32,
						0, rSill, 1 + 32,
						0,0, 901 + 32,
						rSill * sin(-alfaRightTrimWidth), rSill * cos(-alfaRightTrimWidth), 3001 + 32,
						rSillEdge * sin(-alfaRightTrimWidth), rSillEdge * cos(-alfaRightTrimWidth), 1 + 32,
						0, rSillEdge, 3001 + 32

					if not(bShowEdgeHotspots) & bShowJambExtHotspots & gs_trim_offs_out < EPS then
						hotspot2 	0, rSillEdge, 10011
!!!						text2 		0, rSillEdge, "10011"
					endif
					if isWindow & bShowAddHotspots then
						hotspot2 	rSillEdge * sin(-alfaRightTrimWidth), rSillEdge * cos(-alfaRightTrimWidth), 10031
!!!						text2 		rSillEdge * sin(-alfaRightTrimWidth), rSillEdge * cos(-alfaRightTrimWidth), "10031"
					endif
					if not(isWindow) & bShowAddHotspots then
						hotspot2 	rSillEdge * sin(-alfaRightTrimWidth), rSillEdge * cos(-alfaRightTrimWidth), 10001
!!!						text2 		rSillEdge * sin(-alfaRightTrimWidth), rSillEdge * cos(-alfaRightTrimWidth), "10001"
					endif

					del 1
				endif
				if bPShapedRightOpening & not(bDrawRightSLSill) then
					! ===== Outside Trim - Curved Walls - Casing - Lower Right =====

					px1	= px1 - iSign * gs_trim_offs_out * cos(alfaRightEdge)
					py1	= py1 - ySign * gs_trim_offs_out * sin(alfaRightEdge)
					px2	= px1 + iSign * gs_trim_thk_out * sin(alfaRightEdge)
					py2	= py1 - ySign * gs_trim_thk_out * cos(alfaRightEdge)

					px1RSL = rightWidth - gs_reveal_right_sR - gs_sidelight_WHole_width_right - gs_trim_width_out + gs_trim_offs_out
					py1RSL = SQR(rSill^2 - px1RSL^2)
					px2RSL = px1RSL
					py2RSL = py1RSL - ySign * gs_trim_thk_out

					put px2, py2,	1,
						0,		0,		900,
						px2RSL, ySign * py2RSL, 3001,
						px1RSL, ySign * py1RSL, gs_trim_offs_out > EPS,
						px1, py1,	3001

					bCasingIsInside = 0
					gosub "DrawSidelightCasingCurvedWall"
				endif
			endif

			del 1
		else		! Parallel cutting in curved wall
			if not(gs_stack_left) then

				add2 widoLeftJamb,0

				if gs_trim_width_out > EPS & WIDO_SILL > EPS & bShowJambExtension & gs_trim_atframe_out = 0 then

					! ===== Outside Trim - Straight Walls - Jamb Extension - Left =====

					px1 = -leftWidth
					px2 = px1 + gs_trim_width_out

					py1 = leftRevealPnts[idxSillStartRevealLeft][2]
					py2 = ySign * sqr (rSill^2 - (leftRevealPnts[idxSillStartRevealLeft][1] + gs_trim_width_out) ^2) + WOD

					poly2_b 4, 1+2+4+32, gs_trim_pen_fg_out, gs_trim_pen_bg_out,
						px1,	0,		1 + 32,
						px1,	py1,	1 + 32,
						px2,	py2,	1 + 32,
						px2,	0,		1 + 32

					if bShowJambExtHotspots & gs_trim_offs_out > EPS then
						hotspot2 	px2, -WIDO_SILL, 10010
!!!						text2 		px2, -WIDO_SILL, "10010"
					endif
				endif

				del 1
			endif

			if not(gs_stack_right) then

				add2 -widoRightJamb, 0

				if gs_trim_width_out > EPS & WIDO_SILL > EPS & bShowJambExtension & gs_trim_atframe_out = 0 then

					! ===== Outside Trim - Curved Walls - Jamb Extension - Right =====

					px1 = rightWidth
					px2 = px1 - gs_trim_width_out

					py1 = rightRevealPnts[idxSillStartRevealRight][2]
					py2 = ySign * sqr (rSill^2 - (rightRevealPnts[idxSillStartRevealRight][1] - gs_trim_width_out) ^2) + WOD

					poly2_b 4, 1+2+4+32, gs_trim_pen_fg_out, gs_trim_pen_bg_out,
						px1,	0,		1 + 32,
						px1,	py1,	1 + 32,
						px2,	py2,	1 + 32,
						px2,	0,		1 + 32

					if bShowJambExtHotspots & gs_trim_offs_out > EPS then
						hotspot2 	px2, py2, 10010
!!!						text2 		px2, py2, "10010"
					endif
				endif

				del 1
			endif


			add2 0,WOD

			iSign = wallIsLeft - not(wallIsLeft)

			alfaLeftParallel 	= abs (asn ( (leftRevealPnts[idxSillStartRevealLeft][1] + gs_trim_width_out) / rSill))
			alfaRightParallel 	= abs (asn ( (rightRevealPnts[idxSillStartRevealRight][1] - gs_trim_width_out) / rSill))

			LengtToArc = iSign * 180 / rSill / PI
			alfaTrimOffsetOut	= LengtToArc * gs_trim_offs_out
			alfaTrimWidthOut	= LengtToArc * gs_trim_width_out

			alfaTolerOffsetLeftOut	= LengtToArc * tolerOffsetLeftOut
			alfaTolerOffsetRightOut	= LengtToArc * tolerOffsetRightOut

			rSillEdge = rSill + iSign * gs_trim_thk_out

			if not(gs_stack_left) then

				if wallIsLeft then
					alfaLeftEdge = 180 + abs(alfaLeft) - iSign * alfaLeftJamb
				else
					alfaLeftEdge = -abs(alfaLeft) - iSign * alfaLeftJamb
				endif

				pyy1 = spy1
				pyy2 = rSill * cos(alfaLeftEdge)

				if gs_tw_left_out > EPS & gs_trim_thk_out > EPS then

					! ===== Outside Trim - Curved Walls - Casing - Left =====

					alfaLeftTrimWidth	= LengtToArc * gs_tw_left_out

					if wallIsLeft then
						rot2 180 !- abs(alfaLeft) + alfaTrimWidthOut - alfaTrimOffsetOut + iSign * alfaLeftJamb
					else
						rot2 0	!abs(alfaLeft) + alfaTrimWidthOut - alfaTrimOffsetOut + iSign * alfaLeftJamb
					endif

					px1 = ySign * (leftRevealPnts[idxSillStartRevealLeft][1] + tolerOffsetLeftOut + gs_trim_width_out - gs_trim_offs_out)
					px2 = - ySign * rSill * sin(alfaLeftParallel - ySign * (-alfaTolerOffsetLeftOut + alfaLeftTrimWidth + alfaTrimOffsetOut))
					px3 = - ySign * rSillEdge * sin(alfaLeftParallel - ySign * (-alfaTolerOffsetLeftOut + alfaLeftTrimWidth + alfaTrimOffsetOut))

					py1 = sqr (rSill^2 - px1^2)
					py2 = rSill * cos(alfaLeftParallel - ySign * (-alfaTolerOffsetLeftOut + alfaLeftTrimWidth + alfaTrimOffsetOut))
					py3 = rSillEdge * cos(alfaLeftParallel - ySign * (-alfaTolerOffsetLeftOut + alfaLeftTrimWidth + alfaTrimOffsetOut))
					py4 = sqr (rSillEdge^2 - px1^2)

					poly2_b 6, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
						px1, py4, 1 + 32,
						px1, py1, 1 + 32,
						0, 0, 901 + 32,
						px2, py2, 3001 + 32,
						px3, py3, 1 + 32,
						px1, py4, 3001 + 32

					if bShowJambExtHotspots & gs_trim_offs_out < EPS then
						hotspot2 	px1, py4, 10010
!!!						text2 		px1, py4, "10010"
					endif
					if isWindow & bShowAddHotspots then
						hotspot2 	px2, py2, 10030
!!!						text2 		px2, py2, "10030"
					endif
					if not(isWindow) & bShowAddHotspots then
						hotspot2 	px3, py3, 10000
!!!						text2 		px3, py3, "10000"
					endif

					del 1
				endif
			endif

			if not(gs_stack_right) then

				if wallIsLeft then
					alfaRightEdge = -180 - abs(alfaRight) + iSign * alfaRightJamb
				else
					alfaRightEdge = abs(alfaRight) + iSign * alfaRightJamb
				endif

				pyy1 = spy8
				pyy2 = rSill * cos(alfaRightEdge)

				if gs_tw_right_out > EPS & gs_trim_thk_out > EPS then

					! ===== Outside Trim - Curved Walls - Casing - Right =====

					alfaRightTrimWidth	= LengtToArc * gs_tw_right_out

					if wallIsLeft then
						rot2 180 !+ abs(alfaRight) - alfaTrimWidthOut + alfaTrimOffsetOut - iSign * alfaRightJamb
					else
						rot2 0	!-abs(alfaRight) - alfaTrimWidthOut + alfaTrimOffsetOut - iSign * alfaRightJamb
					endif

					px1 = ySign * (rightRevealPnts[idxSillStartRevealRight][1] - tolerOffsetRightOut - gs_trim_width_out + gs_trim_offs_out)
					px2 = ySign * rSill * sin(alfaRightParallel - ySign * (-alfaTolerOffsetRightOut + alfarightTrimWidth + alfaTrimOffsetOut))
					px3 = ySign * rSillEdge * sin(alfarightParallel - ySign * (-alfaTolerOffsetRightOut + alfarightTrimWidth + alfaTrimOffsetOut))

					py1 = sqr (rSill^2 - px1^2)
					py2 = rSill * cos(alfarightParallel - ySign * (-alfaTolerOffsetRightOut + alfarightTrimWidth + alfaTrimOffsetOut))
					py3 = rSillEdge * cos(alfarightParallel - ySign * (-alfaTolerOffsetRightOut + alfarightTrimWidth + alfaTrimOffsetOut))
					py4 = sqr (rSillEdge^2 - px1^2)

					poly2_b 6, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
						px1, py4, 1 + 32,
						px1, py1, 1 + 32,
						0, 0, 901 + 32,
						px2, py2, 3001 + 32,
						px3, py3, 1 + 32,
						px1, py4, 3001 + 32

					if bShowJambExtHotspots & gs_trim_offs_out < EPS then
						hotspot2 	px1, py4, 10011
!!!						text2 		px1, py4, "10011"
					endif
					if isWindow & bShowAddHotspots then
						hotspot2 	px2, py2, 10031
!!!						text2 		px2, py2, "10031"
					endif
					if not(isWindow) & bShowAddHotspots then
						hotspot2 	px3, py3, 10001
!!!						text2 		px3, py3, "10001"
					endif

					del 1
				endif
			endif

			del 1

		endif

	endif	! not(curvedWall)

	if gs_stack_left then
		if (tolerOffsStackCasLeftOut + trim_offs_out_modify - gs_trim_offs_out) > EPS & gs_trim_thk_out > EPS & gs_trim_stack_left = 1 then

			! ===== Outside Trim - Casing at Ganging - Left =====

			px1 = leftRevealPnts[2][1]  + tolerOffsStackCasLeftOut + trim_offs_out_modify - gs_trim_offs_out
			px2 = leftRevealPnts[2][1]
			px3 = px2 + gs_trim_thk_out * tan(alfaLeft) * ySign

			py1 = leftRevealPnts[2][2]
			py2 = leftRevealPnts[2][2] - gs_trim_thk_out

			poly2_b 4, 1+2+4+32, gs_trim_pen_fg_out, gs_trim_pen_bg_out,
				px1,	py1,	1 + 32,
				px2,	py1,	0 + 32,
				px3,	py2,	1 + 32,
				px1,	py2,	1 + 32

			if bShowJambExtHotspots & gs_trim_offs_out < EPS then
				hotspot2 	px1, py2, 10010
!!!				text2		px1, py2, "10010"
			endif
			if isWindow & bShowAddHotspots then
				hotspot2 	px2, py2, 10030
!!!				text2 		px2, py2, "10030"
			endif
			if not(isWindow) & bShowAddHotspots then
				hotspot2 	px2, py2, 10000
!!!				text2 		px2, py2, "10000"
			endif
		endif
	endif

	if not(bRightCornerFunction) & gs_stack_right then
		if (tolerOffsStackCasRightOut + trim_offs_out_modify - gs_trim_offs_out) > EPS & gs_trim_thk_out > EPS & gs_trim_stack_right = 1 then

			! ===== Outside Trim - Casing at Ganging - Right =====

			px1 = rightRevealPnts[2][1] - tolerOffsStackCasRightOut - trim_offs_out_modify + gs_trim_offs_out
			px2 = rightRevealPnts[2][1]
			px3 = px2 - gs_trim_thk_out * tan(alfaRight) * ySign

			py1 = rightRevealPnts[2][2]
			py2 = rightRevealPnts[2][2] - gs_trim_thk_out

			poly2_b 4, 1+2+4+32, gs_trim_pen_fg_out, gs_trim_pen_bg_out,
				 px1,	py1,	1 + 32,
				 px2,	py1,	0 + 32,
				 px3,	py2,	1 + 32,
				 px1,	py2,	1 + 32

			if bShowJambExtHotspots & gs_trim_offs_out < EPS then
				hotspot2 	px1, py2, 10011
!!!				text2 		px1, py2, "10011"
			endif
			if isWindow & bShowAddHotspots then
				hotspot2 	px2, py2, 10031
!!!				text2 		px2, py2, "10031"
			endif
			if not(isWindow) & bShowAddHotspots then
				hotspot2 	px2, py2, 10001
!!!				text2 		px2, py2, "10001"
			endif
		endif
	endif
endif


! Restore the saved parameter buffer ===========================================

call "LoadQueue_WMCC" parameters savedQueueValues = savedQueueValues


! ==============================================================================
!	Close PolyOperations Add-on Channel
! ==============================================================================
if bTShapedOpening & curvedWall & (bDrawInsideTrim | bDrawOutsideTrim) then
	CLOSEADDONSCOPE ch
endif



! ==============================================================================
 end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
! ==============================================================================


! ==============================================================================
! === SUBROUTINES
! ==============================================================================

! ==============================================================================
!		Cross points of circle (xo,yo,ro) and line (x1,y1, x2,y2)
! ------------------------------------------------------------------------------
! Input parameters:
!	xo, yo:		Circle center
!	ro:			Circle radius
!	x1, y1:		Line endpoint 1
!	x2, y2:		Line endpoint 2
! Output parameters:
!	state:		Status (0, 1, 2)
!				  0: No intersection
!				  1: One intersection
!				  2: Two intersections
!	xa, ya:		Cross point 1
!	xb, yb:		Cross point 2
! ==============================================================================

100:
	x1 = x1 - xo
	y1 = y1 - yo

	x2 = x2 - xo
	y2 = y2 - yo

	kf = (y2 - y1) / (x2 - x1)
	ad = 1 + kf * kf
	bd = 2 * y1 * kf - 2 * x1 * kf * kf
	cd = y1 * y1 - 2 * x1 * y1 * kf + x1 * x1 * kf * kf - ro * ro

	if bd * bd - 4 * ad * cd < 0 then
		state = 0
		xa = 0
		ya = 0
		xb = 0
		yb = 0
	else
		xa = (-bd + sqr(bd * bd - 4 * ad * cd)) / (2 * ad)
		ya = y1 + (xa - x1) * kf
		xb = (-bd - sqr(bd * bd - 4 * ad * cd)) / (2 * ad)
		yb = y1 + (xb - x1) * kf

		if abs(xa - xb) < EPS then
			state = 1
		else
			state = 2
		endif
	endif

	xa = xa + xo
	ya = ya + yo
	xb = xb + xo
	yb = yb + yo
return


! ==============================================================================
! Direction Angle
! ------------------------------------------------------------------------------
! Input variables:
!	vx, vy:				vector
!
! Returned variables:
!	alpha:				selected intersection point
! ==============================================================================

103:

if abs(vx) < EPS & abs(vy) < EPS then
	angle = 0
	return
endif

if abs(vx) < EPS then
	if vy > 0 then
		angle = 90
	else
		angle = 270
	endif
else
	angle = atn(vy / vx)
	if vx >= 0 then
		if angle < 0 then
			angle = angle + 360
		endif
	else
		angle = 180 + angle
	endif
endif

return


! ==============================================================================
! Rotate 2D points around curved wall's center
! ------------------------------------------------------------------------------
! Input variables:
!	x,y:				2D point
!	WOD:				"wido orig dist" in the wallhole coordinate system
!	alpha:				rotation angle
! Returned variables:
!	x,y:				rotated 2D point
! ==============================================================================

1000:
	xo = x
	yo = y - WOD
	x = xo * cos(signWallIsLeft * alpha) - yo * sin(signWallIsLeft * alpha)
	y = xo * sin(signWallIsLeft * alpha) + yo * cos(signWallIsLeft * alpha) + WOD
return




"DrawSidelightCasingCurvedWall":
! ==============================================================================
! Cuts Casing polygon with the facade plane of door frame in Curved Walls
! and also draws it
! ------------------------------------------------------------------------------
! ==============================================================================

	! Store casing polygon -------------------------------------------------------

	dim vertArr1[][3]
	dim inhEdgeInfos1[]
	defaultInhEdgeInfo = 0


	gosub "Convert GDL poly2_ to AC polygons"

	nContours1 = 1
	dim contArr1[]
	contArr1[1] = nVertices1 + 1

	if nVertices1 >= 2 then
		preparefunction ch, "Store", "CasingPoly", nVertices1, nContours1, vertArr1, contArr1, defaultInhEdgeInfo, inhEdgeInfos1
	endif


	! ------------------------------------------------------------------------------
	! Cut "CasingPoly" polygon with halfplane
	! ------------------------------------------------------------------------------

	if bCasingIsInside = 1 then
		PREPAREFUNCTION  ch, "HalfPlaneParams", "", 0, -1, WOD - WIDO_FRAME_THICKNESS
		set fill gs_trim_wallhole_fill_in
		ActCasingFillPen 		= gs_trim_wallhole_pen_sl_fg_in
		ActCasingFillBackPen	= gs_trim_wallhole_pen_sl_bg_in
	else
		PREPAREFUNCTION  ch, "HalfPlaneParams", "", 0, 1, -WOD
		set fill gs_trim_wallhole_fill_out
		ActCasingFillPen 		= gs_trim_wallhole_pen_sl_fg_out
		ActCasingFillBackPen	= gs_trim_wallhole_pen_sl_bg_out
	endif


	dim resPolyIDArray[]
	numPoly = CALLFUNCTION (ch, "PolyCut", "CasingPoly", resPolyIDArray)

	! ------------------------------------------------------------------------------
	! Draw resulting polygons
	! ------------------------------------------------------------------------------

	for jk = 1 to numPoly
		polygonID = resPolyIDArray[jk]

		gosub "GetResultingACPolygon"

		if nsp > 0 then
			poly2_b  nsp/3, 1+2+4+64, ActCasingFillPen, ActCasingFillBackPen,
				get(nsp)
		endif
	next jk


	PREPAREFUNCTION ch, "EmptyContainer", "mySourceContainer", ""
	PREPAREFUNCTION ch, "EmptyContainer", "myDestinationContainer", ""
return



"Convert GDL poly2_ to AC polygons":
! ==============================================================================
! Converts GDL poly2_b command values to AC polygon values
! ------------------------------------------------------------------------------
! ==============================================================================

idx = 1
inhEdgeInfosLast = 0

for i=1 to nsp/3
	px = get(1)
	py = get(1)
	ps = round_int (get(1))


	if idx > 1 then
		bSkipThisVertex = (abs(px - vertarr1[1][1]) < EPS & abs(py - vertarr1[1][2]) < EPS)	! Skip this vertex if this is a closing one
	else
		bSkipThisVertex = 0
	endif

	if ps < 900 | ps >= 1000 then	! Skip state '900'
		if not(bSkipThisVertex) then
			vertarr1[idx][1] = px
			vertarr1[idx][2] = py
		endif
		if ps >= 3000 & ps < 4000 then
			if idx > 1 then
				vx = vertarr1[idx-1][1] - 0
				vy = vertarr1[idx-1][2] !- WOD
				gosub 103	! Direction Angle
				savedAngle = angle

				vx = px - 0
				vy = py !- WOD
				gosub 103	! Direction Angle

				vertarr1[idx-1][3] = angle - savedAngle
				if not(bSkipThisVertex) then
					inhEdgeInfos1[idx] = bittest(ps, 0)
				endif
			endif
		else
			if not(bSkipThisVertex) then
				vertarr1[idx][3] = 0
				inhEdgeInfos1[idx] = bittest(ps, 0)
			endif
		endif
		if not(bSkipThisVertex) then
			idx = idx + 1
		endif
	endif
next i
nVertices1 = vardim1(vertarr1)

return


"GetResultingACPolygon":
! ==============================================================================
! Get GDL Polygon
! ------------------------------------------------------------------------------
! Input variables:
!	polygonID:			Polygon index
!
! Returned variables:
!	GDL stack:			GDL polygon
! ==============================================================================

	dim resVertices[]
	numVertices = callfunction(ch, "GETVERTICES", polygonID, resVertices)
	numVertices = numVertices / 3

	dim contArr[]
	numContours = callfunction(ch, "GETCONTOURENDS", polygonID, contArr)

	dim inhEdgeInfos[]
	numEdges = callfunction(ch, "GetInhEdgeInfos", polygonID, inhEdgeInfos)

	for contIndex = 1 to numContours

		if contIndex = 1 then
			begIdx = 0
		else
			begIdx = contArr[contIndex] - 1
		endif
		if contIndex = numContours then
			endIdx = numVertices - 1
		else
			endIdx = contArr[contIndex + 1] - 2
		endif

		bClosed = 0
		bStartWithLast = 0

		index = endIdx * 3
		ac2gdl_lpx = resVertices[index + 1]
		ac2gdl_lpy = resVertices[index + 2]
		ac2gdl_lpa = resVertices[index + 3]
		prevEdgeInfo = round_int(inhEdgeInfos[endIdx + 1])

		if abs(ac2gdl_lpa) > EPS then
			put ac2gdl_lpx, ac2gdl_lpy, 1
			bStartWithLast = 1
		endif

		for vertIndex = begIdx to endIdx
			index = vertIndex * 3
			ac2gdl_px = resVertices[index + 1]
			ac2gdl_py = resVertices[index + 2]
			ac2gdl_pa = resVertices[index + 3]
			edgeInfo	= round_int(inhEdgeInfos[vertIndex + 1])

			if vertIndex = begIdx then
				if bStartWithLast then
					ac2gdl_spx = ac2gdl_lpx
					ac2gdl_spy = ac2gdl_lpy
				else
					ac2gdl_spx = ac2gdl_px
					ac2gdl_spy = ac2gdl_py
				endif
			endif

			if abs(ac2gdl_lpa) > EPS then
				ac2gdl_mx = (ac2gdl_px + ac2gdl_lpx) / 2
				ac2gdl_my = (ac2gdl_py + ac2gdl_lpy) / 2
				ac2gdl_ratio = 1 / 2 / tan (ac2gdl_lpa / 2)

				ac2gdl_cx = ac2gdl_mx - ac2gdl_ratio * (ac2gdl_py - ac2gdl_lpy)	! Arc center
				ac2gdl_cy = ac2gdl_my + ac2gdl_ratio * (ac2gdl_px - ac2gdl_lpx)
				ac2gdl_rad = sqr((ac2gdl_cx - ac2gdl_px)^2 + (ac2gdl_cy - ac2gdl_py)^2)

				vx = ac2gdl_px - ac2gdl_cx
				vy = ac2gdl_py - ac2gdl_cy
				gosub 103	! Direction Angle
				alpha = angle

				vx = ac2gdl_lpx - ac2gdl_cx
				vy = ac2gdl_lpy - ac2gdl_cy
				gosub 103	! Direction Angle
				beta = angle

				put ac2gdl_cx,	ac2gdl_cy,	900,
					0,			ac2gdl_lpa,	4000 + edgeInfo

				if GLOB_CONTEXT <> 5 & (prevEdgeInfo > 0) then
					line_property 0
					arc2 ac2gdl_cx,	ac2gdl_cy, ac2gdl_rad, min(alpha,beta), max(alpha,beta)
				endif
			else
				if GLOB_CONTEXT <> 5 & (prevEdgeInfo > 0) then
					line_property 0
					line2 ac2gdl_lpx, ac2gdl_lpy, ac2gdl_px, ac2gdl_py
				endif
			endif

			if vertIndex > begIdx & abs(ac2gdl_spx - ac2gdl_px) < EPS & abs(ac2gdl_spy - ac2gdl_py) < EPS then
				put ac2gdl_px, ac2gdl_py, -1
				bClosed = 1
			else
				if vertIndex < endIdx | not(bStartWithLast) then
					put ac2gdl_px, ac2gdl_py, edgeInfo
				endif
			endif

			ac2gdl_lpx = ac2gdl_px
			ac2gdl_lpy = ac2gdl_py
			ac2gdl_lpa = ac2gdl_pa
			prevEdgeInfo = edgeInfo
		next vertIndex

		if not(bClosed) & numContours > 1 then	! Close the polygon if it has holes
			put ac2gdl_spx, ac2gdl_spy, -1
		endif

	next contIndex
return




]]></Script_2D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_1D SectVersion="20" SectionFlags="0" SubIdent="0"><![CDATA[

EPS = 0.0001

! iRevealType:
REVEAL_EDGE				= 0
REVEAL_NO				= 1
REVEAL_POSITIVE			= 2
REVEAL_NEGATIVE			= 3
REVEAL_SLANTED			= 4
REVEAL_SPLAYED			= 5
REVEAL_HISTORIC			= 6
REVEAL_DOUBLE			= 7
REVEAL_DOUBLE_SPLAYED	= 8
REVEAL_OUTSIDE_SPLAYED	= 9

! Partial Stucture Display defines:
STRUCTURE_ENTIRE_STRUCTURE	= 0
STRUCTURE_CORE_ONLY			= 1
STRUCTURE_WITHOUT_FINISHES	= 2

! iWindowShape:
SHAPE_RECTANGULAR			= 0
SHAPE_ARCHED				= 1
SHAPE_ROUND					= 2
SHAPE_EYEBROWS				= 3
SHAPE_HALFCIRCLE			= 4 	! straight side is horizontal
SHAPE_MULTISIDE				= 5
SHAPE_OCTAGONAL				= 6
SHAPE_HALFARCH				= 7
SHAPE_PENTAGON				= 8
SHAPE_QUARTERROUND			= 9
SHAPE_HALFROUND				= 10 	! straight side is vertical
SHAPE_TRAPEZOID				= 11
SHAPE_TRIANGLE				= 12
SHAPE_GOTHICARCH			= 13
SHAPE_ELLIPSEARCH			= 14
SHAPE_ROMBUS				= 15
SHAPE_HORSESHOE				= 16
SHAPE_OGEECENTERED			= 17
SHAPE_SARACENIC				= 18
SHAPE_T						= 19
SHAPE_HALF_T_LEFT			= 20
SHAPE_ARCHED_T				= 21
SHAPE_ARCHED_HALF_T_LEFT	= 22
SHAPE_PARALLELOGRAM			= 23
SHAPE_ELLIPSE				= 24
SHAPE_CORNER_TRIANGLE		= 25
SHAPE_QUARTERROUND_NOFRAME	= 26
SHAPE_HALF_T_RIGHT			= 27
SHAPE_ARCHED_HALF_T_RIGHT	= 28

! iCasingWidthControl:
FULL_EDITABLE				= 1
SIDE_AND_BOTTOM_EDITABLE	= 2
SIDE_EDITABLE				= 3

! gs_trimtype_out_int, gs_trimtype_in_int
CASING_NORMAL		= 1
CASING_OVERHANG		= 2
CASING_COMPLEX		= 3		! Only for outside casing

!iCasingHeadTypeOut
CASING_HEAD_RECT			= 1
CASING_HEAD_DECORATIVE_1	= 2
CASING_HEAD_DECORATIVE_2	= 3
CASING_HEAD_DECORATIVE_3	= 4

! iArchitraveCapitalType
ARCH_CAPITAL_SQUARE_ONSIDE		= 1
ARCH_CAPITAL_SQUARE_NEXTSIDE	= 2
ARCH_CAPITAL_DECOR_ONSIDE		= 3
ARCH_CAPITAL_DECOR_NEXTSIDE		= 4

! iNORCasingType
ARCHITRAV_NONE                  = 1
ARCHITRAV_SILL                  = 2
ARCHITRAV_LEFT                  = 3
ARCHITRAV_LEFT_SILL             = 4
ARCHITRAV_RIGHT                 = 5
ARCHITRAV_RIGHT_SILL            = 6
ARCHITRAV_LEFT_RIGHT            = 7
ARCHITRAV_LEFT_RIGHT_SILL       = 8
ARCHITRAV_ENTAB                 = 9
ARCHITRAV_ENTAB_SILL            = 10
ARCHITRAV_ENTAB_LEFT            = 11
ARCHITRAV_ENTAB_LEFT_SILL       = 12
ARCHITRAV_ENTAB_RIGHT           = 13
ARCHITRAV_ENTAB_RIGHT_SILL      = 14
ARCHITRAV_ENTAB_LEFT_RIGHT      = 15
ARCHITRAV_ENTAB_LEFT_RIGHT_SILL = 16
ARCHITRAV_ALL                   = 17
ARCHITRAV_SIMPLE_CASING         = 18


! ==============================================================================
! Get Casing restrictions
! ==============================================================================

call "CasingEnable_WMCC" parameters A=A,
	iRevealType			= iRevealType,
	iWindowShape		= iWindowShape,
	gs_frame_style_m	= gs_frame_style_m,
	returned_parameters bInsideCasingNotAvailableByWallType,
						bInsideCasingNotAvailableByReveal,
						bOutsideCasingNotAvailableByReveal,
						bInsideCasingNotAvailableByFrameStyle,
						bOutsideCasingNotAvailableByFrameStyle


! ==============================================================================
! Reveal Points Indexes
! ==============================================================================

idxSillStartRevealLeft		= iRevealPointsIdx[1]
idxSillEndRevealLeft		= iRevealPointsIdx[2]
idxFrameStartRevealLeft		= iRevealPointsIdx[3]
idxFrameEndRevealLeft		= iRevealPointsIdx[4]
idxBoardEndRevealLeft		= iRevealPointsIdx[6]
idxSillStartPlasterLeft		= iRevealPointsIdx[7]
idxSillEndPlasterLeft		= iRevealPointsIdx[8]
idxSillStartRevealRight		= iRevealPointsIdx[11]
idxSillEndRevealRight		= iRevealPointsIdx[12]
idxFrameStartRevealRight	= iRevealPointsIdx[13]
idxFrameEndRevealRight		= iRevealPointsIdx[14]
idxBoardEndRevealRight		= iRevealPointsIdx[16]
idxSillStartPlasterRight	= iRevealPointsIdx[17]
idxSillEndPlasterRight		= iRevealPointsIdx[18]


! ==============================================================================

bTShapedOpening =  (iWindowShape = SHAPE_T |\
					iWindowShape = SHAPE_HALF_T_LEFT |\
					iWindowShape = SHAPE_HALF_T_RIGHT |\
					iWindowShape = SHAPE_ARCHED_T |\
					iWindowShape = SHAPE_ARCHED_HALF_T_LEFT |\
					iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT)

bPShapedLeftOpening =	(iWindowShape = SHAPE_T |\
						iWindowShape = SHAPE_HALF_T_LEFT |\
						iWindowShape = SHAPE_ARCHED_T |\
						iWindowShape = SHAPE_ARCHED_HALF_T_LEFT) &\
						gs_sidelight_parapet_hgt_left > EPS

bPShapedRightOpening =	(iWindowShape = SHAPE_T |\
						iWindowShape = SHAPE_HALF_T_RIGHT |\
						iWindowShape = SHAPE_ARCHED_T |\
						iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT) &\
						gs_sidelight_parapet_hgt_right > EPS


bInclinedWall	= (abs(WALL_INCL) > EPS)
curvedWall		= (abs(WIDO_ORIG_DIST) > EPS)
wallIsLeft		= (SYMB_ROTANGLE > EPS) exor WIDO_REVEAL_SIDE
signWallIsLeft	= wallIsleft - not(wallIsleft)

if bTShapedOpening then
	bDrawLeftSLSill		= gs_sill_outside_sl_left
	bDrawRightSLSill	= gs_sill_outside_sl_right
	bDrawLeftSLBoard	= gs_board_inside_sl_left
	bDrawRightSLBoard	= gs_board_inside_sl_right
else
	bDrawLeftSLSill		= bDrawSill
	bDrawRightSLSill	= bDrawSill
	bDrawLeftSLBoard	= bDrawBoard
	bDrawRightSLBoard	= bDrawBoard
endif


if not(bCasingUSA) then
	if gs_trimtype_out_int = CASING_NORMAL then
		gs_trimov_top_left_out	= 0
		gs_trimov_top_right_out	= 0
		gs_trimov_bot_left_out	= 0
		gs_trimov_bot_right_out	= 0
	endif
	if gs_trimtype_in_int = CASING_NORMAL then
		gs_trimov_top_left_in	= 0
		gs_trimov_top_right_in	= 0
		gs_trimov_bot_left_in	= 0
		gs_trimov_bot_right_in	= 0
	endif
endif


if gs_trimtype_in_int = CASING_OVERHANG then
	gs_trimov_top_left_in	= gs_trimov_top_right_in

	if	isWindow | \
		iWindowShape = SHAPE_T | \
		iWindowShape = SHAPE_ARCHED_T then
		gs_trimov_bot_left_in	= gs_trimov_bot_right_in
	endif
endif

if gs_trimtype_out_int = CASING_OVERHANG then
	gs_trimov_top_left_out	= gs_trimov_top_right_out

	if	isWindow | \
		iWindowShape = SHAPE_T | \
		iWindowShape = SHAPE_ARCHED_T then
		gs_trimov_bot_left_out	= gs_trimov_bot_right_out
	endif
endif


if Suppress_isWindow then isWindow = 0

bShowJambExtension		= 1

bEnableUniformCasing = ((iWindowShape = SHAPE_RECTANGULAR |\
						 iWindowShape = SHAPE_T |\
						 iWindowShape = SHAPE_HALF_T_LEFT |\
						 iWindowShape = SHAPE_HALF_T_RIGHT) &\
						 not(bTerraceDoorNORUI))

if (iWindowShape = SHAPE_RECTANGULAR |\
	iWindowShape = SHAPE_T |\
	iWindowShape = SHAPE_HALF_T_LEFT |\
	iWindowShape = SHAPE_HALF_T_RIGHT) then

	iCasingWidthControl = FULL_EDITABLE
else
	if (iWindowShape = SHAPE_ARCHED |\
		iWindowShape = SHAPE_ELLIPSEARCH |\
		iWindowShape = SHAPE_TRAPEZOID |\
		iWindowShape = SHAPE_HALFCIRCLE |\
		iWindowShape = SHAPE_PENTAGON |\
		iWindowShape = SHAPE_QUARTERROUND) then

		iCasingWidthControl = SIDE_AND_BOTTOM_EDITABLE
	else
		iCasingWidthControl = SIDE_EDITABLE
	endif
endif


! ==============================================================================
! Disable simple overhang and complex casing types according to window shape
! ==============================================================================

if	iWindowShape <> SHAPE_RECTANGULAR & \
	iWindowShape <> SHAPE_T & \
	iWindowShape <> SHAPE_HALF_T_LEFT & \
	iWindowShape <> SHAPE_HALF_T_RIGHT then

	! Inside
	gs_CasingInTypeEnable = bitset( gs_CasingInTypeEnable, 1, 0)


	! Outside
	gs_CasingOutTypeEnable = bitset( gs_CasingOutTypeEnable, 1, 0)
	gs_CasingOutTypeEnable = bitset( gs_CasingOutTypeEnable, 2, 0)
endif


! ==============================================================================

!if SYMB_MIRRORED exor (SYMB_ROTANGLE > EPS) then
!	widoRightJamb	= WIDO_LEFT_JAMB
!	widoLeftJamb	= WIDO_RIGHT_JAMB
!else
!	widoRightJamb	= WIDO_RIGHT_JAMB
!	widoLeftJamb	= WIDO_LEFT_JAMB
!endif

widoLeftJamb	= gs_reveal_left
widoRightJamb	= gs_reveal_right

widoInnerLeftJamb	= revealInnerLeft
widoInnerRightJamb	= revealInnerRight
widoInnerTopJamb	= 0
widoInnerBottomJamb	= 0
if iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC then
	widoInnerTopJamb	= gs_reveal_splayed_innerTop
	widoInnerBottomJamb	= gs_reveal_splayed_innerBottom
endif
if iRevealType = REVEAL_DOUBLE then
	widoInnerTopJamb	= gs_reveal_double_innerTop
	widoInnerBottomJamb	= gs_reveal_double_innerBottom
endif


! ==============================================================================
! Restrictions for Window Shapes
! ==============================================================================

widoHeadDepth	= gs_reveal_top
widoThresDepth	= gs_reveal_bottom

if	iWindowShape = SHAPE_ARCHED | \
	iWindowShape = SHAPE_ARCHED_T | \
	iWindowShape = SHAPE_ARCHED_HALF_T_LEFT | \
	iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT | \
	iWindowShape = SHAPE_ELLIPSEARCH then
	! --- Arched Window Shape ---

	widoLeftJamb	= widoRightJamb
	widoHeadDepth	= widoRightJamb

	gs_tw_left_in	= gs_tw_right_in
	gs_tw_top_in	= gs_tw_right_in

	gs_tw_left_out	= gs_tw_right_out
	gs_tw_top_out	= gs_tw_right_out
endif

if	iWindowShape = SHAPE_RECTANGULAR |\
	iWindowShape = SHAPE_T |\
	iWindowShape = SHAPE_HALF_T_LEFT |\
	iWindowShape = SHAPE_HALF_T_RIGHT then

	if gs_trim_outside_uniform then
		gs_tw_left_out	= gs_tw_right_out
		gs_tw_top_out	= gs_tw_right_out
		gs_tw_bottom_out = gs_tw_right_out
	endif

	if gs_trim_inside_uniform then
		gs_tw_left_in	= gs_tw_right_in
		gs_tw_top_in	= gs_tw_right_in
		gs_tw_bottom_in = gs_tw_right_in
	endif
endif

if not(isWindow) & not(bTShapedOpening) then
	gs_tw_bottom_in		= 0
	gs_tw_bottom_out	= 0
	gs_stack_bottom		= 0
endif


gs_trim_below_sillLeft		= bCasingBottomOutside
gs_trim_below_sillRight		= bCasingBottomOutside
gs_trim_below_boardLeft		= gs_trim_below_board
gs_trim_below_boardRight	= gs_trim_below_board
if	bPShapedLeftOpening then
	if	( (gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + (gs_trim_width_in - gs_trim_offs_in) * not(bDrawLeftSLBoard)) <= \
			gs_tw_bottom_in ) then gs_trim_below_boardLeft = 0
	if	( (gs_sidelight_parapet_hgt_left + gs_reveal_bottom_sL + (gs_trim_width_out - gs_trim_offs_out) * not(bDrawLeftSLSill) + bDrawLeftSLSill * sillBottomOutside) <= \
			gs_tw_bottom_out ) then gs_trim_below_sillLeft = 0
endif
if	bPShapedRightOpening then
	if	( (gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + (gs_trim_width_in - gs_trim_offs_in) * not(bDrawRightSLBoard)) <= \
			gs_tw_bottom_in ) then gs_trim_below_boardRight = 0
	if	( (gs_sidelight_parapet_hgt_right + gs_reveal_bottom_sR + (gs_trim_width_out - gs_trim_offs_out) * not(bDrawRightSLSill) + bDrawRightSLSill * sillBottomOutside) <= \
			gs_tw_bottom_out ) then gs_trim_below_sillRight = 0
endif

! ==============================================================================
! Calculations for Corner Window
! ==============================================================================

if bRightCornerFunction & abs(rightCornerAngle) > EPS then
	rx = 1 / tan(rightCornerAngle / 2)

	if rightCornerAngle > 180 then
		rightCwDx = WIDO_FRAME_THICKNESS / tan(-rightCornerAngle / 2)
	else
		rightCwDx = 0
	endif

	rightCwDx2 = 0
	if abs(WALL_THICKNESS - rightConnWallThk) > EPS then
		rightCwDx2 = (WALL_THICKNESS - rightConnWallThk) / cos(rightCornerAngle - 90)
	endif
	bFitModeRight = (rightConnWallThk > WALL_THICKNESS + EPS)

!!!	if SYMB_MIRRORED exor WIDO_REVEAL_SIDE then
!!!		! --- Swap Left and Right Attributes
!!!		gs_tw_left_in		= gs_tw_right_in
!!!		gs_tw_left_out		= gs_tw_right_out
!!!		gs_stack_left		= gs_stack_right
!!!		gs_left_oversize	= gs_right_oversize
!!!	endif

	gs_right_oversize = 0
else
	bFitModeRight = 0
endif

if bLeftCornerFunction & abs(leftCornerAngle) > EPS then
	lx = 1 / tan(leftCornerAngle / 2)

	if leftCornerAngle > 180 then
		leftCwDx = WIDO_FRAME_THICKNESS / tan(-leftCornerAngle / 2)
	else
		leftCwDx = 0
	endif

	leftCwDx2 = 0
	if abs(WALL_THICKNESS - leftConnWallThk) > EPS then
		leftCwDx2 = (WALL_THICKNESS - leftConnWallThk) / cos(leftCornerAngle - 90)
	endif
	bFitModeLeft = (leftConnWallThk > WALL_THICKNESS + EPS)

	gs_left_oversize = 0
else
	bFitModeLeft = 0
endif


! ==============================================================================
! Calculations for Inclined Walls
! ==============================================================================

if bInclinedWall then
	bFactor = SYMB_MIRRORED exor WIDO_REVEAL_SIDE exor wallIsLeft
	incFactor = not(bFactor) - bFactor
	incX = incFactor * tan(WALL_INCL)
	incY = incFactor * (1 / cos(WALL_INCL))

	bDir = SYMB_MIRRORED exor (SYMB_ROTANGLE > EPS)
	iDir = not(bDir) - bDir
	incH = cos(WALL_INCL)
	incV = sin(WALL_INCL) * iDir
else
	incX = 0
	incY = 1
	iDir = 0
	incH = 0
	incV = 0
endif


! ==============================================================================
! Calculations for Stack Window
! ==============================================================================

if gs_stack_left then
	overSizeLeft		= gs_left_oversize
	overSizeLeftIn		= gs_left_oversize
	overSizeLeftOut		= gs_left_oversize
	widoLeftJamb		= 0
	gs_reveal_left		= 0
else
	overSizeLeft		= 0
	overSizeLeftIn		= -widoInnerLeftJamb
	overSizeLeftOut		= -widoLeftJamb
	gs_trim_stack_left	= 0
endif

if gs_stack_right then
	overSizeRight		= gs_right_oversize
	overSizeRightIn		= gs_right_oversize
	overSizeRightOut	= gs_right_oversize
	widoRightJamb		= 0
	gs_reveal_right		= 0
else
	overSizeRight		= 0
	overSizeRightIn		= -widoInnerRightJamb
	overSizeRightOut	= -widoRightJamb
	gs_trim_stack_right	= 0
endif
if not(gs_stack_bottom) then gs_trim_stack_bottom = 0
if not(gs_stack_top) 	then gs_trim_stack_top = 0


! ==============================================================================
! Tolerance Offsets
! ==============================================================================

tolerOffsetLeft		= bCasingTolerance * gs_tolerance_left * not(gs_stack_left)
tolerOffsetRight	= bCasingTolerance * gs_tolerance_right * not(gs_stack_right)
tolerOffsetUpper	= bCasingTolerance * gs_tolerance_upper * not(gs_stack_top)
tolerOffsetLower	= bCasingTolerance * gs_tolerance_lower

tolerOffsetLeftIn	= tolerOffsetLeft  * not(gs_trim_atframe_in)
tolerOffsetRightIn	= tolerOffsetRight * not(gs_trim_atframe_in)
tolerOffsetUpperIn	= tolerOffsetUpper * not(gs_trim_atframe_in)
tolerOffsetLowerIn	= tolerOffsetLower * not(gs_trim_atframe_in)

if gs_trim_atframe_out then
	tolerOffsetLeftOut	= 0
	tolerOffsetRightOut	= 0
	tolerOffsetUpperOut = 0
	tolerOffsetLowerOut = 0
else
	tolerOffsetLeftOut	= bCasingTolerance * (gs_tolerance_left  + gs_frame_width * not(gs_casing_nor)) * not(gs_stack_left)
	tolerOffsetRightOut	= bCasingTolerance * (gs_tolerance_right + gs_frame_width * not(gs_casing_nor)) * not(gs_stack_right)
	tolerOffsetUpperOut	= bCasingTolerance * (gs_tolerance_upper + gs_frame_width * not(gs_casing_nor)) * not(gs_stack_top)
	tolerOffsetLowerOut	= bCasingTolerance * (gs_tolerance_lower + gs_frame_width * not(gs_casing_nor)) * not(bDrawSill)
endif

tolerOffsStackCasLeftIn		= bCasingTolerance * gs_tolerance_left * gs_stack_left
tolerOffsStackCasRightIn	= bCasingTolerance * gs_tolerance_right * gs_stack_right
tolerOffsStackCasUpperIn	= bCasingTolerance * gs_tolerance_upper * gs_stack_top
tolerOffsStackCasLowerIn	= bCasingTolerance * gs_tolerance_lower * gs_stack_bottom

tolerOffsStackCasLeftOut	= bCasingTolerance * (gs_tolerance_left + gs_frame_width * not(gs_casing_nor)) * gs_stack_left
tolerOffsStackCasRightOut	= bCasingTolerance * (gs_tolerance_right + gs_frame_width * not(gs_casing_nor)) * gs_stack_right
tolerOffsStackCasUpperOut	= bCasingTolerance * (gs_tolerance_upper + gs_frame_width * not(gs_casing_nor)) * gs_stack_top
tolerOffsStackCasLowerOut	= bCasingTolerance * (gs_tolerance_lower + gs_frame_width * not(gs_casing_nor)) * gs_stack_bottom


! ==============================================================================
! Calculations for Curved Walls
! ==============================================================================

alfaLeft = 0
ySign = 0

if curvedWall & abs(radSill) > EPS & abs(radBoard) > EPS then

	if GLOB_SCRIPT_TYPE = 2 | GLOB_SCRIPT_TYPE = 3 then
		DegRad = PI / 180

		if GLOB_SCRIPT_TYPE <> 2 then
			widoOrigDist = -WIDO_ORIG_DIST
		else
			widoOrigDist = WIDO_ORIG_DIST
		endif

		alfaLeftIn	= abs(atn( leftRevealPnts[idxBoardEndRevealLeft][1]  / ( leftRevealPnts[idxBoardEndRevealLeft][2]  - WOD)))
		alfaRightIn	= abs(atn(rightRevealPnts[idxBoardEndRevealRight][1] / (rightRevealPnts[idxBoardEndRevealRight][2] - WOD)))

		alfaLeftOut	= abs(atn( leftRevealPnts[idxSillEndRevealLeft - 1][1]  / ( leftRevealPnts[idxSillEndRevealLeft - 1][2]  - WOD)))
		alfaRightOut= abs(atn(rightRevealPnts[idxSillEndRevealRight - 1][1] / (rightRevealPnts[idxSillEndRevealRight - 1][2] - WOD)))

		WOD = abs(widoOrigDist) - (SYMB_ROTANGLE > EPS) * WIDO_FRAME_THICKNESS
		WODIn = abs(widoOrigDist) + (SYMB_ROTANGLE < EPS) * WIDO_FRAME_THICKNESS - (SYMB_ROTANGLE > EPS) * WIDO_FRAME_THICKNESS

		alfaLeft	= atn((leftWidth  + overSizeLeft*0)  / WOD)
		alfaRight	= atn((rightWidth + overSizeRight*0) / WOD)

		alfaLeftOs	= atn((leftRevealPnts[idxBoardEndRevealLeft-1][1]  + gs_left_oversize) / WOD)
		alfaRightOs	= atn((rightRevealPnts[idxBoardEndRevealRight-1][1] + gs_right_oversize) / WOD)

		bArchSign = (WIDO_REVEAL_SIDE exor SYMB_ROTANGLE > EPS)
		iArchSign = bArchSign - not(bArchSign)		! 1 / -1

		if WIDO_REVEAL_SIDE then
			WOD = widoOrigDist + WIDO_FRAME_THICKNESS
		else
			WOD = -widoOrigDist
		endif

		if WIDO_REVEAL_SIDE exor SYMB_ROTANGLE < EPS then
			ySign = 1
			if WIDO_REVEAL_SIDE then
				rSill = sqr(refWidth^2 / 4 + WOD^2) - WIDO_SILL
				rBoard = rSill + WALL_THICKNESS
			else
				rSill = sqr(refWidth^2 / 4 + WOD^2) - WIDO_SILL
				rBoard = rSill + WALL_THICKNESS
			endif
		else
			ySign = -1
			if WIDO_REVEAL_SIDE then
				rBoard = sqr(refWidth^2 / 4 + WOD^2) + WIDO_SILL - WALL_THICKNESS
				rSill = rBoard + WALL_THICKNESS
			else
				rSill = sqr(refWidth^2 / 4 + WOD^2) + WIDO_SILL
				rBoard = rSill - WALL_THICKNESS
			endif
		endif

		if leftRevealPnts[idxFrameEndRevealLeft][1] < leftRevealPnts[idxFrameStartRevealLeft][1] then
			idx = idxFrameStartRevealLeft
		else
			idx = idxFrameEndRevealLeft
		endif
		alfaLeftLSL	 = asn(( leftRevealPnts[idx][1] + gs_sidelight_WHole_width_left + gs_reveal_left_sL + gs_trim_width_out - gs_trim_offs_out) / rSill)

		if rightRevealPnts[idxFrameEndRevealRight][1] > rightRevealPnts[idxFrameStartRevealRight][1] then
			idx = idxFrameStartRevealRight
		else
			idx = idxFrameEndRevealRight
		endif
		alfaRightRSL = asn((rightRevealPnts[idx][1] - gs_sidelight_WHole_width_right - gs_reveal_right_sR - gs_trim_width_out + gs_trim_offs_out) / rSill)

		ArcLengthSillToAngle	= 180 / rSill / PI
		ArcLengthBoardToAngle	= 180 / rBoard / PI

		alfaLeftJamb	= widoLeftJamb  * ArcLengthSillToAngle
		alfaRightJamb	= widoRightJamb * ArcLengthSillToAngle
	endif
endif	! curvedWall


! ==============================================================================
! Overhang Control
! ==============================================================================

if abs(WIDO_SILL) > EPS & gs_trim_atframe_out then
	gs_trimov_top_left_out	= 0
	gs_trimov_top_right_out	= 0
	gs_trimov_bot_left_out	= 0
	gs_trimov_bot_right_out	= 0
endif

bTrimovtopleftout 	= 0
bTrimovtoprightout 	= 0
bTrimovbotleftout  	= 0
bTrimovbotrightout  = 0
if abs(gs_trimov_top_left_out)  > EPS then bTrimovtopleftout  = 1
if abs(gs_trimov_top_right_out) > EPS then bTrimovtoprightout = 1
if isWindow then
	if abs(gs_trimov_bot_left_out)  > EPS then bTrimovbotleftout  = 1
	if abs(gs_trimov_bot_right_out) > EPS then bTrimovbotrightout = 1
else
	if bTShapedOpening then
		if (EPS < gs_trimov_bot_left_out & gs_trimov_bot_left_out < gs_sidelight_parapet_hgt_left) then bTrimovbotleftout  = 1
		if (EPS < gs_trimov_bot_right_out & gs_trimov_bot_right_out < gs_sidelight_parapet_hgt_right) then bTrimovbotrightout = 1
	endif
endif

bTrimovtopleftin 	= 0
bTrimovtoprightin 	= 0
bTrimovbotleftin  	= 0
bTrimovbotrightin  	= 0
if abs(gs_trimov_top_left_in)  > EPS then bTrimovtopleftin  = 1
if abs(gs_trimov_top_right_in) > EPS then bTrimovtoprightin = 1
if isWindow then
	if abs(gs_trimov_bot_left_in)  > EPS then bTrimovbotleftin  = 1
	if abs(gs_trimov_bot_right_in) > EPS then bTrimovbotrightin = 1
else
	if bTShapedOpening then
		if (EPS < gs_trimov_bot_left_in & gs_trimov_bot_left_in < gs_sidelight_parapet_hgt_left) then bTrimovbotleftin  = 1
		if (EPS < gs_trimov_bot_right_in & gs_trimov_bot_right_in < gs_sidelight_parapet_hgt_right) then bTrimovbotrightin = 1
	endif
endif


! ==============================================================================
! Apron Control
! ==============================================================================

if gs_apron then
	bBottomtriminmat=gs_apron_mat
	bBottomtriminthk=gs_apron_thk
else
	bBottomtriminmat=gs_trim_in_mat
	bBottomtriminthk=gs_trim_thk_in
endif


! ==============================================================================
! Custom Corner Function Control
! ==============================================================================

if abs(leftCornerAngle mod 360) < EPS then leftCornerAngle = 0
if abs(rightCornerAngle mod 360) < EPS then rightCornerAngle = 0

if bLeftCornerFunction and abs(leftCornerAngle) < EPS then bLeftCornerFunction = 0
if bRightCornerFunction and abs(rightCornerAngle) < EPS then bRightCornerFunction = 0


! ==============================================================================
! Calculation for Corner Column
! ==============================================================================

if gs_corner_column then
	if bRightCornerFunction & abs(rightCornerAngle) > EPS then
		cornerPostXbyWidth	= (-WIDO_FRAME_THICKNESS - gs_cc_pr) * abs(tan(90 - rightCornerAngle / 2)) + gs_cc_width
		cornerPostXbyThk	= (gs_cc_thk - WIDO_FRAME_THICKNESS - gs_cc_pr) * abs(tan(90 - rightCornerAngle / 2))
		pxFrameR = max(cornerPostXbyWidth, cornerPostXbyThk)

		tanAngle = tan(rightCornerAngle / 2)
		if (rightCornerAngle > 180) then
			px1R = -gs_cc_pr / tanAngle
			px2R =  WIDO_FRAME_THICKNESS / tanAngle
			px3R =  -(gs_cc_pr - gs_cc_thk) / tanAngle
		else
			px1R =  gs_cc_pr / tanAngle
			px2R = -WIDO_FRAME_THICKNESS / tanAngle
			px3R =  (gs_cc_pr - gs_cc_thk) / tanAngle
		endif
	endif

	if bLeftCornerFunction & abs(leftCornerAngle) > EPS then
		cornerPostXbyWidth	= (-WIDO_FRAME_THICKNESS - gs_cc_pr) * abs(tan(90 - leftCornerAngle / 2)) + gs_cc_width
		cornerPostXbyThk	= (gs_cc_thk - WIDO_FRAME_THICKNESS - gs_cc_pr) * abs(tan(90 - leftCornerAngle / 2))
		pxFrameL = max(cornerPostXbyWidth, cornerPostXbyThk)

		tanAngle = tan(leftCornerAngle / 2)
		if (leftCornerAngle > 180) then
			px1L = -gs_cc_pr / tanAngle
			px2L =  WIDO_FRAME_THICKNESS / tanAngle
			px3L =  -(gs_cc_pr - gs_cc_thk) / tanAngle
		else
			px1L =  gs_cc_pr / tanAngle
			px2L = -WIDO_FRAME_THICKNESS / tanAngle
			px3L =  (gs_cc_pr - gs_cc_thk) / tanAngle
		endif
	endif

	if (rightCornerAngle > 180) then
		idxL = idxFrameEndRevealLeft
		idxR = idxFrameEndRevealRight
	else
		idxL = idxFrameStartRevealLeft
		idxR = idxFrameStartRevealRight
	endif

	bMirrorRight	= (rightCornerAngle > 180)
	bMirrorLeft		= (leftCornerAngle > 180)
	offsLeftY		= ((leftCornerAngle > 180) exor (rightCornerAngle > 180)) * (2 * gs_cc_pr - gs_cc_thk)
	if abs(leftCornerAngle) > EPS then
		offsLeftX	= -abs(offsLeftY / tan(leftCornerAngle / 2))
	endif
endif


! ==============================================================================
! Calculations for Slanted Reveal
! ==============================================================================

if GLOB_SCRIPT_TYPE = 2 | GLOB_SCRIPT_TYPE = 3 then
	trinfiL = gs_reveal_left_angle
	trinfiR = gs_reveal_right_angle

	trinL = gs_trim_width_in / cos(trinfiL)
	trinR = gs_trim_width_in / cos(trinfiR)

	gi1L=WALL_INCL
	gi2L=90-abs(trinfiL)
	gi3L=180-gi1L-gi2L
	trin2L = trinL/sin(gi3L)*sin(gi2L)

	gi1R=WALL_INCL
	gi2R=90+abs(trinfiR)
	gi3R=180-gi1R-gi2R
	trin2R = trinR/sin(gi3R)*sin(gi2R)

	scLx = gs_trim_thk_in * tan(trinfiL)
	scRx = gs_trim_thk_in * tan(trinfiR)
	sfLx = WIDO_FRAME_THICKNESS * tan(trinfiL)
	sjLx = (WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS) * tan(trinfiL)
	sfjLx = (WALL_THICKNESS - WIDO_SILL) * tan(trinfiL)

	trinfiB = gs_reveal_bottom_angle
	trinB = gs_trim_width_in / cos(trinfiB)
	sfby = WIDO_FRAME_THICKNESS * tan(trinfiB) * (iRevealType = REVEAL_SLANTED)
	sjby = (WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS) * tan(trinfiB)
	scBy = gs_trim_thk_in * tan(trinfiB)

	trinfiT = gs_reveal_top_angle
	trinT = gs_trim_width_in / cos(trinfiT)
	sfty = WIDO_FRAME_THICKNESS * tan(trinfiT) * (iRevealType = REVEAL_SLANTED)
	sjty = (WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS) * tan(trinfiT)
	scTy = gs_trim_thk_in * tan(trinfiT)
else
	trinfiL = 0
	trinfiR = 0

	trinL = 0
	trinR = 0

	gi1L = 0
	gi2L = 0
	gi3L = 0
	trin2L = 0

	gi1R = 0
	gi2R = 0
	gi3R = 0
	trin2R = 0

	scLx = 0
	scRx = 0
	sfLx = 0
	sjLx = 0
	sfjLx = 0

	trinfiB = 0
	trinB = 0
	sfby = 0
	sjby = 0
	scBy = 0

	trinfiT = 0
	trinT = 0
	sfty = 0
	sjty = 0
	scTy = 0
endif


! ==============================================================================
! Set controller parameters for Simple with Overhang
! ==============================================================================

_bPocketDoor = 0
if iDoorType = 6 | iDoorType = 7 then _bPocketDoor = 1

_bEnableOutsideCasingOverhang = bittest(gs_CasingOutTypeEnable, 1)		! Complex with Overhang

if	(_bEnableOutsideCasingOverhang & (gs_trimtype_out_int = CASING_OVERHANG)) |\
	(_bPocketDoor & (gs_frame_wthk | (iRevealType = REVEAL_EDGE))) then

	gs_trim_show_cover_out = 1
endif

_bEnableInsideCasingOverhang = bittest(gs_CasingInTypeEnable, 1)		! Complex with Overhang

if	(_bEnableInsideCasingOverhang & (gs_trimtype_in_int = CASING_OVERHANG)) |\
	(_bPocketDoor & gs_frame_wthk) then

	gs_trim_show_cover_in = 1
endif


! ==============================================================================
! Set controller parameters for Complex Casing
! ==============================================================================

_bArchitraveCapitalOnSide = (iArchitraveCapitalType = ARCH_CAPITAL_SQUARE_ONSIDE |\
							 iArchitraveCapitalType = ARCH_CAPITAL_DECOR_ONSIDE)

_bEnableOutsideCasingComplex = bittest(gs_CasingOutTypeEnable, 2)		! Complex with Overhang

if _bEnableOutsideCasingComplex & (gs_trimtype_out_int = CASING_COMPLEX) then
	gs_trim_show_cover_out = 1
endif


! ==============================================================================
! Enable Switchable Casing Cover
! ==============================================================================

bExtSliding = 0
if iDoorType = 8 | iDoorType = 9 then bExtSliding = 1

_bEnableSwitchableOutCasCover =	(gs_casing_che |\
								 (not(bCasingUSA | gs_casing_nor | bExtSliding) &\ 
								  (iWindowShape = SHAPE_RECTANGULAR |\
								   iWindowShape = SHAPE_ARCHED |\
								   iWindowShape = SHAPE_T |\
								   iWindowShape = SHAPE_HALF_T_LEFT |\
								   iWindowShape = SHAPE_ARCHED_T |\
								   iWindowShape = SHAPE_ARCHED_HALF_T_LEFT |\
								   iWindowShape = SHAPE_HALF_T_RIGHT |\
								   iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT |\
								   iWindowShape = SHAPE_ELLIPSEARCH)))

if not(_bEnableSwitchableOutCasCover) then gs_trim_show_cover_out = 1

_bEnableSwitchableInCasCover =	(gs_casing_che |\
								 (not(bCasingUSA | gs_casing_nor) &\ 
								  (iWindowShape = SHAPE_RECTANGULAR |\
								   iWindowShape = SHAPE_ARCHED |\
								   iWindowShape = SHAPE_T |\
								   iWindowShape = SHAPE_HALF_T_LEFT |\
								   iWindowShape = SHAPE_ARCHED_T |\
								   iWindowShape = SHAPE_ARCHED_HALF_T_LEFT |\
								   iWindowShape = SHAPE_HALF_T_RIGHT |\
								   iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT |\
								   iWindowShape = SHAPE_ELLIPSEARCH)))


! ==============================================================================
! Set Casing Cover in case of Curved Wall
! ==============================================================================

if curvedWall then
	gs_trim_show_cover_out	= 1
	gs_trim_show_cover_in	= 1
endif


! ==============================================================================
! Enable Switchable Bottom Casing
! ==============================================================================

if bEnableSwitchableBottomCasing < 0 then
	bEnableSwitchableBottomCasing = isWindow &\
									(iWindowShape = SHAPE_RECTANGULAR |\
									 iWindowShape = SHAPE_ARCHED |\
									 iWindowShape = SHAPE_EYEBROWS |\
									 iWindowShape = SHAPE_HALFCIRCLE |\
									 iWindowShape = SHAPE_HALFARCH |\
									 iWindowShape = SHAPE_PENTAGON |\
									 iWindowShape = SHAPE_QUARTERROUND |\
									 iWindowShape = SHAPE_TRAPEZOID |\
									 iWindowShape = SHAPE_TRIANGLE |\
									 iWindowShape = SHAPE_GOTHICARCH |\
									 iWindowShape = SHAPE_ELLIPSEARCH |\
									 iWindowShape = SHAPE_HORSESHOE |\
									 iWindowShape = SHAPE_OGEECENTERED |\
									 iWindowShape = SHAPE_SARACENIC |\
									 iWindowShape = SHAPE_CORNER_TRIANGLE |\
									 iWindowShape = SHAPE_QUARTERROUND_NOFRAME)
endif

]]></Script_1D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_PR SectVersion="20" SectionFlags="0" SubIdent="0"><![CDATA[

]]></Script_PR>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_UI SectVersion="20" SectionFlags="0" SubIdent="0"><![CDATA[


CasingTypesonUI = 1
if gs_CasingOutTypeEnable = 1 & gs_CasingInTypeEnable = 1 then CasingTypesonUI = 0

bTShapeOpening = ((iWindowShape = SHAPE_T |\
				  iWindowShape = SHAPE_ARCHED_T) &\
				 (gs_sidelight_parapet_hgt_left > EPS |\
				  gs_sidelight_parapet_hgt_right > EPS))

bPShapeOpening = (((iWindowShape = SHAPE_HALF_T_LEFT |\
					iWindowShape = SHAPE_ARCHED_HALF_T_LEFT) &\
				   (gs_sidelight_parapet_hgt_left > EPS)) |\
				  ((iWindowShape = SHAPE_HALF_T_RIGHT |\
					iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT) &\
				   (gs_sidelight_parapet_hgt_right > EPS)))

bArchedTopTPShape = (iWindowShape = SHAPE_ARCHED_T |\
					 iWindowShape = SHAPE_ARCHED_HALF_T_LEFT |\
					 iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT)


! ================================================================================
! DW Outside Casing UI - INT
! ================================================================================

if bCasingOutPage then

	pageStartY	= 3 + 29

	if	gs_trim_outside_uniform						|\
		iWindowShape = SHAPE_PENTAGON				|\
		iWindowShape = SHAPE_TRAPEZOID				|\
		iWindowShape = SHAPE_ARCHED					|\
		iWindowShape = SHAPE_ELLIPSEARCH			|\
		iWindowShape = SHAPE_T						|\
		iWindowShape = SHAPE_HALF_T_LEFT			|\
		iWindowShape = SHAPE_HALF_T_RIGHT			|\
		iWindowShape = SHAPE_ARCHED_T				|\
		iWindowShape = SHAPE_ARCHED_HALF_T_LEFT		|\
		iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT	|\
		not(iCasingWidthControl = FULL_EDITABLE)	|\
		(iCasingWidthControl = SIDE_EDITABLE)		then

		n = request("Working_length_unit", "", formatt)
	endif

	x1 = 0
	x2 = 15
	x3 = 170	!240
	x4 = 350	!430
	x5 = 440

	cx = 70
	cy = 19
	y = pageStartY
	dy = 20

	dy = 20
	cx2 = 110

	! --------------------------------------------------------------------------------
	! DW Outside Casing Header - Left Side!
	! --------------------------------------------------------------------------------

	ui_style 0, 1
	ui_infield{3} "gs_trim_outside", x1, y, x3-x1-1, cy,
			7, "",
			1,
			1, 0, 0, 0, 0,
			"", stCasingUI[1], 0,	! Outside Casing
			"", stCasingUI[1], 1	! Outside Casing
	y = y + dy + 1

	ui_style 0, 0

	! Outside Casing Uniform Checkbox
	! --------------------------------------------------------------------------------
	if bEnableUniformCasing then
		ui_infield{3} "gs_trim_outside_uniform", x2, y, x3-x2-1, cy,
				7, "",
				1,
				1, 0, 0, 0, 0,
				"", stCasingUI[3], 0,	! Uniform Casing Widths
				"", stCasingUI[3], 1	! Uniform Casing Widths

		y = y + dy
	endif

	! Switchable Bottom Casing Checkbox
	! --------------------------------------------------------------------------------
	if bEnableSwitchableBottomCasing then
		ui_infield{3} "bCasingBottomOutside", x2, y, x3-x2-1, cy,
				7, "",
				1,
				1, 0, 0, 0, 0,
				"", stCasingUI[4], 0,	! Outside Bottom Casing
				"", stCasingUI[4], 1	! Outside Bottom Casing

		y = y + dy
	endif

	! Cover Outer Wall Surface Checkbox
	! --------------------------------------------------------------------------------
	if _bEnableSwitchableOutCasCover &\
		gs_trimtype_out_int <> CASING_COMPLEX then
		ui_infield{3} "gs_trim_show_cover_out", x2, y, x3-x2-1, cy,
				7, "",
				1,
				1, 0, 0, 0, 0,
				"", stCasingUI[16], 0,	! Cover Outer Wall Surface
				"", stCasingUI[16], 1	! Cover Outer Wall Surface

		y = y + dy
	endif



	! Architrave Capital Checkbox
	! --------------------------------------------------------------------------------
	if _bEnableOutsideCasingComplex &\
		gs_trimtype_out_int = CASING_COMPLEX then
		y = y + dy*not(bEnableSwitchableBottomCasing) + dy*not(_bEnableSwitchableOutCasCover) + 1

		ui_infield{3} "bArchitraveCapital", x1, y, x3-x1-1, cy,
				7, "",
				1,
				1, 0, 0, 0, 0,
				"", stCasingUI[21], 0,	! Architrave Capital
				"", stCasingUI[21], 1	! Architrave Capital

		_y_capital_infield = y
		y = y + dy
	else
		if not(bEnableSwitchableBottomCasing) then y = y + dy
	endif



	_y_left = y


	! --------------------------------------------------------------------------------
	! DW Outside Casing Header - Right Side!
	! --------------------------------------------------------------------------------

	y = pageStartY
	ui_style 0, 0

	! Outside Casing Type Selector
	! --------------------------------------------------------------------------------
	if gs_CasingOutTypeEnable > 1 then
		ui_infield{3} "gs_trimtype_out_int", x3, y, x4-x3, cy,
			8, "",
			1,
			1, 0, 0, 0, 0,
			"",	stCasingType[1],	CASING_NORMAL,
			"",	stCasingType[2],	CASING_OVERHANG,
			"",	stCasingType[3],	CASING_COMPLEX

		y = y + dy + 6
	endif

	if	_bEnableOutsideCasingComplex &\
		gs_trimtype_out_int = CASING_COMPLEX then

		! Casing Head Type Selector
		! --------------------------------------------------------------------------------
		cx3 = 85
		cy3 = 55

		ui_infield{3} "iCasingHeadTypeOut", x5 - cx3, y, cx3, cy3,
			2, 488,		! DW_HeadType.png
			4,
			1, 70, 50, 70, 50,
			1,	stCasingHeadType[1],	CASING_HEAD_RECT,
			2,	stCasingHeadType[2],	CASING_HEAD_DECORATIVE_1,
			3,	stCasingHeadType[3],	CASING_HEAD_DECORATIVE_2,
			4,	stCasingHeadType[4],	CASING_HEAD_DECORATIVE_3

	
		! Architrave Capital Type Selector
		! --------------------------------------------------------------------------------
		y = _y_capital_infield
		ui_infield{3} "iArchitraveCapitalType", x3, y, x4-x3, cy,
			8, "",
			1,
			1, 0, 0, 0, 0,
			"",	stArchitraveCapitalType[1],	ARCH_CAPITAL_SQUARE_ONSIDE,
			"",	stArchitraveCapitalType[2],	ARCH_CAPITAL_SQUARE_NEXTSIDE,
			"",	stArchitraveCapitalType[3],	ARCH_CAPITAL_DECOR_ONSIDE,
			"",	stArchitraveCapitalType[4],	ARCH_CAPITAL_DECOR_NEXTSIDE

		y = y + dy
	endif

	_y_right = y


	! --------------------------------------------------------------------------------
	! Horizontal separator
	! --------------------------------------------------------------------------------
	sepy = max(_y_left, _y_right) + 4 - 2
	ui_separator 0, sepy, 444, sepy

	gosub "outsideWarning"


	! --------------------------------------------------------------------------------
	! DW Outside Casing Shapes
	! --------------------------------------------------------------------------------
	_iCasingType		= gs_trimtype_out_int
	_bCasing			= gs_trim_outside
	_bCasingCover		= gs_trim_show_cover_out | (gs_trimtype_out_int = CASING_COMPLEX)
	_bShowBottomCasing	= bCasingBottomOutside

	gosub "shapePictures"


	! Outside Casing Parameters
	! -------------------------------------------------------------------------------

	if isWindow then	! Casing parameters to window shapes

		if gs_trim_outside & _bCasingCover & _bShowShape then

			if iWindowShape = SHAPE_RECTANGULAR then

				! Common Casing Size Parameters

				if gs_trim_outside_uniform then
					str_tooltip = stCasingUITooltip[8]		! Outside Casing Width
				else
					str_tooltip = stCasingUITooltip[1]		! Outside Casing Width Side 1
				endif
				ui_infield "gs_tw_right_out", posx+picx+3, posy+42, cx, 20 ui_tooltip str_tooltip

				if gs_trim_outside_uniform then
					ui_outfield str(formatt, gs_tw_left_out), posx-cx/2-3, posy+46, cx/2, 16, 1
				else
					ui_infield "gs_tw_left_out", posx-cx-2, posy+42, cx, 20 ui_tooltip stCasingUITooltip[2]			! Outside Casing Width Side 2
				endif

				if gs_trim_outside_uniform then
					ui_outfield str(formatt, gs_tw_top_out), posx+29, posy-19, cx/2, 16, 2
				else
					ui_infield "gs_tw_top_out", posx-1+20*(gs_trimtype_out_int = CASING_NORMAL), posy-23, cx, 20 ui_tooltip stCasingUITooltip[3]	! Outside Casing Width Top
				endif

				if bCasingBottomOutside then
					if gs_trim_outside_uniform then
						ui_outfield str(formatt, gs_tw_bottom_out), posx+29, posy+picy+7, cx/2, 16, 2
					else
						ui_infield "gs_tw_bottom_out", posx+19-20*(gs_trimtype_out_int = CASING_COMPLEX), posy+picy+3, cx, 20 ui_tooltip stCasingUITooltip[4]		! Outside Casing Width Bottom
					endif
				endif


				! Casing Overhang Parameters by Casing Type

				if (gs_trimtype_out_int = CASING_OVERHANG) | (gs_trimtype_out_int = CASING_COMPLEX) then

					ui_infield "gs_trimov_top_right_out", posx+78, posy-23, cx, 20 ui_tooltip stCasingUITooltip[9]		! Outside Top Casing Overhang

					if bCasingBottomOutside then
						if (gs_trimtype_out_int = CASING_OVERHANG) then
							ui_infield "gs_trimov_bot_right_out", posx+picx+3, posy+80, cx, 20 ui_tooltip stCasingUITooltip[10]			! Outside Side Casing Overhang
						else
							ui_infield "casingOverhangBottomSideOut", posx+78, posy+picy+3, cx, 20 ui_tooltip stCasingUITooltip[24]	! Outside Bottom Casing Overhang
						endif
					endif
				endif

				if (gs_trimtype_out_int = CASING_COMPLEX) then
					if bArchitraveCapital & not(_bArchitraveCapitalOnSide) then
						ui_infield "architraveCapitalWidth", posx+picx+3, posy+15, cx, 20 ui_tooltip stCasingUITooltip[23]		! Architrave Capital Width
					endif
				endif
			endif

			if (iWindowShape = SHAPE_ARCHED |\
				iWindowShape = SHAPE_ELLIPSEARCH) then

				ui_infield "gs_tw_right_out", posx+picx+3, posy+42, cx, 20 ui_tooltip stCasingUITooltip[8]			! Outside Casing Width

				ui_outfield str(formatt, gs_tw_left_out), posx-cx/2-3, posy+46, cx/2, 16, 1

				ui_outfield str(formatt, gs_tw_top_out), posx+29, posy-19, cx/2, 16, 2

				if bCasingBottomOutside then
					ui_infield "gs_tw_bottom_out", posx+19, posy+picy+3, cx, 20 ui_tooltip stCasingUITooltip[4]		! Outside Casing Width Bottom
				endif
			endif

			if iWindowShape = SHAPE_PENTAGON | iWindowShape = SHAPE_TRAPEZOID then
				ui_infield "gs_tw_right_out", posx+picx+3, posy+42, cx, 20 ui_tooltip stCasingUITooltip[8]			! Outside Casing Width

				ui_outfield str(formatt, gs_tw_left_out), posx-cx/2-3, posy+46, cx/2, 16, 1

				if bCasingBottomOutside then
					ui_infield "gs_tw_bottom_out", posx+19, posy+picy+3, cx, 20 ui_tooltip stCasingUITooltip[4]		! Outside Casing Width Bottom
				endif
			endif

			if iWindowShape = SHAPE_QUARTERROUND then
				ui_infield "gs_tw_right_out", posx-cx-3, posy+42, cx, 20 ui_tooltip stCasingUITooltip[8]			! Outside Casing Width

				if bCasingBottomOutside then
					ui_infield "gs_tw_bottom_out", posx+19, posy+picy+3, cx, 20 ui_tooltip stCasingUITooltip[4]		! Outside Casing Width Bottom
				endif
			endif

			if iWindowShape = SHAPE_HALFCIRCLE then
				ui_infield "gs_tw_right_out", posx+19, posy-23, cx, 20 ui_tooltip stCasingUITooltip[8]				! Outside Casing Width
	
				if bCasingBottomOutside then
					ui_infield "gs_tw_bottom_out", posx+19, posy+picy+3, cx, 20 ui_tooltip stCasingUITooltip[4]		! Outside Casing Width Bottom
				endif
			endif
		endif

	else

		if gs_trim_outside & _bCasingCover & _bShowShape then

			if (iWindowShape = SHAPE_RECTANGULAR) | (iWindowShape = SHAPE_T) | (iWindowShape = SHAPE_HALF_T_LEFT) | (iWindowShape = SHAPE_HALF_T_RIGHT) then

				! Common Casing Size Parameters

				if gs_trim_outside_uniform then
					str_tooltip = stCasingUITooltip[8]		! Outside Casing Width
				else
					str_tooltip = stCasingUITooltip[1]		! Outside Casing Width Side 1
				endif
				ui_infield "gs_tw_right_out", posx+picx+3, posy+42, cx, 20 ui_tooltip str_tooltip

				if gs_trim_outside_uniform then
					ui_outfield str(formatt, gs_tw_left_out), posx-cx/2-3, posy+46, cx/2, 16, 1
				else
					ui_infield "gs_tw_left_out", posx-cx-2, posy+42, cx, 20 ui_tooltip stCasingUITooltip[2]			! Outside Casing Width Side 2
				endif

				if gs_trim_outside_uniform then
					ui_outfield str(formatt, gs_tw_top_out), posx+picx/2-cx/4, posy-19, cx/2, 16, 2
				else
					ui_infield "gs_tw_top_out", posx+picx/2-(cx-18)/2-17*not(gs_trimtype_out_int = CASING_NORMAL) + 5*(iWindowShape = SHAPE_T), posy-23, cx, 20 ui_tooltip stCasingUITooltip[3]	! Outside Casing Width Top
				endif

				if (iWindowShape = SHAPE_T) | (iWindowShape = SHAPE_HALF_T_LEFT) | (iWindowShape = SHAPE_HALF_T_RIGHT) then
					if (iWindowShape = SHAPE_HALF_T_RIGHT) then
						ui_outfield str(formatt, gs_tw_left_out), posx+picx+7, posy+86, cx/2, 16, 0

						if gs_trim_outside_uniform then
							ui_outfield str(formatt, gs_tw_bottom_out), posx+54, posy+picy+7, cx/2, 16, 2
						else
							ui_infield "gs_tw_bottom_out", posx+45, posy+picy+5, cx, 20 ui_tooltip stCasingUITooltip[4]		! Outside Casing Width Bottom
						endif
					else
						ui_outfield str(formatt, gs_tw_left_out), posx-cx/2-3, posy+86, cx/2, 16, 1

						if gs_trim_outside_uniform then
							ui_outfield str(formatt, gs_tw_bottom_out), posx+5, posy+picy+7, cx/2, 16, 2
						else
							ui_infield "gs_tw_bottom_out", posx-4, posy+picy+5, cx, 20 ui_tooltip stCasingUITooltip[4]		! Outside Casing Width Bottom
						endif
					endif

					if (iWindowShape = SHAPE_T) then
						ui_outfield str(formatt, gs_tw_right_out), posx+picx+3, posy+86, cx/2, 16, 0
						ui_outfield str(formatt, gs_tw_bottom_out), posx+picx-cx/2-5, posy+picy+7, cx/2, 16, 2
					endif
				endif


				! Casing Overhang Parameters by Casing Type

				if (gs_trimtype_out_int = CASING_OVERHANG) | (gs_trimtype_out_int = CASING_COMPLEX) then

					ui_infield "gs_trimov_top_right_out", posx+picx-15, posy-23, cx, 20 ui_tooltip stCasingUITooltip[9]		! Outside Top Casing Overhang

					if (gs_trimtype_out_int = CASING_COMPLEX) then
						if bArchitraveCapital & not(_bArchitraveCapitalOnSide) then
							ui_infield "architraveCapitalWidth", posx+picx+3, posy+15, cx, 20 ui_tooltip stCasingUITooltip[23]		! Architrave Capital Width
						endif
					endif

					if (iWindowShape = SHAPE_T) then
						if (gs_trimtype_out_int = CASING_OVERHANG) then
							ui_infield "gs_trimov_bot_right_out", posx+picx+3, posy+65, cx, 20 ui_tooltip stCasingUITooltip[10]			! Outside Side Casing Overhang
						else
							ui_infield "casingOverhangBottomSideOut", posx+picx+3, posy+65, cx, 20 ui_tooltip stCasingUITooltip[24]	! Outside Bottom Casing Overhang
						endif
					endif

					if (iWindowShape = SHAPE_HALF_T_LEFT) | (iWindowShape = SHAPE_HALF_T_RIGHT) then
						if (gs_trimtype_out_int = CASING_OVERHANG) then
							if (iWindowShape = SHAPE_HALF_T_LEFT) then
								ui_infield "gs_trimov_bot_left_out", posx-cx-3, posy+65, cx, 20 ui_tooltip stCasingUITooltip[10]			! Outside Side Casing Overhang
							endif

							if (iWindowShape = SHAPE_HALF_T_RIGHT) then
								ui_infield "gs_trimov_bot_right_out", posx+picx+3, posy+65, cx, 20 ui_tooltip stCasingUITooltip[10]		! Outside Side Casing Overhang
							endif
						else
							if (iWindowShape = SHAPE_HALF_T_RIGHT) then
								ui_infield "casingOverhangBottomSideOut", posx+picx+3, posy+65, cx, 20 ui_tooltip stCasingUITooltip[24]		! Outside Bottom Casing Overhang
							else
								ui_infield "casingOverhangBottomSideOut", posx-cx-3, posy+65, cx, 20 ui_tooltip stCasingUITooltip[24]		! Outside Bottom Casing Overhang
							endif
						endif
					endif
				endif
			endif

			if (iWindowShape = SHAPE_ARCHED_T) | (iWindowShape = SHAPE_ARCHED_HALF_T_LEFT) | (iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT) then

				ui_infield "gs_tw_right_out", posx+picx+3, posy+42, cx, 20 ui_tooltip stCasingUITooltip[8]		! Outside Casing Width
				ui_outfield str(formatt, gs_tw_left_out), posx-cx/2-3, posy+46, cx/2, 16, 1
				ui_outfield str(formatt, gs_tw_top_out), posx+picx/2-cx/4, posy-19, cx/2, 16, 2

				if (iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT) then
					ui_outfield str(formatt, gs_tw_left_out), posx+picx+7, posy+86, cx/2, 16, 0
					ui_infield "gs_tw_bottom_out", posx+45, posy+picy+5, cx, 20 ui_tooltip stCasingUITooltip[4]		! Outside Casing Width Bottom
				else
					ui_outfield str(formatt, gs_tw_left_out), posx-cx/2-3, posy+86, cx/2, 16, 1
					ui_infield "gs_tw_bottom_out", posx-4, posy+picy+5, cx, 20 ui_tooltip stCasingUITooltip[4]		! Outside Casing Width Bottom
				endif
				if (iWindowShape = SHAPE_ARCHED_T) then
					ui_outfield str(formatt, gs_tw_right_out), posx+picx+3, posy+86, cx/2, 16, 0
					ui_outfield str(formatt, gs_tw_bottom_out), posx+picx-cx/2-5, posy+picy+7, cx/2, 16, 2
				endif
			endif
		endif

	endif


	! --------------------------------------------------------------------------------
	! Vertical separator if the shape is showing
	! --------------------------------------------------------------------------------

	sepx = sepx * _bShowShape
	if sepx > 0 then
		ui_separator sepx, sepy+4, sepx, 266
	endif


	! --------------------------------------------------------------------------------
	! DW Outside Casing Section
	! --------------------------------------------------------------------------------

	picx = 99
	picy = 98
	posx = round_int((sepx+440)/2 - picx/2)
	posy = round_int((sepy+266)/2 - picy/2)
	_bShowCasingWidth = not(_bShowShape)

	if gs_trim_outside then
		if _bCasingCover then
			if _bShowCasingWidth then
				if bExtSliding then
					ui_pict 58, posx, posy, picx, picy, 1			! DExt_OutCasSectionWithCasWidth.png
				else
					ui_pict 2, posx, posy, picx, picy, 1			! DW_OutCasSectionWithCasWidth.png
				endif
				ui_infield "gs_trim_thk_out", posx-cx-3, posy+7, cx, 20 ui_tooltip stCasingUITooltip[5]		! Outside Casing Thickness on Wall
				ui_infield "gs_tw_right_out", posx-18, posy-23, cx, 20 ui_tooltip stCasingUITooltip[8]		! Outside Casing Casing Width
				ui_infield "gs_trim_offs_out", posx+59, posy-23, cx, 20 ui_tooltip stCasingUITooltip[7]		! Outside Casing Offset
			else
				if bExtSliding then
					if iRevealType = REVEAL_EDGE then
						ui_pict 489, posx, posy, picx, picy, 1			! DExt_OutCasSectionNoRevealEdge.png
					else
						ui_pict 57, posx, posy, picx, picy, 1			! DExt_OutCasSection.png
					endif
				else
					if _bPocketDoor then
						if gs_frame_wthk then
							ui_pict 496, posx, posy, picx, picy, 1			! DPocket_OutCasSectionCasWallThkFr.png					
						else
							if iRevealType = REVEAL_EDGE then
								ui_pict 500, posx, posy, picx, picy, 1		! DPocket_OutCasSectionCasNoRevealEdge.png
							else
								ui_pict 499, posx, posy, picx, picy, 1		! DPocket_OutCasSectionCas.png
							endif
						endif
					else
						ui_pict 1, posx, posy, picx, picy, 1			! DW_OutCasSection.png
					endif
				endif
				ui_infield "gs_trim_thk_out", posx-27, posy-23, cx, 20 ui_tooltip stCasingUITooltip[5]		! Outside Casing Thickness on Wall
				ui_infield "gs_trim_offs_out", posx+50, posy-23, cx, 20 ui_tooltip stCasingUITooltip[7]		! Outside Casing Offset
			endif
		else
			if _bPocketDoor then
				ui_pict 498, posx, posy, picx, picy, 1			! DPocket_OutCasSectionNoCasCover.png
			else
				ui_pict 3, posx, posy, picx, picy, 1			! DW_OutCasSectionNoCasCover.png
			endif

			ui_infield "gs_trim_jambext_nosing_out", posx-27, posy-23, cx, 20 ui_tooltip stCasingUITooltip[11]	! Outer Nosing
		endif

		ui_infield "gs_trim_width_out", posx+36, posy+98+3, cx, 20 ui_tooltip stCasingUITooltip[6]	! Outside Casing Thickness in Wallhole
	else
		if bExtSliding then
			ui_pict 59, posx, posy, picx, picy, 1			! DExt_OutCasSectionNoCas.png
		else
			if _bPocketDoor then
				if gs_frame_wthk then
					ui_pict 495, posx, posy, picx, picy, 1			! DPocket_OutCasSectionNoCasWallThkFr.png					
				else
					ui_pict 497, posx, posy, picx, picy, 1			! DPocket_OutCasSectionNoCas.png
				endif
			else
				ui_pict 4, posx, posy, picx, picy, 1			! DW_OutCasSectionNoCas.png
			endif
		endif
	endif



endif


! ================================================================================
! DW Inside Casing UI - INT
! ================================================================================

if bCasingInPage then

	if not(bTelescopic) then

		pageStartY	= 3 + 29

		if	gs_trim_inside_uniform						|\
			iWindowShape = SHAPE_PENTAGON				|\
			iWindowShape = SHAPE_TRAPEZOID				|\
			iWindowShape = SHAPE_ARCHED					|\
			iWindowShape = SHAPE_ELLIPSEARCH			|\
			iWindowShape = SHAPE_T						|\
			iWindowShape = SHAPE_HALF_T_LEFT			|\
			iWindowShape = SHAPE_HALF_T_RIGHT			|\
			iWindowShape = SHAPE_ARCHED_T				|\
			iWindowShape = SHAPE_ARCHED_HALF_T_LEFT		|\
			iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT	|\
			not(iCasingWidthControl = FULL_EDITABLE)	|\
			(iCasingWidthControl = SIDE_EDITABLE)		then
	
			n = request("Working_length_unit", "", formatt)
		endif

		x1 = 0
		x2 = 15
		x3 = 170	!240
		x4 = 350	!430
		x5 = 440

		cx = 70
		cy = 19
		y = pageStartY
		dy = 20

		dy = 20
		cx2 = 110

		! --------------------------------------------------------------------------------
		! DW Inside Casing Header - Left Side !
		! --------------------------------------------------------------------------------

		ui_style 0, 1
		ui_infield{3} "gs_trim_inside", x1, y, x3-x1-1, cy,
			7, "",
			1,
			1, 0, 0, 0, 0,
			"", stCasingUI[2], 0,	! Inside Casing
			"", stCasingUI[2], 1	! Inside Casing
		y = y + dy + 1

		ui_style 0, 0

		! Inside Casing Uniform Checkbox
		! --------------------------------------------------------------------------------
		if bEnableUniformCasing then
			ui_infield{3} "gs_trim_inside_uniform", x2, y, x3-x2-1, cy,
					7, "",
					1,
					1, 0, 0, 0, 0,
					"", stCasingUI[3], 0,	! Uniform Casing Widths
					"", stCasingUI[3], 1	! Uniform Casing Widths

			y = y + dy
		endif

		! Cover Inner Wall Surface Checkbox
		! --------------------------------------------------------------------------------
		if _bEnableSwitchableInCasCover then
			ui_infield{3} "gs_trim_show_cover_in", x2, y, x3-x2-1, cy,
					7, "",
					1,
					1, 0, 0, 0, 0,
					"", stCasingUI[17], 0,	! Cover Inner Wall Surface
					"", stCasingUI[17], 1	! Cover Inner Wall Surface

			y = y + dy
		endif

		_y_left = y


		! --------------------------------------------------------------------------------
		! Inside Casing Header - Right Side!
		! --------------------------------------------------------------------------------

		y = pageStartY
		ui_style 0, 0

		! Inside Casing Type Selector
		! --------------------------------------------------------------------------------
		if gs_CasingInTypeEnable > 1 then
			ui_infield{3} "gs_trimtype_in_int", x3, y, x4-x3, cy,
				8, "",
				1,
				1, 0, 0, 0, 0,
				"",	stCasingType[1],	CASING_NORMAL,
				"",	stCasingType[2],	CASING_OVERHANG

			y = y + dy + 6
		endif

		_y_right = y


		! --------------------------------------------------------------------------------
		! Horizontal separator
		! --------------------------------------------------------------------------------
		sepy = max(_y_left, _y_right) + 4
		ui_separator 0, sepy, 444, sepy

		gosub "insideWarning"


		! --------------------------------------------------------------------------------
		! DW Inside Casing Shapes
		! --------------------------------------------------------------------------------
		_iCasingType		= gs_trimtype_in_int
		_bCasing			= gs_trim_inside
		_bCasingCover		= gs_trim_show_cover_in
		_bShowBottomCasing	= 1

		gosub "shapePictures"


		! Inside Casing Parameters
		! -------------------------------------------------------------------------------

		if isWindow then	! Casing parameters to window shapes

			if gs_trim_inside & _bCasingCover & _bShowShape then

				if iWindowShape = SHAPE_RECTANGULAR then

					! Common Casing Size Parameters

					if gs_trim_inside_uniform then
						str_tooltip = stCasingUITooltip[20]		! Inside Casing Width
					else
						str_tooltip = stCasingUITooltip[13]		! Inside Casing Width Side 1
					endif
					ui_infield "gs_tw_right_in", posx+picx+3, posy+42, cx, 20 ui_tooltip str_tooltip

					if gs_trim_inside_uniform then
						ui_outfield str(formatt, gs_tw_left_in), posx-cx/2-3, posy+46, cx/2, 16, 1
					else
						ui_infield "gs_tw_left_in", posx-cx-2, posy+42, cx, 20 ui_tooltip stCasingUITooltip[14]			! Inside Casing Width Side 2
					endif

					if gs_trim_inside_uniform then
						ui_outfield str(formatt, gs_tw_top_in), posx+29, posy-19, cx/2, 16, 2
					else
						ui_infield "gs_tw_top_in", posx-1+20*(gs_trimtype_in_int = CASING_NORMAL), posy-23, cx, 20 ui_tooltip stCasingUITooltip[15]	! Inside Casing Width Top
					endif

					if gs_trim_inside_uniform then
						ui_outfield str(formatt, gs_tw_bottom_in), posx+29, posy+picy+7, cx/2, 16, 2
					else
						ui_infield "gs_tw_bottom_in", posx+19, posy+picy+3, cx, 20 ui_tooltip stCasingUITooltip[16]	! Inside Casing Width Bottom
					endif


					! Casing Overhang Parameters by Casing Type

					if (gs_trimtype_in_int = CASING_OVERHANG) then
						ui_infield "gs_trimov_top_right_in", posx+78, posy-23, cx, 20 ui_tooltip stCasingUITooltip[21]		! Inside Top Casing Overhang

						ui_infield "gs_trimov_bot_right_in", posx+picx+3, posy+80, cx, 20 ui_tooltip stCasingUITooltip[22]			! Inside Side Casing Overhang
					endif
				endif

				if (iWindowShape = SHAPE_ARCHED |\
					iWindowShape = SHAPE_ELLIPSEARCH) then

					ui_infield "gs_tw_right_in", posx+picx+3, posy+42, cx, 20 ui_tooltip stCasingUITooltip[20]		! Inside Casing Width

					ui_outfield str(formatt, gs_tw_left_in), posx-cx/2-3, posy+46, cx/2, 16, 1

					ui_outfield str(formatt, gs_tw_top_in), posx+29, posy-19, cx/2, 16, 2

					ui_infield "gs_tw_bottom_in", posx+19, posy+picy+3, cx, 20 ui_tooltip stCasingUITooltip[16]		! Inside Casing Width Bottom
				endif

				if iWindowShape = SHAPE_PENTAGON | iWindowShape = SHAPE_TRAPEZOID then
					ui_infield "gs_tw_right_in", posx+picx+3, posy+42, cx, 20 ui_tooltip stCasingUITooltip[20]		! Inside Casing Width

					ui_outfield str(formatt, gs_tw_left_in), posx-cx/2-3, posy+46, cx/2, 16, 1

					ui_infield "gs_tw_bottom_in", posx+19, posy+picy+3, cx, 20 ui_tooltip stCasingUITooltip[16]		! Inside Casing Width Bottom
				endif

				if iWindowShape = SHAPE_QUARTERROUND then
					ui_infield "gs_tw_right_in", posx-cx-3, posy+42, cx, 20 ui_tooltip stCasingUITooltip[20]		! Inside Casing Width

					ui_infield "gs_tw_bottom_in", posx+19, posy+picy+3, cx, 20 ui_tooltip stCasingUITooltip[16]		! Inside Casing Width Bottom
				endif

				if iWindowShape = SHAPE_HALFCIRCLE then
					ui_infield "gs_tw_right_in", posx+19, posy-23, cx, 20 ui_tooltip stCasingUITooltip[20]			! Inside Casing Width

					ui_infield "gs_tw_bottom_in", posx+19, posy+picy+3, cx, 20 ui_tooltip stCasingUITooltip[16]		! Inside Casing Width Bottom
				endif
			endif

		else

			if gs_trim_inside & _bCasingCover & _bShowShape then

				if (iWindowShape = SHAPE_RECTANGULAR) | (iWindowShape = SHAPE_T) | (iWindowShape = SHAPE_HALF_T_LEFT) | (iWindowShape = SHAPE_HALF_T_RIGHT) then

					! Common Casing Size Parameters

					if gs_trim_inside_uniform then
						str_tooltip = stCasingUITooltip[20]		! Inside Casing Width
					else
						str_tooltip = stCasingUITooltip[13]		! Inside Casing Width Side 1
					endif
					ui_infield "gs_tw_right_in", posx+picx+3, posy+42, cx, 20 ui_tooltip str_tooltip

					if gs_trim_inside_uniform then
						ui_outfield str(formatt, gs_tw_left_in), posx-cx/2-3, posy+46, cx/2, 16, 1
					else
						ui_infield "gs_tw_left_in", posx-cx-2, posy+42, cx, 20 ui_tooltip stCasingUITooltip[14]			! Inside Casing Width Side 2
					endif

					if gs_trim_inside_uniform then
						ui_outfield str(formatt, gs_tw_top_in), posx+picx/2-cx/4, posy-19, cx/2, 16, 2
					else
						ui_infield "gs_tw_top_in", posx+picx/2-(cx-18)/2-17*not(gs_trimtype_in_int = CASING_NORMAL) + 5*(iWindowShape = SHAPE_T), posy-23, cx, 20 ui_tooltip stCasingUITooltip[15]	! Inside Casing Width Top
					endif

					if (iWindowShape = SHAPE_T) | (iWindowShape = SHAPE_HALF_T_LEFT) | (iWindowShape = SHAPE_HALF_T_RIGHT) then
						if (iWindowShape = SHAPE_HALF_T_RIGHT) then
							ui_outfield str(formatt, gs_tw_left_in), posx+picx+7, posy+86, cx/2, 16, 0

							if gs_trim_inside_uniform then
								ui_outfield str(formatt, gs_tw_bottom_in), posx+54, posy+picy+7, cx/2, 16, 2
							else
								ui_infield "gs_tw_bottom_in", posx+45, posy+picy+5, cx, 20 ui_tooltip stCasingUITooltip[16]		! Inside Casing Width Bottom
							endif
						else
							ui_outfield str(formatt, gs_tw_left_in), posx-cx/2-3, posy+86, cx/2, 16, 1

							if gs_trim_inside_uniform then
								ui_outfield str(formatt, gs_tw_bottom_in), posx+5, posy+picy+7, cx/2, 16, 2
							else
								ui_infield "gs_tw_bottom_in", posx-4, posy+picy+5, cx, 20 ui_tooltip stCasingUITooltip[16]		! Inside Casing Width Bottom
							endif
						endif

						if (iWindowShape = SHAPE_T) then
							ui_outfield str(formatt, gs_tw_right_in), posx+picx+3, posy+86, cx/2, 16, 0
							ui_outfield str(formatt, gs_tw_bottom_in), posx+picx-cx/2-5, posy+picy+7, cx/2, 16, 2
						endif
					endif


					! Casing Overhang Parameters by Casing Type

					if (gs_trimtype_in_int = CASING_OVERHANG) then

						ui_infield "gs_trimov_top_right_in", posx+picx-15, posy-23, cx, 20 ui_tooltip stCasingUITooltip[21]			! Inside Top Casing Overhang

						if (iWindowShape = SHAPE_T) then
							ui_infield "gs_trimov_bot_right_in", posx+picx+3, posy+65, cx, 20 ui_tooltip stCasingUITooltip[22]		! Inside Side Casing Overhang
						endif

						if (iWindowShape = SHAPE_HALF_T_LEFT) then
							ui_infield "gs_trimov_bot_left_in", posx-cx-3, posy+65, cx, 20 ui_tooltip stCasingUITooltip[22]		! Inside Side Casing Overhang
						endif

						if (iWindowShape = SHAPE_HALF_T_RIGHT) then
							ui_infield "gs_trimov_bot_right_in", posx+picx+3, posy+65, cx, 20 ui_tooltip stCasingUITooltip[22]		! Inside Side Casing Overhang
						endif
					endif
				endif

				if (iWindowShape = SHAPE_ARCHED_T) | (iWindowShape = SHAPE_ARCHED_HALF_T_LEFT) | (iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT) then

					ui_infield "gs_tw_right_in", posx+picx+3, posy+42, cx, 20 ui_tooltip stCasingUITooltip[20]		! Inside Casing Width
					ui_outfield str(formatt, gs_tw_left_in), posx-cx/2-3, posy+46, cx/2, 16, 1
					ui_outfield str(formatt, gs_tw_top_in), posx+picx/2-cx/4, posy-19, cx/2, 16, 2

					if (iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT) then
						ui_outfield str(formatt, gs_tw_left_in), posx+picx+7, posy+86, cx/2, 16, 0
						ui_infield "gs_tw_bottom_in", posx+45, posy+picy+5, cx, 20 ui_tooltip stCasingUITooltip[16]	! Inside Casing Width Bottom
					else
						ui_outfield str(formatt, gs_tw_left_in), posx-cx/2-3, posy+86, cx/2, 16, 1
						ui_infield "gs_tw_bottom_in", posx-4, posy+picy+5, cx, 20 ui_tooltip stCasingUITooltip[16]		! Inside Casing Width Bottom
					endif

					if (iWindowShape = SHAPE_ARCHED_T) then
						ui_outfield str(formatt, gs_tw_right_in), posx+picx+3, posy+86, cx/2, 16, 0
						ui_outfield str(formatt, gs_tw_bottom_in), posx+picx-cx/2-5, posy+picy+7, cx/2, 16, 2
					endif
				endif
			endif

		endif
	

		! --------------------------------------------------------------------------------
		! Vertical separator if the shape is showing
		! --------------------------------------------------------------------------------

		sepx = sepx * _bShowShape
		if sepx > 0 then
			ui_separator sepx, sepy+4, sepx, 266
		endif
	

		! --------------------------------------------------------------------------------
		! DW Inside Casing Section
		! --------------------------------------------------------------------------------

		posx = 100
		posy = 150

		picx = 99
		picy = 98
		posx = round_int((sepx+440)/2 - picx/2)
		posy = round_int((sepy+266)/2 - picy/2)
		_bShowCasingWidth = not(_bShowShape)

		if gs_trim_inside then
			if _bCasingCover then
				if _bShowCasingWidth then
					if bExtSliding then
						ui_pict 61, posx, posy, picx, picy, 1			! DExt_InCasSectionWithCasWidth.png
					else
						ui_pict 6, posx, posy, picx, picy, 1			! DW_InCasSectionWithCasWidth.png
					endif

					ui_infield "gs_trim_thk_in", posx-cx-3, posy+70, cx, 20 ui_tooltip stCasingUITooltip[17]		! Inside Casing Thickness on Wall
					ui_infield "gs_tw_right_in", posx-18, posy+picy+3, cx, 20 ui_tooltip stCasingUITooltip[20]		! Inside Casing Casing Width
					ui_infield "gs_trim_offs_in", posx+59, posy+picy+3, cx, 20 ui_tooltip stCasingUITooltip[19]		! Inside Casing Offset
				else
					if bExtSliding then
						ui_pict 60, posx, posy, picx, picy, 1			! DExt_InCasSection.png
					else
						if _bPocketDoor then
							if gs_frame_wthk then
								ui_pict 491, posx, posy, picx, picy, 1		! DPocket_InCasSectionCasWallThkFr.png					
							else
								ui_pict 494, posx, posy, picx, picy, 1		! DPocket_InCasSectionCas.png
							endif
						else
							ui_pict 5, posx, posy, picx, picy, 1			! DW_InCasSection.png
						endif
					endif

					ui_infield "gs_trim_thk_in", posx-27, posy+picy+3, cx, 20 ui_tooltip stCasingUITooltip[17]		! Inside Casing Thickness on Wall
					ui_infield "gs_trim_offs_in", posx+50, posy+picy+3, cx, 20 ui_tooltip stCasingUITooltip[19]		! Inside Casing Offset
				endif
			else
				if bExtSliding then
					ui_pict 62, posx, posy, picx, picy, 1			! DExt_InCasSectionNoCasCover.png
				else
					if _bPocketDoor then
						ui_pict 493, posx, posy, picx, picy, 1			! DPocket_InCasSectionNoCasCover.png
					else
						ui_pict 7, posx, posy, picx, picy, 1			! DW_InCasSectionNoCasCover.png
					endif
				endif

				ui_infield "gs_trim_jambext_nosing_in", posx-27, posy+picy+3, cx, 20 ui_tooltip stCasingUITooltip[12]	! Inner Nosing
			endif

			ui_infield "gs_trim_width_in", posx+36, posy-23, cx, 20 ui_tooltip stCasingUITooltip[18]	! Inside Casing Thickness in Wallhole
		else
			if bExtSliding then
				ui_pict 63, posx, posy, picx, picy, 1			! DExt_InCasSectionNoCas.png
			else
				if _bPocketDoor then
					if gs_frame_wthk then
						ui_pict 490, posx, posy, picx, picy, 1			! DPocket_InCasSectionNoCasWallThkFr.png					
					else
						ui_pict 492, posx, posy, picx, picy, 1			! DPocket_InCasSectionNoCas.png
					endif
				else
					ui_pict 8, posx, posy, picx, picy, 1			! DW_InCasSectionNoCas.png
				endif
			endif
		endif

	endif


	if bTelescopic then

		pageStartY	= 7
		y0			= 20 + pageStartY 

		if	gs_trim_inside_uniform						|\
			not(iCasingWidthControl = FULL_EDITABLE)	|\
			(iCasingWidthControl = SIDE_EDITABLE)		then

			n = request("Working_length_unit", "", formatt)
		endif

		x1 = 0
		x2 = 222
		x3 = 440
		cx = 70
		cy = 19
		y = 5 + pageStartY
		dy = 20

		ui_style 0, 1
		ui_infield{3} "gs_trim_inside", x1, y+5, x2-x1-1, cy,
				7, "",
				1,
				1, 0, 0, 0, 0,
				"", stCasingUI[2], 0,		! Inside Casing
				"", stCasingUI[2], 1		! Inside Casing

		ui_style 0, 0
		y = y + dy + 6

		if bEnableUniformCasing then
			ui_infield{3} "gs_trim_inside_uniform", x1, y+5, x3-x2, cy,
					7, "",
					1,
					1, 0, 0, 0, 0,
					"", stCasingUI[3], 0,	! Uniform Casing Widths
					"", stCasingUI[3], 1	! Uniform Casing Widths
		endif

		sepy = 35 + y0


		! --------------------------------------------------------------------------------
		! Horizontal separator
		! --------------------------------------------------------------------------------

		ui_separator 0, sepy, 444, sepy

		gosub "insideWarning"

		! ------ Horizontal Section
		posx = 0
		posy = 82 + y0
		cx = 70

		if gs_trim_inside then
			if gs_trim_inside_uniform then
				str_tooltip = stCasingUITooltip[20]		! Inside Casing Width
			else
				str_tooltip = stCasingUITooltip[13]		! Inside Casing Width Side 1
			endif

			ui_pict 482, posx, posy, 199, 97, 1			! telescopic_wallcover.png

			if gs_trim_inside_uniform then
				ui_outfield str(formatt, gs_tw_left_in), posx+11, posy+104, cx/2, 16, 2 ui_tooltip stCasingUITooltip[14]
			else
				ui_infield "gs_tw_left_in", posx, posy+100, cx, 20 ui_tooltip stCasingUITooltip[14]			! Inside Casing Width Side 2
			endif
			ui_infield "gs_tw_right_in", posx+(cx+5)*2-21, posy+100, cx, 20 ui_tooltip str_tooltip
			ui_infield "gs_trim_thk_in", posx+202, posy+73, cx, 20 ui_tooltip stCasingUITooltip[17]			! Inside Casing Thickness on Wall
			ui_infield "gs_trim_width_in", posx+15, posy-23, cx, 20 ui_tooltip stCasingUITooltip[18]		! Inside Casing Thickness in Wallhole
		else
			ui_pict 483, posx, posy, 199, 97, 1			! telescopic_wallcover_no.png
		endif

		! ------ Vertical Section
		posx = 279
		posy = 51 + y0
		dist = 45

		if gs_trim_inside then
			ui_pict 484, posx+7, posy, 84, 46, 1			! telescopic_wallcover_top.png

			if gs_trim_inside_uniform then
				ui_outfield str(formatt, gs_tw_top_in), posx+96, posy+22, cx/2, 16, 0
			else
				ui_infield "gs_tw_top_in", posx+94, posy+18, cx, 20 ui_tooltip stCasingUITooltip[15]		! Inside Casing Width Top
			endif
		else
			ui_pict 485, posx+7, posy, 84, 46, 1			! telescopic_wallcover_top_no.png

		endif
		ui_pict 481, posx+7*bTelescopic, posy+88+dist, 68, 42, 1		! telescopic_wallcover_bottom.png

	endif

endif


! ==============================================================================
! --- USA Window Casing Tabpage ---
! ==============================================================================

if bCasingPageUSA & isWindow then

	y0	 = 5
	
	sepx = 230

	flox = 140
	floy = 142
	secx = 142
	secy = 115

	pos1_x = 75
	pos1_y = 40 + y0

	pos2_x = sepx + 40
	pos2_y = 20 + y0

	descx = 70
	rowy = 18

	ui_style 0,1
	ui_infield{3} "gs_trim_outside", 70, y0, 150, rowy,
			7, "",
			2,
			1, 20, 20, 20, 20,
			0, stCasingTextUSA[9], 0,	! Outside
			1, stCasingTextUSA[9], 1

	ui_infield{3} "gs_trim_inside", 70, 206 + y0, 150, rowy,
			7, "",
			2,
			1, 20, 20, 20, 20,
			0, stCasingTextUSA[8], 0,	! Inside
			1, stCasingTextUSA[8], 1

	if bInsideCasingNotAvailableByReveal | bInsideCasingNotAvailableByWallType then
		y2 = 193 + y0
		ui_pict 446, 0, y2, 12, 12, 1	! ui_warningsign.png
		ui_style 0,0
		idx = 26 + (not(bInsideCasingNotAvailableByReveal) & bInsideCasingNotAvailableByWallType)
		ui_outfield stCasingTextUSA[idx], 20, y2, 200, 15

		gs_trim_inside = 0
	endif

	ui_style 0,0

	! Pict Index ---------------------------------------------------[

	ui_separator pos1_x + flox + 15, 5 + y0, pos1_x + flox + 15, 230 + y0

	! Wall Pict
	pictx_w1 = 65
	picty_w1 = 45
	pictx_w2 = 45
	picty_w2 = 40
	indexWallPict = 152	! 152 - 153
	indexWallSectPict = 186	! 186 - 187
	if gs_wt_m > 1 then	! Solid Wall, Custom Closure
		indexWallPict = indexWallPict + 1
		indexWallSectPict = indexWallSectPict + 1
	endif

	! Sash Pict
	pictx_s1 = 75
	picty_s1 = 45
	pictx_s2 = 45
	picty_s2 = 75
	indexOpPict = 154	! 154 - 165
	indexOpSectPict = 188	! 188 - 189
	if not(bOpeningDirection) then	! Outside Opening Direction
		indexOpPict = indexOpPict + 4
		indexOpSectPict = indexOpSectPict + 1
		if gs_trim_outside then
			if (gs_wt_m=1 AND ABS(WIDO_SILL) < EPS) OR gs_wt_m=2 OR gs_wt_m=3 OR gs_wt_m=4 then
				indexOpPict = indexOpPict + 4
			endif
		endif
	endif

	if not(gs_sill_outside) then
		if not(gs_board_inside) then
			indexOpPict = indexOpPict + 0	! No Sill & No Board
		else
			indexOpPict = indexOpPict + 1	! Board
		endif
	else
		if not(gs_board_inside) then
			indexOpPict = indexOpPict + 2	! Sill
		else
			indexOpPict = indexOpPict + 3	! Sill & Board
		endif
	endif

	! Outside Pict
	pictx_o1 = 140
	picty_o1 = 33
	pictx_o2 = 33
	picty_o2 = 115
	indexOutPict = 166	! 166 - 177
	indexOutSectPict = 190	! 190 - 195
	if gs_wt_m = 3 then	! Stud Wall
		indexOutPict = indexOutPict + 4
		indexOutSectPict = indexOutSectPict + 2
	endif
	if gs_wt_m = 4 then	! Brick Veneer
		indexOutPict = indexOutPict + 8
		indexOutSectPict = indexOutSectPict + 4
	endif

	if not(gs_sill_outside) then
		if not(gs_trim_outside) then
			indexOutPict = indexOutPict + 0	! No Sill & No Casing
			! if gs_wt_m = 1 then no pict
		else
			if (gs_wt_m=1 AND ABS(WIDO_SILL) < EPS) OR gs_wt_m=2 OR gs_wt_m=3 OR gs_wt_m=4 then
				indexOutPict = indexOutPict + 1		! No Sill & Casing, with Casing Offset
			else
				indexOutPict = indexOutPict + 320	! No Sill & Casing, without Casing Offset
			endif
		endif
	else
		if not(gs_trim_outside) then
			indexOutPict = indexOutPict + 2	! Sill & No Casing
		else
			if (gs_wt_m=1 AND ABS(WIDO_SILL) < EPS) OR gs_wt_m=2 OR gs_wt_m=3 OR gs_wt_m=4 then
				indexOutPict = indexOutPict + 3		! Sill & Casing, with Casing Offset
			else
				indexOutPict = indexOutPict + 321	! Sill & Casing, without Casing Offset
			endif
		endif
	endif

	if gs_trim_outside then
		indexOutSectPict = indexOutSectPict + 1
	endif

	! Inside Pict
	pictx_i1 = 140
	picty_i1 = 64
	pictx_i2 = 64
	picty_i2 = 115
	indexInPict = 178	! 178 - 185
	indexInSectPict = 196	! 196 - 199
	if gs_wt_m > 1 then
		indexInPict = indexInPict + 4
		indexInSectPict = indexInSectPict + 2
	endif

	if not(gs_board_inside) then
		if not(gs_trim_inside) then
			indexInPict = indexInPict + 0	! No Board & No Casing
			! if gs_wt_m = 1 then no pict
		else
			indexInPict = indexInPict + 1	! No Board & Casing
		endif
	else
		if not(gs_trim_inside) then
			indexInPict = indexInPict + 2	! Board & No Casing
		else
			indexInPict = indexInPict + 3	! Board & Casing
		endif
	endif

	if gs_trim_inside then
		indexInSectPict = indexInSectPict + 1
	endif

	! Pict Index ---------------------------------------------------]

	if indexOutPict <> 166 then	! clear area
		ui_pict indexOutPict, pos1_x, pos1_y, pictx_o1, picty_o1, 1
	endif
	if indexOutSectPict <> 190 then	! clear area
		ui_pict indexOutSectPict, pos2_x, pos2_y, pictx_o2, picty_o2, 1
	endif

	ui_pict indexWallPict, pos1_x, pos1_y + picty_o1, pictx_w1, picty_w1, 1
	ui_pict indexWallSectPict, pos2_x + pictx_o2, pos2_y, pictx_w2, picty_w2, 1

	ui_pict indexOpPict, pos1_x + pictx_w1, pos1_y + picty_o1, pictx_s1, picty_s1, 1
	ui_pict indexOpSectPict, pos2_x + pictx_o2, pos2_y + picty_w2, pictx_s2, picty_s2, 1

	ui_pict indexInPict, pos1_x, pos1_y + picty_o1 + picty_w1, pictx_i1, picty_i1, 1
	ui_pict indexInSectPict, pos2_x + pictx_o2 + pictx_w2, pos2_y, pictx_i2, picty_i2, 1


	if gs_trim_inside then
		ui_infield "gs_trim_width_in", pos1_x - descx - 1, pos1_y + 100, descx, rowy ui_tooltip stCasingTextUSA[21]		! Jamb Extension Width
		ui_infield "gs_trim_thk_in",pos1_x - descx - 1, pos1_y + 125, descx, rowy ui_tooltip stCasingTextUSA[23]		! Casing Thickness Inside

		ui_infield "gs_tw_right_in", pos1_x, pos1_y + 145, descx, rowy ui_tooltip stCasingTextUSA[20]					! Side Casing Width Inside
		if (gs_wt_m=1 & gs_trim_width_in > EPS) | gs_wt_m=2 | gs_wt_m=3 | gs_wt_m=4 then
			ui_infield "gs_trim_offs_in",pos1_x + descx + 1, pos1_y + 145, descx, rowy ui_tooltip stCasingTextUSA[22]	! Casing Offset Inside
		endif

		ui_infield "gs_tw_top_in", 444 - descx - 10, y0 - 3, descx, rowy ui_tooltip stCasingTextUSA[25]		! Head Casing Width Inside
	endif

	if gs_trim_outside then
		ui_infield "gs_tw_right_out", pos1_x, pos1_y - 20, descx, rowy ui_tooltip stCasingTextUSA[16]					! Side Casing Width Outside
		ui_infield "gs_trim_thk_out",pos1_x - descx - 1, pos1_y + 22, descx, rowy ui_tooltip stCasingTextUSA[19]		! Casing Thickness Outside

		if (gs_wt_m=1 AND ABS(WIDO_SILL) < EPS) OR gs_wt_m=2 OR gs_wt_m=3 OR gs_wt_m=4 then
			ui_infield "gs_trim_offs_out", pos1_x + descx + 1, pos1_y - 20, descx, rowy ui_tooltip stCasingTextUSA[18]	! Casing Offset Outside
		endif

		ui_infield "gs_tw_top_out", sepx + 14, y0 - 3, descx, rowy ui_tooltip stCasingTextUSA[24]		! Head Casing Width Outside
	endif


	! Casing Overhangs
	pos_x = sepx + 14
	pos_y = pos2_y + secy + 2
	descx = 135
	contx = 50
	dy = 23

	if gs_trim_outside then
		if (gs_wt_m=2 | gs_wt_m=1 & ABS(WIDO_SILL) < EPS | gs_wt_m=3) then
			if gs_win_type < 63 then
				ui_outfield stCasingTextUSA[1], pos_x, pos_y, descx, rowy			! Brick Mold. Top Overh.
				ui_infield "gs_trimov_top_right_out", pos_x + descx + 1, pos_y, contx , rowy
				pos_y = pos_y + dy
			endif

			if gs_win_type < 73 then
				ui_outfield stCasingTextUSA[2], pos_x, pos_y, descx, rowy			! Brick Mold. Bot. Overh.
				ui_infield "gs_trimov_bot_right_out", pos_x + descx + 1, pos_y, contx , rowy
				pos_y = pos_y + dy
			endif
		endif
	endif

	if gs_trim_inside then
		if (gs_wt_m > 1 | gs_wt_m = 1 & gs_trim_width_in > 0) then
			if gs_win_type < 63 then
				ui_outfield stCasingTextUSA[3],  pos_x, pos_y, descx, rowy			! Casing Trim Top Overh.
				ui_infield "gs_trimov_top_right_in", pos_x + descx + 1, pos_y, contx , rowy
				pos_y = pos_y + dy
			endif

			if gs_win_type < 73 then
				ui_outfield stCasingTextUSA[4],  pos_x, pos_y, descx, rowy			! Casing Trim Bot. Overh.
				ui_infield "gs_trimov_bot_right_in", pos_x + descx + 1, pos_y, contx , rowy
				pos_y = pos_y + dy
			endif
		endif
	endif

endif


! ==============================================================================
! --- USA Door Casing Tabpage ---
! ==============================================================================

if bCasingPageUSA & not(isWindow) then
	bPocketDoor = (iDoorType = 39 | iDoorType = 40)

		y0	 = 5

		sepx = 230
		flox = 140
		floy = 142
		secx = 142
		secy = 115

		pos1_x = 75
		pos1_y = 40 + y0

		pos2_x = sepx + 40
		pos2_y = 45 + y0

		descx = 70
		rowy = 18

		ui_style 0,1
		ui_infield{3} "gs_trim_outside", 70, y0, 150, rowy,
				7, "",
				2,
				1, 20, 20, 20, 20,
				0, stCasingTextUSA[9], 0,	! Outside
				1, stCasingTextUSA[9], 1

		if not(gs_sectgar) then
			ui_infield{3} "gs_trim_inside", 70, 206 + y0, 150, rowy,
					7, "",
					2,
					1, 20, 20, 20, 20,
					0, stCasingTextUSA[8], 0,	! Inside
					1, stCasingTextUSA[8], 1
		endif
		ui_style 0,0

! Garagge Doors ------------------------------------------------------------
		if gs_sectgar then
			! Pict Index ---------------------------------------------------[
			flox = 140
			floy = 170
			secx = 170
			secy = 115

			ui_separator pos1_x + flox + 15, 5 + y0, pos1_x + flox + 15, 230 + y0

		!	if gs_wt_m = 1 then	! Solid Wall, Custom Closure
				indexPict = 389	! 390 - 393
		!	endif
			if gs_wt_m = 2 then	! Stud Wall
				indexPict = 393	! 394 - 397
			endif
			if gs_wt_m = 3 then	! Stud Wall with Siding
				indexPict = 397	! 398 - 401
			endif
			if gs_wt_m = 4 then	! Brick Veneer
				indexPict = 401	!  402 - 405
			endif

			indexOp = 0

			! Casing Type Picture Index
			if not(gs_trim_outside) then	! No Casing
				indexCas = 1
			else							! Casing OutSide
				indexCas = 2
			endif

			IndexPictHor = indexPict + indexOp + indexCas	! 1-2
			IndexPictVer = indexPict + indexOp + 2 + indexCas	! 2-4

			ui_pict IndexPictHor, pos1_x, pos1_y, flox, floy, 1
			ui_pict IndexPictVer, pos2_x, pos2_y, secx, secy, 1

			if bInsideCasingNotAvailableByReveal | bInsideCasingNotAvailableByWallType then
				y2 = 187 + y0
				ui_pict 446, 0, y2, 12, 12, 1	! ui_warningsign.png
				ui_style 0,0
				idx = 26 + (not(bInsideCasingNotAvailableByReveal) & bInsideCasingNotAvailableByWallType)
				ui_outfield stCasingTextUSA[idx], 20, y2, 350, 15

				gs_trim_inside = 0
			endif
		else
! Pocket Doors ------------------------------------------------------------
			if bPocketDoor then
				! Pict Index ---------------------------------------------------[
				flo1_x = 140
				flo1_y = 67
				flo2_x = 140
				flo2_y = 25
				flo3_x = 140
				flo3_y = 50
				flox = 140
				floy = 142
				secx = 142
				secy = 115

				ui_separator pos1_x + flox + 15, 5 + y0, pos1_x + flox + 15, 230 + y0

				indexPict = 409	! 410 - 421
				indexMain = 424
				indexPict2 = 433 ! 434 - 445

				if gs_pocket_door_frame then
					if gs_frame_wthk then			! Frame = Wall Thk
						indexVert = indexPict2		! Full Frame
						indexOut = indexPict
						indexIn = indexPict + 8
					else
						indexVert = indexPict2 + 4	! Small Frame
						indexOut = indexPict + 2
						indexIn = indexPict + 10
					endif
				else
					indexVert = indexPict2 + 8 		! No Frame
					indexOut = indexPict + 5		! No Frame
					indexIn = indexPict + 12		! No Frame
				endif

				! Casing Type Picture Index
				if not(gs_trim_outside) then
					indexOut = indexOut + 2
					if not(gs_trim_inside) then		! No Casing
						indexVert = indexVert + 1
						indexIn = indexIn + 2
					else							! Casing Inside
						indexVert = indexVert + 2
						indexIn = indexIn + 1
					endif
				else
					if not(gs_trim_inside) then		! Casing Outside
						indexVert = indexVert + 3
						indexIn = indexIn + 2
						indexOut = indexOut + 1
					else							! Full Casing
						indexVert = indexVert + 4
						indexIn = indexIn + 1
						indexOut = indexOut + 3 - (2 * (gs_pocket_door_frame & gs_frame_wthk))
					endif
				endif

				ui_pict indexOut, pos1_x, pos1_y, flo1_x, flo1_y, 1
				ui_pict indexMain, pos1_x, pos1_y + flo1_y, flo2_x, flo2_y, 1
				ui_pict indexIn, pos1_x, pos1_y + flo1_y + flo2_y, flo3_x, flo3_y, 1
				ui_pict indexVert, pos2_x, pos2_y, secx, secy, 1

			else

! Normal Doors ------------------------------------------------------------
				! Pict Index ---------------------------------------------------[
				flox = 140
				floy = 142
				secx = 142
				secy = 115

				ui_separator pos1_x + flox + 15, 5 + y0, pos1_x + flox + 15, 230 + y0

				! Wall Pict
				pictx_w1 = 65
				picty_w1 = 45
				pictx_w2 = 45
				picty_w2 = 40
				indexWallPict = 152	! 152 - 153
				indexWallSectPict = 186	! 186 - 187
				if gs_wt_m > 1 then	! Solid Wall, Custom Closure
					indexWallPict = indexWallPict + 1
					indexWallSectPict = indexWallSectPict + 1
				endif

				! Sash Pict
				pictx_s1 = 75
				picty_s1 = 45
				pictx_s2 = 45
				picty_s2 = 75
				indexOpPict = 200	! 200 - 201
				indexOpSectPict = 202	! 202 - 203
				if not(bOpeningDirection) then	! Outside Opening Direction
					indexOpPict = indexOpPict + 1
					indexOpSectPict = indexOpSectPict + 1
				endif

				! Outside Pict
				pictx_o1 = 140
				picty_o1 = 33
				pictx_o2 = 33
				picty_o2 = 115
				indexOutPict = 166	! 166 - 177
				indexOutSectPict = 190	! 190 - 195
				if gs_wt_m = 3 then	! Stud Wall
					indexOutPict = indexOutPict + 4
					indexOutSectPict = indexOutSectPict + 2
				endif
				if gs_wt_m = 4 then	! Brick Veneer
					indexOutPict = indexOutPict + 8
					indexOutSectPict = indexOutSectPict + 4
				endif


				if not(gs_trim_outside) then
					indexOutPict = indexOutPict + 0	! No Sill & No Casing
					! if gs_wt_m = 1 then no pict
				else
					if (gs_wt_m=1 AND ABS(WIDO_SILL) < EPS) OR gs_wt_m=2 OR gs_wt_m=3 OR gs_wt_m=4 then
						indexOutPict = indexOutPict + 1		! No Sill & Casing
					else
						indexOutPict = indexOutPict + 320	! No Sill & Casing, without Casing Offset
					endif
				endif


				if gs_trim_outside then
					indexOutSectPict = indexOutSectPict + 1
				endif

				! Inside Pict
				pictx_i1 = 140
				picty_i1 = 64
				pictx_i2 = 64
				picty_i2 = 115
				indexInPict = 178	! 178 - 185
				indexInSectPict = 196	! 196 - 199
				if gs_wt_m > 1 then
					indexInPict = indexInPict + 4
					indexInSectPict = indexInSectPict + 2
				endif

				if not(gs_trim_inside) then
					indexInPict = indexInPict + 0	! No Board & No Casing
					! if gs_wt_m = 1 then no pict
				else
					indexInPict = indexInPict + 1	! No Board & Casing
				endif


				if gs_trim_inside then
					indexInSectPict = indexInSectPict + 1
				endif

				! Pict Index ---------------------------------------------------]

				if indexOutPict <> 166 then	! clear area
					ui_pict indexOutPict, pos1_x, pos1_y, pictx_o1, picty_o1, 1
				endif
				if indexOutSectPict <> 190 then	! clear area
					ui_pict indexOutSectPict, pos2_x, pos2_y, pictx_o2, picty_o2, 1
				endif

				ui_pict indexWallPict, pos1_x, pos1_y + picty_o1, pictx_w1, picty_w1, 1
				ui_pict indexWallSectPict, pos2_x + pictx_o2, pos2_y, pictx_w2, picty_w2, 1

				ui_pict indexOpPict, pos1_x + pictx_w1, pos1_y + picty_o1, pictx_s1, picty_s1, 1
				ui_pict indexOpSectPict, pos2_x + pictx_o2, pos2_y + picty_w2, pictx_s2, picty_s2, 1

				ui_pict indexInPict, pos1_x, pos1_y + picty_o1 + picty_w1, pictx_i1, picty_i1, 1
				ui_pict indexInSectPict, pos2_x + pictx_o2 + pictx_w2, pos2_y, pictx_i2, picty_i2, 1
			endif

		endif

		! Pict Index ---------------------------------------------------]


		if gs_trim_inside then
			if not(gs_frame_wthk) then
				ui_infield "gs_trim_width_in", pos1_x - descx - 1, pos1_y + 100, descx, rowy ui_tooltip stCasingTextUSA[21]		! Jamb Extension Width
			endif
			if not(gs_sectgar) then
				ui_infield "gs_tw_right_in", pos1_x, pos1_y + 145, descx, rowy ui_tooltip stCasingTextUSA[20]					! Side Casing Width Inside
				if (gs_wt_m=1 & gs_trim_width_in > EPS) | gs_wt_m=2 | gs_wt_m=3 | gs_wt_m=4 then
					ui_infield "gs_trim_offs_in",pos1_x + descx + 1, pos1_y + 145, descx, rowy ui_tooltip stCasingTextUSA[22]	! Casing Offset Inside
				endif

				ui_infield "gs_trim_thk_in",pos1_x - descx - 1, pos1_y + 120, descx, rowy ui_tooltip stCasingTextUSA[23]		! Casing Thickness Inside
			endif

			ui_infield "gs_tw_top_in", 444 - descx - 10, 22 + y0, descx, rowy ui_tooltip stCasingTextUSA[25]		! Head Casing Width Inside
		endif

		if gs_trim_outside then
			ui_infield "gs_tw_right_out", pos1_x, pos1_y - 20, descx, rowy				ui_tooltip stCasingTextUSA[16]		! Side Casing Width Outside
			ui_infield "gs_trim_thk_out",pos1_x - descx - 1, pos1_y + 22, descx, rowy 	ui_tooltip stCasingTextUSA[19]		! Casing Thickness Outside
			if gs_sectgar | (bPocketDoor & not(gs_frame_wthk) & not(gs_trim_inside)) then
				ui_infield "gs_trim_width_out", pos1_x - descx - 1, pos1_y + 42, descx, rowy ui_tooltip stCasingTextUSA[17]	! Jamb Extension Width Outside
			endif

			if (gs_wt_m=1 AND ABS(WIDO_SILL) < EPS) OR gs_wt_m=2 OR gs_wt_m=3 OR gs_wt_m=4 then
				ui_infield "gs_trim_offs_out", pos1_x + descx + 1, pos1_y - 20, descx, rowy ui_tooltip stCasingTextUSA[18]	! Casing Offset Outside
			endif

			ui_infield "gs_tw_top_out", sepx + 14, 22 + y0, descx, rowy ui_tooltip stCasingTextUSA[24]	! Head Casing Width Outside
		endif


		! Casing Overhangs
		pos_x = sepx + 14
		pos_y = pos2_y + secy + 15
		descx = 135
		contx = 50
		dy = 30

		if gs_trim_outside then
			if (gs_wt_m=2 | gs_wt_m=1 & ABS(WIDO_SILL) < EPS | gs_wt_m=3) then
				ui_outfield stCasingTextUSA[1], pos_x, pos_y, descx, rowy		! Brick Mold. Top Overh.
				ui_infield "gs_trimov_top_right_out", pos_x + descx + 1, pos_y, contx , rowy
				pos_y = pos_y + dy
			endif
		endif

		if gs_trim_inside then
			if (gs_wt_m > 1 | gs_wt_m = 1 & gs_trim_width_in > 0) then
				ui_outfield stCasingTextUSA[3],  pos_x, pos_y, descx, rowy		! Casing Trim Top Overh.
				ui_infield "gs_trimov_top_right_in", pos_x + descx + 1, pos_y, contx , rowy
				pos_y = pos_y + dy
			endif
		endif

endif


! ================================================================================
end
! ================================================================================


! --------------------------------------------------------------------------------
! Warning Message Inside
! --------------------------------------------------------------------------------
"insideWarning":
	if bInsideCasingNotAvailableByReveal then
		ui_pict 446, 2, sepy+7, 12, 12, 1	! ui_warningsign.png
		ui_style 0,0
		ui_outfield stCasingUI[18], 23, sepy+7, 240, 34
	else
		if bInsideCasingNotAvailableByWallType then
			ui_pict 446, 2, sepy+7, 12, 12, 1	! ui_warningsign.png
			ui_style 0,0
			ui_outfield stCasingUI[12], 23, sepy+7, 240, 34		! Casing is not available with trapezoid and curved walls.
		else
			if bInsideCasingNotAvailableByFrameStyle then
				if isWindow then
					ui_pict 446, 2, sepy+7, 12, 12, 1	! ui_warningsign.png
					ui_style 0,0
					ui_outfield stCasingUI[19], 23, sepy+7, 240, 34		! Casing is not available with the actual frame style.
				else
					posy = sepy+7+185*(bTShapeOpening | bPShapeOpening)
					ui_pict 446, 2, posy, 12, 12, 1	! ui_warningsign.png
					ui_style 0,0
					ui_outfield stCasingUI[19], 23, posy, 240, 34		! Casing is not available with the actual frame style.
				endif
			endif
		endif
	endif
return



! --------------------------------------------------------------------------------
! Warning Message Outside
! --------------------------------------------------------------------------------
"outsideWarning":
	if bOutsideCasingNotAvailableByReveal then
		ui_pict 446, 2, sepy+7, 12, 12, 1	! ui_warningsign.png
		ui_style 0,0
		ui_outfield stCasingUI[18], 23, sepy+7, 300, 34
	else
		if bOutsideCasingNotAvailableByFrameStyle then
			if isWindow then
				ui_pict 446, 2, sepy+7, 12, 12, 1	! ui_warningsign.png
				ui_style 0,0
				ui_outfield stCasingUI[19], 23, sepy+7, 300, 34		! Casing is not available with the actual frame style.
			else
				posy = sepy+7+185*(bTShapeOpening | bPShapeOpening)
				ui_pict 446, 2, posy, 12, 12, 1	! ui_warningsign.png
				ui_style 0,0
				ui_outfield stCasingUI[19], 23, posy, 300, 34		! Casing is not available with the actual frame style.
			endif
		endif
	endif
return


! --------------------------------------------------------------------------------
! Door and Window Shape Pictures
! -------------------------------------------------------------------------------- 
! Input parameters:
!	isWindow:				0: Door
!							1: Window
!	iWindowShape
!	_iCasingType:			gs_trimtype_in_int
!							gs_trimtype_out_int
!	_bCasing:				gs_trim_inside
!							gs_trim_outside
!	_bCasingCover:			gs_trim_show_cover_in
!							gs_trim_show_cover_out
!	_bShowBottomCasing:		in case of inside casing	: 1
!							in case of outside casing	: bCasingBottomOutside
! Output parameters:
!	
!	
!	
!	
! --------------------------------------------------------------------------------
"shapePictures":

	_bShowShape = 0

	if isWindow then

		! Window shape pictures
		! -------------------------------------------------------------------------------
		sepx = 267
		picx = 93
		if iWindowShape = SHAPE_HALFCIRCLE then
			picy = 67
		else
			picy = 98
		endif
		posx = round_int(sepx/2 - picx/2)
		posy = round_int((sepy+266)/2 - picy/2)

		if (iWindowShape = SHAPE_RECTANGULAR) then

			if _bCasing & not(not(_iCasingType = CASING_COMPLEX) & not(_bCasingCover)) then

				if (_iCasingType = CASING_NORMAL) then
					if _bShowBottomCasing then
						ui_pict 10, posx, posy, picx, picy, 1			! W_CasSimpleRect.png
					else
						ui_pict 11, posx, posy, picx, picy, 1			! W_CasSimpleRectNoBottomCas.png
					endif
				endif

				if (_iCasingType = CASING_OVERHANG) then
					if _bShowBottomCasing then
						ui_pict 12, posx, posy, picx, picy, 1		! W_CasSimpleOverhang.png
					else
						ui_pict 13, posx, posy, picx, picy, 1		! W_CasSimpleOverhangNoBottomCas.png
					endif
				endif

				if (_iCasingType = CASING_COMPLEX) then
					if bArchitraveCapital then
						if _bArchitraveCapitalOnSide then
							if _bShowBottomCasing then
								ui_pict 14, posx, posy, picx, picy, 1			! W_CasComplexOverhOnSide.png
							else
								ui_pict 15, posx, posy, picx, picy, 1			! W_CasComplexOverhOnSideNoBottCas.png
							endif
						else
							if _bShowBottomCasing then
								ui_pict 16, posx, posy, picx, picy, 1			! W_CasComplexOverhNextSide.png
							else
								ui_pict 17, posx, posy, picx, picy, 1			! W_CasComplexOverhNextSideNoBottCas.png
							endif
						endif
					else
						if _bShowBottomCasing then
							ui_pict 52, posx, posy, picx, picy, 1			! W_CasComplexOverh.png
						else
							ui_pict 53, posx, posy, picx, picy, 1			! W_CasComplexOverhNoBottomCas.png
						endif
					endif
				endif
			else
				ui_pict 9, posx, posy, picx, picy, 1			! W_CasNo.png
			endif

			_bShowShape = 1
		endif

		if (iWindowShape = SHAPE_ARCHED |\
			iWindowShape = SHAPE_ELLIPSEARCH) then

			if _bCasing & _bCasingCover then
				if _bShowBottomCasing then
					ui_pict 19, posx, posy, picx, picy, 1			! W_CasSimpleArch.png
				else
					ui_pict 20, posx, posy, picx, picy, 1			! W_CasSimpleArchNoBottomCas.png
				endif
			else
				ui_pict 18, posx, posy, picx, picy, 1				! W_CasNoArch.png
			endif

			_bShowShape = 1
		endif

		if (iWindowShape = SHAPE_HALFCIRCLE) then
			if _bCasing & _bCasingCover then
				if _bShowBottomCasing then
					ui_pict 22, posx, posy, picx, picy, 1			! W_CasSimpleHalfround.png
				else
					ui_pict 23, posx, posy, picx, picy, 1			! W_CasSimpleHalfroundNoBottomCas.png
				endif
			else
				ui_pict 21, posx, posy, picx, picy, 1				! W_CasNoHalfround.png
			endif

			_bShowShape = 1
		endif

		if (iWindowShape = SHAPE_PENTAGON) then
			if _bCasing & _bCasingCover then
				if _bShowBottomCasing then
					ui_pict 25, posx, posy, picx, picy, 1			! W_CasSimplePentagon.png
				else
					ui_pict 26, posx, posy, picx, picy, 1			! W_CasSimplePentagonNoBottomCas.png
				endif
			else
				ui_pict 24, posx, posy, picx, picy, 1				! W_CasNoPentagon.png
			endif

			_bShowShape = 1
		endif

		if (iWindowShape = SHAPE_QUARTERROUND) then
			if _bCasing & _bCasingCover then
				if _bShowBottomCasing then
					ui_pict 28, posx, posy, picx, picy, 1			! W_CasSimpleQuarterround.png
				else
					ui_pict 29, posx, posy, picx, picy, 1			! W_CasSimpleQuarterroundNoBottomCas.png
				endif
			else
				ui_pict 27, posx, posy, picx, picy, 1				! W_CasNoQuarterround.png
			endif

			_bShowShape = 1
		endif

		if (iWindowShape = SHAPE_TRAPEZOID) then
			if _bCasing & _bCasingCover then
				if _bShowBottomCasing then
					ui_pict 31, posx, posy, picx, picy, 1			! W_CasSimpleTrapezoid.png
				else
					ui_pict 32, posx, posy, picx, picy, 1			! W_CasSimpleTrapezoidNoBottomCas.png
				endif
			else
				ui_pict 30, posx, posy, picx, picy, 1				! W_CasNoTrapezoid.png
			endif

			_bShowShape = 1
		endif

	else	! Door shape pictures

		! Door shape pictures
		! -------------------------------------------------------------------------------
		sepx = 267
		if (iWindowShape = SHAPE_T) | (iWindowShape = SHAPE_ARCHED_T) then
			picx = 116
		else
			picx = 93
		endif
		picy = 98
		posx = round_int(sepx/2 - picx/2)
		posy = round_int((sepy+266)/2 - picy/2)

		if (iWindowShape = SHAPE_RECTANGULAR) then

			if _bCasing & not(not(_iCasingType = CASING_COMPLEX) & not(_bCasingCover)) then

				if (_iCasingType = CASING_NORMAL) then
					ui_pict 34, posx, posy, picx, picy, 1			! D_CasSimpleRect.png
				endif

				if (_iCasingType = CASING_OVERHANG) then
						ui_pict 35, posx, posy, picx, picy, 1		! D_CasSimpleOverhangRect.png
				endif

				if (_iCasingType = CASING_COMPLEX) then
					if bArchitraveCapital then
						if _bArchitraveCapitalOnSide then
							ui_pict 36, posx, posy, picx, picy, 1			! D_CasComplexOverhOnSideRect.png
						else
							ui_pict 37, posx, posy, picx, picy, 1			! D_CasComplexOverhNextSideRect.png
						endif
					else
						ui_pict 54, posx, posy, picx, picy, 1			! D_CasComplexOverhRect.png
					endif
				endif
			else
				ui_pict 33, posx, posy, picx, picy, 1			! D_CasNoRect.png
			endif

			_bShowShape = 1
		endif

		if (iWindowShape = SHAPE_HALF_T_LEFT) then

			if _bCasing & _bCasingCover then

				if (_iCasingType = CASING_NORMAL) then
					ui_pict 39, posx, posy, picx, picy, 1			! D_CasSimpleRectPShape.png
				endif

				if (_iCasingType = CASING_OVERHANG) then
					ui_pict 40, posx, posy, picx, picy, 1		! D_CasSimpleOverhangRectPShape.png
				endif

				if (_iCasingType = CASING_COMPLEX) then
					if bArchitraveCapital then
						if _bArchitraveCapitalOnSide then
							ui_pict 41, posx, posy, picx, picy, 1			! D_CasComplexOverhOnSideRectPShape.png
						else
							ui_pict 42, posx, posy, picx, picy, 1			! D_CasComplexOverhNextSideRectPShape.png
						endif
					else
						ui_pict 55, posx, posy, picx, picy, 1			! D_CasComplexOverhRectPShape.png
					endif
				endif
			else
				ui_pict 38, posx, posy, picx, picy, 1			! D_CasNoRectPShape.png
			endif

			_bShowShape = 1
		endif

		if (iWindowShape = SHAPE_HALF_T_RIGHT) then

			if _bCasing & _bCasingCover then

				if (_iCasingType = CASING_NORMAL) then
					ui_pict 65, posx, posy, picx, picy, 1			! D_CasSimpleRectPMShape.png
				endif

				if (_iCasingType = CASING_OVERHANG) then
					ui_pict 66, posx, posy, picx, picy, 1		! D_CasSimpleOverhangRectPMShape.png
				endif

				if (_iCasingType = CASING_COMPLEX) then
					if bArchitraveCapital then
						if _bArchitraveCapitalOnSide then
							ui_pict 67, posx, posy, picx, picy, 1			! D_CasComplexOverhOnSideRectPMShape.png
						else
							ui_pict 68, posx, posy, picx, picy, 1			! D_CasComplexOverhNextSideRectPMShape.png
						endif
					else
						ui_pict 71, posx, posy, picx, picy, 1			! D_CasComplexOverhRectPMShape.png
					endif
				endif
			else
				ui_pict 64, posx, posy, picx, picy, 1			! D_CasNoRectPMShape.png
			endif

			_bShowShape = 1
		endif

		if (iWindowShape = SHAPE_T) then

			if _bCasing & not(not(_iCasingType = CASING_COMPLEX) & not(_bCasingCover)) then

				if (_iCasingType = CASING_NORMAL) then
					ui_pict 44, posx, posy, picx, picy, 1			! D_CasSimpleRectTShape.png
				endif

				if (_iCasingType = CASING_OVERHANG) then
					ui_pict 45, posx, posy, picx, picy, 1		! D_CasSimpleOverhangRectTShape.png
				endif

				if (_iCasingType = CASING_COMPLEX) then
					if bArchitraveCapital then
						if _bArchitraveCapitalOnSide then
							ui_pict 46, posx, posy, picx, picy, 1			! D_CasComplexOverhOnSideRectTShape.png
						else
							ui_pict 47, posx, posy, picx, picy, 1			! D_CasComplexOverhNextSideRectTShape.png
						endif
					else
						ui_pict 56, posx, posy, picx, picy, 1			! D_CasComplexOverhRectTShape.png
					endif
				endif
			else
				ui_pict 43, posx, posy, picx, picy, 1			! D_CasNoRectTShape.png
			endif

			_bShowShape = 1
		endif

		if (iWindowShape = SHAPE_ARCHED_HALF_T_LEFT) then
			if _bCasing & _bCasingCover then
				ui_pict 49, posx, posy, picx, picy, 1			! D_CasSimpleArchPShape.png
			else
				ui_pict 48, posx, posy, picx, picy, 1			! D_CasNoArchPShape.png
			endif

			_bShowShape = 1
		endif

		if (iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT) then
			if _bCasing & _bCasingCover then
				ui_pict 70, posx, posy, picx, picy, 1			! D_CasSimpleArchPMShape.png
			else
				ui_pict 69, posx, posy, picx, picy, 1			! D_CasNoArchPMShape.png
			endif

			_bShowShape = 1
		endif

		if (iWindowShape = SHAPE_ARCHED_T) then
			if _bCasing & _bCasingCover then
				ui_pict 51, posx, posy, picx, picy, 1			! D_CasSimpleArchTShape.png
			else
				ui_pict 50, posx, posy, picx, picy, 1			! D_CasNoArchTShape.png
			endif

			_bShowShape = 1
		endif
	endif
return

]]></Script_UI>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_VL SectVersion="20" SectionFlags="0" SubIdent="0"><![CDATA[

! Contact person: <NJ>

! ==============================================================================
! This macro draws the Casing
! ------------------------------------------------------------------------------
! Input parameters:
!	A:						Window nominal width (length)
!	B:						Window nominal height (length)
!	gs_IsCurved:			Does the window follow the curvature of the wall? (0 / 1)
!	isWindow:				Is the macro applied for a window or for a door?
!	iWindowShape:			Shape of the window (integer)
!								0 = rectangular (default)
!								1 = arched
!							Note: only the rectangular shape can be a Corner Window
! Corner Function --------------------------------------------------------------
!	bLeftCornerFunction:		Turn macro in Corner Window mode at the left side (0 / 1)
!	leftCornerAngle:		Angle between connected walls in case of Corner Window (angle)
!	leftConnWallThk:		Thickness of the connected wall in case of Corner Window (length)
!	bRightCornerFunction:	Turn macro in Corner Window mode at the right side (0 / 1)
!	rightCornerAngle:		Angle between connected walls in case of Corner Window (angle)
!	rightConnWallThk:		Thickness of the connected wall in case of Corner Window (length)
! Casing -----------------------------------------------------------------------
!	gs_trim_width_in:		Width of inside Trim. (length)
!	gs_trim_width_out:		Width of outside Trim. (length)
!	gs_trim_offs_in:		Offset of Casing inside. (length)
!	gs_trim_offs_out:		Offset of Casing outside. (length)
!	gs_trim_thk_in:			Thickness of inside Trim. (length)
!	gs_trim_thk_out:		Thickness of outside Trim. (length)
!	gs_tw_left_in:			Width of inside casing on the left (length)
!	gs_tw_right_in:			Width of inside casing on the right (length)
!	gs_tw_left_out:			Width of outside casing on the left (length)
!	gs_tw_right_out:		Width of outside casing on the right (length)
! Ganging ----------------------------------------------------------------------
!	gs_stack_left:			Align to door/window on left side (0 / 1)
!	gs_stack_right:			Align to door/window on right side (0 / 1)
!	gs_stack_top:			Align to door/window on upper side (0 / 1)
!	gs_stack_bottom:		Align to door/window on bottom side (0 / 1)
!	--- String Tables ---
!
! Related Global Variables:
!	GLOB_SCRIPT_TYPE
!	GLOB_CONTEXT
!	WALL_THICKNESS
!	WALL_INCL
!	WIDO_FRAME_THICKNESS
!	WIDO_SILL
!	WIDO_ORIG_DIST
!	WIDO_REVEAL_SIDE
!	SYMB_MIRRORED
!	SYMB_ROTANGLE
! ==============================================================================

if gs_sectgar then
	lock "gs_trim_inside"
	parameters gs_trim_inside = 0
else
	if iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED then
		lock "gs_trim_outside"
		parameters gs_trim_outside = 0
	endif
endif


! ==============================================================================
! SWE Casing Types
! ==============================================================================

dim sCasingInTypeValueMask[]
dim iCasingInTypeValueMask[]

i=1
if bittest( gs_CasingInTypeEnable, 0) then 				! Rectangular
	sCasingInTypeValueMask[i] = stCasingType[1]
	iCasingInTypeValueMask[i] = 1
	i = i + 1
endif
if bittest( gs_CasingInTypeEnable, 1) then 				! SWE Traditional
	sCasingInTypeValueMask[i] = stCasingType[2]
	iCasingInTypeValueMask[i] = 2
	i = i + 1
endif

if i > 1 then
	values "gs_trimtype_in"		sCasingInTypeValueMask
	values "gs_trimtype_in_int"	iCasingInTypeValueMask
endif


dim sCasingOutTypeValueMask[]
dim iCasingOutTypeValueMask[]

i=1
if bittest( gs_CasingOutTypeEnable, 0) then 				! Rectangular
	sCasingOutTypeValueMask[i] = stCasingType[1]
	iCasingOutTypeValueMask[i] = 1
	i = i + 1
endif
if bittest( gs_CasingOutTypeEnable, 1) then 				! SWE Traditional
	sCasingOutTypeValueMask[i] = stCasingType[2]
	iCasingOutTypeValueMask[i] = 2
	i = i + 1
endif
if bittest( gs_CasingOutTypeEnable, 2) then 				! Complex
	sCasingOutTypeValueMask[i] = stCasingType[3]
	iCasingOutTypeValueMask[i] = 3
	i = i + 1
endif

if i > 1 then
	values "gs_trimtype_out"	 sCasingOutTypeValueMask
	values "gs_trimtype_out_int" iCasingOutTypeValueMask
endif


if GLOB_MODPAR_NAME = "gs_trimtype_in" then
	gs_trimtype_in_int = CASING_NORMAL
	if gs_trimtype_in = stCasingType[2] then gs_trimtype_in_int = CASING_OVERHANG
	parameters gs_trimtype_in_int = gs_trimtype_in_int
else
	gs_trimtype_in = stCasingType[min(2, max(1,gs_trimtype_in_int))]
	parameters gs_trimtype_in = gs_trimtype_in
endif

if	GLOB_MODPAR_NAME = "gs_trimtype_out" then
	gs_trimtype_out_int = CASING_NORMAL
	if gs_trimtype_out = stCasingType[2] then gs_trimtype_out_int = CASING_OVERHANG
	if gs_trimtype_out = stCasingType[3] then gs_trimtype_out_int = CASING_COMPLEX
	parameters gs_trimtype_out_int = gs_trimtype_out_int
else
	gs_trimtype_out = stCasingType[min(2, max(1,gs_trimtype_out_int))]
	parameters gs_trimtype_out = gs_trimtype_out
endif

if gs_CasingInTypeEnable = 0 | gs_CasingInTypeEnable = 1 then
	hideparameter "gs_trimtype_in", "gs_trimtype_in_int"
endif

if gs_CasingOutTypeEnable = 0 | gs_CasingOutTypeEnable = 1 then
	hideparameter "gs_trimtype_out", "gs_trimtype_out_int"
endif


! ==============================================================================
! Casing parameter handling in case of pocket door or curved wall
! ==============================================================================

if gs_trim_outside & ((_bPocketDoor & (gs_frame_wthk | (iRevealType = REVEAL_EDGE))) | curvedWall) then
	lock "gs_trim_show_cover_out"
endif

if gs_trim_inside & ((_bPocketDoor & gs_frame_wthk) | curvedWall) then
	lock "gs_trim_show_cover_in"
endif


! ==============================================================================
! Simple with Overhang casing parameter handling
! ==============================================================================

if _bEnableOutsideCasingOverhang then
	if gs_trim_outside & (gs_trimtype_out_int = CASING_OVERHANG) then
		lock "gs_trim_show_cover_out"
	endif
endif

if _bEnableInsideCasingOverhang then
	if gs_trim_inside & (gs_trimtype_in_int = CASING_OVERHANG) then
		lock "gs_trim_show_cover_in"
	endif
endif


! ==============================================================================
! Complex casing parameter handling
! ==============================================================================

if _bEnableOutsideCasingComplex then	! Complex is enabled in outside
	values{2} "iCasingHeadTypeOut"	CASING_HEAD_RECT, stCasingHeadType[1],
									CASING_HEAD_DECORATIVE_1, stCasingHeadType[2],
									CASING_HEAD_DECORATIVE_2, stCasingHeadType[3],
									CASING_HEAD_DECORATIVE_3, stCasingHeadType[4]

	values{2} "iArchitraveCapitalType"	ARCH_CAPITAL_SQUARE_ONSIDE,		stArchitraveCapitalType[1],
										ARCH_CAPITAL_SQUARE_NEXTSIDE,	stArchitraveCapitalType[2],
										ARCH_CAPITAL_DECOR_ONSIDE,		stArchitraveCapitalType[3],
										ARCH_CAPITAL_DECOR_NEXTSIDE,	stArchitraveCapitalType[4]

	if gs_trim_outside & (gs_trimtype_out_int = CASING_COMPLEX) then
		if not(bArchitraveCapital) then
			lock "iArchitraveCapitalType", "architraveCapitalWidth"
		endif
		lock "gs_trim_show_cover_out"
	else
		lock "iCasingHeadTypeOut", "bArchitraveCapital", "iArchitraveCapitalType", "architraveCapitalWidth"
	endif
endif

! ==============================================================================

if gs_trim_inside then
	if gs_wt_m = 1 then
		if gs_trim_atframe_in 	= 0 then values "gs_trim_offs_in"	range [0, gs_trim_width_in]
	else
		if gs_trim_atframe_in 	= 0 then values "gs_trim_offs_in"	range [0, )
	endif
	values "gs_trim_thk_in"		range [0,)
	values "gs_trim_width_in"	range [0,)
endif
if gs_trim_outside then
	if gs_trim_atframe_out 	= 0 & not(bCasingTolerance) then values "gs_trim_offs_out"	range [0, gs_trim_width_out]
	if gs_trim_atframe_out 	= 0 & bCasingTolerance then values "gs_trim_offs_out"	range [0, )
	values "gs_trim_thk_out"	range [0,)
	values "gs_trim_width_out"	range [0,)
endif

if gs_trim_inside then
	values "gs_tw_left_in"		range [gs_trim_width_in,)
	values "gs_tw_right_in"		range [gs_trim_width_in,)
	values "gs_tw_top_in"		range [gs_trim_width_in,)
	if isWindow then
		values "gs_tw_bottom_in"	range [gs_trim_width_in,)
	else
		if bTShapedOpening then
			values "gs_tw_bottom_in"	range [gs_trim_width_in,)
		endif
	endif
endif
if gs_trim_outside then
	values "gs_tw_left_out"		range [gs_trim_width_out,)
	values "gs_tw_right_out"	range [gs_trim_width_out,)
	values "gs_tw_top_out"		range [gs_trim_width_out,)
	if isWindow then
		values "gs_tw_bottom_out"	range [gs_trim_width_out,)
	else
		if bTShapedOpening then
			values "gs_tw_bottom_out"	range [gs_trim_width_out,)
		endif
	endif
endif

if iWindowShape = SHAPE_ARCHED | iWindowShape = SHAPE_ELLIPSEARCH then
	if gs_trim_inside then
		parameters gs_tw_left_in	= gs_tw_right_in
		parameters gs_tw_top_in		= gs_tw_right_in
	endif
	if gs_trim_outside then
		parameters gs_tw_left_out	= gs_tw_right_out
		parameters gs_tw_top_out	= gs_tw_right_out
	endif
endif

values "gs_trim_fill_in"	filltypes_mask 1
values "gs_trim_fill_out"	filltypes_mask 1


! ==============================================================================
! Trim parameter logic
! ==============================================================================

if (bInsideCasingNotAvailableByReveal |\
	bInsideCasingNotAvailableByWallType |\
	bInsideCasingNotAvailableByFrameStyle) then
	lock "gs_trim_inside"
endif
if (bOutsideCasingNotAvailableByReveal |\
	bOutsideCasingNotAvailableByFrameStyle) then
	lock "gs_trim_outside"
endif

if _bEnableSwitchableInCasCover then
	if gs_trim_inside & not(gs_trim_show_cover_in) then
		hideparameter "gs_trim_inside_uniform"
		lock "gs_trim_inside_uniform"
	endif
endif

if _bEnableSwitchableOutCasCover then
	if gs_trim_outside & not(gs_trim_show_cover_out) then
		hideparameter "gs_trim_outside_uniform"
		lock "gs_trim_outside_uniform"

		if isWindow then
			hideparameter "bCasingBottomOutside"
			lock "bCasingBottomOutside"
		endif
	endif
else
	if bExtSliding & not(gs_casing_nor) then
		parameters gs_trim_show_cover_out = 1
	endif
endif

if not(gs_trim_inside) | bInsideCasingNotAvailableByReveal | bInsideCasingNotAvailableByFrameStyle then
	hideparameter	"gs_trimtype_in",
					"gs_trimtype_in_int",
					"gs_trim_inside_uniform",
					"gs_trim_width_in",
					"gs_trim_offs_in",
					"gs_trim_thk_in",
					"gs_tw_left_in",
					"gs_tw_right_in",
					"gs_tw_top_in",
					"gs_trim_in_mat",
					"gs_trim_pen_fg_in",
					"gs_trim_pen_bg_in",
					"gs_trim_fill_in"

	lock			"gs_trimtype_in",
					"gs_trimtype_in_int",
					"gs_trim_inside_uniform",
					"gs_trim_width_in",
					"gs_trim_offs_in",
					"gs_trim_thk_in",
					"gs_tw_left_in",
					"gs_tw_right_in",
					"gs_tw_top_in",
					"gs_trim_in_mat",
					"gs_trim_pen_fg_in",
					"gs_trim_pen_bg_in",
					"gs_trim_fill_in"

	if isWindow | (not(isWindow) & bTShapedOpening) then
		hideparameter "gs_tw_bottom_in"
		lock "gs_tw_bottom_in"
	endif

	if gs_casing_che then
		hideparameter	"gs_trim_jambext_nosing_in"
		lock	"gs_trim_jambext_nosing_in"
	endif

	if bittest(gs_CasingInTypeEnable, 1) then 		! SWE Traditional
		hideparameter "gs_trimov_top_right_in"

		lock "gs_trimov_top_right_in"

		if isWindow | bTShapedOpening then
			hideparameter "gs_trimov_bot_right_in"

			lock "gs_trimov_bot_right_in"
		endif
	endif
else
	if not(bCasingUSA) & (isWindow | (not(isWindow) & bTShapedOpening)) then
		if gs_trimtype_in_int = CASING_NORMAL then		! Rectangular
			hideparameter	"gs_trimov_top_right_in",
							"gs_trimov_bot_right_in",
							"gs_trimov_bot_left_in"
			lock	"gs_trimov_top_right_in",
					"gs_trimov_bot_right_in",
					"gs_trimov_bot_left_in"
		else
			if not((iWindowShape = SHAPE_T & (gs_sidelight_parapet_hgt_left > EPS | gs_sidelight_parapet_hgt_right > EPS)) |\
				   (iWindowShape = SHAPE_HALF_T_RIGHT & (gs_sidelight_parapet_hgt_right > EPS)) |\
				   (isWindow & (iWindowShape = SHAPE_RECTANGULAR))) then

				hideparameter "gs_trimov_bot_right_in"
				lock "gs_trimov_bot_right_in"
			endif
			if not((iWindowShape = SHAPE_HALF_T_LEFT & (gs_sidelight_parapet_hgt_left > EPS))) then
				hideparameter "gs_trimov_bot_left_in"
				lock "gs_trimov_bot_left_in"
			endif
		endif
	endif
endif

if not(gs_trim_outside) | bOutsideCasingNotAvailableByReveal | bOutsideCasingNotAvailableByFrameStyle then
		hideparameter	"gs_trimtype_out",
						"gs_trimtype_out_int",
						"gs_trim_outside_uniform",
						"gs_trim_width_out",
						"gs_trim_offs_out",
						"gs_trim_thk_out",
						"gs_tw_left_out",
						"gs_tw_right_out",
						"gs_tw_top_out",
						"gs_trim_out_mat",
						"gs_trim_pen_fg_out",
						"gs_trim_pen_bg_out",
						"gs_trim_fill_out"

		lock			"gs_trimtype_out",
						"gs_trimtype_out_int",
						"gs_trim_outside_uniform",
						"gs_trim_width_out",
						"gs_trim_offs_out",
						"gs_trim_thk_out",
						"gs_tw_left_out",
						"gs_tw_right_out",
						"gs_tw_top_out",
						"gs_trim_out_mat",
						"gs_trim_pen_fg_out",
						"gs_trim_pen_bg_out",
						"gs_trim_fill_out"

	if isWindow | (not(isWindow) & bTShapedOpening) then
		hideparameter "gs_tw_bottom_out"
		lock "gs_tw_bottom_out"
	endif

	if gs_casing_che then
		hideparameter	"gs_trim_jambext_nosing_out"
		lock	"gs_trim_jambext_nosing_out"
	endif

	if bittest(gs_CasingOutTypeEnable, 1) then 		! SWE Traditional
		hideparameter "gs_trimov_top_right_out"

		lock "gs_trimov_top_right_out"

		if isWindow | bTShapedOpening then
			hideparameter "gs_trimov_bot_right_out"

			lock "gs_trimov_bot_right_out"
		endif
	endif
else
	if not(bCasingUSA) & (isWindow | (not(isWindow) & bTShapedOpening)) then
		if gs_trimtype_out_int = CASING_NORMAL then		! Rectangular
			if	iWindowShape = SHAPE_RECTANGULAR |\
				iWindowShape = SHAPE_T |\
				iWindowShape = SHAPE_HALF_T_LEFT |\
				iWindowShape = SHAPE_ARCHED_T |\
				iWindowShape = SHAPE_ARCHED_HALF_T_LEFT |\
				iWindowShape = SHAPE_HALF_T_RIGHT |\
				iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT then

				hideparameter	"gs_trimov_top_right_out",
								"gs_trimov_bot_right_out",
								"gs_trimov_bot_left_out"
				lock	"gs_trimov_top_right_out",
						"gs_trimov_bot_right_out",
						"gs_trimov_bot_left_out"
			endif
		else
			if not((iWindowShape = SHAPE_T & (gs_sidelight_parapet_hgt_left > EPS | gs_sidelight_parapet_hgt_right > EPS)) |\
				   (iWindowShape = SHAPE_HALF_T_RIGHT & (gs_sidelight_parapet_hgt_right > EPS)) |\
				   (isWindow & (iWindowShape = SHAPE_RECTANGULAR))) then

				hideparameter "gs_trimov_bot_right_out"
				lock "gs_trimov_bot_right_out"
			endif
			if not((iWindowShape = SHAPE_HALF_T_LEFT & (gs_sidelight_parapet_hgt_left > EPS))) then
				hideparameter "gs_trimov_bot_left_out"
				lock "gs_trimov_bot_left_out"
			endif
		endif
	endif
endif

! Uniform Surfaces =============================================================

if	(not(gs_trim_inside) | bInsideCasingNotAvailableByReveal | bInsideCasingNotAvailableByFrameStyle) &\
	(not(gs_trim_outside) | bOutsideCasingNotAvailableByReveal | bOutsideCasingNotAvailableByFrameStyle) then

	hideparameter "bLinkCasingSurfaces"
	lock "bLinkCasingSurfaces"
endif

! ==============================================================================
! Uniform Casing Surfaces
! ==============================================================================

dim	surfaceParNames[]							:	dim	surfaceParameters[]
	surfaceParNames[1]	= "gs_trim_in_mat"		:		surfaceParameters[1]	= gs_trim_in_mat
	surfaceParNames[2]	= "gs_trim_out_mat"		:		surfaceParameters[2]	= gs_trim_out_mat

if bEnableApron then
	surfaceParNames[3]	= "gs_apron_mat"		:		surfaceParameters[3]	= gs_apron_mat
endif

_lastModCasingSurfaceParameter = gs_trim_in_mat

if stored_material[3][1] <> -9999 then
	for i = 1 to vardim1(surfaceParNames)
		if GLOB_MODPAR_NAME = surfaceParNames[i] then
			_lastModCasingSurfaceParameter	= surfaceParameters[i]
			stored_material[3][i]	= surfaceParameters[i]
			stored_material[4][i]	= 1

			for j = 1 to i-1
				stored_material[4][j]	= 0
				parameters stored_material[4][j]	= stored_material[4][j]
			next j

			for k = i+1 to vardim1(surfaceParNames)
				stored_material[4][k]	= 0
				parameters stored_material[4][k]	= stored_material[4][k]
			next k
		endif

		parameters	stored_material[3][i]	= stored_material[3][i],
					stored_material[4][i]	= stored_material[4][i]

		if stored_material[4][i] = 1 then
			_lastModCasingSurfaceParameter = stored_material[3][i]
		endif
	next i
else
	parameters	stored_material[3][1]	= gs_trim_in_mat,
				stored_material[3][2]	= gs_trim_out_mat

	if bEnableApron then
		parameters	stored_material[3][3]	= gs_apron_mat
	endif
endif

if bLinkCasingSurfaces then
	parameters	gs_trim_in_mat		= _lastModCasingSurfaceParameter,
				gs_trim_out_mat		= _lastModCasingSurfaceParameter

	if bEnableApron then
		parameters	gs_apron_mat	= _lastModCasingSurfaceParameter
	endif
else
	if GLOB_MODPAR_NAME = "bLinkCasingSurfaces" then
		parameters	gs_trim_in_mat		= stored_material[3][1],
					gs_trim_out_mat		= stored_material[3][2]

		if bEnableApron then
			parameters	gs_apron_mat	= stored_material[3][3]
		endif
	else
		parameters	stored_material[3][1]	= gs_trim_in_mat,
					stored_material[3][2]	= gs_trim_out_mat

		if bEnableApron then
			parameters	stored_material[3][3]	= gs_apron_mat
		endif
	endif
endif

if	(not(gs_trim_inside) | bInsideCasingNotAvailableByReveal | bInsideCasingNotAvailableByFrameStyle) &\
	(not(gs_trim_outside) | bOutsideCasingNotAvailableByReveal | bOutsideCasingNotAvailableByFrameStyle) then

	hideparameter "gs_trim_pen_cont"
	lock "gs_trim_pen_cont"
endif

if not(	iWindowShape = SHAPE_RECTANGULAR |\
		iWindowShape = SHAPE_T |\
		iWindowShape = SHAPE_HALF_T_LEFT |\
		iWindowShape = SHAPE_HALF_T_RIGHT ) then
	hideparameter "gs_trim_outside_uniform", "gs_trim_inside_uniform"
	lock "gs_trim_outside_uniform", "gs_trim_inside_uniform"
else
	if gs_trim_outside_uniform then
		hideparameter "gs_tw_left_out", "gs_tw_top_out"
		lock "gs_tw_left_out", "gs_tw_top_out"

		if isWindow | (not(isWindow) & bTShapedOpening) then
			hideparameter "gs_tw_bottom_out"
			lock "gs_tw_bottom_out"
		endif
	endif
	if gs_trim_inside_uniform then
		hideparameter "gs_tw_left_in", "gs_tw_top_in"
		lock "gs_tw_left_in", "gs_tw_top_in"

		if isWindow | (not(isWindow) & bTShapedOpening) then
			hideparameter "gs_tw_bottom_in"
			lock "gs_tw_bottom_in"
		endif
	endif
endif

if (gs_trim_inside | gs_trim_outside) then
	if gs_stack_left	then
		hideparameter "gs_tw_left_in", "gs_tw_left_out"
		lock "gs_tw_left_in", "gs_tw_left_out"
	else
		if bCasingUSA then hideparameter "gs_trim_stack_left"
	endif
	if gs_stack_right	then
		hideparameter "gs_tw_right_in", "gs_tw_right_out"
		lock "gs_tw_right_in", "gs_tw_right_out"
	else
		if bCasingUSA then hideparameter "gs_trim_stack_right"
	endif
	if gs_stack_top		then
		hideparameter "gs_tw_top_in", "gs_tw_top_out"
		lock "gs_tw_top_in", "gs_tw_top_out"
	else
		if bCasingUSA then hideparameter "gs_trim_stack_top"
	endif
	if gs_stack_bottom	then
		hideparameter "gs_tw_bottom_in", "gs_tw_bottom_out"
		lock "gs_tw_bottom_in", "gs_tw_bottom_out"
	else
		if bCasingUSA & isWindow then hideparameter "gs_trim_stack_bottom"
	endif

	if iWindowShape = SHAPE_ARCHED | iWindowShape = SHAPE_ARCHED then
		hideparameter	"gs_tw_left_in",
						"gs_tw_top_in",
						"gs_tw_left_out",
						"gs_tw_top_out"

		lock			"gs_tw_left_in",
						"gs_tw_top_in",
						"gs_tw_left_out",
						"gs_tw_top_out"
	endif
else
	if bEnableCasingAtGanging then
		if isWindow then
			hideparameter	"gs_trim_stack_bottom"
			lock			"gs_trim_stack_bottom"
		endif

		hideparameter	"gs_trim_stack_left",
						"gs_trim_stack_right",
						"gs_trim_stack_top"

		lock			"gs_trim_stack_left",
						"gs_trim_stack_right",
						"gs_trim_stack_top"
	endif
endif

if bCasingUSA then
	hideparameter	"gs_trim_atframe_out", "gs_trim_atframe_in"
	lock			"gs_trim_atframe_out", "gs_trim_atframe_in"

	if isWindow then
		hideparameter	"gs_trimb_atframe_out"
		lock			"gs_trimb_atframe_out"
	endif
endif

if	bEnableApron & not(gs_apron) then
	hideparameter	"gs_apron_thk",
					"gs_apron_width",
					"gs_apron_mat"
	lock			"gs_apron_thk",
					"gs_apron_width",
					"gs_apron_mat"
endif

if abs(WIDO_SILL) > EPS & gs_trim_atframe_out then
	lock "gs_trimov_top_left_out", "gs_trimov_top_right_out", "gs_trimov_bot_left_out", "gs_trimov_bot_right_out"
	hideparameter "gs_trimov_top_left_out", "gs_trimov_top_right_out", "gs_trimov_bot_left_out", "gs_trimov_bot_right_out"
endif

if _bEnableSwitchableInCasCover then
	if not(gs_trim_inside) then
		lock "gs_trim_show_cover_in"
		hideparameter "gs_trim_show_cover_in"
	endif

	if gs_trim_show_cover_in then
		lock "gs_trim_jambext_nosing_in"
		hideparameter "gs_trim_jambext_nosing_in"
	else
		lock	"gs_tw_right_in",
				"gs_tw_left_in",
				"gs_tw_top_in",
				"gs_tw_bottom_in",
				"gs_trim_thk_in",
				"gs_trim_offs_in"
		hideparameter	"gs_tw_right_in",
						"gs_tw_left_in",
						"gs_tw_top_in",
						"gs_tw_bottom_in",
						"gs_trim_thk_in",
						"gs_trim_offs_in"
	endif
endif

if _bEnableSwitchableOutCasCover then
	if not(gs_trim_outside) then
		lock "gs_trim_show_cover_out"
		hideparameter "gs_trim_show_cover_out"
	endif

	if gs_trim_show_cover_out then
		lock "gs_trim_jambext_nosing_out"
		hideparameter "gs_trim_jambext_nosing_out"
	else
		lock	"gs_tw_right_out",
				"gs_tw_left_out",
				"gs_tw_top_out",
				"gs_tw_bottom_out",
				"gs_trim_thk_out",
				"gs_trim_offs_out"
		hideparameter	"gs_tw_right_out",
						"gs_tw_left_out",
						"gs_tw_top_out",
						"gs_tw_bottom_out",
						"gs_trim_thk_out",
						"gs_trim_offs_out"
	endif
endif

if bEnableSwitchableBottomCasing & not(bCasingUSA | gs_casing_nor) then
	if not(gs_trim_outside) then
		hideparameter	"bCasingBottomOutside"
		lock			"bCasingBottomOutside"
	endif
endif


for i = 1 to 255
	put i
next i
values "gs_trim_pen_cont"	use(NSP)
values "gs_trim_pen_fg_in"	use(NSP)
values "gs_trim_pen_fg_out"	get(NSP)


! =============================================================================
! IFC Parameters
! =============================================================================

if isWindow = 0	then
	ifc_CasingDepth = max(gs_trim_thk_in*gs_trim_inside, gs_trim_thk_out*gs_trim_outside)
	parameters ifc_CasingDepth = ifc_CasingDepth

	ifc_CasingThickness = max(gs_tw_right_in*gs_trim_inside, gs_tw_right_out*gs_trim_outside)
	parameters ifc_CasingThickness = ifc_CasingThickness
endif


end	! ===== end ===== end ===== end ===== end ===== end ===== end ===== end ===== end ===== end =====



]]></Script_VL>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Comment SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Comment>

<CalledMacros SectVersion="2" SectionFlags="0" SubIdent="0">
	<Macro>
		<MName><![CDATA["CasingEnable_WMCC"]]></MName>
		<MainGUID>1AA39DBC-134E-4087-AE06-907C1965BE8B</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["SaveQueue_WMCC"]]></MName>
		<MainGUID>3C5CB4C9-88DB-4D04-980A-0422BE2B1A24</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["LoadQueue_WMCC"]]></MName>
		<MainGUID>4D59CACA-3851-4598-A37A-A70EB0E48955</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["CasingEnable_WMCC"]]></MName>
		<MainGUID>1AA39DBC-134E-4087-AE06-907C1965BE8B</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["SaveQueue_WMCC"]]></MName>
		<MainGUID>3C5CB4C9-88DB-4D04-980A-0422BE2B1A24</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["LoadQueue_WMCC"]]></MName>
		<MainGUID>4D59CACA-3851-4598-A37A-A70EB0E48955</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["CasingEnable_WMCC"]]></MName>
		<MainGUID>1AA39DBC-134E-4087-AE06-907C1965BE8B</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["CasingEnable_WMCC"]]></MName>
		<MainGUID>1AA39DBC-134E-4087-AE06-907C1965BE8B</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["CasingEnable_WMCC"]]></MName>
		<MainGUID>1AA39DBC-134E-4087-AE06-907C1965BE8B</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["CasingEnable_WMCC"]]></MName>
		<MainGUID>1AA39DBC-134E-4087-AE06-907C1965BE8B</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["CasingEnable_WMCC"]]></MName>
		<MainGUID>1AA39DBC-134E-4087-AE06-907C1965BE8B</MainGUID>
	</Macro>
</CalledMacros>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="1" path="uipicts/Casing/DW_OutCasSection.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="2" path="uipicts/Casing/DW_OutCasSectionWithCasWidth.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="3" path="uipicts/Casing/DW_OutCasSectionNoCasCover.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="4" path="uipicts/Casing/DW_OutCasSectionNoCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="5" path="uipicts/Casing/DW_InCasSection.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="6" path="uipicts/Casing/DW_InCasSectionWithCasWidth.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="7" path="uipicts/Casing/DW_InCasSectionNoCasCover.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="8" path="uipicts/Casing/DW_InCasSectionNoCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="9" path="uipicts/Casing/W_CasNo.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="10" path="uipicts/Casing/W_CasSimpleRect.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="11" path="uipicts/Casing/W_CasSimpleRectNoBottomCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="12" path="uipicts/Casing/W_CasSimpleOverhang.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="13" path="uipicts/Casing/W_CasSimpleOverhangNoBottomCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="14" path="uipicts/Casing/W_CasComplexOverhOnSide.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="15" path="uipicts/Casing/W_CasComplexOverhOnSideNoBottCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="16" path="uipicts/Casing/W_CasComplexOverhNextSide.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="17" path="uipicts/Casing/W_CasComplexOverhNextSideNoBottCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="18" path="uipicts/Casing/W_CasNoArch.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="19" path="uipicts/Casing/W_CasSimpleArch.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="20" path="uipicts/Casing/W_CasSimpleArchNoBottomCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="21" path="uipicts/Casing/W_CasNoHalfround.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="22" path="uipicts/Casing/W_CasSimpleHalfround.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="23" path="uipicts/Casing/W_CasSimpleHalfroundNoBottomCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="24" path="uipicts/Casing/W_CasNoPentagon.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="25" path="uipicts/Casing/W_CasSimplePentagon.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="26" path="uipicts/Casing/W_CasSimplePentagonNoBottomCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="27" path="uipicts/Casing/W_CasNoQuarterround.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="28" path="uipicts/Casing/W_CasSimpleQuarterround.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="29" path="uipicts/Casing/W_CasSimpleQuarterroundNoBottomCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="30" path="uipicts/Casing/W_CasNoTrapezoid.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="31" path="uipicts/Casing/W_CasSimpleTrapezoid.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="32" path="uipicts/Casing/W_CasSimpleTrapezoidNoBottomCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="33" path="uipicts/Casing/D_CasNoRect.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="34" path="uipicts/Casing/D_CasSimpleRect.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="35" path="uipicts/Casing/D_CasSimpleOverhangRect.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="36" path="uipicts/Casing/D_CasComplexOverhOnSideRect.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="37" path="uipicts/Casing/D_CasComplexOverhNextSideRect.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="38" path="uipicts/Casing/D_CasNoRectPShape.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="39" path="uipicts/Casing/D_CasSimpleRectPShape.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="40" path="uipicts/Casing/D_CasSimpleOverhangRectPShape.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="41" path="uipicts/Casing/D_CasComplexOverhOnSideRectPShape.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="42" path="uipicts/Casing/D_CasComplexOverhNextSideRectPShape.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="43" path="uipicts/Casing/D_CasNoRectTShape.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="44" path="uipicts/Casing/D_CasSimpleRectTShape.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="45" path="uipicts/Casing/D_CasSimpleOverhangRectTShape.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="46" path="uipicts/Casing/D_CasComplexOverhOnSideRectTShape.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="47" path="uipicts/Casing/D_CasComplexOverhNextSideRectTShape.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="48" path="uipicts/Casing/D_CasNoArchPShape.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="49" path="uipicts/Casing/D_CasSimpleArchPShape.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="50" path="uipicts/Casing/D_CasNoArchTShape.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="51" path="uipicts/Casing/D_CasSimpleArchTShape.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="52" path="uipicts/Casing/W_CasComplexOverh.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="53" path="uipicts/Casing/W_CasComplexOverhNoBottomCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="54" path="uipicts/Casing/D_CasComplexOverhRect.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="55" path="uipicts/Casing/D_CasComplexOverhRectPShape.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="56" path="uipicts/Casing/D_CasComplexOverhRectTShape.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="57" path="uipicts/Casing/DExt_OutCasSection.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="58" path="uipicts/Casing/DExt_OutCasSectionWithCasWidth.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="59" path="uipicts/Casing/DExt_OutCasSectionNoCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="60" path="uipicts/Casing/DExt_InCasSection.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="61" path="uipicts/Casing/DExt_InCasSectionWithCasWidth.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="62" path="uipicts/Casing/DExt_InCasSectionNoCasCover.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="63" path="uipicts/Casing/DExt_InCasSectionNoCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="64" path="uipicts/Casing/D_CasNoRectPMShape.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="65" path="uipicts/Casing/D_CasSimpleRectPMShape.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="66" path="uipicts/Casing/D_CasSimpleOverhangRectPMShape.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="67" path="uipicts/Casing/D_CasComplexOverhOnSideRectPMShape.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="68" path="uipicts/Casing/D_CasComplexOverhNextSideRectPMShape.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="69" path="uipicts/Casing/D_CasNoArchPMShape.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="70" path="uipicts/Casing/D_CasSimpleArchPMShape.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="71" path="uipicts/Casing/D_CasComplexOverhRectPMShape.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="152" path="uipicts/Casing/usw_wall_wt1.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="153" path="uipicts/Casing/usw_wall_wt2.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="154" path="uipicts/Casing/usw_sash_in_nosill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="155" path="uipicts/Casing/usw_sash_in_insill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="156" path="uipicts/Casing/usw_sash_in_outsill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="157" path="uipicts/Casing/usw_sash_in_fullsill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="158" path="uipicts/Casing/usw_sash_out_nocas_nosill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="159" path="uipicts/Casing/usw_sash_out_nocas_insill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="160" path="uipicts/Casing/usw_sash_out_nocas_outsill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="161" path="uipicts/Casing/usw_sash_out_nocas_fullsill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="162" path="uipicts/Casing/usw_sash_out_cas_nosill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="163" path="uipicts/Casing/usw_sash_out_cas_insill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="164" path="uipicts/Casing/usw_sash_out_cas_outsill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="165" path="uipicts/Casing/usw_sash_out_cas_fullsill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="167" path="uipicts/Casing/usw_out_wt1_cas_nosill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="168" path="uipicts/Casing/usw_out_wt1_nocas_sill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="169" path="uipicts/Casing/usw_out_wt1_cas_sill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="170" path="uipicts/Casing/usw_out_wt3_nocas_nosill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="171" path="uipicts/Casing/usw_out_wt3_cas_nosill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="172" path="uipicts/Casing/usw_out_wt3_nocas_sill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="173" path="uipicts/Casing/usw_out_wt3_cas_sill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="174" path="uipicts/Casing/usw_out_wt4_nocas_nosill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="175" path="uipicts/Casing/usw_out_wt4_cas_nosill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="176" path="uipicts/Casing/usw_out_wt4_nocas_sill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="177" path="uipicts/Casing/usw_out_wt4_cas_sill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="178" path="uipicts/Casing/usw_in_wt1_nocas_nosill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="179" path="uipicts/Casing/usw_in_wt1_cas_nosill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="180" path="uipicts/Casing/usw_in_wt1_nocas_sill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="181" path="uipicts/Casing/usw_in_wt1_cas_sill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="182" path="uipicts/Casing/usw_in_wt2_nocas_nosill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="183" path="uipicts/Casing/usw_in_wt2_cas_nosill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="184" path="uipicts/Casing/usw_in_wt2_nocas_sill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="185" path="uipicts/Casing/usw_in_wt2_cas_sill.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="186" path="uipicts/Casing/usw_wallsect_wt1.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="187" path="uipicts/Casing/usw_wallsect_wt2.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="188" path="uipicts/Casing/usw_sashsect_in.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="189" path="uipicts/Casing/usw_sashsect_out.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="191" path="uipicts/Casing/usw_outsec_wt1_cas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="192" path="uipicts/Casing/usw_outsec_wt3_nocas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="193" path="uipicts/Casing/usw_outsec_wt3_cas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="194" path="uipicts/Casing/usw_outsec_wt4_nocas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="195" path="uipicts/Casing/usw_outsec_wt4_cas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="196" path="uipicts/Casing/usw_insect_wt1_nocas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="197" path="uipicts/Casing/usw_insect_wt1_cas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="198" path="uipicts/Casing/usw_insect_wt2_nocas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="199" path="uipicts/Casing/usw_insect_wt2_cas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="200" path="uipicts/Casing/usd_leaf_in.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="201" path="uipicts/Casing/usd_leaf_out.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="202" path="uipicts/Casing/usd_leafsect_in.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="203" path="uipicts/Casing/usd_leafsect_out.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="390" path="uipicts/Casing/usd_sectg_wt1_inOpDir_hor_noCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="391" path="uipicts/Casing/usd_sectg_wt1_inOpDir_hor_outCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="392" path="uipicts/Casing/usd_sectg_wt1_inOpDir_vert_noCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="393" path="uipicts/Casing/usd_sectg_wt1_inOpDir_vert_outCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="394" path="uipicts/Casing/usd_sectg_wt2_inOpDir_hor_noCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="395" path="uipicts/Casing/usd_sectg_wt2_inOpDir_hor_outCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="396" path="uipicts/Casing/usd_sectg_wt2_inOpDir_vert_noCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="397" path="uipicts/Casing/usd_sectg_wt2_inOpDir_vert_outCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="398" path="uipicts/Casing/usd_sectg_wt3_inOpDir_hor_noCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="399" path="uipicts/Casing/usd_sectg_wt3_inOpDir_hor_outCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="400" path="uipicts/Casing/usd_sectg_wt3_inOpDir_vert_noCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="401" path="uipicts/Casing/usd_sectg_wt3_inOpDir_vert_outCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="402" path="uipicts/Casing/usd_sectg_wt4_inOpDir_hor_noCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="403" path="uipicts/Casing/usd_sectg_wt4_inOpDir_hor_outCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="404" path="uipicts/Casing/usd_sectg_wt4_inOpDir_vert_noCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="405" path="uipicts/Casing/usd_sectg_wt4_inOpDir_vert_outCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="410" path="uipicts/Casing/usd_pock_wt1_fr1_out_cas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="411" path="uipicts/Casing/usd_pock_wt1_fr1_out_nocas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="412" path="uipicts/Casing/usd_pock_wt1_fr2_out_cas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="413" path="uipicts/Casing/usd_pock_wt1_fr2_out_nocas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="414" path="uipicts/Casing/usd_pock_wt1_fr2_out_cas2.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="415" path="uipicts/Casing/usd_pock_wt1_fr3_out_cas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="416" path="uipicts/Casing/usd_pock_wt1_fr3_out_nocas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="417" path="uipicts/Casing/usd_pock_wt1_fr3_out_cas2.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="418" path="uipicts/Casing/usd_pock_wt1_fr1_in_cas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="419" path="uipicts/Casing/usd_pock_wt1_fr1_in_nocas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="420" path="uipicts/Casing/usd_pock_wt1_fr2_in_cas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="421" path="uipicts/Casing/usd_pock_wt1_fr2_in_nocas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="422" path="uipicts/Casing/usd_pock_wt1_fr3_in_cas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="423" path="uipicts/Casing/usd_pock_wt1_fr3_in_nocas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="424" path="uipicts/Casing/usd_pock_wt1_hor_main.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="434" path="uipicts/Casing/usd_pock_wt1_fr1_vert_noCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="435" path="uipicts/Casing/usd_pock_wt1_fr1_vert_inCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="436" path="uipicts/Casing/usd_pock_wt1_fr1_vert_outCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="437" path="uipicts/Casing/usd_pock_wt1_fr1_vert_fullCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="438" path="uipicts/Casing/usd_pock_wt1_fr2_vert_noCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="439" path="uipicts/Casing/usd_pock_wt1_fr2_vert_inCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="440" path="uipicts/Casing/usd_pock_wt1_fr2_vert_outCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="441" path="uipicts/Casing/usd_pock_wt1_fr2_vert_fullCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="442" path="uipicts/Casing/usd_pock_wt1_fr3_vert_noCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="443" path="uipicts/Casing/usd_pock_wt1_fr3_vert_inCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="444" path="uipicts/Casing/usd_pock_wt1_fr3_vert_outCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="445" path="uipicts/Casing/usd_pock_wt1_fr3_vert_fullCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="446" path="uipicts/ui_warningsign.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="481" path="uipicts/Casing/telescopic_wallcover_bottom.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="482" path="uipicts/Casing/telescopic_wallcover.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="483" path="uipicts/Casing/telescopic_wallcover_no.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="484" path="uipicts/Casing/telescopic_wallcover_top.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="485" path="uipicts/Casing/telescopic_wallcover_top_no.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="486" path="uipicts/Casing/usw_out_wt1_cas_nosill_noOffset.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="487" path="uipicts/Casing/usw_out_wt1_cas_sill_noOffset.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="488" path="uipicts/Casing/DW_HeadType.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="489" path="uipicts/Casing/DExt_OutCasSectionNoRevealEdge.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="490" path="uipicts/Casing/DPocket_InCasSectionNoCasWallThkFr.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="491" path="uipicts/Casing/DPocket_InCasSectionCasWallThkFr.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="492" path="uipicts/Casing/DPocket_InCasSectionNoCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="493" path="uipicts/Casing/DPocket_InCasSectionNoCasCover.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="494" path="uipicts/Casing/DPocket_InCasSectionCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="495" path="uipicts/Casing/DPocket_OutCasSectionNoCasWallThkFr.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="496" path="uipicts/Casing/DPocket_OutCasSectionCasWallThkFr.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="497" path="uipicts/Casing/DPocket_OutCasSectionNoCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="498" path="uipicts/Casing/DPocket_OutCasSectionNoCasCover.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="499" path="uipicts/Casing/DPocket_OutCasSectionCas.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="500" path="uipicts/Casing/DPocket_OutCasSectionCasNoRevealEdge.png">
</GDLPict>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_FWM SectVersion="20" SectionFlags="0" SubIdent="0"><![CDATA[

]]></Script_FWM>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_BWM SectVersion="20" SectionFlags="0" SubIdent="0"><![CDATA[

]]></Script_BWM>

<Keywords SectVersion="1" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Keywords>

<Copyright SectVersion="1" SectionFlags="0" SubIdent="0"><Author>BIMobject</Author><License><Type>CC BY-ND</Type><Version>3.0</Version></License></Copyright><ParamSection SectVersion="25" SectionFlags="0" SubIdent="0">
	<ParamSectHeader>
		<Version>25</Version>
		<AutoHotspots>no</AutoHotspots>
		<StatBits>
			<STBit_FixSize/>
		</StatBits>
		<WDLeftFrame>0</WDLeftFrame>
		<WDRightFrame>0</WDRightFrame>
		<WDTopFrame>0</WDTopFrame>
		<WDBotFrame>0</WDBotFrame>
		<LayFlags>65535</LayFlags>
		<WDMirrorThickness>0</WDMirrorThickness>
		<WDWallInset>0</WDWallInset>
		<SymbolColor>0</SymbolColor>
	</ParamSectHeader>
	<Parameters>
		<Length Name="A">
			<Description><![CDATA["Dimension 1"]]></Description>
			<Value>1</Value>
		</Length>
		<Length Name="B">
			<Description><![CDATA["Dimension 2"]]></Description>
			<Value>1</Value>
		</Length>
		<Length Name="ZZYZX">
			<Description><![CDATA["Height"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Integer Name="AC_WallContours">
			<Description><![CDATA["Wall Contours (0-None,1-Full,2-Side,3-Length)"]]></Description>
			<Value>0</Value>
		</Integer>
		<Integer Name="AC_Hole_Hotspot_Control">
			<Description><![CDATA["Hotspots 0-None,1-2D,2-3D,3-All"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>3</Value>
		</Integer>
		<Boolean Name="AC_show2DHotspotsIn3D">
			<Description><![CDATA["Show 2D Hotspots in 3D"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="ac_bottomlevel">
			<Description><![CDATA["Bottom Level"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Length Name="ac_toplevel">
			<Description><![CDATA["Top Level"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Integer Name="gs_macro_version">
			<Description><![CDATA["Macro Version"]]></Description>
			<Value>12</Value>
		</Integer>
		<Integer Name="iDoorType">
			<Description><![CDATA["Door Type"]]></Description>
			<Value>0</Value>
		</Integer>
		<Angle Name="AC_Hole_Position_Angle">
			<Description><![CDATA["Hole Position Angle"]]></Description>
			<Value>0</Value>
		</Angle>
		<Integer Name="AC_WallType">
			<Description><![CDATA["Wall Type"]]></Description>
			<Value>1</Value>
		</Integer>
		<Integer Name="AC_WindowInWallContour">
			<Description><![CDATA["Window in Wall Contour"]]></Description>
			<ArrayValues FirstDimension="4" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
			</ArrayValues>
		</Integer>
		<Length Name="AC_WallContourPolygon">
			<Description><![CDATA["Wall Contour Polygon"]]></Description>
			<ArrayValues FirstDimension="1" SecondDimension="3">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="AC_Wall_Direction_Type">
			<Description><![CDATA["Wall Direction Type"]]></Description>
			<Value>0</Value>
		</Integer>
		<Boolean Name="AC_HoleSideMaterial">
			<Description><![CDATA["Hole has Wall's Side Surface"]]></Description>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="AC_HoleMaterialCurved">
			<Description><![CDATA["Hole Surface's Split is Curved in Curved Walls"]]></Description>
			<Value>0</Value>
		</Boolean>

		<!-- gs_wallhole_geometry: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_wallhole_geometry">
			<Description><![CDATA["Wallhole Geometry"]]></Description>
		</Title>
		<Length Name="refWidth">
			<Description><![CDATA["Reference Width"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="leftWidth">
			<Description><![CDATA["Left Offset from the Origo"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="rightWidth">
			<Description><![CDATA["Right Offset from the Origo"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="radSill">
			<Description><![CDATA["Curved Wall - Sill Radius"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="radBoard">
			<Description><![CDATA["Curved Wall - Board Radius"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="WOD">
			<Description><![CDATA["Curved Wall - Wall Center Distance"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="offsY">
			<Description><![CDATA["Vertical Offset Size"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_sidelight_WHole_width_left">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_sidelight_WHole_width_right">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_sidelight_parapet_hgt_left">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_sidelight_parapet_hgt_right">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="sillRight">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="sillLeft">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="sillLeft_sL">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="sillRight_sL">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="sillLeft_sR">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="sillRight_sR">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="boardLeft_sL">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="boardRight_sL">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="boardLeft_sR">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="boardRight_sR">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- gs_macro_control_parameters: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_macro_control_parameters">
			<Description><![CDATA["Macro Control Parameters"]]></Description>
		</Title>
		<Boolean Name="isWindow">
			<Description><![CDATA["Window or Door Type Object"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="isEmptyOpening">
			<Description><![CDATA["Opening"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="Suppress_isWindow">
			<Description><![CDATA["Force to Door Type Object"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_IsCurved">
			<Description><![CDATA["Curved Window"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bParalellInCurvedWalls">
			<Description><![CDATA["Parallel Opening in Curved Walls"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bCasingTolerance">
			<Description><![CDATA["Offset Casing with Tolerance Sizes"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bDrawOutsideCasingFill">
			<Description><![CDATA["Draw Wallhole Fill at Outside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bDrawInsideCasingFill">
			<Description><![CDATA["Draw Wallhole Fill at Inside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Integer Name="gs_CasingOutTypeEnable">
			<Description><![CDATA["Casing Outside Type Enable"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="gs_CasingInTypeEnable">
			<Description><![CDATA["Casing Inside Type Enable"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Boolean Name="bShowEdgeHotspots">
			<Description><![CDATA["Show Hotspots at Jamb Extensions Edge"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bshowCasbSill">
			<Description><![CDATA["Show Casing below Sill on UI"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="smallRadiusEllips">
			<Description><![CDATA["smaller radius of ellips arch"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- iWindowShape: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Integer Name="iWindowShape">
			<Description><![CDATA["Window Shape"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Length Name="archHeight">
			<Description><![CDATA["Height of the Arc"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.25</Value>
		</Length>
		<Integer Name="nArchResolution">
			<Description><![CDATA["Arch Resolution"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>

		<!-- iRevealType: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Integer Name="iRevealType">
			<Description><![CDATA["Reveal Type"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Length Name="gs_reveal_left">
			<Description><![CDATA["Jamb Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_right">
			<Description><![CDATA["Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_left_sL">
			<Description><![CDATA["Lower Jamb Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_right_sR">
			<Description><![CDATA["Lower Jamb Depth Side 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="revealInnerLeft">
			<Description><![CDATA["Inner Jamb Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="revealInnerRight">
			<Description><![CDATA["Inner Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerLeft_sL">
			<Description><![CDATA["Inner Lower Jamb Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerRight_sR">
			<Description><![CDATA["Inner Lower Jamb Depth Side 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_top">
			<Description><![CDATA["Head Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_bottom">
			<Description><![CDATA["Sill Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_reveal_bottom_sL">
			<Description><![CDATA["Sill Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_bottom_sR">
			<Description><![CDATA["Sill Depth Side 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_splayed_innerTop">
			<Description><![CDATA["Inner Head Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_splayed_innerBottom">
			<Description><![CDATA["Inner Sill Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerTop">
			<Description><![CDATA["Inner Head Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerBottom">
			<Description><![CDATA["Inner Sill Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerBottom_sL">
			<Description><![CDATA["Inner Sill Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerBottom_sR">
			<Description><![CDATA["Inner Sill Depth Side 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_outer_jamb_depth">
			<Description><![CDATA["Outer Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.08</Value>
		</Length>
		<Angle Name="gs_reveal_left_angle">
			<Description><![CDATA["Angle Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Angle Name="gs_reveal_right_angle">
			<Description><![CDATA["Angle Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Angle Name="gs_reveal_top_angle">
			<Description><![CDATA["Upper Side Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Angle Name="gs_reveal_bottom_angle">
			<Description><![CDATA["Bottom Side Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Angle Name="gs_reveal_outerLeft_angle">
			<Description><![CDATA["Outer Angle Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Angle Name="gs_reveal_outerRight_angle">
			<Description><![CDATA["Outer Angle Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Angle Name="gs_reveal_outerTop_angle">
			<Description><![CDATA["Outer Angle Upper Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Angle Name="gs_reveal_outerBottom_angle">
			<Description><![CDATA["Outer Angle Bottom Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Length Name="gs_mountingFrame_width_right">
			<Description><![CDATA["Mounting Frame Width Right"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_mountingFrame_width_top">
			<Description><![CDATA["Mounting Frame Width Upper"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_mountingFrame_width_bottom">
			<Description><![CDATA["Mounting Frame Width Bottom"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="leftRevealPnts">
			<Description><![CDATA["Left Reveal Points"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="2" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="rightRevealPnts">
			<Description><![CDATA["Right Reveal Points"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="2" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="iRevealPointsIdx">
			<Description><![CDATA["Reveal Points Index"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="20" SecondDimension="0">
				<AVal Row="1">1</AVal>
				<AVal Row="2">1</AVal>
				<AVal Row="3">1</AVal>
				<AVal Row="4">1</AVal>
				<AVal Row="5">1</AVal>
				<AVal Row="6">2</AVal>
				<AVal Row="7">1</AVal>
				<AVal Row="8">1</AVal>
				<AVal Row="9">1</AVal>
				<AVal Row="10">1</AVal>
				<AVal Row="11">1</AVal>
				<AVal Row="12">1</AVal>
				<AVal Row="13">1</AVal>
				<AVal Row="14">1</AVal>
				<AVal Row="15">1</AVal>
				<AVal Row="16">2</AVal>
				<AVal Row="17">1</AVal>
				<AVal Row="18">1</AVal>
				<AVal Row="19">1</AVal>
				<AVal Row="20">1</AVal>
			</ArrayValues>
		</Integer>

		<!-- gs_corner_functions: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_corner_functions">
			<Description><![CDATA["Corner Functions"]]></Description>
		</Title>
		<Boolean Name="bLeftCornerFunction">
			<Description><![CDATA["Left Corner"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Angle Name="leftCornerAngle">
			<Description><![CDATA["Left Corner Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Length Name="leftConnWallThk">
			<Description><![CDATA["Left Connected Wall Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="bRightCornerFunction">
			<Description><![CDATA["Right Corner"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Angle Name="rightCornerAngle">
			<Description><![CDATA["Right Corner Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Length Name="rightConnWallThk">
			<Description><![CDATA["Right Connected Wall Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- gs_tolerance: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_tolerance">
			<Description><![CDATA["Tolerance"]]></Description>
		</Title>
		<Length Name="gs_tolerance_left">
			<Description><![CDATA["Tolerance Left"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_tolerance_right">
			<Description><![CDATA["Tolerance Right"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_tolerance_upper">
			<Description><![CDATA["Tolerance Upper"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_tolerance_lower">
			<Description><![CDATA["Tolerance Lower"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- gs_window_oversize: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_window_oversize">
			<Description><![CDATA["Oversize"]]></Description>
		</Title>
		<Length Name="gs_left_oversize">
			<Description><![CDATA["Left Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_right_oversize">
			<Description><![CDATA["Right Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_upper_oversize">
			<Description><![CDATA["Upper Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_lower_oversize">
			<Description><![CDATA["Lower Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- gs_trim_outside: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="gs_trim_outside">
			<Description><![CDATA["Casing Outside"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bDrawOutsideTrim">
			<Description><![CDATA["Draw Outside Casing 2D and 3D"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bShowTrimOutsideSplice">
			<Description><![CDATA["Show Outside Trim Splice Lines"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<String Name="gs_trimtype_out">
			<Description><![CDATA["Casing Type Outside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Simple"]]></Value>
		</String>
		<Integer Name="gs_trimtype_out_int">
			<Description><![CDATA["Casing Type Outside"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="iCasingHeadTypeOut">
			<Description><![CDATA["Outside Casing Head Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Boolean Name="bArchitraveCapital">
			<Description><![CDATA["Architrave Capital"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Integer Name="iArchitraveCapitalType">
			<Description><![CDATA["Architrave Capital Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Length Name="architraveCapitalWidth">
			<Description><![CDATA["Architrave Capital Width"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.02</Value>
		</Length>
		<Boolean Name="bCasingBottomOutside">
			<Description><![CDATA["Outside Bottom Casing"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="gs_trim_outside_uniform">
			<Description><![CDATA["Uniform Casing Widths"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Length Name="gs_tw_right_out">
			<Description><![CDATA["Width Side 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.05</Value>
		</Length>
		<Length Name="gs_tw_left_out">
			<Description><![CDATA["Width Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.05</Value>
		</Length>
		<Length Name="gs_tw_top_out">
			<Description><![CDATA["Width Top"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.05</Value>
		</Length>
		<Length Name="gs_tw_bottom_out">
			<Description><![CDATA["Width Bottom"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.05</Value>
		</Length>
		<Length Name="gs_trim_thk_out">
			<Description><![CDATA["Thickness on Wall"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.019</Value>
		</Length>
		<Length Name="gs_trim_width_out">
			<Description><![CDATA["Thickness in Wallhole"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.025</Value>
		</Length>
		<Length Name="gs_trim_offs_out">
			<Description><![CDATA["Offset"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_trimov_top_left_out">
			<Description><![CDATA["Top Overhang"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_trimov_top_right_out">
			<Description><![CDATA["Top Overhang"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_trimov_bot_left_out">
			<Description><![CDATA["Bottom Overhang"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_trimov_bot_right_out">
			<Description><![CDATA["Bottom Overhang"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="casingOverhangBottomSideOut">
			<Description><![CDATA["Bottom Overhang"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.05</Value>
		</Length>
		<Boolean Name="gs_trimb_atframe_out">
			<Description><![CDATA["Bottom Casing at Frame Outside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_trim_atframe_out">
			<Description><![CDATA["Casing at Frame Outside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_trim_show_cover_out">
			<Description><![CDATA["Cover Outer Wall Surface"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Length Name="gs_trim_jambext_nosing_out">
			<Description><![CDATA["Nosing"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.05</Value>
		</Length>

		<!-- gs_trim_inside: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="gs_trim_inside">
			<Description><![CDATA["Casing Inside"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bDrawInsideTrim">
			<Description><![CDATA["Draw Inside Casing 2D and 3D"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bShowTrimInsideSplice">
			<Description><![CDATA["Show Inside Trim Splice Lines"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<String Name="gs_trimtype_in">
			<Description><![CDATA["Casing Type Inside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Simple"]]></Value>
		</String>
		<Integer Name="gs_trimtype_in_int">
			<Description><![CDATA["Casing Type Inside"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Boolean Name="gs_trim_below_board">
			<Description><![CDATA["Casing below Board"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_trim_inside_uniform">
			<Description><![CDATA["Uniform Casing Widths"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Length Name="gs_tw_right_in">
			<Description><![CDATA["Width Side 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.05</Value>
		</Length>
		<Length Name="gs_tw_left_in">
			<Description><![CDATA["Width Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.05</Value>
		</Length>
		<Length Name="gs_tw_top_in">
			<Description><![CDATA["Width Top"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.05</Value>
		</Length>
		<Length Name="gs_tw_bottom_in">
			<Description><![CDATA["Width Bottom"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.05</Value>
		</Length>
		<Length Name="gs_trim_thk_in">
			<Description><![CDATA["Thickness on Wall"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.019</Value>
		</Length>
		<Length Name="gs_trim_width_in">
			<Description><![CDATA["Thickness in Wallhole"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.025</Value>
		</Length>
		<Length Name="gs_trim_offs_in">
			<Description><![CDATA["Offset"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_trimov_top_left_in">
			<Description><![CDATA["Top Overhang"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_trimov_top_right_in">
			<Description><![CDATA["Top Overhang"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_trimov_bot_left_in">
			<Description><![CDATA["Casing Overhang Bottom Left Inside"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_trimov_bot_right_in">
			<Description><![CDATA["Bottom Overhang"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="gs_trim_atframe_in">
			<Description><![CDATA["Casing at Frame Inside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_trim_stack_left">
			<Description><![CDATA["Casing at Ganging Left"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_trim_stack_right">
			<Description><![CDATA["Casing at Ganging Right"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_trim_stack_bottom">
			<Description><![CDATA["Casing at Ganging Bottom"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_trim_stack_top">
			<Description><![CDATA["Casing at Ganging Top"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_trim_show_cover_in">
			<Description><![CDATA["Cover Inner Wall Surface"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Length Name="gs_trim_jambext_nosing_in">
			<Description><![CDATA["Nosing"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.03</Value>
		</Length>
		<Boolean Name="bWindowSymbolAtMiddle">
			<Description><![CDATA["Window Symbol at Middle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- gs_apron: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="gs_apron">
			<Description><![CDATA["Apron"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="gs_apron_thk">
			<Description><![CDATA["Apron Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.0254</Value>
		</Length>
		<Length Name="gs_apron_width">
			<Description><![CDATA["Apron Width"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.0508</Value>
		</Length>

		<!-- bDrawSill: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="bDrawSill">
			<Description><![CDATA["Draw Sill"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="iSillType">
			<Description><![CDATA["Type of the Sill"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Length Name="sillBottom">
			<Description><![CDATA["Sill Bottom Distance"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="sillBottomOutside">
			<Description><![CDATA["Sill Bottom Outside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="bSillPlaneCut">
			<Description><![CDATA["Use Cut Plane at Sill Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="SillSideHeight">
			<Description><![CDATA["Cut Plane Height"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Angle Name="sillSideAngle">
			<Description><![CDATA["Cut Plane Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Boolean Name="bThresholdSillPlaneCut">
			<Description><![CDATA["Use Cut Plane at Threshold Sill Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="ThresholdSillSideHeight">
			<Description><![CDATA["Cut Plane Height"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- bDrawBoard: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="bDrawBoard">
			<Description><![CDATA["Draw Board"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="boardBottom">
			<Description><![CDATA["Board Bottom Distance"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="bBoardPlaneCut">
			<Description><![CDATA["Use Cut Plane at Board Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="boardSideHeight">
			<Description><![CDATA["Cut Plane Height"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Angle Name="boardSideAngle">
			<Description><![CDATA["Cut Plane Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Boolean Name="bThresholdBoardPlaneCut">
			<Description><![CDATA["Use Cut Plane at Threshold Board Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="ThresholdBoardSideHeight">
			<Description><![CDATA["Cut Plane Height"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- gs_2D_representation: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_2D_representation">
			<Description><![CDATA["2D and Section Representation"]]></Description>
		</Title>
		<Integer Name="lod2D_Casing">
			<Description><![CDATA["Level of Detail in 2D"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Boolean Name="bShowAddHotspots">
			<Description><![CDATA["Show Additional Hotspots"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<PenColor Name="gs_pen_2D">
			<Description><![CDATA["2D Contour Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4</Value>
		</PenColor>
		<PenColor Name="gs_trim_pen_cont">
			<Description><![CDATA["Casing Cut Line Pen on Both Sides"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</PenColor>
		<Boolean Name="gs_bFills">
			<Description><![CDATA["Use Fills"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<FillPattern Name="gs_wallhole_fill">
			<Description><![CDATA["Wallhole Fill Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</FillPattern>
		<PenColor Name="gs_wallhole_pen_fg">
			<Description><![CDATA["Wallhole Fill Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<PenColor Name="gs_wallhole_pen_bg">
			<Description><![CDATA["Wallhole Fill Background Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>92</Value>
		</PenColor>
		<FillPattern Name="gs_wallhole_fill_sl">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</FillPattern>
		<PenColor Name="gs_wallhole_pen_sl_fg">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<PenColor Name="gs_wallhole_pen_sl_bg">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<Boolean Name="gs_trim_bFills_in">
			<Description><![CDATA["Use Fills on Inside Casing"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<PenColor Name="gs_trim_wallhole_pen_fg_in">
			<Description><![CDATA["Fill Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>-1</Value>
		</PenColor>
		<PenColor Name="gs_trim_wallhole_pen_bg_in">
			<Description><![CDATA["Fill Backgroud Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<Boolean Name="gs_trim_bFills_out">
			<Description><![CDATA["Use Fills on Outside Casing"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<PenColor Name="gs_trim_wallhole_pen_fg_out">
			<Description><![CDATA["Fill Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>-1</Value>
		</PenColor>
		<PenColor Name="gs_trim_wallhole_pen_bg_out">
			<Description><![CDATA["Fill Backgroud Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<FillPattern Name="gs_trim_fill_in">
			<Description><![CDATA["Casing Fill Type Inside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>65</Value>
		</FillPattern>
		<PenColor Name="gs_trim_pen_fg_in">
			<Description><![CDATA["Casing Fill Pen Inside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>7</Value>
		</PenColor>
		<PenColor Name="gs_trim_pen_bg_in">
			<Description><![CDATA["Casing Fill Background Pen Inside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>39</Value>
		</PenColor>
		<FillPattern Name="gs_trim_fill_out">
			<Description><![CDATA["Casing Fill Type Outside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>26</Value>
		</FillPattern>
		<PenColor Name="gs_trim_pen_fg_out">
			<Description><![CDATA["Casing Fill Pen Outside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4</Value>
		</PenColor>
		<PenColor Name="gs_trim_pen_bg_out">
			<Description><![CDATA["Casing Fill Background Pen Outside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>59</Value>
		</PenColor>

		<!-- gs_3D_representation: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_3D_representation">
			<Description><![CDATA["3D Representation"]]></Description>
		</Title>
		<Integer Name="lod3D">
			<Description><![CDATA["Level of Detail in 3D"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<PenColor Name="gs_frame_pen">
			<Description><![CDATA["Frame Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>2</Value>
		</PenColor>

		<!-- gs_window_material: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_window_material">
			<Description><![CDATA["Surfaces"]]></Description>
		</Title>
		<Boolean Name="bLinkCasingSurfaces">
			<Description><![CDATA["Uniform Casing Surfaces"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Integer Name="stored_material">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="4" SecondDimension="2">
				<AVal Column="1" Row="1">-9999</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0</AVal>
			</ArrayValues>
		</Integer>
		<Material Name="gs_trim_in_mat">
			<Description><![CDATA["Interior Casing Surface"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Material>
		<Material Name="gs_trim_out_mat">
			<Description><![CDATA["Exterior Casing Surface"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Material>
		<Material Name="gs_apron_mat">
			<Description><![CDATA["Apron Surface"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>59</Value>
		</Material>

		<!-- gs_window_stack: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_window_stack">
			<Description><![CDATA["Ganging"]]></Description>
		</Title>
		<Boolean Name="gs_stack_left">
			<Description><![CDATA["Connection on the Left"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_stack_right">
			<Description><![CDATA["Connection on the Right"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_stack_top">
			<Description><![CDATA["Connection on the Top"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_stack_bottom">
			<Description><![CDATA["Connection on the Bottom"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="gs_ui_sub_tabpage">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Length Name="bBoardElevUsa">
			<Description><![CDATA["Board Elevation (USA)"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- gs_string_resources: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_string_resources">
			<Description><![CDATA["String Resources"]]></Description>
		</Title>
		<String Name="stCasingType">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="3" SecondDimension="0">
				<AVal Row="1"><![CDATA["Simple"]]></AVal>
				<AVal Row="2"><![CDATA["Traditional"]]></AVal>
				<AVal Row="3"><![CDATA["Complex"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stCasingHeadType">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="4" SecondDimension="0">
				<AVal Row="1"><![CDATA["Type 1"]]></AVal>
				<AVal Row="2"><![CDATA["Type 2"]]></AVal>
				<AVal Row="3"><![CDATA["Type 3"]]></AVal>
				<AVal Row="4"><![CDATA["Type 4"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stArchitraveCapitalType">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="3" SecondDimension="0">
				<AVal Row="1"><![CDATA["Type 1"]]></AVal>
				<AVal Row="2"><![CDATA["Type 2"]]></AVal>
				<AVal Row="3"><![CDATA["Type 3"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stSubTabpageToolTip">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Sub Tab Page Selection: General Settings, Attributes"]]></Value>
		</String>
		<String Name="stCutLinePenNote">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["3D/Uncut Line Pen for casing is the same as for the window frame."]]></Value>
		</String>

		<!-- gs_corner_column: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="gs_corner_column">
			<Description><![CDATA["Corner Column"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Length Name="gs_cc_width">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.175</Value>
		</Length>
		<Length Name="gs_cc_thk">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.14</Value>
		</Length>
		<Length Name="gs_cc_pr">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.05</Value>
		</Length>
		<Length Name="openingHeight">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1.5</Value>
		</Length>
		<Boolean Name="bCasingInPage">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bCasingOutPage">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<String Name="stCasingUI">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="49" SecondDimension="0">
				<AVal Row="1"><![CDATA["Inside"]]></AVal>
				<AVal Row="2"><![CDATA["Outside"]]></AVal>
				<AVal Row="3"><![CDATA["Increase Wallhole by Casing"]]></AVal>
				<AVal Row="4"><![CDATA["Contour Pen"]]></AVal>
				<AVal Row="5"><![CDATA["Inside"]]></AVal>
				<AVal Row="6"><![CDATA["Outside"]]></AVal>
				<AVal Row="7"><![CDATA["Fill Type"]]></AVal>
				<AVal Row="8"><![CDATA["Fill Pen"]]></AVal>
				<AVal Row="9"><![CDATA["Background Pen"]]></AVal>
				<AVal Row="10"><![CDATA["Cover Outer Wall"]]></AVal>
				<AVal Row="11"><![CDATA["Cover Inner Wall"]]></AVal>
				<AVal Row="12"><![CDATA["Casing Width Left Outside"]]></AVal>
				<AVal Row="13"><![CDATA["Casing Width Right Outside"]]></AVal>
				<AVal Row="14"><![CDATA["Casing Width Outside"]]></AVal>
				<AVal Row="15"><![CDATA["Casing Offset Outside"]]></AVal>
				<AVal Row="16"><![CDATA["Casing Thickness Outside"]]></AVal>
				<AVal Row="17"><![CDATA["Outer Nosing"]]></AVal>
				<AVal Row="18"><![CDATA["Casing Width Left Inside"]]></AVal>
				<AVal Row="19"><![CDATA["Casing Width Right Inside"]]></AVal>
				<AVal Row="20"><![CDATA["Head Type"]]></AVal>
				<AVal Row="21"><![CDATA["Architrave Capital"]]></AVal>
				<AVal Row="22"><![CDATA["Casing Thickness Inside"]]></AVal>
				<AVal Row="23"><![CDATA["Inner Nosing"]]></AVal>
				<AVal Row="24"><![CDATA["Casing Width Bottom Outside"]]></AVal>
				<AVal Row="25"><![CDATA["Casing Width Top Outside"]]></AVal>
				<AVal Row="26"><![CDATA["Casing Width Bottom Inside"]]></AVal>
				<AVal Row="27"><![CDATA["Casing Width Top Inside"]]></AVal>
				<AVal Row="28"><![CDATA["Casing Type Inside"]]></AVal>
				<AVal Row="29"><![CDATA["Overhang Top Outside"]]></AVal>
				<AVal Row="30"><![CDATA["Overhang Bottom Outs."]]></AVal>
				<AVal Row="31"><![CDATA["Casing Type Outside"]]></AVal>
				<AVal Row="32"><![CDATA["Overhang Top Inside"]]></AVal>
				<AVal Row="33"><![CDATA["Overhang Bottom Ins."]]></AVal>
				<AVal Row="34"><![CDATA["Trim Width Left Outside"]]></AVal>
				<AVal Row="35"><![CDATA["Trim Width Right Outside"]]></AVal>
				<AVal Row="36"><![CDATA["Trim Offset Outside"]]></AVal>
				<AVal Row="37"><![CDATA["Trim Thickness Outside"]]></AVal>
				<AVal Row="38"><![CDATA["Trim Width Outside"]]></AVal>
				<AVal Row="39"><![CDATA["Trim Thickness Top Inside"]]></AVal>
				<AVal Row="40"><![CDATA["Trim Thickness Left Inside"]]></AVal>
				<AVal Row="41"><![CDATA["Trim Thickness Right Inside"]]></AVal>
				<AVal Row="42"><![CDATA["Trim Offset Inside"]]></AVal>
				<AVal Row="43"><![CDATA["Trim Thickness Inside"]]></AVal>
				<AVal Row="44"><![CDATA["Trim Width Inside"]]></AVal>
				<AVal Row="45"><![CDATA["Trim Width Top Outside"]]></AVal>
				<AVal Row="46"><![CDATA["Trim Width Top Inside"]]></AVal>
				<AVal Row="47"><![CDATA["Casing below Sill"]]></AVal>
				<AVal Row="48"><![CDATA["Casing is not available with the actual reveal type."]]></AVal>
				<AVal Row="49"><![CDATA["Casing is not available with trapezoid and curved walls."]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stCasingUITooltip">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="24" SecondDimension="0">
				<AVal Row="1"><![CDATA["Outside Casing Width Side 1"]]></AVal>
				<AVal Row="2"><![CDATA["Outside Casing Width Side 2"]]></AVal>
				<AVal Row="3"><![CDATA["Outside Casing Width Top"]]></AVal>
				<AVal Row="4"><![CDATA["Outside Casing Width Bottom"]]></AVal>
				<AVal Row="5"><![CDATA["Outside Casing Thickness on Wall"]]></AVal>
				<AVal Row="6"><![CDATA["Outside Casing Thickness in Wallhole"]]></AVal>
				<AVal Row="7"><![CDATA["Outside Casing Offset"]]></AVal>
				<AVal Row="8"><![CDATA["Outside Casing Width"]]></AVal>
				<AVal Row="9"><![CDATA["Outside Top Casing Overhang"]]></AVal>
				<AVal Row="10"><![CDATA["Outside Side Casing Overhang"]]></AVal>
				<AVal Row="11"><![CDATA["Outer Nosing"]]></AVal>
				<AVal Row="12"><![CDATA["Inner Nosing"]]></AVal>
				<AVal Row="13"><![CDATA["Inside Casing Width Side 1"]]></AVal>
				<AVal Row="14"><![CDATA["Inside Casing Width Side 2"]]></AVal>
				<AVal Row="15"><![CDATA["Inside Casing Width Top"]]></AVal>
				<AVal Row="16"><![CDATA["Inside Casing Width Bottom"]]></AVal>
				<AVal Row="17"><![CDATA["Inside Casing Thickness on Wall"]]></AVal>
				<AVal Row="18"><![CDATA["Inside Casing Thickness in Wallhole"]]></AVal>
				<AVal Row="19"><![CDATA["Inside Casing Offset"]]></AVal>
				<AVal Row="20"><![CDATA["Inside Casing Width"]]></AVal>
				<AVal Row="21"><![CDATA["Inside Top Casing Overhang"]]></AVal>
				<AVal Row="22"><![CDATA["Inside Side Casing Overhang"]]></AVal>
				<AVal Row="23"><![CDATA["Architrave Capital Width"]]></AVal>
				<AVal Row="24"><![CDATA["Outside Bottom Casing Overhang"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stNORCasingTypes">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="18" SecondDimension="0">
				<AVal Row="1"><![CDATA["None"]]></AVal>
				<AVal Row="2"><![CDATA["Sill only"]]></AVal>
				<AVal Row="3"><![CDATA["Left only"]]></AVal>
				<AVal Row="4"><![CDATA["Left, Sill"]]></AVal>
				<AVal Row="5"><![CDATA["Right only"]]></AVal>
				<AVal Row="6"><![CDATA["Right, Sill"]]></AVal>
				<AVal Row="7"><![CDATA["Left, Right"]]></AVal>
				<AVal Row="8"><![CDATA["Left, Right, Sill"]]></AVal>
				<AVal Row="9"><![CDATA["Entablature only"]]></AVal>
				<AVal Row="10"><![CDATA["Entablature, Sill"]]></AVal>
				<AVal Row="11"><![CDATA["Entablature, Left"]]></AVal>
				<AVal Row="12"><![CDATA["Entablature, Left, Sill"]]></AVal>
				<AVal Row="13"><![CDATA["Entablature, Right"]]></AVal>
				<AVal Row="14"><![CDATA["Entablature, Right, Sill"]]></AVal>
				<AVal Row="15"><![CDATA["Entablature, Left, Right"]]></AVal>
				<AVal Row="16"><![CDATA["Entablature, Left, Right, Sill"]]></AVal>
				<AVal Row="17"><![CDATA["All"]]></AVal>
				<AVal Row="18"><![CDATA["Simple Casing"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stCasingTextNOR">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="2" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
				<AVal Row="2"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<Boolean Name="bEnableCasingNORUI">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bTerraceDoorNORUI">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="iNORCasingType">
			<Description><![CDATA["Casing Configuration"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>18</Value>
		</Integer>
		<Boolean Name="bEnableOutsideCasingSWEUI">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bEnableInsideCasingSWEUI">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bOpeningDirection">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>
		<Integer Name="iPanelType">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Integer>
		<Boolean Name="gs_board_inside">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_board_inside_sl_left">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_board_inside_sl_right">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bEnableSill">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bEnableApron">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bEnableCasingAtGanging">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_sill_outside">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_sill_outside_sl_left">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_sill_outside_sl_right">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>

		<!-- gs_usa_parameters: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_usa_parameters">
			<Description><![CDATA["USA Parameters"]]></Description>
		</Title>
		<Integer Name="gs_wt_m">
			<Description><![CDATA["Wall Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Boolean Name="bCasingPageUSA">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<String Name="stCasingTextUSA">
			<Description><![CDATA["UI Casing Text"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="7" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
				<AVal Row="2"><![CDATA[""]]></AVal>
				<AVal Row="3"><![CDATA[""]]></AVal>
				<AVal Row="4"><![CDATA[""]]></AVal>
				<AVal Row="5"><![CDATA[""]]></AVal>
				<AVal Row="6"><![CDATA[""]]></AVal>
				<AVal Row="7"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<Integer Name="iFrameStyle">
			<Description><![CDATA["Frame Style"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Length Name="gs_frame_width">
			<Description><![CDATA["Frame Width"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.05</Value>
		</Length>
		<Angle Name="gs_sill_angle">
			<Description><![CDATA["Sill Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Length Name="gs_board_thk">
			<Description><![CDATA["Stool Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="gs_fsill">
			<Description><![CDATA["Bottom Frame at Sill"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="gs_trim_offs_out_top">
			<Description><![CDATA["Trim Offset Outside Top"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_trim_offs_out_bottom">
			<Description><![CDATA["Trim Offset Outside Bottom"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="trim_offs_out_modify">
			<Description><![CDATA["Trim Offset Left-Right Modify Value"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="gs_sectgar">
			<Description><![CDATA["Sectional Garage Door"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_pocket">
			<Description><![CDATA["Sectional Garage Door"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="gs_door_type">
			<Description><![CDATA["Door Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="gs_win_type">
			<Description><![CDATA["Window Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Boolean Name="gs_casing_nor">
			<Description><![CDATA["NOR Casing"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_casing_che">
			<Description><![CDATA["CHE Casing"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bCasingUSA">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_pocket_door_frame">
			<Description><![CDATA["Pocket Door Frame"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_frame_wthk">
			<Description><![CDATA["Frame Thickness=Wall Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bLineCasingOffset">
			<Description><![CDATA["Show Line at Casing Offset"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- gs_sunshade_parameters: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_sunshade_parameters">
			<Description><![CDATA["SunShade Parameters"]]></Description>
		</Title>
		<Length Name="casingSetBackOnSides_out">
			<Description><![CDATA["Casing Set Back Outside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="casingSetBackOnSides_in">
			<Description><![CDATA["Casing Set Back Inside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="lengthCasingSetback">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="ifc_CasingDepth">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="ifc_CasingThickness">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Length>
		<Boolean Name="bTelescopic">
			<Description><![CDATA["Telescopic Door"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Integer Name="gs_frame_style_m">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Integer>
		<Boolean Name="bEnableSwitchableBottomCasing">
			<Description><![CDATA[""]]></Description>
			<Value>1</Value>
		</Boolean>
	</Parameters>
</ParamSection>
</Symbol>
