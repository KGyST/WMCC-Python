<Symbol IsArchivable="no" IsPlaceable="no" MainGUID="54645068-4414-4170-8128-8968482F76C0" MigrationValue="Normal" Owner="1196638531" Signature="1196644685" Version="34">
<Ancestry SectVersion="1" SectionFlags="0" SubIdent="0" Template="no">
	<MainGUID>F938E33A-329D-4A36-BE3E-85E126820996</MainGUID>
	<MainGUID>103E8D2C-8230-42E1-9597-46F84CCE28C0</MainGUID>
	<MainGUID>6ACDA889-69B2-4EC5-936C-CB1DA7032A92</MainGUID>
	<MainGUID>F6AE9687-2BC7-4D47-88C9-8F793E1DE2D6</MainGUID>
</Ancestry>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_3D SectVersion="20" SectionFlags="0" SubIdent="0"><![CDATA[

! Contact person: <NJ>

! ==============================================================================
! This macro draws the Board
! ------------------------------------------------------------------------------
! Input parameters:
! Geometry ---------------------------------------------------------------------
!	A:						wallhole width (length) (Obsolete)
!	B:						wallhole height (length)
!	refWidth:				reference width in curved walls (length)
!	leftWidth:				wallhole's side distance from the origin at the left side (length)
!	rightWidth:				wallhole's side distance from the origin at the right side (length)
!	AC_Hole_Position_Angle:	Position angle of the window in a curved wall
!	offsY:					for positioning 3D along y (length)
! Functions --------------------------------------------------------------------
!	gs_IsCurved:			Does the window follow the curvature of the wall? (0 / 1)
!	iWindowShape:			Shape of the window (integer)
!								0 = rectangular (default)
!								1 = arched
!							Note: only the rectangular shape can be a Corner Window
! Reveal -----------------------------------------------------------------------
!	iRevealType:
!	gs_reveal_left_angle:
!	gs_reveal_right_angle:
! Corner Function --------------------------------------------------------------
!	bLeftCornerFunction:		Turn macro in Corner Window mode at the left side (0 / 1)
!	leftCornerAngle:		Angle between connected walls in case of Corner Window (angle)
!	leftConnWallThk:		Thickness of the connected wall in case of Corner Window (length)
!	bRightCornerFunction:	Turn macro in Corner Window mode at the right side (0 / 1)
!	rightCornerAngle:		Angle between connected walls in case of Corner Window (angle)
!	rightConnWallThk:		Thickness of the connected wall in case of Corner Window (length)
! Oversize ---------------------------------------------------------------------
!	gs_left_oversize:		Left opening oversize (length)
!	gs_right_oversize:		Right opening oversize (length)
!	gs_lower_oversize:		Lower opening oversize (length)
! Sill -------------------------------------------------------------------------
!	gs_sill_oversize:		Identifies the method as the macro handles the nominal
!								opening sizes when Sill are turned on. (0 / 1)
!	iSillType:				Identifies the type of the Sill.
!								(integer; 1 = Standard Sill, 2 = Brick Sill, 3 = Stone Sill, 4 = Ceramic Sill)
!								(5 = Eternite Sill, 6 = Concrete Tub, 7 = Aluminum Sill)
!	gs_sill_thk:			Thickness of the Sill. (length)
!	gs_board_width:			Width of the Board. (length)
!	gs_board_thk:			Thickness of the Board. (length)
!	gs_board_nosing:		Nosing of the Board. (length)
!	gs_board_angle:			Board slope. (angle)
!	gs_board_ovhg_left:		Board overhang on the left side. (length)
!	gs_board_ovhg_right:	Board overhang on the right side. (length)
!	gs_board_slip_in:		Slip in of the Board. Only effective when iSillType = 2 or iSillType = 3 (length)
!	gs_board_curved:		Board edge is curved or straight. (0 / 1)
!	bShowBoardSplice:		Show or hide the Board's joint line in case of Corner Window  (0 / 1)
! Ganging ----------------------------------------------------------------------
!	gs_stack_left:			Align to door/window on left side (0 / 1)
!	gs_stack_right:			Align to door/window on right side (0 / 1)
!	gs_stack_bottom:		Align to door/window on bottom side (0 / 1)
! 2D Representation ------------------------------------------------------------
!	gs_board_fill:			Type of the fill on the Board. (fill type)
!	gs_board_pen_fg:		Fill pen on the Board. (pen)
!	gs_board_pen_bg:		Fill background pen on the Board. (pen)
! 3D Representation ------------------------------------------------------------
!	lod3D:					Level of detail. Not used. (integer)
!	gs_frame_pen:			Drawing pen of 3D. (pen)
! Materials --------------------------------------------------------------------
!	gs_board_mat:			Board material (material)
!
! Related Global Variables:
!	GLOB_SCRIPT_TYPE
!	GLOB_CONTEXT
!	WALL_THICKNESS
!	WALL_INCL
!	WALL_RESOL
!	WIDO_FRAME_THICKNESS
!	WIDO_SILL
!	WIDO_LEFT_JAMB
!	WIDO_RIGHT_JAMB
!	WIDO_THRES_DEPTH
!	WIDO_HEAD_DEPTH
!	WIDO_ORIG_DIST
!	WIDO_REVEAL_SIDE
!	SYMB_MIRRORED
!	SYMB_ROTANGLE
!	SYMB_FILL
!	SYMB_SECT_PEN
!	SYMB_FILL_PEN
!	SYMB_FBGD_PEN
! ==============================================================================

widoInnerBottomJamb	= 0
if iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC then
	widoInnerBottomJamb	= gs_reveal_splayed_innerBottom
endif
if iRevealType = REVEAL_DOUBLE then
	widoInnerBottomJamb	= gs_reveal_double_innerBottom
endif

boardLeft_sL	= 0
boardRight_sL	= 0
boardLeft_sR	= 0
boardRight_sR	= 0
boardElevation = -overSizeLower + widoInnerBottomJamb + bBoardElevUsa


! Draw Board -------------------------------------------------------------------

if bDrawBoard & lod3D > 0 & ((WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS + gs_board_nosing) > EPS) & not(gs_stack_bottom) then

! Save the current parameter buffer --------------------------------------------

	dim savedQueueValues[]
	call "SaveQueue_WMCC" parameters returned_parameters savedQueueValues

	if gs_board_fill	< 1 then gs_board_fill		= SYMB_FILL
	if gs_board_pen_bg	< 1 then gs_board_pen_bg	= SYMB_FBGD_PEN
	if gs_board_pen_fg	< 1 then gs_board_pen_fg	= SYMB_FILL_PEN
	if gs_board_pen_3D	< 1 then gs_board_pen_3D	= gs_frame_pen		! Compatibility

	rotx -90
	if WIDO_REVEAL_SIDE then
		addy -WIDO_FRAME_THICKNESS
	else
		muly -1
	endif

	resol WALL_RESOL

	if not(gs_turn_plaster_show_3D) then
		thkPlasterAtBoardLeft	= 0
		thkPlasterAtBoardRight	= 0
	endif
	if gs_stack_left then
		thkPlasterAtBoardLeft	= 0
	endif
	if gs_stack_right then
		thkPlasterAtBoardRight	= 0
	endif

! Draw Board -------------------------------------------------------------------

	if bTShapedOpening then
		if gs_board_inside_sl_left & gs_sidelight_left & gs_sidelight_parapet_hgt_left > EPS then
			addz gs_sidelight_parapet_hgt_left + (gs_reveal_double_innerBottom_sL - gs_reveal_double_innerBottom)
			sidelightCutLeft  = 0
			sidelightCutRight = 1
			sidelightCutPosRight = -leftWidth + gs_sidelight_WHole_width_left + bDrawInsideTrim * gs_trim_width_in + gs_reveal_double_innerLeft_sL + thkPlasterAtBoardSlLeft
			gosub "DrawBoard"
			del 1
			boardLeft_sL  = leftWidth + gs_board_ovhg_left - gs_reveal_double_innerLeft_sL - thkPlasterAtBoardSlLeft
			boardRight_sL = -sidelightCutPosRight
		else
			boardLeft_sL  = 0
			boardRight_sL = 0
		endif

		if gs_board_inside_sl_right & gs_sidelight_right & gs_sidelight_parapet_hgt_right > EPS then
			addz gs_sidelight_parapet_hgt_right + (gs_reveal_double_innerBottom_sR - gs_reveal_double_innerBottom)
			sidelightCutLeft  = 1
			sidelightCutRight = 0
			sidelightCutPosLeft = rightWidth - gs_sidelight_WHole_width_right - bDrawInsideTrim * gs_trim_width_in - gs_reveal_double_innerRight_sR - thkPlasterAtBoardSlRight
			gosub "DrawBoard"
			del 1
			boardLeft_sR  = sidelightCutPosLeft
			boardRight_sR = rightWidth  + gs_board_ovhg_right - gs_reveal_double_innerRight_sR - thkPlasterAtBoardSlRight
		else
			boardLeft_sR  = 0
			boardRight_sR = 0
		endif
	else
		sidelightCutLeft  = 0
		sidelightCutRight = 0
		gosub "DrawBoard"

		boardLeft_sL  = 0
		boardRight_sL = 0
		boardLeft_sR  = 0
		boardRight_sR = 0
	endif

! Restore the saved parameter buffer --------------------------------------------

	call "LoadQueue_WMCC" parameters savedQueueValues = savedQueueValues
endif


! ==============================================================================
! returning parameters for cutting the casing
! ==============================================================================

dim boardPoly[]
	boardPoly[1] = 0

! --- cutting shape for casing ----------------------------------------------

if iRevealType = REVEAL_DOUBLE_SPLAYED & gs_reveal_bottom_angle > EPS  then
	boardPoly[1] = WIDO_FRAME_THICKNESS - bBoardNnosUsa - EPS	: boardPoly[2] = -boardElevation - EPS * tan(gs_reveal_bottom_angle)
	boardPoly[3] = WIDO_FRAME_THICKNESS - bBoardNnosUsa - EPS 	: boardPoly[4] = -boardElevation - gs_board_thk/cos(gs_reveal_bottom_angle) - EPS * tan(gs_reveal_bottom_angle)
	boardPoly[5] = WALL_THICKNESS + 1							: boardPoly[6] = -boardElevation - gs_board_thk/cos(gs_reveal_bottom_angle) + (WALL_THICKNESS + 1 - WIDO_FRAME_THICKNESS + bBoardNnosUsa + EPS)*tan(gs_reveal_bottom_angle)
	boardPoly[7] = WALL_THICKNESS + 1							: boardPoly[8] = -boardElevation + (WALL_THICKNESS + 1 - WIDO_FRAME_THICKNESS + bBoardNnosUsa + EPS)*tan(gs_reveal_bottom_angle)
	gs_board_angle = gs_reveal_bottom_angle
	boardSideHeight = boardElevation + gs_board_thk / cos(gs_reveal_bottom_angle)
else
	if abs (gs_board_angle) > EPS then
		boardPoly[1] = WIDO_FRAME_THICKNESS - bBoardNnosUsa - EPS 			: boardPoly[2] = -boardElevation
		boardPoly[3] = WIDO_FRAME_THICKNESS - bBoardNnosUsa - EPS 			: boardPoly[4] = -boardElevation - gs_board_thk
		boardPoly[5] = boardPoly[3] + gs_board_thk / tan (gs_board_angle)	: boardPoly[6] = -boardElevation
	else
		boardPoly[1] = WIDO_FRAME_THICKNESS - bBoardNnosUsa - EPS	: boardPoly[2] = -boardElevation
		boardPoly[3] = WIDO_FRAME_THICKNESS - bBoardNnosUsa - EPS 	: boardPoly[4] = -boardElevation - gs_board_thk
		boardPoly[5] = WALL_THICKNESS + 1							: boardPoly[6] = -boardElevation - gs_board_thk
		boardPoly[7] = WALL_THICKNESS + 1							: boardPoly[8] = -boardElevation
	endif
	boardSideHeight = boardElevation + gs_board_thk
endif

end rightRevealPnts[1][1] + gs_board_ovhg_right,	! boardRight
	leftRevealPnts[1][1]  - gs_board_ovhg_left,		! boardLeft
	boardLeft_sL,
	boardRight_sL,
	boardLeft_sR,
	boardRight_sR,
	boardElevation,									! boardBottom
	boardSideHeight,								! boardSideHeight
	gs_board_angle,									! boardSideAngle
	boardPoly										! boardPoly


! ==============================================================================
! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
! ==============================================================================


! ==============================================================================
! Draw Board
! ==============================================================================

"DrawBoard":
	pen gs_board_pen_3D
	sect_fill gs_board_fill, gs_board_pen_bg, gs_board_pen_fg, gs_board_pen_sectcont

	if iSillType = 1 | not(gs_sill_oversize) then gs_board_slip_in = 0

	if maxBoardAngle > -EPS & gs_board_angle > maxBoardAngle then gs_board_angle = maxBoardAngle
	if gs_board_angle < 0 then gs_board_angle = 0

	addz boardElevation

	if abs(bBoardNnosUsa) > EPS then		! Cut Board with FrameSill
		add 0, leftRevealPnts[idxBoardStartRevealLeft][2] - bBoardNnosUsa, gs_board_thk - gs_rebw_lower
		rotx 90
		roty 90
		cutpoly	4,
			0, 0,
			bBoardNnosUsa, tan(gs_sill_angle) * bBoardNnosUsa,
			bBoardNnosUsa, -0.2,
			0, -0.2
		del 3
	endif

	if iRevealType = REVEAL_DOUBLE_SPLAYED then
		boardAngleTop	 = gs_reveal_bottom_angle
		boardAngleBottom = gs_reveal_bottom_angle
		boardThickness 	 = gs_board_thk / cos(gs_reveal_bottom_angle)
	else
		boardAngleTop	 = gs_board_angle
		boardAngleBottom = 0
		boardThickness	 = gs_board_thk
	endif

	if AC_WallType <> 2 then

		bCurvedAtBoardSide		= (curvedWall & gs_board_curved)
		bCurvedAtWindowFrame	= (curvedWall & gs_IsCurved)

		if not(curvedWall) then

			if sidelightCutLeft then
				py = bpy6 - (bpy6 - bpy7) / (bpx7 - bpx6) * (sidelightCutPosLeft - bpx6)
				put sidelightCutPosLeft,	WIDO_FRAME_THICKNESS,	15, gs_board_mat,
					sidelightCutPosLeft,	py,						15, gs_board_mat
			else
				if thkPlasterAtBoardLeft > EPS then
					startIdx = idxBoardStartPlasterLeft
					endIdx	 = idxBoardEndPlasterLeft
				else
					startIdx = idxBoardStartRevealLeft
					endIdx	 = idxBoardEndRevealLeft
				endif

				if abs(bBoardNnosUsa) > EPS then	! Board Negative Nosing by USA Framesill
					put leftRevealPnts[startIdx][1] + frameWidthLeft,	leftRevealPnts[startIdx][2] - bBoardNnosUsa,	15, gs_board_mat
					put leftRevealPnts[startIdx][1] + frameWidthLeft,	leftRevealPnts[startIdx][2],					15, gs_board_mat
				endif

				for i = startIdx to endIdx
					put leftRevealPnts[i][1], leftRevealPnts[i][2], 8 + 7 * not(gs_stack_left), gs_board_mat	! 15 or 8
				next i

				put	bpx5, bpy5,	 8 + 7 * not(gs_stack_left),							gs_board_mat,	! 15 or 8
					bpx6, bpy6, 13 + 2 * not(gs_stack_left) + bCurvedAtBoardSide * 64,	gs_board_mat	! 15 or 13
			endif

			if sidelightCutRight then
				py = bpy6 - (bpy6 - bpy7) / (bpx7 - bpx6) * (sidelightCutPosRight - bpx6)
				put sidelightCutPosRight,	py,						15, gs_board_mat,
					sidelightCutPosRight,	WIDO_FRAME_THICKNESS,	15, gs_board_mat
			else
				put	bpx7, bpy7,  8 + 7 * not(gs_stack_right),							gs_board_mat,	! 15 or 8
					bpx8, bpy8,  8 + 7 * not(gs_stack_right),							gs_board_mat	! 15 or 8

				if thkPlasterAtBoardRight > EPS then
					startIdx = idxBoardEndPlasterRight
					endIdx	 = idxBoardStartPlasterRight
				else
					startIdx = idxBoardEndRevealRight
					endIdx	 = idxBoardStartRevealRight
				endif

				for i = startIdx to endIdx step -1
					if i = endIdx then
						put rightRevealPnts[i][1], rightRevealPnts[i][2], 13 + 2 * not(gs_stack_right), gs_board_mat	! 15 or 13
					else
						put rightRevealPnts[i][1], rightRevealPnts[i][2],  8 + 7 * not(gs_stack_right), gs_board_mat	! 15 or 8
					endif
				next i

				if abs(bBoardNnosUsa) > EPS then	! Board Negative Nosing by USA Framesill
					put rightRevealPnts[endIdx][1] - frameWidthRight, rightRevealPnts[endIdx][2],					15, gs_board_mat
					put rightRevealPnts[endIdx][1] - frameWidthRight, rightRevealPnts[endIdx][2] - bBoardNnosUsa,	15, gs_board_mat
				endif
			endif
		else
			put 0, WOD, 900, gs_board_mat

			if sidelightCutLeft then
				if bCurvedAtBoardSide then
					py = WOD - iArchSign * sqr((radBoard - iArchSign * gs_board_nosing)^2 - sidelightCutPosLeft^2)
				else
					py = bpy6 - (bpy6 - bpy7) / (bpx7 - bpx6) * (sidelightCutPosLeft - bpx6)
				endif
				put sidelightCutPosLeft,	WIDO_FRAME_THICKNESS,	15,								gs_board_mat,
					sidelightCutPosLeft,	py,						15 + bCurvedAtBoardSide * 64,	gs_board_mat
			else
				if thkPlasterAtBoardLeft > EPS then
					startIdx = idxBoardStartPlasterLeft
					endIdx	 = idxBoardEndPlasterLeft
				else
					startIdx = idxBoardStartRevealLeft
					endIdx	 = idxBoardEndRevealLeft
				endif

				for i = startIdx to endIdx - 1
					put leftRevealPnts[i][1], leftRevealPnts[i][2],	8 + 7 * not(gs_stack_left), gs_board_mat			! 15 or 8
				next i

				if gs_board_ovhg_left > EPS | thkPlasterAtBoardLeft > EPS then
					alfaStart	= -signWallIsLeft * atn(leftRevealPnts[endIdx][1] / (leftRevealPnts[endIdx][2] - WOD))
					alfaEnd		= -signWallIsLeft * atn(bpx5 / (bpy5 - WOD))

					arcRadius	= radBoard
					bMiddlePoints = 1
					firstStatus	= 8 + 7 * not(gs_stack_left) + 64
					lastStatus	= 8 + 7 * not(gs_stack_left) + 64

					if abs(alfaStart - alfaEnd) > EPS then gosub 100
				endif

				put	bpx6, bpy6, 13 + 2 * not(gs_stack_right) + bCurvedAtBoardSide * 64,		gs_board_mat
			endif

			if sidelightCutRight then
				if bCurvedAtBoardSide then
					py = WOD - iArchSign * sqr((radBoard - iArchSign * gs_board_nosing)^2 - sidelightCutPosRight^2)
				else
					py = bpy6 - (bpy6 - bpy7) / (bpx7 - bpx6) * (sidelightCutPosRight - bpx6)
				endif
				put sidelightCutPosRight,	py,						3000 * bCurvedAtBoardSide + 15, gs_board_mat,
					sidelightCutPosRight,	WIDO_FRAME_THICKNESS,	15,								gs_board_mat
			else
				put	bpx7, bpy7, 3000 * bCurvedAtBoardSide + 8 + 7 * not(gs_stack_right),	gs_board_mat	! 15 or 8

				if thkPlasterAtBoardRight > EPS then
					startIdx = idxBoardEndPlasterRight
					endIdx	 = idxBoardStartPlasterRight
				else
					startIdx = idxBoardEndRevealRight
					endIdx	 = idxBoardStartRevealRight
				endif

				if gs_board_ovhg_right > EPS | thkPlasterAtBoardRight > EPS then
					alfaStart	= -signWallIsLeft * atn(bpx8 / (bpy8 - WOD))
					alfaEnd		= -signWallIsLeft * atn(rightRevealPnts[startIdx][1] / (rightRevealPnts[startIdx][2] - WOD))

					arcRadius	= radBoard
					bMiddlePoints = 1
					firstStatus	= 8 + 7 * not(gs_stack_right) + 64
					lastStatus	= 8 + 7 * not(gs_stack_right) + 64

					if abs(alfaStart - alfaEnd) > EPS then gosub 100
				endif

				for i = startIdx - 1 to endIdx step -1
					if i = endIdx then
						put rightRevealPnts[i][1], rightRevealPnts[i][2], 13 + 2 * not(gs_stack_left), gs_board_mat	! 15 or 13
					else
						put rightRevealPnts[i][1], rightRevealPnts[i][2],  8 + 7 * not(gs_stack_right), gs_board_mat	! 15 or 8
					endif
				next i
			endif

			if not(sidelightCutLeft) then
				! Close polygon
				if thkPlasterAtBoardLeft > EPS then
					put leftRevealPnts[idxBoardStartPlasterLeft][1], leftRevealPnts[idxBoardStartPlasterLeft][2], 3000 * (bCurvedAtWindowFrame) + 8 + 7 * not(gs_stack_left), gs_board_mat	! 15 or 8
				else
					put leftRevealPnts[idxBoardStartRevealLeft][1],  leftRevealPnts[idxBoardStartRevealLeft][2],  3000 * (bCurvedAtWindowFrame) + 8 + 7 * not(gs_stack_left), gs_board_mat	! 15 or 8
				endif
			endif
		endif

		sprism_{2} gs_board_mat, gs_board_mat, gs_board_mat,
			nsp/4,
			0,WIDO_FRAME_THICKNESS, 1,WIDO_FRAME_THICKNESS, boardThickness,	boardAngleTop,
			0,WIDO_FRAME_THICKNESS, 1,WIDO_FRAME_THICKNESS, 0,				boardAngleBottom,
			get(nsp)

		if sidelightCutLeft then
			hotspot sidelightCutPosLeft, leftRevealPnts[idxBoardStartRevealLeft][2]  - bBoardNnosUsa, boardThickness, 10061
		else
			hotspot leftRevealPnts[idxBoardStartRevealLeft][1], leftRevealPnts[idxBoardStartRevealLeft][2]  - bBoardNnosUsa, boardThickness, 10002
		endif

		if sidelightCutRight then
			hotspot sidelightCutPosRight, rightRevealPnts[idxBoardStartRevealRight][2] - bBoardNnosUsa, boardThickness, 10060
		else
			hotspot rightRevealPnts[idxBoardStartRevealRight][1], rightRevealPnts[idxBoardStartRevealRight][2] - bBoardNnosUsa, boardThickness, 10003
		endif
	else

		ch = initaddonscope ("PolyOperations", "", "")

! Generate Board Polygon -------------------------------------------------------

		bPolyFor3D = 1
		gosub 2000

! Draw resulting polygons ------------------------------------------------------

		defaultStatusCode = 8
		dim statusCodes[2]
		statusCodes[1] = 15
		statusCodes[2] = 15

		dim resPolyIDArr[]
		numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)

		for i = 1 to numPoly
			polygonID = resPolyIDArr[i]
			gosub 1000	! Get GDL Polygon

			sprism_{2} gs_board_mat, gs_board_mat, gs_board_mat,
				nsp/4,
				0,WIDO_FRAME_THICKNESS, 1,WIDO_FRAME_THICKNESS, boardThickness,	boardAngleTop,
				0,WIDO_FRAME_THICKNESS, 1,WIDO_FRAME_THICKNESS, 0,				boardAngleBottom,
				get(nsp)
		next i

! Close channel ----------------------------------------------------------------

		closeaddonscope ch
	endif

	if abs(bBoardNnosUsa) > EPS then cutend

	del 1

return


! ==============================================================================
! Arch Segmentation
! ------------------------------------------------------------------------------
! Input parameters:
!	alfaStart:		Start angle (angle)
!	alfaEnd:		End angle (angle)
!	arcRadius:		Arc radius (length)
!	bMiddlePoints:	Generate middle points (0 / 1)
!	firstStatus:	Status of the first segment (integer)
!	lastStatus:		Status of the last segment (integer)
! ==============================================================================

100:
	if not(wallIsLeft) then
		alfaStart = 180 - alfaStart
		alfaEnd = 180 - alfaEnd
	endif
	segmentAngle = 360 / WALL_RESOL


	! --- Point at Start Angle ---
	if WIDO_REVEAL_SIDE then
		if SYMB_ROTANGLE < EPS then
			difAngle = (AC_Hole_Position_Angle + alfaStart) mod segmentAngle
		else
			difAngle = -(AC_Hole_Position_Angle - 180 - alfaStart) mod segmentAngle
		endif
	else
		if SYMB_ROTANGLE < EPS then
			difAngle = -(AC_Hole_Position_Angle - alfaStart + 180) mod segmentAngle
		else
			difAngle = (AC_Hole_Position_Angle + alfaStart) mod segmentAngle
		endif
	endif

	difAngle2 = difAngle
	if abs(difAngle) > segmentAngle / 2 then difAngle = -segmentAngle / 2 + abs(difAngle mod (segmentAngle / 2))

	segmentR = arcRadius / cos(difAngle)
	put segmentR * sin(alfaStart), -segmentR * cos(alfaStart) + WOD, firstStatus, gs_board_mat

	if bMiddlePoints then
		! --- Middle Points ---
		segmentR = arcRadius / cos(segmentAngle / 2)

		if alfaStart > alfaEnd then
			alfaActual = alfaStart - difAngle2 + segmentAngle / 2

			if alfaActual > alfaStart then alfaActual = alfaActual - segmentAngle
			if alfaActual > alfaStart then alfaActual = alfaActual - segmentAngle

			if alfaActual < alfaEnd then alfaActual = alfaActual + segmentAngle

			if alfaActual < alfaStart & alfaActual > alfaEnd then
				do
					put segmentR * sin(alfaActual), -segmentR * cos(alfaActual) + WOD, 79, gs_board_mat

					alfaActual = alfaActual - segmentAngle

				while alfaActual > alfaEnd
			endif
		else
			alfaActual = alfaStart - difAngle2 + segmentAngle / 2

			if alfaActual < alfaStart then alfaActual = alfaActual + segmentAngle
			if alfaActual > alfaEnd then alfaActual = alfaActual - segmentAngle

			if alfaActual > alfaStart & alfaActual < alfaEnd then
				do
					put segmentR * sin(alfaActual), -segmentR * cos(alfaActual) + WOD, 79, gs_board_mat

					alfaActual = alfaActual + segmentAngle
				while alfaActual < alfaEnd
			endif
		endif
	endif


	! --- Point at End Angle ---
	if WIDO_REVEAL_SIDE then
		if SYMB_ROTANGLE < EPS then
			difAngle = (AC_Hole_Position_Angle + alfaEnd) mod segmentAngle
		else
			difAngle = -(AC_Hole_Position_Angle + 180 - alfaEnd) mod segmentAngle
		endif
	else
		if SYMB_ROTANGLE < EPS then
			difAngle = -(AC_Hole_Position_Angle - alfaEnd + 180) mod segmentAngle
		else
			difAngle = (AC_Hole_Position_Angle + alfaEnd) mod segmentAngle
		endif
	endif

	if abs(difAngle) > segmentAngle / 2 then difAngle = -segmentAngle / 2 + abs(difAngle mod (segmentAngle / 2))

	segmentR = arcRadius / cos(difAngle)
	put segmentR * sin(alfaEnd), -segmentR * cos(alfaEnd) + WOD, lastStatus, gs_board_mat

return


1000:
! ==============================================================================
! Get GDL Polygon
! ------------------------------------------------------------------------------
! Input variables:
!	ch:					Channel
!	polygonID:			Polygon index
!	defaultStatusCode:	Default status code
!	statusCodes[]:		Status code array
!
! Returned variables:
!	GDL stack:			GDL polygon
! ==============================================================================

	dim resVertices[]
	numVertices = callfunction(ch, "GetVertices", polygonID, resVertices)
	numVertices = numVertices / 3

	dim contArr[]
	numContours = callfunction(ch, "GetContourEnds", polygonID, contArr)

	dim inhEdgeInfos[]
	numEdges = callfunction(ch, "GetInhEdgeInfos", polygonID, inhEdgeInfos)

	for contIndex = 1 to numContours

		if contIndex = 1 then
			begIdx = 0
		else
			begIdx = contArr[contIndex] - 1
		endif
		if contIndex = numContours then
			endIdx = numVertices - 1
		else
			endIdx = contArr[contIndex + 1] - 2
		endif

		bClosed = 0
		bStartWithLast = 0

		index = endIdx * 3
		lastVertX	= resVertices[index + 1]
		lastVertY	= resVertices[index + 2]
		lastVertA	= resVertices[index + 3]
		edgeInfo	= inhEdgeInfos[begIdx + 1]

		if abs(lastVertA) > EPS then
			put lastVertX, lastVertY, 1, gs_board_mat
			bStartWithLast = 1
		endif

		for vertIndex = begIdx to endIdx
			index = vertIndex * 3
			actVertX = resVertices[index + 1]
			actVertY = resVertices[index + 2]
			actVertA = resVertices[index + 3]

			if edgeInfo > 0 & edgeInfo <= vardim1(statusCodes) then
				statusCode = statusCodes[edgeInfo]
			else
				statusCode = defaultStatusCode
			endif

			if vertIndex = begIdx then
				if bStartWithLast then
					ac2gdl_spx = lastVertX
					ac2gdl_spy = lastVertY
				else
					ac2gdl_spx = actVertX
					ac2gdl_spy = actVertY
				endif
			endif

			if abs(lastVertA) > EPS then
				ac2gdl_mx = (actVertX + lastVertX) / 2
				ac2gdl_my = (actVertY + lastVertY) / 2
				ac2gdl_ratio = 1 / 2 / tan (lastVertA / 2)

				ac2gdl_cx = ac2gdl_mx - ac2gdl_ratio * (actVertY - lastVertY)	! Arc center
				ac2gdl_cy = ac2gdl_my + ac2gdl_ratio * (actVertX - lastVertX)

				put ac2gdl_cx,	ac2gdl_cy,	900,					gs_board_mat,
					0,			lastVertA,	4000 + statusCode + 64,	gs_board_mat
			endif

			if vertIndex > begIdx & abs(ac2gdl_spx - actVertX) < EPS & abs(ac2gdl_spy - actVertY) < EPS then
!!!				put actVertX, actVertY, -1, gs_board_mat	! Board polygon never contains holes
				bClosed = 1
			else
				if vertIndex < endIdx | not(bStartWithLast) then
					put actVertX, actVertY, statusCode, gs_board_mat
				endif
			endif

			lastVertX	= actVertX
			lastVertY	= actVertY
			lastVertA	= actVertA
			edgeInfo	= inhEdgeInfos[vertIndex + 2]
		next vertIndex

		if not(bClosed) & numContours > 1 then	! Close the polygon if it has holes
			put ac2gdl_spx, ac2gdl_spy, -1, gs_board_mat
		endif

	next contIndex
return


]]></Script_3D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_2D SectVersion="20" SectionFlags="0" SubIdent="0"><![CDATA[

! Contact person: <NJ>

! ==============================================================================
! This macro draws the Board
! ------------------------------------------------------------------------------
! Input parameters:
! Geometry ---------------------------------------------------------------------
!	A:						wallhole width (length) (Obsolete)
!	refWidth:				reference width in curved walls (length)
!	leftWidth:				wallhole's side distance from the origin at the left side (length)
!	rightWidth:				wallhole's side distance from the origin at the right side (length)
! Functions --------------------------------------------------------------------
!	gs_IsCurved:			Does the window follow the curvature of the wall? (0 / 1)
!	bParalellInCurvedWalls:	is the wallhole parallel in curved walls (0 / 1)
! Reveal -----------------------------------------------------------------------
!	iRevealType:
!	gs_reveal_left_angle:
!	gs_reveal_right_angle:
! Corner Function --------------------------------------------------------------
!	bLeftCornerFunction:		Turn macro in Corner Window mode at the left side (0 / 1)
!	leftCornerAngle:		Angle between connected walls in case of Corner Window (angle)
!	leftConnWallThk:		Thickness of the connected wall in case of Corner Window (length)
!	bRightCornerFunction:	Turn macro in Corner Window mode at the right side (0 / 1)
!	rightCornerAngle:		Angle between connected walls in case of Corner Window (angle)
!	rightConnWallThk:		Thickness of the connected wall in case of Corner Window (length)
! Oversize ---------------------------------------------------------------------
!	gs_left_oversize:		Left opening oversize (length)
!	gs_right_oversize:		Right opening oversize (length)
! Board ------------------------------------------------------------------------
!	gs_board_width:			Width of the Board. (length)
!	gs_board_nosing:		Nosing of the Board. (length)
!	gs_board_ovhg_left:		Board overhang on the left side. (length)
!	gs_board_ovhg_right:	Board overhang on the right side. (length)
!	gs_board_curved:		Board edge is curved or straight. (0 / 1)
!	bShowBoardSplice:		Show or hide the Board's joint line in case of Corner Window  (0 / 1)
!	bWindowSymbolAtMiddle:	Is the window symbol appears always on the middle of the wall (CHI special) (0 / 1)
! 2D Representation ------------------------------------------------------------
!	lod2D_sillBoard:		Level of detail. (integer, 0..1)
!	gs_pen_2D:				Contour pen of the Trim, Sill and Board. (pen)
!	gs_bFills:				Use fills (boolean)
!	gs_board_wallhole_fill:			Type of the fill on the Board. (fill type)
!	gs_board_wallhole_pen_fg:		Fill pen on the Board. (pen)
!	gs_board_wallhole_pen_bg:		Fill background pen on the Board. (pen)
!	gs_board_wallhole_fill_sl:		Type of the fill on the Board, at the sidelights. (fill type)
!	gs_board_wallhole_pen_sl_fg:	Fill pen on the Board, at the sidelights. (pen)
!	gs_board_wallhole_pen_sl_bg:	Fill background pen on the Board, at the sidelights. (pen)
! Ganging ----------------------------------------------------------------------
!	gs_stack_left:			Align to door/window on left side (0 / 1)
!	gs_stack_right:			Align to door/window on right side (0 / 1)
!	gs_stack_bottom:		Align to door/window on bottom side (0 / 1)
! Wall Inset -----------------------------------------------------------
!	gs_parapet_wall_inset:	Switch on / off the Wall Inset function. (0 / 1)
!	gs_parapet_inset_thk:	Depth of Wall Inset. (length)
!
! Related Global Variables:
!	GLOB_SCRIPT_TYPE
!	GLOB_CONTEXT
!	WALL_THICKNESS
!	WALL_INCL
!	WALL_SECT_PEN
!	WIDO_FRAME_THICKNESS
!	WIDO_SILL
!	WIDO_LEFT_JAMB
!	WIDO_RIGHT_JAMB
!	WIDO_ORIG_DIST
!	WIDO_REVEAL_SIDE
!	SYMB_MIRRORED
!	SYMB_ROTANGLE
!
! Hotspot IDs:
!	10002:		Board left
!	10003:		Board right
! ==============================================================================

LINE_ATTRIBUTES_GDLLINE		= 0			! Draw GDL Line in the section
LINE_ATTRIBUTES_WALLLINE	= 1			! Draw WallLine in the section
LINE_ATTRIBUTES_WALLSIDE	= 2			! The section is on the wall side (it is an arc in curved wall)
LINE_ATTRIBUTES_DRAWCC		= 3			! The section is drawn by CavityClosure macro (otherwise the WallHoleCut macro)
LINE_ATTRIBUTES_CONTOUR		= 4			! The section is contour or inner line
!!!	LINE_ATTRIBUTES_WALLEDGE	= 0			! The section is on the wall edge (always a line)

! Line Property defines:
LINE_PROPERTY_GENERIC	= 0
LINE_PROPERTY_INNER		= 1
LINE_PROPERTY_CONTOUR	= 2


! Draw Board -------------------------------------------------------------------

if lod2D_sillBoard > 0 & bDrawBoard & not(gs_stack_bottom) then

! Save the current parameter buffer --------------------------------------------

	dim savedQueueValues[]
	call "SaveQueue_WMCC" parameters returned_parameters savedQueueValues

	if gs_board_pen_2D < 1 then gs_board_pen_2D = gs_pen_2D		! Compatibility

	if WIDO_REVEAL_SIDE then
		add2 0,-WIDO_FRAME_THICKNESS
	else
		mul2 1,-1
	endif

	if gs_stack_left then
		gs_board_ovhg_left = gs_left_oversize
		overSizeLeft = gs_left_oversize
		widoLeftJamb = 0
	endif

	if gs_stack_right then
		gs_board_ovhg_right = gs_right_oversize
		overSizeRight = gs_right_oversize
		widoRightJamb = 0
	endif

! Draw Board -------------------------------------------------------------------

	if bTShapedOpening then
		gs_wallhole_fill	= gs_board_wallhole_fill_sl
		gs_wallhole_pen_fg	= gs_board_wallhole_pen_sl_fg
		gs_wallhole_pen_bg	= gs_board_wallhole_pen_sl_bg

		if gs_board_inside_sl_left & gs_sidelight_left & gs_sidelight_parapet_hgt_left > EPS then
			sidelightCutLeft  = 0
			sidelightCutRight = 1
			sidelightCutPosRight = -leftWidth + gs_sidelight_WHole_width_left + bDrawInsideTrim * gs_trim_width_in + gs_reveal_double_innerLeft_sL + thkPlasterAtBoardLeft
			gosub "DrawBoard"
		endif

		if gs_board_inside_sl_right & gs_sidelight_right & gs_sidelight_parapet_hgt_right > EPS then
			sidelightCutLeft  = 1
			sidelightCutRight = 0
			sidelightCutPosLeft = rightWidth - gs_sidelight_WHole_width_right - bDrawInsideTrim * gs_trim_width_in - gs_reveal_double_innerRight_sR - thkPlasterAtBoardRight
			gosub "DrawBoard"
		endif
	else
		gs_wallhole_fill	= gs_board_wallhole_fill
		gs_wallhole_pen_fg	= gs_board_wallhole_pen_fg
		gs_wallhole_pen_bg	= gs_board_wallhole_pen_bg

		sidelightCutLeft  = 0
		sidelightCutRight = 0
		gosub "DrawBoard"
	endif

! Restore the saved parameter buffer --------------------------------------------

	call "LoadQueue_WMCC" parameters savedQueueValues = savedQueueValues
endif


! ==============================================================================
end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
! ==============================================================================


! ==============================================================================
!	Draw Board
! ==============================================================================

"DrawBoard":
	set fill gs_wallhole_fill
	line_property 0
	line_type 1
	pen gs_board_pen_2D

	if AC_WallType <> 2 then

		bCurvedAtBoardSide		= (curvedWall & gs_board_curved)
		bCurvedAtWindowFrame	= (curvedWall & gs_IsCurved)

		if curvedWall then put 0,WOD,900

		if sidelightCutLeft then
			if bCurvedAtBoardSide then
				py = WOD - iArchSign * sqr((radBoard - iArchSign * gs_board_nosing)^2 - sidelightCutPosLeft^2)
			else
				py = bpy6 - (bpy6 - bpy7) / (bpx7 - bpx6) * (sidelightCutPosLeft - bpx6)
			endif
			put sidelightCutPosLeft,	WIDO_FRAME_THICKNESS,	1,
				sidelightCutPosLeft,	py,						1
		else
			if abs(bBoardNnosUsa) > EPS then	! Board Negative Nosing by USA Framesill
				put leftRevealPnts[idxBoardStartRevealLeft][1] + frameWidthLeft,	leftRevealPnts[idxBoardStartRevealLeft][2] - bBoardNnosUsa,	0
				put leftRevealPnts[idxBoardStartRevealLeft][1] + frameWidthLeft,	leftRevealPnts[idxBoardStartRevealLeft][2],					0
			endif

			for i=idxBoardStartPlasterLeft to idxBoardEndPlasterLeft
				put leftRevealPnts[i][1],	leftRevealPnts[i][2],	0
			next i

			put	bpx5,	bpy5,	3000 * curvedWall + (not(gs_stack_left) & not(bLeftCornerFunction)),
				bpx6,	bpy6,	1
		endif

		if sidelightCutRight then
			if bCurvedAtBoardSide then
				py = WOD - iArchSign * sqr((radBoard - iArchSign * gs_board_nosing)^2 - sidelightCutPosRight^2)
			else
				py = bpy6 - (bpy6 - bpy7) / (bpx7 - bpx6) * (sidelightCutPosRight - bpx6)
			endif
			put sidelightCutPosRight,	py,						3000 * bCurvedAtBoardSide + 1,
				sidelightCutPosRight,	WIDO_FRAME_THICKNESS,	0
		else
			put	bpx7,	bpy7,	3000 * bCurvedAtBoardSide + (not(gs_stack_right) & not(bRightCornerFunction)),
				bpx8,	bpy8,	0

			for i=idxBoardEndPlasterRight to idxBoardStartPlasterLeft step -1
				put rightRevealPnts[i][1],	rightRevealPnts[i][2]
				if i = idxBoardEndPlasterRight then
					put 3000 * curvedWall
				else
					put 0
				endif
			next i

			if abs(bBoardNnosUsa) > EPS then	! Board Negative Nosing by USA Framesill
				put rightRevealPnts[idxBoardStartRevealRight][1] - frameWidthRight,	rightRevealPnts[idxBoardStartRevealRight][2],				0
				put rightRevealPnts[idxBoardStartRevealRight][1] - frameWidthRight,	rightRevealPnts[idxBoardStartRevealRight][2] - bBoardNnosUsa,	0
			endif

			! Close polygon
			if curvedWall & bCurvedAtWindowFrame then
				put	leftRevealPnts[idxBoardStartPlasterLeft][1],	leftRevealPnts[idxBoardStartPlasterLeft][2],	3000
			endif
		endif

		penFillFg	= gs_wallhole_pen_fg
		penFillBg	= gs_wallhole_pen_bg
		gosub 300	! Draw wallhole fill

		if bShowAddHotspots then
			if sidelightCutLeft then
				hotspot2 sidelightCutPosLeft, bpy6, 10061
			else
				hotspot2 bpx6, bpy6, 10002
			endif

			if sidelightCutRight then
				hotspot2 sidelightCutPosRight, bpy6, 10060
			else
				hotspot2 bpx7, bpy7, 10003
			endif
		endif
	else
		ch = initaddonscope ("PolyOperations", "", "")

! Generate Board Polygon -------------------------------------------------------

		bPolyFor3D = 0
		gosub 2000

! Draw resulting polygons ------------------------------------------------------

		dim resPolyIDArr[]
		numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)

		for i = 1 to numPoly
			polygonID = resPolyIDArr[i]
			gosub 1000	! Get GDL Polygon

			fill gs_wallhole_fill
			poly2_b nsp/3, 2+4+64, gs_wallhole_pen_fg, gs_wallhole_pen_bg,
				get(nsp)
		next i

! Draw wall contour lines ------------------------------------------------------

		dim lineAttributes[2][4]
		lineAttributes[1][1] = WALL_SECT_PEN
		lineAttributes[1][2] = WALL_LINETYPE
		lineAttributes[1][3] = LINE_PROPERTY_CONTOUR
		lineAttributes[1][4] = bitset(0, LINE_ATTRIBUTES_WALLLINE)

		lineAttributes[2][1] = gs_board_pen_2D
		lineAttributes[2][2] = 1
		lineAttributes[2][3] = LINE_PROPERTY_GENERIC
		lineAttributes[2][4] = bitset(0, LINE_ATTRIBUTES_GDLLINE)

		bPutHotsopts	= 0

		for i = 1 to numPoly
			polygonID = resPolyIDArr[i]
			gosub 1001	! Draw one polygon contour line
		next i

! Show Hotspots ----------------------------------------------------------------

		if boardNosing > EPS & bShowAddHotspots then

			if sidelightCutLeft then
				hotspot2 sidelightCutPosLeft, hotspotLeftY, 10061
			else
				if not(gs_stack_left) & hotspotLeftX < -EPS then
					hotspot2 hotspotLeftX, hotspotLeftY, 10002	! Left
				endif
			endif
			if sidelightCutRight then
				hotspot2 sidelightCutPosRight, hotspotRightY, 10060
			else
				if not(gs_stack_right) & hotspotRightX > EPS then
					hotspot2 hotspotRightX, hotspotRightY, 10003	! Right
				endif
			endif
		endif

! Close channel ----------------------------------------------------------------

		closeaddonscope ch
	endif

return



! ==============================================================================
! Direction Angle
! ------------------------------------------------------------------------------
! Input variables:
!	vx, vy:				vector
!
! Returned variables:
!	alpha:				selected intersection point
! ==============================================================================

103:

if abs(vx) < EPS & abs(vy) < EPS then
	angle = 0
	return
endif

if abs(vx) < EPS then
	if vy > 0 then
		angle = 90
	else
		angle = 270
	endif
else
	angle = atn(vy / vx)
	if vx >= 0 then
		if angle < 0 then
			angle = angle + 360
		endif
	else
		angle = 180 + angle
	endif
endif

return

! ==============================================================================
! Draw wallblock with contour
! ------------------------------------------------------------------------------
! Input variables:
!	stack:				wallblock polygon
!	penFillFg			fill foreground pen (pen index)
!	penFillBg			fill background pen (pen index)
! ==============================================================================

300:
	if nsp >= 9 then
		if gs_bFills then
			poly2_b nsp/3, 2+4+64, penFillFg, penFillBg,
				use(nsp)
		endif
	else
		for ii=1 to nsp
			n = get(1)
		next ii
		return
	endif

	bHaveFirst = 0
	numPoints = nsp/3

	for ii=1 to numPoints
		if ii = 1 | not(bHaveFirst) then
			x1 = get(1)
			y1 = get(1)
			s1 = get(1)
			firstX = x1
			firstY = y1
			firstS = s1
			if s1 < 100 then bHaveFirst = 1
		endif
		if ii = numPoints then
			x2 = firstX
			y2 = firstY
			s2 = firstS
		else
			if bHaveFirst then
				x2 = get(1)
				y2 = get(1)
				s2 = get(1)
			endif
		endif

		if bHaveFirst then
			if bittest(s1, 0) & (s1 >= 1000 | s1 < 100) then
				if s2 >= 3000 then
					R = sqr(x2^2 + (y2 - WOD)^2)

					vx = x1
					vy = y1 - WOD
					gosub 103	! Direction Angle
					alpha = angle

					vx = x2
					vy = y2 - WOD
					gosub 103	! Direction Angle
					beta = angle

					if abs(alpha - beta) > EPS then
						arc2 0,WOD, R, min(alpha,beta), max(alpha,beta)
					endif
				else
					if s2 < 100 then
						line2 x1,y1, x2,y2
					endif
				endif
			endif

			if s2 >= 1000 | s2 < 100 then
				x1 = x2
				y1 = y2
				s1 = s2
			endif
		endif
	next ii
return


1000:
! ==============================================================================
! Get GDL Polygon
! ------------------------------------------------------------------------------
! Input variables:
!	ch:						Channel
!	polygonID:			Polygon index
!
! Returned variables:
!	GDL stack:			GDL polygon
! ==============================================================================

	dim resVertices[]
	numVertices = callfunction(ch, "GetVertices", polygonID, resVertices)
	numVertices = numVertices / 3

	dim contArr[]
	numContours = callfunction(ch, "GetContourEnds", polygonID, contArr)

	for contIndex = 1 to numContours

		if contIndex = 1 then
			begIdx = 0
		else
			begIdx = contArr[contIndex] - 1
		endif
		if contIndex = numContours then
			endIdx = numVertices - 1
		else
			endIdx = contArr[contIndex + 1] - 2
		endif

		bClosed = 0
		bStartWithLast = 0

		index = endIdx * 3
		ac2gdl_lpx = resVertices[index + 1]
		ac2gdl_lpy = resVertices[index + 2]
		ac2gdl_lpa = resVertices[index + 3]

		if abs(ac2gdl_lpa) > EPS then
			put ac2gdl_lpx, ac2gdl_lpy, 1
			bStartWithLast = 1
		endif

		for vertIndex = begIdx to endIdx
			index = vertIndex * 3
			ac2gdl_px = resVertices[index + 1]
			ac2gdl_py = resVertices[index + 2]
			ac2gdl_pa = resVertices[index + 3]

			if vertIndex = begIdx then
				if bStartWithLast then
					ac2gdl_spx = ac2gdl_lpx
					ac2gdl_spy = ac2gdl_lpy
				else
					ac2gdl_spx = ac2gdl_px
					ac2gdl_spy = ac2gdl_py
				endif
			endif

			if abs(ac2gdl_lpa) > EPS then
				ac2gdl_mx = (ac2gdl_px + ac2gdl_lpx) / 2
				ac2gdl_my = (ac2gdl_py + ac2gdl_lpy) / 2
				ac2gdl_ratio = 1 / 2 / tan (ac2gdl_lpa / 2)

				ac2gdl_cx = ac2gdl_mx - ac2gdl_ratio * (ac2gdl_py - ac2gdl_lpy)	! Arc center
				ac2gdl_cy = ac2gdl_my + ac2gdl_ratio * (ac2gdl_px - ac2gdl_lpx)

				put ac2gdl_cx,	ac2gdl_cy,	900,
					0,			ac2gdl_lpa,	4001
			endif

			if vertIndex > begIdx & abs(ac2gdl_spx - ac2gdl_px) < EPS & abs(ac2gdl_spy - ac2gdl_py) < EPS then
!!!				put ac2gdl_px, ac2gdl_py, -1	! Board polygon never contains holes
				bClosed = 1
			else
				if vertIndex < endIdx | not(bStartWithLast) then
					put ac2gdl_px, ac2gdl_py, 1
				endif
			endif

			ac2gdl_lpx = ac2gdl_px
			ac2gdl_lpy = ac2gdl_py
			ac2gdl_lpa = ac2gdl_pa
		next vertIndex

		if not(bClosed) & numContours > 1 then	! Close the polygon if it has holes
			put ac2gdl_spx, ac2gdl_spy, -1
		endif

	next contIndex
return


1001:
! ==============================================================================
! Draw one polygon contour line
! ------------------------------------------------------------------------------
! Input variables:
!	ch:						Channel
!	polygonID:				Polygon ID
!	lineAttributes[][3]:	Line attribute array
!								[][1] = pen color
!								[][2] = line type
!								[][3] = line property
!								[][4] = additional line attributes
! ==============================================================================

	dim resVertices[]
	numVertices = callfunction(ch, "GetVertices", polygonID, resVertices)
	numVertices = numVertices / 3

	dim contArr[]
	numContours = callfunction(ch, "GetContourEnds", polygonID, contArr)

	dim inhEdgeInfos[]
	numEdges = callfunction(ch, "GetInhEdgeInfos", polygonID, inhEdgeInfos)

	for contIndex = 1 to numContours

		if contIndex = 1 then
			begIdx = 0
		else
			begIdx = contArr[contIndex] - 1
		endif
		if contIndex = numContours then
			endIdx = numVertices - 1
		else
			endIdx = contArr[contIndex + 1] - 2
		endif

		bClosed = 0
		bStartWithLast = 0

		index = endIdx * 3
		lastVertX	= resVertices[index + 1]
		lastVertY	= resVertices[index + 2]
		lastVertA	= resVertices[index + 3]
		edgeInfo	= inhEdgeInfos[endIdx + 1]

		for vertIndex = begIdx to endIdx

			index = vertIndex * 3
			actVertX = resVertices[index + 1]
			actVertY = resVertices[index + 2]
			actVertA = resVertices[index + 3]

!!text2	(lastVertX + actVertX) / 2,
!!		(lastVertY + actVertY) / 2,
!!		edgeInfo

!!!ccc=ccc+0.1
!!!circle2 lastVertX, lastVertY, ccc
!!!circle2 actVertX, actVertY, ccc

			if edgeInfo > 0 & edgeInfo <= vardim1(lineAttributes) then

				if lineAttributes[edgeInfo][1] > 0 then
					pen				lineAttributes[edgeInfo][1]
					line_type		lineAttributes[edgeInfo][2]

					line_property	lineAttributes[edgeInfo][3]
					iAttributes = round_int(lineAttributes[edgeInfo][4])

					if abs(lastVertA) > EPS then
						ac2gdl_mx = (actVertX + lastVertX) / 2
						ac2gdl_my = (actVertY + lastVertY) / 2
						ac2gdl_ratio = 1 / 2 / tan (lastVertA / 2)

						ac2gdl_cx = ac2gdl_mx - ac2gdl_ratio * (actVertY - lastVertY)	! Arc center
						ac2gdl_cy = ac2gdl_my + ac2gdl_ratio * (actVertX - lastVertX)
						ac2gdl_rad = sqr((ac2gdl_cx - actVertX)^2 + (ac2gdl_cy - actVertY)^2)

						vx = actVertX - ac2gdl_cx
						vy = actVertY - ac2gdl_cy
						gosub 103	! Direction Angle
						alpha = angle

						vx = lastVertX - ac2gdl_cx
						vy = lastVertY - ac2gdl_cy
						gosub 103	! Direction Angle
						beta = angle

						if abs(alpha - beta) > EPS then
							if abs(alpha - beta) > 180 + EPS then
								angleStart	= max(alpha,beta)
								angleEnd	= min(alpha,beta)
							else
								angleStart	= min(alpha,beta)
								angleEnd	= max(alpha,beta)
							endif
							if bittest(iAttributes, LINE_ATTRIBUTES_GDLLINE) then
								arc2 ac2gdl_cx,	ac2gdl_cy, ac2gdl_rad, angleStart, angleEnd
							endif
							if bittest(iAttributes, LINE_ATTRIBUTES_WALLLINE) then
								wallarc2 ac2gdl_cx,	ac2gdl_cy, ac2gdl_rad, angleStart, angleEnd
							endif
						endif
					else
						if bittest(iAttributes, LINE_ATTRIBUTES_GDLLINE) then
							line2 lastVertX, lastVertY, actVertX, actVertY
						endif
						if bittest(iAttributes, LINE_ATTRIBUTES_WALLLINE) then
							wallline2 lastVertX, lastVertY, actVertX, actVertY
						endif
					endif
				endif
			endif

			lastVertX	= actVertX
			lastVertY	= actVertY
			lastVertA	= actVertA
			edgeInfo	= inhEdgeInfos[vertIndex + 1]

		next vertIndex
	next contIndex
return




]]></Script_2D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_1D SectVersion="20" SectionFlags="0" SubIdent="0"><![CDATA[

! const values for parameter: iBoardInPolyWall
BOARD_PARALLEL_WINDOW      = 1
BOARD_PARALLEL_WALLPOLYGON = 2

EPS = 0.0001

! iRevealType:
REVEAL_EDGE				= 0
REVEAL_NO				= 1
REVEAL_POSITIVE			= 2
REVEAL_NEGATIVE			= 3
REVEAL_SLANTED			= 4
REVEAL_SPLAYED			= 5
REVEAL_HISTORIC			= 6
REVEAL_DOUBLE			= 7
REVEAL_DOUBLE_SPLAYED	= 8
REVEAL_OUTSIDE_SPLAYED	= 9

! iWindowShape:
SHAPE_RECTANGULAR			= 0
SHAPE_ARCHED				= 1
SHAPE_ROUND					= 2
SHAPE_EYEBROWS				= 3
SHAPE_HALFCIRCLE			= 4 	! straight side is horizontal
SHAPE_MULTISIDE				= 5
SHAPE_OCTAGONAL				= 6
SHAPE_HALFARCH				= 7
SHAPE_PENTAGON				= 8
SHAPE_QUARTERROUND			= 9
SHAPE_HALFROUND				= 10 	! straight side is vertical
SHAPE_TRAPEZOID				= 11
SHAPE_TRIANGLE				= 12
SHAPE_GOTHICARCH			= 13
SHAPE_ELLIPSEARCH			= 14
SHAPE_ROMBUS				= 15
SHAPE_HORSESHOE				= 16
SHAPE_OGEECENTERED			= 17
SHAPE_SARACENIC				= 18
SHAPE_T						= 19
SHAPE_HALF_T_LEFT			= 20
SHAPE_ARCHED_T				= 21
SHAPE_ARCHED_HALF_T_LEFT	= 22
SHAPE_PARALLELOGRAM			= 23
SHAPE_ELLIPSE				= 24
SHAPE_CORNER_TRIANGLE		= 25
SHAPE_QUARTERROUND_NOFRAME	= 26
SHAPE_HALF_T_RIGHT			= 27
SHAPE_ARCHED_HALF_T_RIGHT	= 28

! const values for parameter: iBoardInPolyWall
BOARD_PARALLEL_WINDOW      = 1
BOARD_PARALLEL_WALLPOLYGON = 2

! ==============================================================================

bTShapedOpening =  (iWindowShape = SHAPE_T |\
					iWindowShape = SHAPE_HALF_T_LEFT |\
					iWindowShape = SHAPE_HALF_T_RIGHT |\
					iWindowShape = SHAPE_ARCHED_T |\
					iWindowShape = SHAPE_ARCHED_HALF_T_LEFT |\
					iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT)

bInclinedWall	= (abs(WALL_INCL) > EPS)
curvedWall		= (abs(WIDO_ORIG_DIST) > EPS)
wallIsLeft		= (SYMB_ROTANGLE > EPS) exor WIDO_REVEAL_SIDE
signWallIsLeft	= wallIsleft - not(wallIsleft)

if bDoorWithSidelightSupport then
	bHasAnyBoardOn = (	(gs_sidelight_left  & gs_sidelight_parapet_hgt_left > EPS  & gs_board_inside_sl_left) | \
						(gs_sidelight_right & gs_sidelight_parapet_hgt_right > EPS & gs_board_inside_sl_right))
else
	bHasAnyBoardOn = (gs_board_inside)
endif


! ==============================================================================

if SYMB_MIRRORED exor (SYMB_ROTANGLE > EPS) then
	widoRightJamb	= WIDO_LEFT_JAMB
	widoLeftJamb	= WIDO_RIGHT_JAMB
else
	widoRightJamb	= WIDO_RIGHT_JAMB
	widoLeftJamb	= WIDO_LEFT_JAMB
endif


! ==============================================================================
! Restrictions for Window Shapes
! ==============================================================================

if iWindowShape = 1 then
	! --- Arched Window Shape ---

	widoLeftJamb	= widoRightJamb
endif


! ==============================================================================
! Calculations for Corner Window
! ==============================================================================

if bRightCornerFunction & abs(rightCornerAngle) > EPS then
	rx = 1 / tan(rightCornerAngle / 2)

	if rightCornerAngle > 180 then
		rightCwDx = WIDO_FRAME_THICKNESS / tan(-rightCornerAngle / 2)
	else
		rightCwDx = 0
	endif

	rightCwDx2 = 0
	if abs(WALL_THICKNESS - rightConnWallThk) > EPS then
		rightCwDx2 = (WALL_THICKNESS - rightConnWallThk) / cos(rightCornerAngle - 90)
	endif
	bFitMode = (rightConnWallThk > WALL_THICKNESS + EPS)

	gs_right_oversize = 0
endif

if bLeftCornerFunction & abs(leftCornerAngle) > EPS then
	lx = 1 / tan(leftCornerAngle / 2)

	if leftCornerAngle > 180 then
		leftCwDx = WIDO_FRAME_THICKNESS / tan(-leftCornerAngle / 2)
	else
		leftCwDx = 0
	endif

	leftCwDx2 = 0
	if abs(WALL_THICKNESS - leftConnWallThk) > EPS then
		leftCwDx2 = (WALL_THICKNESS - leftConnWallThk) / cos(leftCornerAngle - 90)
	endif
	bFitMode = (leftConnWallThk > WALL_THICKNESS + EPS)

	gs_left_oversize = 0
endif


! ==============================================================================
! Calculations for Inclined Walls
! ==============================================================================

if bInclinedWall then
	bFactor = SYMB_MIRRORED exor WIDO_REVEAL_SIDE exor wallIsLeft
	incFactor = not(bFactor) - bFactor
	incX = incFactor * tan(WALL_INCL)
	incY = incFactor * (1 / cos(WALL_INCL))

	bDir = SYMB_MIRRORED exor (SYMB_ROTANGLE > EPS)
	iDir = not(bDir) - bDir
	incH = cos(WALL_INCL)
	incV = sin(WALL_INCL) * iDir
else
	incX = 0
	incY = 1
	incH = 0
	incV = 0
endif


! ==============================================================================
! Calculations for Stack Window
! ==============================================================================

if gs_stack_left then
	gs_board_ovhg_left	= gs_left_oversize
	overSizeLeft		= gs_left_oversize
	overSizeLeftOut		= gs_left_oversize
	widoLeftJamb		= 0
else
	overSizeLeft		= 0
	overSizeLeftOut		= -widoLeftJamb
endif

if gs_stack_right then
	gs_board_ovhg_right	= gs_right_oversize
	overSizeRight		= gs_right_oversize
	overSizeRightOut	= gs_right_oversize
	widoRightJamb		= 0
else
	overSizeRight		= 0
	overSizeRightOut	= -widoRightJamb
endif


! ==============================================================================
! Calculations for Wall Inset
! ==============================================================================

parapetInset = gs_parapet_wall_inset * gs_parapet_inset_thk


! ==============================================================================
! Board Nosing
! ==============================================================================

boardNosing = gs_board_nosing


! ==============================================================================
! Reveal Points Indexes
! ==============================================================================

idxFrameStartRevealLeft		= iRevealPointsIdx[3]
idxFrameEndRevealLeft		= iRevealPointsIdx[4]
idxBoardStartRevealLeft		= iRevealPointsIdx[5]
idxBoardEndRevealLeft		= iRevealPointsIdx[6]
idxBoardStartPlasterLeft	= iRevealPointsIdx[9]
idxBoardEndPlasterLeft		= iRevealPointsIdx[10]
idxFrameStartRevealRight	= iRevealPointsIdx[13]
idxFrameEndRevealRight		= iRevealPointsIdx[14]
idxBoardStartRevealRight	= iRevealPointsIdx[15]
idxBoardEndRevealRight		= iRevealPointsIdx[16]
idxBoardStartPlasterRight	= iRevealPointsIdx[19]
idxBoardEndPlasterRight		= iRevealPointsIdx[20]


! ==============================================================================
! Calculations for Straight Walls
! ==============================================================================

maxBoardAngle = 0

casingOffsetLeft = 0
casingOffsetRight = 0

if gs_trim_show_cover_in & GLOB_SCRIPT_TYPE = 2 then
	casingOffsetLeft	= (bDrawInsideTrim * not(gs_trim_atframe_in) * gs_trim_thk_in * (gs_board_ovhg_left  < CasingInsLeftOutPoint))
	casingOffsetRight	= (bDrawInsideTrim * not(gs_trim_atframe_in) * gs_trim_thk_in * (gs_board_ovhg_right < CasingInsRightOutPoint))
endif

if not(curvedWall) then

	if GLOB_SCRIPT_TYPE = 2 | GLOB_SCRIPT_TYPE = 3 then
		if vardim1(leftRevealPnts) >= idxBoardEndRevealLeft then
			if bLeftCornerFunction then
				bpx5 = leftRevealPnts[idxBoardEndRevealLeft][1]
				bpy5 = leftRevealPnts[idxBoardEndRevealLeft][2]

				bpx6 = bpx5 + boardNosing * lx
				bpy6 = bpy5 + boardNosing
			else
				if bInclinedWall then
					if gs_stack_left then
						bpx5 = leftRevealPnts[idxBoardEndRevealLeft][1]
						bpy5 = leftRevealPnts[idxBoardEndRevealLeft][2]

						bpx6 = bpx5
						bpy6 = bpy5 + boardNosing / incH
					else
						bpx5 = leftRevealPnts[idxBoardEndRevealLeft][1] - gs_board_ovhg_left * incH
						bpy5 = leftRevealPnts[idxBoardEndRevealLeft][2] - gs_board_ovhg_left * incV

						bpx6 = bpx5 - boardNosing * incV
						bpy6 = bpy5 + boardNosing * incH

						bpx5 = bpx5 - casingOffsetLeft * incV
						bpy5 = bpy5 + casingOffsetLeft * incH
					endif
				else
					bpx5 = leftRevealPnts[idxBoardEndRevealLeft][1] - not(gs_stack_left) * gs_board_ovhg_left
					bpy5 = leftRevealPnts[idxBoardEndRevealLeft][2] + casingOffsetLeft

					bpx6 = bpx5
					bpy6 = bpy5 + boardNosing - casingOffsetLeft
				endif
			endif
		endif

		if vardim1(rightRevealPnts) >= idxBoardEndRevealRight then
			if bRightCornerFunction then
				bpx8 = rightRevealPnts[idxBoardEndRevealRight][1]
				bpy8 = rightRevealPnts[idxBoardEndRevealRight][2]

				bpx7 = bpx8 - boardNosing * rx
				bpy7 = bpy8 + boardNosing
			else
				if bInclinedWall then
					if gs_stack_right then
						bpx8 = rightRevealPnts[idxBoardEndRevealRight][1]
						bpy8 = rightRevealPnts[idxBoardEndRevealRight][2]

						bpx7 = bpx8
						bpy7 = bpy8 + boardNosing / incH
					else
						bpx8 = rightRevealPnts[idxBoardEndRevealRight][1] + gs_board_ovhg_right * incH
						bpy8 = rightRevealPnts[idxBoardEndRevealRight][2] + gs_board_ovhg_right * incV

						bpx7 = bpx8 - boardNosing * incV
						bpy7 = bpy8 + boardNosing * incH

						bpx8 = bpx8 - casingOffsetLeft * incV
						bpy8 = bpy8 + casingOffsetLeft * incH
					endif
				else
					bpx8 = rightRevealPnts[idxBoardEndRevealRight][1] + not(gs_stack_right) * gs_board_ovhg_right
					bpy8 = rightRevealPnts[idxBoardEndRevealRight][2] + casingOffsetRight

					bpx7 = bpx8
					bpy7 = bpy8 + boardNosing - casingOffsetRight
				endif
			endif
		endif
	endif

	if bHasAnyBoardOn then
		if bLeftCornerFunction & (abs(WALL_THICKNESS - leftConnWallThk) > EPS) then
			tempWallThkLeft = leftConnWallThk
		else
			tempWallThkLeft = WALL_THICKNESS
		endif
		if bRightCornerFunction & (abs(WALL_THICKNESS - rightConnWallThk) > EPS) then
			tempWallThkRight = rightConnWallThk
		else
			tempWallThkRight = WALL_THICKNESS
		endif
		wallThk = min (WALL_THICKNESS, tempWallThkLeft, tempWallThkRight)
		temp = wallThk - WIDO_SILL - WIDO_FRAME_THICKNESS + gs_board_nosing
		if abs(temp) < EPS then
			maxBoardAngle = 90
		else
			maxBoardAngle = atn(gs_board_thk / temp)
		endif
	endif
endif


! ==============================================================================
! Calculations for Curved Walls
! ==============================================================================

if curvedWall & abs(radBoard) > EPS then

	if gs_parapet_wall_inset & not(bDrawBoard) & not(bDrawInsideTrim) then gs_board_curved = 0

	if GLOB_SCRIPT_TYPE = 2 | GLOB_SCRIPT_TYPE = 3 then
		bArchSign = (WIDO_REVEAL_SIDE exor SYMB_ROTANGLE > EPS)
		iArchSign = bArchSign - not(bArchSign)		! 1 / -1

		if wallIsLeft then
			alfaL = -atn((leftWidth)  / (WOD - WIDO_FRAME_THICKNESS))
			alfaR =  atn((rightWidth) / (WOD - WIDO_FRAME_THICKNESS))
		else
			alfaL = -atn((leftWidth)  / WOD)
			alfaR =  atn((rightWidth) / WOD)
		endif

		ArcLengthBoardToAngle	= 180 / radBoard / PI

		alfaBoardLeftOvhg	= not(gs_stack_left)  * gs_board_ovhg_left  * ArcLengthBoardToAngle
		alfaBoardRightOvhg	= not(gs_stack_right) * gs_board_ovhg_right * ArcLengthBoardToAngle

		if gs_stack_left then
			bpx5 = leftRevealPnts[idxBoardEndRevealLeft][1] - casingOffsetLeft * sin(alfaL)
			bpy5 = leftRevealPnts[idxBoardEndRevealLeft][2] + casingOffsetLeft

			bpx6 = bpx5 - boardNosing * sin(alfaL) + casingOffsetLeft * sin(alfaL)
			bpy6 = bpy5 + boardNosing * cos(alfaL) - casingOffsetLeft
		else
			if bParalellInCurvedWalls then
				bpx5 = leftRevealPnts[idxBoardEndRevealLeft][1] - gs_board_ovhg_left
				bpy5 = -signWallIsLeft * sqr(radBoard^2 - bpx5^2) + WOD + casingOffsetLeft

				bpx6 = bpx5
				bpy6 = -signWallIsLeft * sqr((radBoard - signWallIsLeft * boardNosing)^2 - bpx6^2) + WOD
			else
				x = leftRevealPnts[idxBoardEndRevealLeft][1] - casingOffsetLeft * sin(alfaL)
				y = leftRevealPnts[idxBoardEndRevealLeft][2] + casingOffsetLeft
				alpha = -alfaBoardLeftOvhg
				gosub 9000	! Rotate 2D points around curved wall's center
				bpx5 = x
				bpy5 = y

				alpha = abs(atn(bpx5 / (bpy5 - WOD)))
				bpx6 = bpx5 + boardNosing * sin(alpha) * signWallIsLeft + casingOffsetLeft * sin(alfaL)
				bpy6 = bpy5 + boardNosing * cos(alpha) - casingOffsetLeft
			endif
		endif

		if gs_stack_right then
			bpx8 = rightRevealPnts[idxBoardEndRevealRight][1] - casingOffsetRight * sin(alfaR)
			bpy8 = rightRevealPnts[idxBoardEndRevealRight][2] + casingOffsetRight

			bpx7 = bpx8 - boardNosing * sin(alfaR) + casingOffsetRight * sin(alfaR)
			bpy7 = bpy8 + boardNosing * cos(alfaR) - casingOffsetRight
		else
			if bParalellInCurvedWalls then
				bpx8 = rightRevealPnts[idxBoardEndRevealRight][1] + gs_board_ovhg_right
				bpy8 = -signWallIsLeft * sqr(radBoard^2 - bpx8^2) + WOD + casingOffsetRight

				bpx7 = bpx8
				bpy7 = -signWallIsLeft * sqr((radBoard - signWallIsLeft * boardNosing)^2 - bpx7^2) + WOD
			else
				x = rightRevealPnts[idxBoardEndRevealRight][1] - casingOffsetRight * sin(alfaR)
				y = rightRevealPnts[idxBoardEndRevealRight][2] + casingOffsetRight
				alpha = alfaBoardRightOvhg
				gosub 9000	! Rotate 2D points around curved wall's center
				bpx8 = x
				bpy8 = y

				alpha = abs(atn(bpx8 / (bpy8 - WOD)))
				bpx7 = bpx8 - boardNosing * sin(alpha) * signWallIsLeft + casingOffsetRight * sin(alfaR)
				bpy7 = bpy8 + boardNosing * cos(alpha) - casingOffsetRight
			endif
		endif
	endif

	if bHasAnyBoardOn then
		! --- Check Board angle ---

		temp = max(abs(bpy6 + WOD) - WIDO_FRAME_THICKNESS, abs(bpy7 + WOD) - WIDO_FRAME_THICKNESS)
		maxBoardLength = max(abs(radBoard - iArchSign * gs_board_nosing - abs(WOD)) - WIDO_FRAME_THICKNESS, temp)
		if abs(maxBoardLength) < EPS then
			maxBoardAngle = 90
		else
			asnMaxBoardAngle = (gs_board_thk - 0.001) / maxBoardLength
			if asnMaxBoardAngle <= 1.0 & asnMaxBoardAngle >= -1.0 then
				maxBoardAngle = asn((gs_board_thk - 0.001) / maxBoardLength)
			else
				maxBoardAngle = 0
			endif
		endif
	endif
endif

goto 1


! ==============================================================================
! Rotate 2D points around curved wall's center
! ------------------------------------------------------------------------------
! Input variables:
!	x,y:				2D point
!	WOD:				"wido orig dist" in the wallhole coordinate system
!	alpha:				rotation angle
! Returned variables:
!	x,y:				rotated 2D point
! ==============================================================================

9000:
	xo = x
	yo = y - WOD
	x = xo * cos(signWallIsLeft * alpha) - yo * sin(signWallIsLeft * alpha)
	y = xo * sin(signWallIsLeft * alpha) + yo * cos(signWallIsLeft * alpha) + WOD
return


! ==============================================================================
! Generate Board Polygon - in Polygonal Walls
! ------------------------------------------------------------------------------
! Input variables:
!	ch:
!	leftRevealPnts, rightRevealPnts:
!	reveal point indices:
!	bPolyFor3D:
!	AC_WallContourPolygon:
!	boardNosing:
!	gs_stack_left:
!	gs_stack_right:
! ==============================================================================

2000:

	hotspotLeftX	= 0
	hotspotLeftY	= 0
	hotspotRightX	= 0
	hotspotRightY	= 0

	preparefunction ch, "CreateContainer", "mySourceContainer", ""
	preparefunction ch, "CreateContainer", "myDestinationContainer", ""

	preparefunction ch, "SetSourceContainer",	 	"mySourceContainer", ""
	preparefunction ch, "SetDestinationContainer",	"myDestinationContainer", ""

	! Avoid generating invalid polygons
	if WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS < EPS then
		return
	endif

! Store original wallhole polygon ----------------------------------------------

	dim vertArr1[][3]

	defaultInhEdgeInfo = -1
	dim inhEdgeInfos1[]

	put leftRevealPnts[idxFrameStartRevealLeft][1],	leftRevealPnts[idxFrameStartRevealLeft][2],	not(gs_stack_left)
	put leftRevealPnts[idxFrameEndRevealLeft][1],	leftRevealPnts[idxFrameEndRevealLeft][2]

	lastBoardPointX = leftRevealPnts[idxFrameEndRevealLeft][1]
	lastBoardPointY = leftRevealPnts[idxFrameEndRevealLeft][2]
	for i=idxBoardStartRevealLeft to idxBoardEndRevealLeft
		if leftRevealPnts[i][2] >= WIDO_FRAME_THICKNESS then
			distFromLast = abs((leftRevealPnts[i][1] - lastBoardPointX)^2 + (leftRevealPnts[i][2] - lastBoardPointY)^2)
			if distFromLast > EPS then
				put not(gs_stack_left)	! previous point status
				put leftRevealPnts[i][1], leftRevealPnts[i][2]
				lastBoardPointX = leftRevealPnts[i][1]
				lastBoardPointY = leftRevealPnts[i][2]
				bHasAnyBoardPoint = 1
			endif
		endif
	next i
	put -1	! last pont status

	bHasAnyBoardPoint = 0
	for i = idxBoardEndRevealRight to idxBoardStartRevealRight step -1
		if rightRevealPnts[i][2] >= WIDO_FRAME_THICKNESS then
			distFromLast = abs((rightRevealPnts[i][1] - lastBoardPointX)^2 + (rightRevealPnts[i][2] - lastBoardPointY)^2)
			if not(bHasAnyBoardPoint) | distFromLast > EPS then
				put rightRevealPnts[i][1], rightRevealPnts[i][2], not(gs_stack_right)
				lastBoardPointX = rightRevealPnts[i][1]
				lastBoardPointY = rightRevealPnts[i][2]
				bHasAnyBoardPoint = 1
			endif
		endif
	next i
	if idxBoardStartRevealRight <> idxFrameEndRevealRight then
		put rightRevealPnts[idxFrameEndRevealRight][1],	rightRevealPnts[idxFrameEndRevealRight][2],	not(gs_stack_right)
	endif
	put rightRevealPnts[idxFrameStartRevealRight][1],rightRevealPnts[idxFrameStartRevealRight][2],	0

	nVertices1 = nsp/3
	for i=1 to nVertices1
		px = get(1)
		py = get(1)
		ps = get(1)
		vertarr1[i][1]	 = px
		vertarr1[i][2]	 = py
		vertarr1[i][3]	 = 0
		if bPolyFor3D then
			if ps < 0 then
				inhEdgeInfos1[i] = ps
			else
				inhEdgeInfos1[i] = 2 * ps
			endif
		else
			inhEdgeInfos1[i] = -(ps < 0)	! Mark wallhole edges (0 / -1)
		endif
	next i

	nContours1 = 1
	dim contArr1[]
	contArr1[1] = nVertices1 + 1

	if nVertices1 >= 2 then
		preparefunction ch, "Store", "poly1", nVertices1, nContours1, vertArr1, contArr1, defaultInhEdgeInfo, inhEdgeInfos1
	endif

	prevSourceContainer	= ""
	lastDestContainer	= "mySourceContainer"
	preparefunction ch, "SetDestinationContainer", lastDestContainer, ""

! Offset board side edge -------------------------------------------------------

	dim dstPolyIDArr[]
	numPoly = callfunction (ch, "GetDestinationPolygons", "", dstPolyIDArr)

	dim edgeIds[]
	edgeIds[numPoly] = 0
	for i=1 to numPoly

		dim inhEdgeInfos[]
		numEdges = callfunction(ch, "GetInhEdgeInfos", dstPolyIDArr[i], inhEdgeInfos)

		for j=1 to numEdges
			if inhEdgeInfos[j] = -1 then edgeIds[i] = j
		next j
	next i

	if prevSourceContainer <> "" then
		preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
	endif
	preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
	prevSourceContainer	= lastDestContainer
	lastDestContainer	= "myDestContainer2"
	preparefunction ch, "CreateContainer",			lastDestContainer, ""
	preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

	dim srcPolyIDArr[]
	numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

	dim tempResPolyIDArr[]
	for i=1 to numPoly

		preparefunction ch, "OffsetParams", "", edgeIds[i], 2.00

		tempNumPoly = callfunction (ch, "OffsetEdge", srcPolyIDArr[i], tempResPolyIDArr)
	next i

!!!dim resPolyIDArr[]
!!!numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)
!!!
!!!for i = 1 to numPoly
!!!	polygonID = resPolyIDArr[i]
!!!	gosub 1000	! Get GDL Polygon
!!!
!!!	ccc=0
!!!	for j=1 to nsp/3
!!!		xx=get(1)
!!!		yy=get(1)
!!!		ss=get(1)
!!!		ccc=ccc+0.003
!!!		circle2 xx,yy,ccc
!!!		text2 xx,yy,j
!!!	next j
!!!next i
!!!end

! Store wall contour polygon in wallhole coordinate system ---------------------

	if prevSourceContainer <> "" then
		preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
	endif
	preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
	prevSourceContainer	= lastDestContainer
	lastDestContainer	= "myDestContainer3"
	preparefunction ch, "CreateContainer",			lastDestContainer, ""
	preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

	nVertices2 = vardim1(AC_WallContourPolygon)
	dim vertArr2[][3]

	dim srcPolyIDArr[]
	numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

	defaultInhEdgeInfo = 0
	dim inhEdgeInfos2[]
!!!ccc=0
	for i=1 to nVertices2
		vertarr2[i][1] = AC_WallContourPolygon[i][1]
		if WIDO_REVEAL_SIDE then
			vertarr2[i][2] = AC_WallContourPolygon[i][2] + WIDO_FRAME_THICKNESS
			vertarr2[i][3] = AC_WallContourPolygon[i][3]
		else
			vertarr2[i][2] = -AC_WallContourPolygon[i][2]
			vertarr2[i][3] = -AC_WallContourPolygon[i][3]
		endif

		inhEdgeInfos2[i] = 1
!!!ccc=ccc+0.003
!!!circle2 vertarr2[i][1], vertarr2[i][2], ccc
!!!text2 vertarr2[i][1], vertarr2[i][2], i
	next i

	nContours2 = 1
	dim contArr2[]
	contArr2[1] = nVertices2 + 1

	preparefunction ch, "Store", "wallContourPoly", nVertices2, nContours2, vertArr2, contArr2, defaultInhEdgeInfo, inhEdgeInfos2

! Substract polygons -----------------------------------------------------------

	dim tempResPolyIDArr[]
	for i = 1 to numPoly
		tempNumPoly = callfunction (ch, "wallContourPoly - " + srcPolyIDArr[i], "", tempResPolyIDArr)
	next i
	savedNumPoly = tempNumPoly

! Parallel to Polygon Wall case ------------------------------------------------

!!!	if not(bBoardInPolyWall) then

! Intersect polygon wall contour and wallhole polygons -------------------------

		dim tempResPolyIDArr[]
		for i = 1 to numPoly
			tempNumPoly = callfunction (ch, "wallContourPoly / " + srcPolyIDArr[i], "", tempResPolyIDArr)
		next i

! Choose left and right reference points ---------------------------------------

		leftPx	= 0
		leftPy	= 0
		rightPx	= 0
		rightPy	= 0

		for i = 1 to tempNumPoly
			polygonID = tempResPolyIDArr[i]

			dim resVertices[]
			numVertices = callfunction(ch, "GetVertices", polygonID, resVertices)
			numVertices = numVertices / 3

			dim contArr[]
			numContours = callfunction(ch, "GetContourEnds", polygonID, contArr)

			dim inhEdgeInfos[]
			numEdges = callfunction(ch, "GetInhEdgeInfos", polygonID, inhEdgeInfos)

			for contIndex = 1 to numContours

				if contIndex = 1 then
					begIdx = 0
				else
					begIdx = contArr[contIndex] - 1
				endif
				if contIndex = numContours then
					endIdx = numVertices - 1
				else
					endIdx = contArr[contIndex + 1] - 2
				endif

!index = endIdx * 3
!lastVertX	= resVertices[index + 1]
!lastVertY	= resVertices[index + 2]
!lastVertA	= resVertices[index + 3]
				edgeInfo	= inhEdgeInfos[endIdx + 1]

				for vertIndex = begIdx to endIdx

					index = vertIndex * 3
					actVertX = resVertices[index + 1]
					actVertY = resVertices[index + 2]
					actVertA = resVertices[index + 3]

!text2	(lastVertX + actVertX) / 2,
!		(lastVertY + actVertY) / 2,
!		edgeInfo

					if edgeInfo <> inhEdgeInfos[vertIndex + 1] then
						if actVertX < 0 then
							if actVertY > leftPy then
								leftPx = actVertX
								leftPy = actVertY
							endif
						else
							if actVertY > rightPy then
								rightPx = actVertX
								rightPy = actVertY
							endif
						endif
!circle2 actVertX, actVertY, 0.05
					endif

!lastVertX	= actVertX
!lastVertY	= actVertY
!lastVertA	= actVertA
					edgeInfo	= inhEdgeInfos[vertIndex + 1]

				next vertIndex
			next contIndex
		next i

		! If any of the reference points missing, switch back to "Parallel to Window" mode
		if abs(leftPx) < EPS | leftPy < WIDO_FRAME_THICKNESS + EPS | abs(rightPx) < EPS | rightPy < WIDO_FRAME_THICKNESS + EPS then
			bBoardInPolyWall = 1
		endif
!!!	endif	! bBoardInPolyWall

!	if not(bBoardInPolyWall) then
!		circle2 leftPx,leftPy, 0.10
!		circle2 rightPx,rightPy, 0.10
!	endif

! Store Board polygon ----------------------------------------------------------

	if prevSourceContainer <> "" then
		preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
	endif
	preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
	prevSourceContainer	= lastDestContainer
	lastDestContainer	= "myDestContainer5"
	preparefunction ch, "CreateContainer",			lastDestContainer, ""
	preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

	dim srcPolyIDArr[]
	numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)
	numPoly = savedNumPoly

	boardNosingY = max(leftRevealPnts[idxBoardEndRevealLeft][2], rightRevealPnts[idxBoardEndRevealRight][2])
	if bBoardInPolyWall then
		boardNosingY = max(boardNosingY, max(leftPy, rightPy))
	endif
	boardNosingY = boardNosingY + boardNosing

	boardOvhgLeft	= max(gs_board_ovhg_left,	EPS)
	boardOvhgRight	= max(gs_board_ovhg_right,	EPS)

	if not(bBoardInPolyWall) then
		if abs(leftPx - rightPx) > EPS then
			boardDirAngle = atn((leftPy - rightPy) / (leftPx - rightPx))
		else
			bBoardInPolyWall = 0
		endif
	endif

	if sidelightCutLeft then
		put	sidelightCutPosLeft, boardNosingY,	2,
			sidelightCutPosLeft, 0,				2
		hotspotLeftX = sidelightCutPosLeft
		hotspotLeftY = boardNosingY
	else
		if bBoardInPolyWall then
			if boardNosing > EPS then
				hotspotLeftX = leftRevealPnts[idxBoardEndRevealLeft][1] - not(gs_stack_left) * boardOvhgLeft
				hotspotLeftY = boardNosingY
				put hotspotLeftX, hotspotLeftY, 2 * not(gs_stack_left)
			endif

			for i=idxBoardEndRevealLeft to idxBoardStartRevealLeft step -1
				put leftRevealPnts[i][1] - not(gs_stack_left) * boardOvhgLeft, leftRevealPnts[i][2] - (not(bPolyFor3D) & i <> idxBoardEndRevealLeft) * EPS,
					2 * ((not(gs_stack_left) & (bPolyFor3D | i <> idxBoardStartRevealLeft)) | (bPolyFor3D & i = idxBoardStartRevealLeft))
			next i
		else
			if boardNosing > EPS then
				if gs_stack_left then
					put leftPx, leftPy + boardNosing / cos(boardDirAngle), 0
				else
					hotspotLeftX = leftPx - boardNosing * sin(boardDirAngle) - boardOvhgLeft * cos(boardDirAngle)
					hotspotLeftY = leftPy + boardNosing * cos(boardDirAngle) - boardOvhgLeft * sin(boardDirAngle)

					put hotspotLeftX, hotspotLeftY, 2
					put hotspotLeftX + 2 * boardOvhgLeft * sin(boardDirAngle), hotspotLeftY - 2 * boardOvhgLeft * cos(boardDirAngle), 2
				endif
			endif

			put leftPx, leftPy, 2 * not(gs_stack_left)
			for i=idxBoardEndRevealLeft to idxBoardStartRevealLeft step -1
				if leftRevealPnts[i][2] < leftPy - EPS then
					put leftRevealPnts[i][1] - not(gs_stack_left) * EPS, leftRevealPnts[i][2] - (not(bPolyFor3D) & i <> idxBoardEndRevealLeft) * EPS,
						2 * ((not(gs_stack_left) & (bPolyFor3D | i <> idxBoardStartRevealLeft)) | (bPolyFor3D & i = idxBoardStartRevealLeft))
				endif
			next i
		endif
	endif

	if abs(bBoardNnosUsa) > EPS then	! Board Negative Nosing by USA Framesill
		put  leftRevealPnts[idxBoardStartRevealLeft][1]  + frameWidthLeft,	 leftRevealPnts[idxBoardStartRevealLeft][2],				2,
			 leftRevealPnts[idxBoardStartRevealLeft][1]  + frameWidthLeft,	 leftRevealPnts[idxBoardStartRevealLeft][2]  - bBoardNnosUsa,	2,
			rightRevealPnts[idxBoardStartRevealRight][1] - frameWidthRight, rightRevealPnts[idxBoardStartRevealRight][2] - bBoardNnosUsa,	2,
			rightRevealPnts[idxBoardStartRevealRight][1] - frameWidthRight,	rightRevealPnts[idxBoardStartRevealRight][2],				2
	endif

	if sidelightCutRight then
		put	sidelightCutPosRight, 0,			2,
			sidelightCutPosRight, boardNosingY,	2
		hotspotRightX = sidelightCutPosRight
		hotspotRightY = boardNosingY
	else
		if bBoardInPolyWall then
			for i=idxBoardStartRevealRight to idxBoardEndRevealRight
				put rightRevealPnts[i][1] + not(gs_stack_right) * boardOvhgRight, rightRevealPnts[i][2] - (not(bPolyFor3D) & i <> idxBoardEndRevealRight) * EPS,
					2 * ((not(gs_stack_right)) | (i = idxBoardEndRevealRight & boardNosing < EPS))
			next i
			if boardNosing > EPS then
				hotspotRightX = rightRevealPnts[idxBoardEndRevealRight][1] + not(gs_stack_right) * boardOvhgRight
				hotspotRightY = boardNosingY
				put hotspotRightX, hotspotRightY, 2
			endif
		else
			for i=idxBoardStartRevealRight to idxBoardEndRevealRight
				if rightRevealPnts[i][2] < rightPy - EPS then
					put rightRevealPnts[i][1] + not(gs_stack_right) * EPS, rightRevealPnts[i][2] - (not(bPolyFor3D) & i <> idxBoardEndRevealRight) * EPS,
						2 * ((not(gs_stack_right)) | (i = idxBoardEndRevealRight & boardNosing < EPS))
				endif
			next i

			put rightPx, rightPy, 2 * not(gs_stack_right)

			if boardNosing > EPS then
				if gs_stack_right then
					put rightPx, rightPy + boardNosing / cos(boardDirAngle), 2
				else
					hotspotRightX = rightPx - boardNosing * sin(boardDirAngle) + boardOvhgRight * cos(boardDirAngle)
					hotspotRightY = rightPy + boardNosing * cos(boardDirAngle) + boardOvhgRight * sin(boardDirAngle)

					put hotspotRightX + 2 * boardOvhgRight * sin(boardDirAngle), hotspotRightY- 2 * boardOvhgRight * cos(boardDirAngle), 2
					put hotspotRightX, hotspotRightY, 2
				endif
			endif
		endif
	endif

	dim vertArrBoard[][3]
	dim inhEdgeInfosBoard[]
	defaultInhEdgeInfo = 0

	for i=1 to nsp/3
		px = get(1)
		py = get(1)
		ps = round_int (get(1))

		vertArrBoard[i][1]	= px
		vertArrBoard[i][2]	= py
		vertArrBoard[i][3]	= 0
		inhEdgeInfosBoard[i]= ps
	next i
	nVerticesBoard = vardim1(vertArrBoard)

	nContoursBoard = 1
	dim contArrBoard[]
	contArrBoard[1] = nVerticesBoard + 1

	if nVertices1 >= 2 then
		preparefunction ch, "Store", "boardPoly", nVerticesBoard, nContoursBoard, vertArrBoard, contArrBoard, defaultInhEdgeInfo, inhEdgeInfosBoard
	endif

!! Regularize polygon(s) --------------------------------------------------------
!
!	dim srcPolyIDArr[]
!	numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)
!
!	dim tempResPolyIDArr[]
!	for i=1 to numPoly
!		tempNumPoly = callfunction (ch, "Regularize", srcPolyIDArr[i], tempResPolyIDArr)
!	next i
!
!	if prevSourceContainer <> "" then
!		preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
!	endif
!	preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
!	prevSourceContainer	= lastDestContainer
!	lastDestContainer	= "myDestContainer5"
!	preparefunction ch, "CreateContainer",			lastDestContainer, ""
!	preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

! Substract polygons -----------------------------------------------------------

	dim operandPolygonNames[]
		operandPolygonNames[1] = "boardPoly"
	numOperandPolygonNames = 1
	containerIdx = 10

	while numPoly > 0 do

		for i = 2 to numPoly
			tempNumPoly = callfunction (ch, "CopyPolygon", srcPolyIDArr[i], tempResPolyIDArr)
		next i
		lastNumPoly = numPoly - 1

		for i=1 to numOperandPolygonNames
			tempNumPoly = callfunction (ch, operandPolygonNames[i] + " - " + srcPolyIDArr[1], "", tempResPolyIDArr)
		next i

		numResPoly = tempNumPoly - lastNumPoly + 1

		dim resPolyIDArr[]
		tempNumPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)

		numOperandPolygonNames = tempNumPoly - lastNumPoly

		for i=1 to numOperandPolygonNames
			operandPolygonNames[i] = resPolyIDArr[lastNumPoly + i]
		next i

		numPoly = numPoly - 1

		if numPoly > 0 then
			if prevSourceContainer <> "" then
				preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
			endif
			preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
			prevSourceContainer	= lastDestContainer
			lastDestContainer	= "myDestContainer" + str(containerIdx, 1, 0)
			preparefunction ch, "CreateContainer",			lastDestContainer, ""
			preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""
			containerIdx = containerIdx + 1
		endif
	endwhile
return


1:


]]></Script_1D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_PR SectVersion="20" SectionFlags="0" SubIdent="0"><![CDATA[

]]></Script_PR>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_UI SectVersion="20" SectionFlags="0" SubIdent="0"><![CDATA[


pageStartY = 10 + 30

if bDoorWithSidelightSupport then
	if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then
		ui_pict 51, 7, pageStartY - 2, 12, 12, 1	! ui_warningsign.png
		ui_style 0,0
		ui_outfield stBoardUI[20], 28, pageStartY - 2, 410, 17
		end
	endif
endif

x1 = 2
x2 = 35
x3 = 140
x4 = 195
y = pageStartY
dy = 26
cx = 40
cy = 24
px = 30
py = 20

ui_style 0,1

if bDoorWithSidelightSupport then
	if iWindowShape = SHAPE_T | iWindowShape = SHAPE_ARCHED_T then
		ui_infield{3} "gs_board_inside_sl_right", x1, y, 190, 19,
				7, "",
				2,
				1, 20, 20, 20, 20,
				0, stBoardUI[17], 0,	! Board - Sidelight 1
				1, stBoardUI[17], 1		! Board - Sidelight 1
		ui_infield{3} "gs_board_inside_sl_left", 205, y, 190, 19,
				7, "",
				2,
				1, 20, 20, 20, 20,
				0, stBoardUI[18], 0,	! Board - Sidelight 2
				1, stBoardUI[18], 1		! Board - Sidelight 2
	else
		if iWindowShape = SHAPE_HALF_T_LEFT | iWindowShape = SHAPE_ARCHED_HALF_T_LEFT then
			ui_infield{3} "gs_board_inside_sl_left", x1, y, 190, 19,
					7, "",
					2,
					1, 20, 20, 20, 20,
					0, stBoardUI[19], 0,	! Board - Sidelight
					1, stBoardUI[19], 1		! Board - Sidelight
		else
			if iWindowShape = SHAPE_HALF_T_RIGHT | iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT then
				ui_infield{3} "gs_board_inside_sl_right", x1, y, 190, 19,
						7, "",
						2,
						1, 20, 20, 20, 20,
						0, stBoardUI[19], 0,	! Board - Sidelight
						1, stBoardUI[19], 1		! Board - Sidelight
			endif
		endif
	endif
else
	ui_infield{3} "gs_board_inside", x1, y, 190, 19,
			7, "",
			2,
			1, 20, 20, 20, 20,
			0, stBoardUI[1], 0,		! Board
			1, stBoardUI[1], 1		! Board
endif

y = y + dy

ui_style 0,0
ui_infield{3} "gs_board_curved", x1, y, 300, 19,
			7, "",
			2,
			1, 20, 20, 20, 20,
			0, stBoardUI[5], 0,		! Is Curved in Curved Walls
			1, stBoardUI[5], 1		! Is Curved in Curved Walls

bFlag = not(bHasAnyBoardOn) | abs (gs_board_angle) > EPS
iFlag = 4 * bFlag

y = y + dy

ui_outfield stBoardUI[13], x1, y, 202, 15, iFlag		! In Polygonal Walls
ui_infield{3} "iBoardInPolyWall", x1 + 202 + 1, y-4, 180, 19,
			8, "", 2, 1, 0, 0, 0, 0,
			1, `Parallel to Window`, BOARD_PARALLEL_WINDOW,
			2, `Parallel to Wall Polygon`, BOARD_PARALLEL_WALLPOLYGON				

y = y + dy + 5

bFlag = not(bHasAnyBoardOn)
iFlag = 4 * bFlag


! --- overhangs ---
x1 = 30
x2 = x1 + 75
y1 = y + 35

if bHasAnyBoardOn and not (gs_stack_bottom) then
	if iPanelType = 0 then
		ui_pict 9, x1, y1, 60, 52, 1		!ui_board_leftovhg_win0
		ui_pict 10, x2, y1, 60, 52, 1		!ui_board_rightovhg_win0
	endif
	if iPanelType = 1 then
		if not(bOpeningDirection) then	! Outside
			ui_pict 11, x1, y1, 60, 52, 1		!ui_board_leftovhg_win1_out
			ui_pict 12, x2, y1, 60, 52, 1		!ui_board_rightovhg_win1_out
		else
			ui_pict 13, x1, y1, 60, 52, 1		!ui_board_leftovhg_win1_in
			ui_pict 14, x2, y1, 60, 52, 1		!ui_board_rightovhg_win1_in
		endif
	endif
	if iPanelType = 2 then
		! Single Double Hung`s always inside direction
		ui_pict 17, x1, y1, 60, 52, 1		!ui_board_leftovhg_win2_in
		ui_pict 18, x2, y1, 60, 52, 1		!ui_board_rightovhg_win2_in
	endif
	if iPanelType = 3 then
		ui_pict 19, x1, y1, 60, 52, 1			!ui_board_leftovhg_win3
		ui_pict 20, x2, y1, 60, 52, 1			!ui_board_rightovhg_win3
	endif

	ui_pict 21, x1, y1+52, 60, 18, 1			!ui_board_leftovhg_2
	ui_pict 22, x2, y1+52, 60, 18, 1			!ui_board_rightovhg_2

	ui_infield "gs_board_ovhg_left",	x1-19, y1+75,	79, 19	ui_tooltip stBoardUI[2]		! Left Overhang
	ui_infield "gs_board_ovhg_right",	x2, y1+75,	79, 19	ui_tooltip stBoardUI[3]		! Right Overhang
else
	if iPanelType = 0 then
		ui_pict 25, x1, y1, 60, 52, 1			!ui_board_leftovhg_win0_noboard
		ui_pict 26, x2, y1, 60, 52, 1			!ui_board_rightovhg_win0_noboard
	endif
	if iPanelType = 1 then
		if not(bOpeningDirection) then	! Outside
			ui_pict 27, x1, y1, 60, 52, 1		!ui_board_leftovhg_win1_out_noboard
			ui_pict 28, x2, y1, 60, 52, 1		!ui_board_rightovhg_win1_out_noboard
		else
			ui_pict 29, x1, y1, 60, 52, 1		!ui_board_leftovhg_win1_in_noboard
			ui_pict 30, x2, y1, 60, 52, 1		!ui_board_rightovhg_win1_in_noboard
		endif
	endif
	if iPanelType = 2 then
		! Single Double Hung`s always inside direction
		ui_pict 33, x1, y1, 60, 52, 1		!ui_board_leftovhg_win2_in_noboard
		ui_pict 34, x2, y1, 60, 52, 1		!ui_board_rightovhg_win2_in_noboard
	endif
	if iPanelType = 3 then
		ui_pict 35, x1, y1, 60, 52, 1			!ui_board_leftovhg_win3_noboard
		ui_pict 36, x2, y1, 60, 52, 1			!ui_board_rightovhg_win3_noboard
	endif
endif


! --- board section ---
x1 = 230
y1 = y + 15

if iPanelType = 0 then
	ui_pict 37,		x1, 	y1, 	94, 37, 1		!ui_board_win0
endif
if iPanelType = 1 then
	if not(bOpeningDirection) then	! Outside
		ui_pict 38, 	x1, 	y1, 	94, 37, 1		!ui_board_win1_out
	else
		ui_pict 39, 	x1, 	y1, 	94, 37, 1		!ui_board_win1_in
	endif
endif
if iPanelType = 2 then
	! Single Double Hung`s always inside direction
	ui_pict 41, 	x1, 	y1, 	94, 37, 1		!ui_board_win2_in
endif
if iPanelType = 3 then
	ui_pict 42, 			x1, 	y1, 	94, 37, 1	!ui_board_win3
endif

if bHasAnyBoardOn and not (gs_stack_bottom) then
	if iRevealType = REVEAL_DOUBLE_SPLAYED then
		ui_pict 48, x1, 	y1+37, 	125, 85, 1			!ui_board_main_splayed
		ui_infield "gs_board_thk",		x1+132, 	y1+58,	79, 19	ui_tooltip stBoardUI[11]	! Board Thickness
		ui_infield "gs_board_nosing",	x1+132, 	y1+81,	79, 19	ui_tooltip stBoardUI[12]	! Board Nosing
		ui_infield "gs_board_width",	x1+132, 	y1+104 ,	79, 19	ui_tooltip stBoardUI[14]	! Board Width
	else
		if gs_board_angle < EPS then
			ui_pict 46, 	x1, 	y1+37, 	94, 85, 1			!ui_board_main0_board
			ui_pict 47, 	x1+94, 	y1+27, 	31, 76, 1			!ui_board_main0_boardend
		else
			ui_pict 43, 	x1, 	y1+37, 	94, 85, 1			!ui_board_main_board
			ui_pict 44, 	x1+94, 	y1+27, 	31, 76, 1			!ui_board_main_boardend
		endif

		ui_infield "gs_board_angle",	x1+128, 	y1+23,	79, 19	ui_tooltip stBoardUI[10]	! Board Angle
		ui_infield "gs_board_thk",		x1+128, 	y1+46,	79, 19	ui_tooltip stBoardUI[11]	! Board Thickness
		ui_infield "gs_board_nosing",	x1+128, 	y1+69,	79, 19	ui_tooltip stBoardUI[12]	! Board Nosing
		ui_infield "gs_board_width",	x1+128, 	y1+92,	79, 19	ui_tooltip stBoardUI[14]	! Board Width
	endif
else
	ui_pict 45, 		x1, 	y1+37, 	94, 85, 1		!ui_board_main_noboard
endif

!	x1 = 2
!	x2 = x1 + 33
!	x3 = x1 + 218
!
!	y = pageStartY
!	dy = 26
!	cx = 40
!	cy = 23
!	px = 30
!	py = 20
!
!	if not(bDoorWithSidelightSupport) then
!		ui_style 0,1
!		ui_infield{3} "gs_board_inside", x1, y, x3-x1, 15,
!				7, "",
!				2,
!				1, 20, 20, 20, 20,
!				0, stBoardUI[ 1], 0,		! Board
!				1, stBoardUI[ 1], 1			! Board
!	endif
!	y=y+dy
!
!	bFlag = not(bHasAnyBoardOn)
!	iFlag = 4 * bFlag
!
!	ui_style 0,0
!
!	if bFlag then
!		ui_pict 2, x1, y-1, 12,17, 1		! ui_mat_lock.png
!	else
!		ui_pict 1, x1, y-1, 12,17, 1		! ui_mat.png
!	endif
!	ui_outfield stBoardUI[6],  x2, y, 100, 15, iFlag			! Material
!	ui_infield "gs_board_mat", x3, y-8, x3-x2-1, 28
!
!	ui_style 0,1
!	y=y+dy+5
!	ui_outfield stBoardUI[15],  x1, y, 100, 15, iFlag			! Section Attributes
!
!	ui_style 0,0
!	bFlag = not(bHasAnyBoardOn)
!	iFlag = 4 * bFlag
!	y=y+dy
!
!	if bFlag then
!		ui_pict 50, x1, y, 24, 17, 1		! ui_contour_pen_lock.png
!	else
!		ui_pict 49, x1, y, 24, 17, 1		! ui_contour_pen.png
!	endif
!	ui_outfield stBoardUI[16], x2, y, x3-x2-1, 18, iFlag	! Contour Pen
!	ui_infield "gs_board_pen_sectcont",	 x3,y, cx, cy
!	y=y+dy
!
!	bFlag = not(gs_bFills & bHasAnyBoardOn)
!	iFlag = 4 * bFlag
!
!	if bFlag then
!		ui_pict 4, x1, y, 13, 17, 1		! ui_fill_type_lock.png
!	else
!		ui_pict 3, x1, y, 13, 17, 1		! ui_fill_type.png
!	endif
!	ui_outfield stBoardUI[7], x2, y, 100, 15, iFlag			! Fill Type
!	ui_infield "gs_board_fill", x3, y, x3-x2-1, 28
!	y=y+31
!
!	if bFlag then
!		ui_pict 6, x1, y, 24, 17, 1		! ui_fill_pen_lock.png
!	else
!		ui_pict 5, x1, y, 24, 17, 1		! ui_fill_pen.png
!	endif
!	ui_outfield stBoardUI[8], x2, y, x3-x2-1, 18, iFlag	! Fill Pen
!	ui_infield "gs_board_pen_fg",	 x3,y, cx, cy
!	y=y+dy
!
!	if bFlag then
!		ui_pict 8, x1, y, 24, 17, 1		! ui_back_pen_lock.png
!	else
!		ui_pict 7, x1, y, 24, 17, 1		! ui_back_pen.png
!	endif
!	ui_outfield stBoardUI[9], x2, y, x3-x2-1, 18, iFlag	! Background Pen
!	ui_infield "gs_board_pen_bg", x3, y, cx, cy
!endif


]]></Script_UI>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_VL SectVersion="20" SectionFlags="0" SubIdent="0"><![CDATA[

! Contact person: <NJ>

! ==============================================================================
! This macro draws the Board
! ------------------------------------------------------------------------------
! Input parameters:
!	A:						Window nominal width (length)
!	B:						Window nominal height (length)
!	gs_IsCurved:			Does the window follow the curvature of the wall? (0 / 1)
!	iWindowShape:			Shape of the window (integer)
!								0 = rectangular (default)
!								1 = arched
!							Note: only the rectangular shape can be a Corner Window
! Corner Function --------------------------------------------------------------
!	bLeftCornerFunction:		Turn macro in Corner Window mode at the left side (0 / 1)
!	leftCornerAngle:		Angle between connected walls in case of Corner Window (angle)
!	leftConnWallThk:		Thickness of the connected wall in case of Corner Window (length)
!	bRightCornerFunction:	Turn macro in Corner Window mode at the right side (0 / 1)
!	rightCornerAngle:		Angle between connected walls in case of Corner Window (angle)
!	rightConnWallThk:		Thickness of the connected wall in case of Corner Window (length)
! Oversize ---------------------------------------------------------------------
!	ac_right_oversize:		Right opening oversize (length)
! Sill -------------------------------------------------------------------------
!	gs_sill_oversize:		Identifies the method as the macro handles the nominal
!								opening sizes when Sill are turned on. (0 / 1)
!	gs_sill_thk:			Thickness of the Sill. (length)
!	gs_board_width:			Width of Board. (length)
!	gs_board_thk:			Thickness of the Board. (length)
!	gs_board_nosing:		Nosing of the Board. (length)
!	gs_board_angle:			Board slope. (angle)
!	gs_board_ovhg_left:		Board overhang on the left side. (length)
!	gs_board_ovhg_right:	Board overhang on the right side. (length)
!	gs_board_slip_in:		Slip in of the Board. Only effective when iSillType = 2 or iSillType = 3 (length)
!	gs_board_curved:		Board edge is curved or straight. (0 / 1)
! Ganging ----------------------------------------------------------------------
!	gs_stack_left:			Align to door/window on left side (0 / 1)
!	gs_stack_right:			Align to door/window on right side (0 / 1)
!	gs_stack_bottom:		Align to door/window on bottom side (0 / 1)
!	--- String Tables ---
!
! Related Global Variables:
!	GLOB_SCRIPT_TYPE
!	GLOB_CONTEXT
!	WALL_THICKNESS
!	WALL_INCL
!	WIDO_FRAME_THICKNESS
!	WIDO_SILL
!	WIDO_LEFT_JAMB
!	WIDO_RIGHT_JAMB
!	WIDO_ORIG_DIST
!	WIDO_REVEAL_SIDE
!	SYMB_MIRRORED
!	SYMB_ROTANGLE
! ==============================================================================


! ==============================================================================
! Window Oversize Calculations
! ==============================================================================

if bDoorWithSidelightSupport then
	if not(gs_sidelight_left & gs_sidelight_parapet_hgt_left > EPS) then
		hideparameter "gs_board_inside_sl_left"
		lock "gs_board_inside_sl_left"
		if gs_sidelight_left & gs_sidelight_parapet_hgt_left < EPS then
			gs_board_inside_sl_left = 0
			parameters gs_board_inside_sl_left = 0
		endif
	endif
	if not(gs_sidelight_right & gs_sidelight_parapet_hgt_right > EPS) then
		hideparameter "gs_board_inside_sl_right"
		lock "gs_board_inside_sl_right"
		if gs_sidelight_right & gs_sidelight_parapet_hgt_right < EPS then
			gs_board_inside_sl_right = 0
			parameters gs_board_inside_sl_right = 0
		endif
	endif
endif

if not(bHasAnyBoardOn) | gs_stack_bottom then						! Off
	hideparameter	"gs_board_thk",
					"gs_board_width",
					"gs_board_nosing",
					"gs_board_angle",
					"gs_board_angle",
					"gs_board_ovhg_left",
					"gs_board_ovhg_right",
					"gs_board_slip_in",
					"gs_board_curved",
					"gs_board_pen_sectcont",
					"gs_board_pen_3D",
					"gs_board_fill",
					"gs_board_pen_fg",
					"gs_board_pen_bg",
					"gs_board_mat",
					"iBoardInPolyWall"

	lock	"gs_board_thk",
			"gs_board_width",
			"gs_board_nosing",
			"gs_board_angle",
			"gs_board_angle",
			"gs_board_ovhg_left",
			"gs_board_ovhg_right",
			"gs_board_slip_in",
			"gs_board_curved",
			"gs_board_pen_sectcont",
			"gs_board_pen_3D",
			"gs_board_fill",
			"gs_board_pen_fg",
			"gs_board_pen_bg",
			"gs_board_mat",
			"iBoardInPolyWall"
else
	if bHasAnyBoardOn & not(gs_sill_oversize) then
		hideparameter	"gs_board_slip_in"	! Inside, Both Sides
		lock 			"gs_board_slip_in"
	endif

	if gs_stack_left then
		hideparameter "gs_board_ovhg_left"
		lock "gs_board_ovhg_left"
	endif
	if gs_stack_right then
		hideparameter "gs_board_ovhg_right"
		lock "gs_board_ovhg_right"
	endif

	if bHasAnyBoardOn then			! Inside, Both Sides

		values "gs_board_thk" range (0, ]

		if maxBoardAngle > EPS then
			if gs_board_angle > maxBoardAngle - EPS then
				gs_board_angle = maxBoardAngle - EPS
				parameters gs_board_angle = maxBoardAngle - EPS
			endif
			values "gs_board_angle" range[0, maxBoardAngle)
		else
			values "gs_board_angle" range[0,)
		endif

		values "gs_board_width"			range[WALL_THICKNESS + minBoardNosing - WIDO_SILL - WIDO_FRAME_THICKNESS, )
		values "gs_board_nosing"		range[minBoardNosing,]
		values "gs_board_ovhg_left"		range[minBoardOvhgLeft,]
		values "gs_board_ovhg_right"	range[minBoardOvhgRight,]
	endif
endif

values{2} "iBoardInPolyWall" 	BOARD_PARALLEL_WINDOW,		stBoardInPolyWall[1],
								BOARD_PARALLEL_WALLPOLYGON,	stBoardInPolyWall[2]

if abs(gs_board_angle) > EPS then
	iBoardInPolyWall = BOARD_PARALLEL_WINDOW
	parameters iBoardInPolyWall = iBoardInPolyWall
	lock	"iBoardInPolyWall"
endif

if iRevealType = REVEAL_DOUBLE_SPLAYED then
	if GLOB_MODPAR_NAME = "gs_board_width" then
		gs_board_nosing = gs_board_width * cos(gs_reveal_bottom_angle) - (WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS)
		parameters gs_board_nosing = gs_board_nosing
	else
		gs_board_width = ((WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS) + gs_board_nosing) / cos(gs_reveal_bottom_angle)
		parameters gs_board_width = gs_board_width
	endif
else
	if GLOB_MODPAR_NAME = "gs_board_width" then
		gs_board_nosing = gs_board_width - (WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS)
		parameters gs_board_nosing = gs_board_nosing
	else
		gs_board_width = gs_board_nosing + (WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS)
		parameters gs_board_width = gs_board_width
	endif
endif


]]></Script_VL>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Comment SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Comment>

<CalledMacros SectVersion="2" SectionFlags="0" SubIdent="0">
	<Macro>
		<MName><![CDATA["SaveQueue_WMCC"]]></MName>
		<MainGUID>3C5CB4C9-88DB-4D04-980A-0422BE2B1A24</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["LoadQueue_WMCC"]]></MName>
		<MainGUID>4D59CACA-3851-4598-A37A-A70EB0E48955</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["SaveQueue_WMCC"]]></MName>
		<MainGUID>3C5CB4C9-88DB-4D04-980A-0422BE2B1A24</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["LoadQueue_WMCC"]]></MName>
		<MainGUID>4D59CACA-3851-4598-A37A-A70EB0E48955</MainGUID>
	</Macro>
</CalledMacros>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="9" path="uipicts/Board/ui_board_leftovhg_win0.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="10" path="uipicts/Board/ui_board_rightovhg_win0.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="11" path="uipicts/Board/ui_board_leftovhg_win1_out.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="12" path="uipicts/Board/ui_board_rightovhg_win1_out.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="13" path="uipicts/Board/ui_board_leftovhg_win1_in.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="14" path="uipicts/Board/ui_board_rightovhg_win1_in.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="15" path="uipicts/Board/ui_board_leftovhg_win2_out.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="16" path="uipicts/Board/ui_board_rightovhg_win2_out.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="17" path="uipicts/Board/ui_board_leftovhg_win2_in.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="18" path="uipicts/Board/ui_board_rightovhg_win2_in.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="19" path="uipicts/Board/ui_board_leftovhg_win3.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="20" path="uipicts/Board/ui_board_rightovhg_win3.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="21" path="uipicts/Board/ui_board_leftovhg_2.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="22" path="uipicts/Board/ui_board_rightovhg_2.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="25" path="uipicts/Board/ui_board_leftovhg_win0_noboard.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="26" path="uipicts/Board/ui_board_rightovhg_win0_noboard.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="27" path="uipicts/Board/ui_board_leftovhg_win1_out_noboard.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="28" path="uipicts/Board/ui_board_rightovhg_win1_out_noboard.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="29" path="uipicts/Board/ui_board_leftovhg_win1_in_noboard.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="30" path="uipicts/Board/ui_board_rightovhg_win1_in_noboard.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="31" path="uipicts/Board/ui_board_leftovhg_win2_out_noboard.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="32" path="uipicts/Board/ui_board_rightovhg_win2_out_noboard.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="33" path="uipicts/Board/ui_board_leftovhg_win2_in_noboard.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="34" path="uipicts/Board/ui_board_rightovhg_win2_in_noboard.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="35" path="uipicts/Board/ui_board_leftovhg_win3_noboard.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="36" path="uipicts/Board/ui_board_rightovhg_win3_noboard.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="37" path="uipicts/Board/ui_board_win0.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="38" path="uipicts/Board/ui_board_win1_out.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="39" path="uipicts/Board/ui_board_win1_in.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="40" path="uipicts/Board/ui_board_win2_out.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="41" path="uipicts/Board/ui_board_win2_in.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="42" path="uipicts/Board/ui_board_win3.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="43" path="uipicts/Board/ui_board_main_board.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="44" path="uipicts/Board/ui_board_main_boardend.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="45" path="uipicts/Board/ui_board_main_noboard.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="46" path="uipicts/Board/ui_board_main0_board.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="47" path="uipicts/Board/ui_board_main0_boardend.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="48" path="uipicts/Board/ui_board_main_splayed.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="51" path="uipicts/ui_warningsign.png">
</GDLPict>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_FWM SectVersion="20" SectionFlags="0" SubIdent="0"><![CDATA[

]]></Script_FWM>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_BWM SectVersion="20" SectionFlags="0" SubIdent="0"><![CDATA[

]]></Script_BWM>

<Keywords SectVersion="1" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Keywords>

<Copyright SectVersion="1" SectionFlags="0" SubIdent="0"><Author>BIMobject</Author><License><Type>CC BY-ND</Type><Version>3.0</Version></License></Copyright><ParamSection SectVersion="25" SectionFlags="0" SubIdent="0">
	<ParamSectHeader>
		<Version>25</Version>
		<AutoHotspots>no</AutoHotspots>
		<StatBits>
			<STBit_FixSize/>
		</StatBits>
		<WDLeftFrame>0</WDLeftFrame>
		<WDRightFrame>0</WDRightFrame>
		<WDTopFrame>0</WDTopFrame>
		<WDBotFrame>0</WDBotFrame>
		<LayFlags>65535</LayFlags>
		<WDMirrorThickness>0</WDMirrorThickness>
		<WDWallInset>0</WDWallInset>
		<SymbolColor>0</SymbolColor>
	</ParamSectHeader>
	<Parameters>
		<Length Name="A">
			<Description><![CDATA["Dimension 1"]]></Description>
			<Value>1</Value>
		</Length>
		<Length Name="B">
			<Description><![CDATA["Dimension 2"]]></Description>
			<Value>1</Value>
		</Length>
		<Length Name="ZZYZX">
			<Description><![CDATA["Height"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Integer Name="AC_WallContours">
			<Description><![CDATA["Wall Contours (0-None,1-Full,2-Side,3-Length)"]]></Description>
			<Value>0</Value>
		</Integer>
		<Integer Name="AC_Hole_Hotspot_Control">
			<Description><![CDATA["Hotspots 0-None,1-2D,2-3D,3-All"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>3</Value>
		</Integer>
		<Boolean Name="AC_show2DHotspotsIn3D">
			<Description><![CDATA["Show 2D Hotspots in 3D"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="ac_bottomlevel">
			<Description><![CDATA["Bottom Level"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Length Name="ac_toplevel">
			<Description><![CDATA["Top Level"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="AC_HoleSideMaterial">
			<Description><![CDATA["Hole has Wall's Side Surface"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="AC_HoleMaterialCurved">
			<Description><![CDATA["Hole Surface's Split is Curved in Curved Walls"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Integer Name="gs_macro_version">
			<Description><![CDATA["Macro Version"]]></Description>
			<Value>12</Value>
		</Integer>
		<Angle Name="AC_Hole_Position_Angle">
			<Description><![CDATA["Hole Position Angle"]]></Description>
			<Value>0</Value>
		</Angle>
		<Integer Name="AC_WallType">
			<Description><![CDATA["Wall Type"]]></Description>
			<Value>1</Value>
		</Integer>
		<Integer Name="AC_WindowInWallContour">
			<Description><![CDATA["Window in Wall Contour"]]></Description>
			<ArrayValues FirstDimension="4" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
			</ArrayValues>
		</Integer>
		<Length Name="AC_WallContourPolygon">
			<Description><![CDATA["Wall Contour Polygon"]]></Description>
			<ArrayValues FirstDimension="1" SecondDimension="3">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="AC_Wall_Direction_Type">
			<Description><![CDATA["Wall Direction Type"]]></Description>
			<Value>0</Value>
		</Integer>

		<!-- gs_wallhole_geometry: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_wallhole_geometry">
			<Description><![CDATA["Wallhole Geometry"]]></Description>
		</Title>
		<Length Name="refWidth">
			<Description><![CDATA["Reference Width"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="leftWidth">
			<Description><![CDATA["Left Offset from the Origo"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="rightWidth">
			<Description><![CDATA["Right Offset from the Origo"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="radBoard">
			<Description><![CDATA["Curved Wall - Board Radius"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="WOD">
			<Description><![CDATA["Curved Wall - Wall Center Distance"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="overSizeLower">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="offsY">
			<Description><![CDATA["Vertical Offset Size"]]></Description>
			<Value>0</Value>
		</Length>

		<!-- gs_macro_control_parameters: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_macro_control_parameters">
			<Description><![CDATA["Macro Control Parameters"]]></Description>
		</Title>
		<Integer Name="iPanelType">
			<Description><![CDATA["Window Panel Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Boolean Name="gs_IsCurved">
			<Description><![CDATA["Curved Window"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bParalellInCurvedWalls">
			<Description><![CDATA["Parallel Opening in Curved Walls"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bOpeningDirection">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bDoorWithSidelightSupport">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="iWindowShape">
			<Description><![CDATA["Window Shape"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Integer>

		<!-- iRevealType: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Integer Name="iRevealType">
			<Description><![CDATA["Reveal Type"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Angle Name="gs_reveal_left_angle">
			<Description><![CDATA["Angle Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Angle Name="gs_reveal_right_angle">
			<Description><![CDATA["Angle Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Length Name="gs_reveal_splayed_innerBottom">
			<Description><![CDATA["Inner Sill Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerBottom">
			<Description><![CDATA["Inner Sill Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerLeft_sL">
			<Description><![CDATA["Inner Lower Jamb Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerRight_sR">
			<Description><![CDATA["Inner Lower Jamb Depth Side 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerBottom_sL">
			<Description><![CDATA["Inner Sill Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerBottom_sR">
			<Description><![CDATA["Inner Sill Depth Side 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="leftRevealPnts">
			<Description><![CDATA["Left Reveal Points"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="rightRevealPnts">
			<Description><![CDATA["Right Reveal Points"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="iRevealPointsIdx">
			<Description><![CDATA["Reveal Points Index"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="20" SecondDimension="0">
				<AVal Row="1">1</AVal>
				<AVal Row="2">1</AVal>
				<AVal Row="3">1</AVal>
				<AVal Row="4">1</AVal>
				<AVal Row="5">1</AVal>
				<AVal Row="6">1</AVal>
				<AVal Row="7">1</AVal>
				<AVal Row="8">1</AVal>
				<AVal Row="9">1</AVal>
				<AVal Row="10">1</AVal>
				<AVal Row="11">1</AVal>
				<AVal Row="12">1</AVal>
				<AVal Row="13">1</AVal>
				<AVal Row="14">1</AVal>
				<AVal Row="15">1</AVal>
				<AVal Row="16">1</AVal>
				<AVal Row="17">1</AVal>
				<AVal Row="18">1</AVal>
				<AVal Row="19">1</AVal>
				<AVal Row="20">1</AVal>
			</ArrayValues>
		</Integer>
		<Length Name="skinOffsetBoard">
			<Description><![CDATA["Thickness of Hidden Wall Skins at Board Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- gs_turn_plaster: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_turn_plaster">
			<Description><![CDATA["Turn Plaster"]]></Description>
		</Title>
		<Boolean Name="gs_turn_plaster_show_3D">
			<Description><![CDATA["Show in 3D"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="thkPlasterAtBoardLeft">
			<Description><![CDATA["Plaster Thickness at Board - Left Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtBoardSlLeft">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtBoardRight">
			<Description><![CDATA["Plaster Thickness at Board - Right Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtBoardSlRight">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- gs_corner_functions: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_corner_functions">
			<Description><![CDATA["Corner Functions"]]></Description>
		</Title>
		<Boolean Name="bLeftCornerFunction">
			<Description><![CDATA["Left Corner"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Angle Name="leftCornerAngle">
			<Description><![CDATA["Left Corner Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Length Name="leftConnWallThk">
			<Description><![CDATA["Left Connected Wall Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="bRightCornerFunction">
			<Description><![CDATA["Right Corner"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Angle Name="rightCornerAngle">
			<Description><![CDATA["Right Corner Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Length Name="rightConnWallThk">
			<Description><![CDATA["Right Connected Wall Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- gs_window_oversize: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_window_oversize">
			<Description><![CDATA["Oversize"]]></Description>
		</Title>
		<Length Name="gs_left_oversize">
			<Description><![CDATA["Left Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_right_oversize">
			<Description><![CDATA["Right Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_lower_oversize">
			<Description><![CDATA["Lower Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="gs_sill_oversize">
			<Description><![CDATA["Sill Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="iSillType">
			<Description><![CDATA["Type of the Sill"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Length Name="gs_sill_thk">
			<Description><![CDATA["Sill Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.025</Value>
		</Length>

		<!-- gs_board_inside: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="gs_board_inside">
			<Description><![CDATA["Board"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="gs_board_inside_sl_left">
			<Description><![CDATA["Board - Sidelight Left"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="gs_board_inside_sl_right">
			<Description><![CDATA["Board - Sidelight Right"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bDrawBoard">
			<Description><![CDATA["Draw Board 2D and 3D"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Length Name="gs_board_width">
			<Description><![CDATA["Board Width"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.3</Value>
		</Length>
		<Length Name="gs_board_thk">
			<Description><![CDATA["Board Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.025</Value>
		</Length>
		<Length Name="gs_board_nosing">
			<Description><![CDATA["Board Nosing"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.03</Value>
		</Length>
		<Angle Name="gs_board_angle">
			<Description><![CDATA["Board Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Length Name="gs_board_ovhg_left">
			<Description><![CDATA["Board Overhang Left"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_board_ovhg_right">
			<Description><![CDATA["Board Overhang Right"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_board_slip_in">
			<Description><![CDATA["Board Slip-in Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="gs_board_curved">
			<Description><![CDATA["Board is Curved in Curved Walls"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bBoardInPolyWall">
			<Description><![CDATA["Board in Polygonal Walls"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bShowBoardSplice">
			<Description><![CDATA["Show Board Splice Lines (CW)"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bWindowSymbolAtMiddle">
			<Description><![CDATA["Window Symbol at Middle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="minBoardNosing">
			<Description><![CDATA["Minimal Nosing"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="minBoardOvhgLeft">
			<Description><![CDATA["Minimal Left Overhang"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="minBoardOvhgRight">
			<Description><![CDATA["Minimal Right Overhang"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- bDrawInsideTrim: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="bDrawInsideTrim">
			<Description><![CDATA["Casing Inside"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="gs_trim_thk_in">
			<Description><![CDATA["Thickness on Wall"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.019</Value>
		</Length>
		<Boolean Name="gs_trim_atframe_in">
			<Description><![CDATA["Casing at Frame Inside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="gs_trim_width_in">
			<Description><![CDATA["Thickness in Wallhole"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- gs_2D_representation: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_2D_representation">
			<Description><![CDATA["2D and Section Representation"]]></Description>
		</Title>
		<Integer Name="lod2D_sillBoard">
			<Description><![CDATA["Level of Detail in 2D"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Boolean Name="bShowAddHotspots">
			<Description><![CDATA["Show Additional Hotspots"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<PenColor Name="gs_pen_2D">
			<Description><![CDATA["2D Contour Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4</Value>
		</PenColor>
		<Boolean Name="gs_bFills">
			<Description><![CDATA["Use Fills"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<FillPattern Name="gs_board_wallhole_fill">
			<Description><![CDATA["Wallhole Fill Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</FillPattern>
		<PenColor Name="gs_board_wallhole_pen_fg">
			<Description><![CDATA["Wallhole Fill Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<PenColor Name="gs_board_wallhole_pen_bg">
			<Description><![CDATA["Wallhole Fill Background Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>92</Value>
		</PenColor>
		<FillPattern Name="gs_board_wallhole_fill_sl">
			<Description><![CDATA["Wallhole Fill Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</FillPattern>
		<PenColor Name="gs_board_wallhole_pen_sl_fg">
			<Description><![CDATA["Wallhole Fill Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<PenColor Name="gs_board_wallhole_pen_sl_bg">
			<Description><![CDATA["Wallhole Fill Background Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<PenColor Name="gs_board_pen_2D">
			<Description><![CDATA["Board 2D Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<PenColor Name="gs_board_pen_3D">
			<Description><![CDATA["Board 3D Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<FillPattern Name="gs_board_fill">
			<Description><![CDATA["Board Fill Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>65</Value>
		</FillPattern>
		<PenColor Name="gs_board_pen_fg">
			<Description><![CDATA["Board Fill Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<PenColor Name="gs_board_pen_bg">
			<Description><![CDATA["Board Fill Background Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<PenColor Name="gs_board_pen_sectcont">
			<Description><![CDATA["Section Contour Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>

		<!-- gs_3D_representation: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_3D_representation">
			<Description><![CDATA["3D Representation"]]></Description>
		</Title>
		<Integer Name="lod3D">
			<Description><![CDATA["Level of Detail in 3D"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<PenColor Name="gs_frame_pen">
			<Description><![CDATA["Frame Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>2</Value>
		</PenColor>

		<!-- gs_window_material: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_window_material">
			<Description><![CDATA["Surfaces"]]></Description>
		</Title>
		<Material Name="gs_board_mat">
			<Description><![CDATA["Board Surface"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>78</Value>
		</Material>

		<!-- ac_details: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="ac_details">
			<Description><![CDATA["Computed Oversize Values"]]></Description>
		</Title>
		<Length Name="ac_left_oversize">
			<Description><![CDATA["AC Left Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="ac_right_oversize">
			<Description><![CDATA["AC Right Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="ac_upper_oversize">
			<Description><![CDATA["AC Upper Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="ac_lower_oversize">
			<Description><![CDATA["AC Lower Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- gs_window_stack: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_window_stack">
			<Description><![CDATA["Ganging"]]></Description>
		</Title>
		<Boolean Name="gs_stack_left">
			<Description><![CDATA["Connection on the Left"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_stack_right">
			<Description><![CDATA["Connection on the Right"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_stack_bottom">
			<Description><![CDATA["Connection on the Bottom"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- gs_parapet_wall_inset: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="gs_parapet_wall_inset">
			<Description><![CDATA["Wall Inset"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="gs_parapet_inset_thk">
			<Description><![CDATA["Depth of Inset"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.2</Value>
		</Length>

		<!-- gs_sidelight_left: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="gs_sidelight_left">
			<Description><![CDATA["Left Sidelight"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="gs_sidelight_WHole_width_left">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_sidelight_parapet_hgt_left">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- gs_sidelight_right: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="gs_sidelight_right">
			<Description><![CDATA["Right Sidelight"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="gs_sidelight_WHole_width_right">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_sidelight_parapet_hgt_right">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- gs_string_resources: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_string_resources">
			<Description><![CDATA["String Resources"]]></Description>
		</Title>
		<String Name="stBoardUI">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="20" SecondDimension="0">
				<AVal Row="1"><![CDATA["Board"]]></AVal>
				<AVal Row="2"><![CDATA["Overhang Left"]]></AVal>
				<AVal Row="3"><![CDATA["Overhang Right"]]></AVal>
				<AVal Row="4"><![CDATA["Slip in Depth"]]></AVal>
				<AVal Row="5"><![CDATA["Is Curved in Curved Walls"]]></AVal>
				<AVal Row="6"><![CDATA["Surface"]]></AVal>
				<AVal Row="7"><![CDATA["Fill Type"]]></AVal>
				<AVal Row="8"><![CDATA["Fill Pen"]]></AVal>
				<AVal Row="9"><![CDATA["Background Pen"]]></AVal>
				<AVal Row="10"><![CDATA["Board Angle"]]></AVal>
				<AVal Row="11"><![CDATA["Board Thickness"]]></AVal>
				<AVal Row="12"><![CDATA["Board Nosing"]]></AVal>
				<AVal Row="13"><![CDATA["In Polygonal Walls"]]></AVal>
				<AVal Row="14"><![CDATA["Board Width"]]></AVal>
				<AVal Row="15"><![CDATA["Section Attributes"]]></AVal>
				<AVal Row="16"><![CDATA["Contour Pen"]]></AVal>
				<AVal Row="17"><![CDATA["Board - Sidelight 1"]]></AVal>
				<AVal Row="18"><![CDATA["Board - Sidelight 2"]]></AVal>
				<AVal Row="19"><![CDATA["Board - Sidelight"]]></AVal>
				<AVal Row="20"><![CDATA["Board is only available with a raised sidelight."]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stSubTabpageToolTip">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Sub Tab Page Selection: General Settings, Attributes"]]></Value>
		</String>

		<!-- gs_usa_parameters: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_usa_parameters">
			<Description><![CDATA["USA Parameters"]]></Description>
		</Title>
		<Length Name="bBoardElevUsa">
			<Description><![CDATA["Board Elevation (USA)"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="bBoardNnosUsa">
			<Description><![CDATA["Negative Nosing at Rebate Width Lower (USA)"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="frameWidthLeft">
			<Description><![CDATA["Frame Width at Left Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="frameWidthRight">
			<Description><![CDATA["Frame Width at Right Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Angle Name="gs_sill_angle">
			<Description><![CDATA["Sill Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Length Name="gs_rebw_lower">
			<Description><![CDATA["Rebate Width Lower"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="CasingInsLeftOutPoint">
			<Description><![CDATA[""]]></Description>
			<Value>0.1</Value>
		</Length>
		<Length Name="CasingInsRightOutPoint">
			<Description><![CDATA[""]]></Description>
			<Value>0.1</Value>
		</Length>
		<Integer Name="iBoardInPolyWall">
			<Description><![CDATA[""]]></Description>
			<Value>1</Value>
		</Integer>
		<String Name="stBoardInPolyWall">
			<Description><![CDATA[""]]></Description>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<Boolean Name="gs_trim_show_cover_in">
			<Description><![CDATA["Cover Inner Wall Surface"]]></Description>
			<Value>1</Value>
		</Boolean>
		<Angle Name="gs_reveal_bottom_angle">
			<Description><![CDATA["Cover Inner Wall Surface"]]></Description>
			<Value>20</Value>
		</Angle>
	</Parameters>
</ParamSection>
</Symbol>
