<?xml version="1.0" encoding="UTF-8"?>
<Symbol IsArchivable="no" IsPlaceable="no" MainGUID="83EA284F-5B98-46D3-BC8A-B6CF826AE017" MigrationValue="Normal" Owner="1196638531" Signature="1196644685" Version="34">
<Ancestry SectVersion="1" SectionFlags="0" SubIdent="0" Template="no">
	<MainGUID>F938E33A-329D-4A36-BE3E-85E126820996</MainGUID>
	<MainGUID>103E8D2C-8230-42E1-9597-46F84CCE28C0</MainGUID>
	<MainGUID>B2970E4C-8680-4061-8670-2F4B638F3953</MainGUID>
</Ancestry>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_3D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[

! Contact person: <NJ>

! ==============================================================================
! This macro cuts the wallhole
! ------------------------------------------------------------------------------
! Input parameters:
! Geometry ---------------------------------------------------------------------
!	A:						Window nominal width (length)
!	B:						Window nominal height (length)
!	archHeight:				Height of the arc (length)
!	nArchResolution:		Arc resolution for arched windows (integer)
!								if nArchResolution < 3 then WALL_RESOL used instead
! Functions --------------------------------------------------------------------
!	iWindowShape:			Shape of the window (integer)
!								0 = rectangular (default)
!								1 = arched
!							Note: only the rectangular shape can be a Corner Window
!	AC_Hole_Hotspot_Control:
!	AC_HoleSideMaterial:
!	AC_HoleMaterialCurved:
! Reveal -----------------------------------------------------------------------
!	iRevealType:
!	gs_reveal_left_angle:
!	gs_reveal_right_angle:
!	gs_reveal_top_angle:
!	gs_reveal_bottom_angle:
! Corner Function --------------------------------------------------------------
!	bLeftCornerFunction:		Turn macro in Corner Window mode at the left side (0 / 1)
!	leftCornerAngle:		Angle between connected walls in case of Corner Window (angle)
!	leftConnWallThk:		Thickness of the connected wall in case of Corner Window (length)
!	bRightCornerFunction:	Turn macro in Corner Window mode at the right side (0 / 1)
!	rightCornerAngle:		Angle between connected walls in case of Corner Window (angle)
!	rightConnWallThk:		Thickness of the connected wall in case of Corner Window (length)
!	bCornerWindow:			Traditional Corner Window
! Oversize ---------------------------------------------------------------------
!	gs_left_oversize:		Left opening oversize (length)
!	gs_right_oversize:		Right opening oversize (length)
!	gs_upper_oversize:		Upper opening oversize (length)
!	gs_lower_oversize:		Lower opening oversize (length)
! Ganging ----------------------------------------------------------------------
!	gs_stack_left:			Align to door/window on left side (0 / 1)
!	gs_stack_right:			Align to door/window on right side (0 / 1)
!	gs_stack_top:			Align to door/window on upper side (0 / 1)
!	gs_stack_bottom:		Align to door/window on bottom side (0 / 1)
! Parapet ----------------------------------------------------------------------
!	gs_parapet_wall_inset:	Switch on / off the Wall Inset function. (0 / 1)
!	gs_parapet_inset_thk:	Depth of Wall Inset. (length)
!	gs_parapet_width:		Parapet width (length)
!	gs_parapet_height:		Parapet height (length)
!
! Related Global Variables:
!	WALL_THICKNESS
!	WALL_VIEW_PEN
!	WIDO_FRAME_THICKNESS
!	WIDO_SILL
!	WIDO_ORIG_DIST
!	WIDO_REVEAL_SIDE
!	SYMB_MIRRORED
!	SYMB_ROTANGLE
! ==============================================================================

_bCustomMatNicheTop		= 0

! === Turn Plaster in 3D ===[

thkPlasterAtSillLeft	= thkPlasterAtSillLeft		* gs_turn_plaster_show_3D
thkPlasterAtSillRight	= thkPlasterAtSillRight		* gs_turn_plaster_show_3D
thkPlasterAtSillTop		= thkPlasterAtSillTop		* gs_turn_plaster_show_3D
thkPlasterAtSillBottom	= thkPlasterAtSillBottom	* gs_turn_plaster_show_3D

thkPlasterAtSillSlLeft			= thkPlasterAtSillSlLeft		* gs_turn_plaster_show_3D
thkPlasterAtSillSlLeftBottom	= thkPlasterAtSillSlLeftBottom	* gs_turn_plaster_show_3D
thkPlasterAtSillSlRight			= thkPlasterAtSillSlRight		* gs_turn_plaster_show_3D
thkPlasterAtSillSlRightBottom	= thkPlasterAtSillSlRightBottom	* gs_turn_plaster_show_3D

thkPlasterAtBoardLeft	= thkPlasterAtBoardLeft		* gs_turn_plaster_show_3D
thkPlasterAtBoardRight	= thkPlasterAtBoardRight	* gs_turn_plaster_show_3D
thkPlasterAtBoardTop	= thkPlasterAtBoardTop		* gs_turn_plaster_show_3D
thkPlasterAtBoardBottom	= thkPlasterAtBoardBottom	* gs_turn_plaster_show_3D

thkPlasterAtBoardSlLeft			= thkPlasterAtBoardSlLeft		* gs_turn_plaster_show_3D
thkPlasterAtBoardSlLeftBottom	= thkPlasterAtBoardSlLeftBottom	* gs_turn_plaster_show_3D
thkPlasterAtBoardSlRight		= thkPlasterAtBoardSlRight		* gs_turn_plaster_show_3D
thkPlasterAtBoardSlRightBottom	= thkPlasterAtBoardSlRightBottom* gs_turn_plaster_show_3D

thkPlasterAtSill	= max(thkPlasterAtSillLeft, thkPlasterAtSillRight, thkPlasterAtSillTop, thkPlasterAtSillBottom)
thkPlasterAtBoard	= max(thkPlasterAtBoardLeft, thkPlasterAtBoardRight, thkPlasterAtBoardTop, thkPlasterAtBoardBottom)

SillPlasterAtFrame	= thkPlasterAtSill  * (iRevealType = REVEAL_NEGATIVE | (iRevealType = REVEAL_DOUBLE & iSillRevealType = REVEAL_NEGATIVE))
BoardPlasterAtFrame	= thkPlasterAtBoard * (iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC | (iRevealType = REVEAL_DOUBLE & iBoardRevealType = REVEAL_NEGATIVE))

if not(bCut3DWallhole) then

	! void cut if no wallhole is needed
	addz -2 * WALL_THICKNESS - 1
	wallniche 4, 1, 2+16,
		0,0,1,	0.1,
		-0.1,	0,		31,
		-0.1,	0.1,	31,
		 0.1,	0.1,	31,
		 0.1,	0,		31
	del 1
	end
endif

!!! Chinese
signRevealSide = not(WIDO_REVEAL_SIDE) - WIDO_REVEAL_SIDE
SymbolMid_shiftDy = bDWSymbolAtMiddle * (WIDO_SILL - WALL_THICKNESS / 2 + WIDO_FRAME_THICKNESS / 2) * signRevealSide

addz -SymbolMid_shiftDy

! === Window Shape related definitions ===[

bNeedMiddleCut = 0

if iRevealType = REVEAL_DOUBLE then
	CustRevealOffsetDepth	= WIDO_FRAME_THICKNESS
	CustRevealLeftJamb		= revealInnerLeft
	CustRevealRightJamb		= revealInnerRight
	CustRevealTopJamb		= gs_reveal_double_innerTop
	CustRevealBottJamb		= gs_reveal_double_innerBottom
else
	CustRevealOffsetDepth	= 0
	CustRevealLeftJamb		= 0
	CustRevealRightJamb		= 0
	CustRevealTopJamb		= 0
	CustRevealBottJamb		= 0
endif

if thkPlasterAtBoardLeft > EPS | thkPlasterAtBoardRight > EPS | thkPlasterAtBoardTop > EPS | thkPlasterAtBoardBottom > EPS then
	bNeedMiddleCut = 1
	CustRevealOffsetDepth	= WIDO_FRAME_THICKNESS
endif
if iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE | iRevealType = REVEAL_DOUBLE_SPLAYED then
	bNeedMiddleCut = 1
endif


if iWindowShape <> SHAPE_MULTISIDE then
	if nArchResolution < 3 then nArchResolution = WALL_RESOL
endif

if iWindowShape = SHAPE_ARCHED then
	if archHeight < EPS then
		iWindowShape = SHAPE_RECTANGULAR		! Switch back to rectangular shape
	else
		if archHeight > (openingWidth / 2 - EPS) then
			archHeight = openingWidth / 2
			arcR = archHeight
			bHalfCircle = 1
		else
			arcR = (openingWidth / 2) / sin(2 * atn(archHeight / (openingWidth / 2)))
			bHalfCircle = 0
		endif
	endif
endif

if iWindowShape = SHAPE_HALFARCH then
	if archHeight < EPS then
		iWindowShape = SHAPE_RECTANGULAR		! Switch back to rectangular shape
	else
		arcR = (openingWidth * openingWidth + archHeight * archHeight) / (2 * archHeight)
		shoulder_angle	= ACS(openingWidth / arcR)

		!Sill
		if curvedWall & not(bParalellInCurvedWalls) then
			thkPlasterAtSillLeft_distx	= thkPlasterAtSillLeft  / cos(alfaLeftOs  - alfaLeftJamb)
			thkPlasterAtSillRight_distx	= thkPlasterAtSillRight / cos(alfaRightOs - alfaRightJamb)
			offLeft		= leftWidth  - abs(WOD) * tan(alfaLeftOs  - alfaLeftJamb)  + gs_left_oversize  + thkPlasterAtSillLeft_distx  + SillPlasterAtFrame * tan(alfaLeftOs  - alfaLeftJamb)
			offRight	= rightWidth - abs(WOD) * tan(alfaRightOs - alfaRightJamb) + gs_right_oversize + thkPlasterAtSillRight_distx + SillPlasterAtFrame * tan(alfaRightOs - alfaRightJamb)
		else
			offLeft	 = leftJamb  + thkPlasterAtSillLeft
			offRight = rightJamb + thkPlasterAtSillRight
		endif
		offTop = upperJamb + thkPlasterAtSillTop
		x1 = rightWidth + overSizeRight * not(bRightCornerFunction) - offRight
		y1 = 0
		x2 = x1
		y2 = openingHeight+1
		xo = rightWidth + overSizeRight * not(bRightCornerFunction)
		yo = B + overSizeUpper - arcR
		ro = arcR - offTop

		GOSUB 101	! Circle - Line intersection
		if ya > yb then
			SillTopy	= ya
		else
			SillTopy	= yb
		endif
		SillTopx	= x1

		x1 = -leftWidth - overSizeLeft + offLeft
		x2 = x1
		GOSUB 101	! Circle - Line intersection
		if ya > yb then
			SillShouldy	= ya
		else
			SillShouldy	= yb
		endif
		SillShouldx	= x1

		!Board
		if curvedWall & not(bParalellInCurvedWalls) then
			thkPlasterAtBoardLeft_distx	 = thkPlasterAtBoardLeft  / cos(alfaLeftInnJamb)
			thkPlasterAtBoardRight_distx = thkPlasterAtBoardRight / cos(alfaRightInnJamb)
			if iRevealType = REVEAL_DOUBLE exor wallIsLeft then
				dxL = WIDO_FRAME_THICKNESS * tan(alfaLeftOs)
				dxR = WIDO_FRAME_THICKNESS * tan(alfaRightOs)
			else
				dxL = 0
				dxR = 0
			endif

			offLeft		= CustRevealLeftJamb  + thkPlasterAtBoardLeft_distx  + BoardPlasterAtFrame * tan(alfaLeftInnJamb)  - dxL
			offRight	= CustRevealRightJamb + thkPlasterAtBoardRight_distx + BoardPlasterAtFrame * tan(alfaRightInnJamb) - dxR
		else
			offLeft		= CustRevealLeftJamb   + thkPlasterAtBoardLeft
			offRight	= CustRevealRightJamb  + thkPlasterAtBoardRight
		endif
		offTop = CustRevealTopJamb + thkPlasterAtBoardTop
		x1 = rightWidth + overSizeRight * not(bRightCornerFunction) - offRight
		y1 = 0
		x2 = x1
		y2 = openingHeight+1
		ro = arcR - offTop

		GOSUB 101	! Circle - Line intersection
		if ya > yb then
			BoardTopy	= ya
		else
			BoardTopy	= yb
		endif
		BoardTopx	= x1

		x1 = -leftWidth - overSizeLeft + offLeft
		x2 = x1
		GOSUB 101	! Circle - Line intersection
		if ya > yb then
			BoardShouldy	= ya
		else
			BoardShouldy	= yb
		endif
		BoardShouldx	= x1

		!Frame
		if curvedWall & not(bParalellInCurvedWalls) & wallIsLeft then
			offLeft		= -WIDO_FRAME_THICKNESS * tan(alfaLeftOs)
			offRight	= -WIDO_FRAME_THICKNESS * tan(alfaRightOs)
		else
			offLeft		= 0
			offRight	= 0
		endif
		offTop = 0

		x1 = rightWidth + overSizeRight * not(bRightCornerFunction) - offRight
		y1 = 0
		x2 = x1
		y2 = openingHeight+1
		ro = arcR - offTop

		GOSUB 101	! Circle - Line intersection
		if ya > yb then
			FrameTopy	= ya
		else
			FrameTopy	= yb
		endif
		FrameTopx	= x1

		x1 = -leftWidth - overSizeLeft + offLeft
		x2 = x1
		GOSUB 101	! Circle - Line intersection
		if ya > yb then
			FrameShouldy	= ya
		else
			FrameShouldy	= yb
		endif
		FrameShouldx	= x1

		opWidth = openingWidth - leftJamb - rightJamb
		arcR_revealSide = (opWidth * opWidth + archHeight * archHeight) / (2 * archHeight)
		bFullArc = (abs(openingWidth - archHeight) < EPS)
	endif
endif

if iWindowShape = SHAPE_HALFROUND then

	ang_segm = 360 / nArchResolution

	offSillRight = rightJamb + thkPlasterAtSillRight

	xa = openingWidth * cos(-90)
	ya = openingHeight / 2 * sin(-90)
	if ABS(ya) < EPS then
		ang_cent = -90
	else
		ang_cent = ATN(xa/ya)
	endif

	xa_el = openingWidth * cos(-90 - ang_segm)
	ya_el = openingHeight / 2 * sin(-90 - ang_segm)
	if ABS(ya_el) < EPS then
		ang_cent_el = -90
	else
		ang_cent_el = ATN(xa_el/ya_el)
	endif

	xa_ut = openingWidth * cos(-90 + ang_segm)
	ya_ut = openingHeight / 2 * sin(-90 + ang_segm)
	if ABS(ya_ut) < EPS then
		ang_cent_ut = -90
	else
		ang_cent_ut = ATN(xa_ut/ya_ut)
	endif

	if xa_ut - ABS( offSillRight * sin(ang_cent_ut)) > offSillRight then
		x11 = offSillRight
		y11 = -openingHeight
		x12 = offSillRight
		y12 = openingHeight
		x21 = xa 	- ABS( offSillRight * sin(ang_cent))
		y21 = ya 	+ ( offSillRight * cos(ang_cent))
		x22 = xa_ut - ABS( offSillRight * sin(ang_cent_ut))
		y22 = ya_ut + ( offSillRight * cos(ang_cent_ut))
		GOSUB 100

		sillArcoffs = openingHeight/2 - ABS(cy)
	else
		sillArcoffs = 0
	endif


	offBoardRight = CustRevealRightJamb + thkPlasterAtBoardRight

	xa = openingWidth * cos(-90)
	ya = openingHeight / 2 * sin(-90)
	if ABS(ya) < EPS then
		ang_cent = -90
	else
		ang_cent = ATN(xa/ya)
	endif

	xa_el = openingWidth * cos(-90 - ang_segm)
	ya_el = openingHeight / 2 * sin(-90 - ang_segm)
	if ABS(ya_el) < EPS then
		ang_cent_el = -90
	else
		ang_cent_el = ATN(xa_el/ya_el)
	endif

	xa_ut = openingWidth * cos(-90 + ang_segm)
	ya_ut = openingHeight / 2 * sin(-90 + ang_segm)
	if ABS(ya_ut) < EPS then
		ang_cent_ut = -90
	else
		ang_cent_ut = ATN(xa_ut/ya_ut)
	endif

	if xa_ut - ABS( offBoardRight * sin(ang_cent_ut)) > offBoardRight then
		x11 = offBoardRight
		y11 = -openingHeight
		x12 = offBoardRight
		y12 = openingHeight
		x21 = xa 	- ABS( offBoardRight * sin(ang_cent))
		y21 = ya 	+ ( offBoardRight * cos(ang_cent))
		x22 = xa_ut - ABS( offBoardRight * sin(ang_cent_ut))
		y22 = ya_ut + ( offBoardRight * cos(ang_cent_ut))
		GOSUB 100

		boardArcoffs = openingHeight/2 - ABS(cy)
	else
		boardArcoffs = 0
	endif
endif

if iWindowShape = SHAPE_GOTHICARCH then
	if archHeight < EPS then
		iWindowShape = SHAPE_RECTANGULAR		! Switch back to rectangular shape
	else
		arcR = (openingWidth / 4) + (archHeight * archHeight / openingWidth)
		centSillArcoffs		= archHeight - SQR((arcR - rightJamb - thkPlasterAtSillRight)^2 - (arcR - openingWidth/2)^2)
		centBoardArcoffs	= archHeight - SQR((arcR - CustRevealRightJamb - thkPlasterAtBoardRight)^2 - (arcR - openingWidth/2)^2)
	endif
endif

if iWindowShape = SHAPE_PENTAGON then
	if archHeight < EPS then
		iWindowShape = SHAPE_RECTANGULAR		! Switch back to rectangular shape
	else
		tan_topAngle = archHeight / (openingWidth / 2)
	endif
endif

if iWindowShape = SHAPE_ELLIPSEARCH then
	if archHeight < EPS then
		iWindowShape = SHAPE_RECTANGULAR		! Switch back to rectangular shape
	else
		middleRadiusEllips = (openingWidth * openingWidth / 4 - openingWidth * smallRadiusEllips + archHeight * archHeight) / (2 * archHeight - 2 * smallRadiusEllips)
		smallRadiusEllips_reveal = smallRadiusEllips - rightJamb - thkPlasterAtSillRight
		middleRadiusEllips_reveal = middleRadiusEllips - rightJamb - thkPlasterAtSillRight

		smallRadiusEllips_Innreveal = smallRadiusEllips - CustRevealRightJamb - thkPlasterAtBoardRight
		middleRadiusEllips_Innreveal = middleRadiusEllips - CustRevealRightJamb - thkPlasterAtBoardRight

		if abs(openingWidth / 2 - smallRadiusEllips) > EPS then
			alphaSide = atn ((middleRadiusEllips - archHeight) / (openingWidth / 2 - smallRadiusEllips))
		else
			alphaSide = 0
		endif
		alphaMiddle = (90 - alphaSide) * 2

		if abs((openingWidth - 2 * rightJamb) / 2 - smallRadiusEllips_reveal) > EPS then
			alphaSide_reveal = atn((middleRadiusEllips_reveal - (archHeight - rightJamb)) / ((openingWidth - 2 * rightJamb) / 2 - smallRadiusEllips_reveal))
		else
			alphaSide_reveal = 0
		endif
		alphaMiddle_reveal = 90 - alphaSide_reveal

		if abs((openingWidth - 2 * CustRevealRightJamb) / 2 - smallRadiusEllips_Innreveal) > EPS then
			alphaSide_Innreveal = atn((middleRadiusEllips_Innreveal - (archHeight - CustRevealRightJamb)) / ((openingWidth - 2 * CustRevealRightJamb) / 2 - smallRadiusEllips_Innreveal))
		else
			alphaSide_Innreveal = 0
		endif
		alphaMiddle_Innreveal = 90 - alphaSide_Innreveal
	endif
endif

if iWindowShape = SHAPE_TRAPEZOID then
	if archHeight < EPS then
		iWindowShape = SHAPE_RECTANGULAR		! Switch back to rectangular shape
	else
		tan_topAngle = archHeight / ac_wallhole_width
		archHeighT_Reveal =  ((openingWidth + oversizeRight - leftJamb - rightJamb) * archHeight)  / (openingWidth + oversizeRight)
		archHeight_Innreveal =  ((openingWidth + oversizeRight - CustRevealLeftJamb - CustRevealRightJamb) * archHeight)  / (openingWidth + oversizeRight)

	endif
endif

if iWindowShape = SHAPE_TRIANGLE then
	tan_LeftSide = ac_wallhole_height / (ac_wallhole_width / 2 + gs_posTopEdge_triangle)
	tan_RightSide = ac_wallhole_height / (ac_wallhole_width / 2 - gs_posTopEdge_triangle)
endif

if iWindowShape = SHAPE_PARALLELOGRAM then
	if archHeight < EPS then
		iWindowShape = SHAPE_RECTANGULAR		! Switch back to rectangular shape
	else
		tan_topAngle = archHeight / openingWidth
		upperJambModify =  (1 / cos(atn(archHeight / (openingWidth + oversizeRight))))
		archHeighT_Reveal =  ((openingWidth + oversizeRight - leftJamb - rightJamb) * archHeight)  / (openingWidth + oversizeRight)
		archHeight_Innreveal =  ((openingWidth + oversizeRight - CustRevealLeftJamb - CustRevealRightJamb) * archHeight)  / (openingWidth + oversizeRight)
	endif
endif

if iWindowShape = SHAPE_ROMBUS then
	upperJambModify	= (1 / cos(atn(openingHeight / openingWidth)))
	sideJambModify	= (1 / cos(atn(openingWidth / openingHeight)))
endif

if iWindowShape = SHAPE_MULTISIDE then
	if gs_numOfSides = 4 then
		iWindowShape = SHAPE_RECTANGULAR		! Switch back to rectangular shape
	else
		if (gs_numOfSides MOD 2) = 0 then
			if (gs_numOfSides MOD 4) = 0 then
				normalRadius = (openingWidth / 2) / (cos (180 / gs_numOfSides))
			else
				normalRadius = openingWidth / 2
			endif
		else
			if gs_numOfSides = 3 then
				normalRadius = (openingWidth / 2) / (cos (30))
			else
				normalRadius = (openingWidth / 2) / (sin (((gs_numOfSides - 1) * 90) / gs_numOfSides))
			endif
		endif
		revealRadius	= normalRadius - rightJamb / cos (180 / gs_numOfSides)
		innrevealRadius	= normalRadius - CustRevealRightJamb / cos (180 / gs_numOfSides)
		plasterOffs		= thkPlasterAtSillRight		/ cos (180 / gs_numOfSides)
		innplasterOffs	= thkPlasterAtBoardRight	/ cos (180 / gs_numOfSides)
	endif
endif

if iWindowShape = SHAPE_OCTAGONAL then
	normalRadius	= openingHeight / (2 * cos (22.5))
	revealRadius	= (openingHeight - 2 * rightJamb) / (2 * cos (22.5))
	innrevealRadius	= (openingHeight - 2 * CustRevealRightJamb) / (2 * cos (22.5))
	plasterOffs		= (2 * thkPlasterAtSillRight) / (2 * cos (22.5))
	innplasterOffs	= (2 * thkPlasterAtBoardRight) / (2 * cos (22.5))
endif

if iWindowShape = SHAPE_HALFCIRCLE then
	archHeight = openingWidth / 2
	arcR = archHeight
endif

if iWindowShape = SHAPE_ARCHED_T then
	if archHeight < EPS then
		iWindowShape = SHAPE_T		! Switch back to rectangular T shape
	else
		if archHeight > (openingWidth / 2 - EPS) then
			archHeight = openingWidth / 2
			arcR = archHeight
			bHalfCircle = 1
		else
			arcR = (openingWidth / 2) / sin(2 * atn(archHeight / (openingWidth / 2)))
			bHalfCircle = 0
		endif
	endif
endif

if iWindowShape = SHAPE_T then
	if gs_sidelight_parapet_hgt_left < EPS & gs_sidelight_parapet_hgt_right < EPS then iWindowShape = SHAPE_RECTANGULAR
	if gs_sidelight_parapet_hgt_left < EPS & gs_sidelight_parapet_hgt_right > EPS then iWindowShape = SHAPE_HALF_T_RIGHT
	if gs_sidelight_parapet_hgt_left > EPS & gs_sidelight_parapet_hgt_right < EPS then iWindowShape = SHAPE_HALF_T_LEFT
endif

if iWindowShape = SHAPE_ARCHED_T then
	if gs_sidelight_parapet_hgt_left < EPS & gs_sidelight_parapet_hgt_right < EPS then iWindowShape = SHAPE_ARCHED
	if gs_sidelight_parapet_hgt_left < EPS & gs_sidelight_parapet_hgt_right > EPS then iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT
	if gs_sidelight_parapet_hgt_left > EPS & gs_sidelight_parapet_hgt_right < EPS then iWindowShape = SHAPE_ARCHED_HALF_T_LEFT
endif

if iWindowShape = SHAPE_ARCHED_HALF_T_LEFT | iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT then
	if archHeight < EPS then
		if iWindowShape = SHAPE_ARCHED_HALF_T_LEFT then
			iWindowShape = SHAPE_HALF_T_LEFT	! Switch back to rectangular half - T shape
		else
			iWindowShape = SHAPE_HALF_T_RIGHT	! Switch back to rectangular half - T shape
		endif
	else
		if archHeight > (openingWidth / 2 - EPS) then
			archHeight = openingWidth / 2
			arcR = archHeight
			bHalfCircle = 1
		else
			arcR = (openingWidth / 2) / sin(2 * atn(archHeight / (openingWidth / 2)))
			bHalfCircle = 0
		endif
	endif
endif

if iWindowShape = SHAPE_HORSESHOE then
	RadArch = ((ArchHeight - gs_lowerArchHeight)^2 +(openingWidth/2)^2) / openingWidth

	x1 = 0
	y1 = 0
	x2 = 0
	y2 = openingHeight + 1
	xo = openingWidth / 2 - RadArch
	yo = openingHeight - (ArchHeight - gs_lowerArchHeight)
	ro = RadArch - rightJamb - thkPlasterAtSillRight

	gosub 101	! Circle - Line intersection

	if ya > yb then
		SillHighArcoffs = ya
	else
		SillHighArcoffs = yb
	endif

	ro = RadArch
	gosub 101	! Circle - Line intersection

	if ya > yb then
		FrameHighArcoffs = ya
	else
		FrameHighArcoffs = yb
	endif

	ro = RadArch - CustRevealRightJamb - thkPlasterAtBoardRight
	gosub 101	! Circle - Line intersection

	if ya > yb then
		BoardHighArcoffs = ya
	else
		BoardHighArcoffs = yb
	endif


	x1 = -openingWidth / 2
	y1 = openingHeight - ArchHeight - rightJamb - thkPlasterAtSillRight
	x2 = openingWidth / 2
	y2 = openingHeight - ArchHeight - rightJamb - thkPlasterAtSillRight
	xo = openingWidth / 2 - RadArch
	yo = openingHeight - (ArchHeight - gs_lowerArchHeight)
	ro = RadArch - rightJamb - thkPlasterAtSillRight

	gosub 101	! Circle - Line intersection

	if state then
		SillLowArcoffsy = ya

		if xa < xb then
			SillLowArcoffsx = xb
		else
			SillLowArcoffsx = xa
		endif
	else
		SillLowArcoffsx = openingWidth / 2 - RadArch
		SillLowArcoffsy = openingHeight - ArchHeight - rightJamb - thkPlasterAtSillRight
	endif

	y1 = openingHeight - ArchHeight
	y2 = openingHeight - ArchHeight
	ro = RadArch

	gosub 101	! Circle - Line intersection

	FrameLowArcoffsy = ya

	if xa < xb then
		FrameLowArcoffsx = xb
	else
		FrameLowArcoffsx = xa
	endif


	y1 = openingHeight - ArchHeight - CustRevealRightJamb - thkPlasterAtBoardRight
	y2 = openingHeight - ArchHeight - CustRevealRightJamb - thkPlasterAtBoardRight
	ro = RadArch - CustRevealRightJamb - thkPlasterAtBoardRight

	gosub 101	! Circle - Line intersection

	if state then
		BoardLowArcoffsy = ya

		if xa < xb then
			BoardLowArcoffsx = xb
		else
			BoardLowArcoffsx = xa
		endif
	else
		BoardLowArcoffsx = openingWidth / 2 - RadArch
		BoardLowArcoffsy = openingHeight - ArchHeight - CustRevealRightJamb - thkPlasterAtBoardRight
	endif
endif

if iWindowShape = SHAPE_OGEECENTERED then
	gs_shoulder_height	= openingHeight - ArchHeight

	RadArc = ((ArchHeight / 2)^2 + (openingWidth / 4)^2) / (openingWidth / 2)

	x1 = 0
	y1 = 0
	x2 = 0
	y2 = openingHeight
	xo = RadArc
	yo = openingHeight
	ro = RadArc + rightJamb + thkPlasterAtSillRight

	if thkPlasterAtSillRight | rightJamb then

		gosub 101	! Circle - Line intersection

		if ya < yb then
			centSillArcoffs = ya
		else
			centSillArcoffs = yb
		endif
	else
		centSillArcoffs = openingHeight
	endif


	ro = RadArc + CustRevealRightJamb + thkPlasterAtBoardRight

	if thkPlasterAtBoardRight | CustRevealRightJamb then

		gosub 101	! Circle - Line intersection

		if ya < yb then
			centBoardArcoffs = ya
		else
			centBoardArcoffs = yb
		endif
	else
		centBoardArcoffs = openingHeight
	endif
endif

if iWindowShape = SHAPE_SARACENIC then
	gs_shoulder_height	= openingHeight - ArchHeight
	rOrigArc = (ArchHeight)*COS(30)

	radArch = (openingWidth / 2 * tan(30) - ArchHeight) / (tan(30) - cos(60) * tan(30) - sin(60))

	FrametangArcx 	= openingWidth / 2 - radArch + (radArch) * cos(60)
	FrametangArcy 	= openingHeight - ArchHeight + (radArch) * sin(60)

	SilltangArcx = openingWidth / 2 - radArch + (radArch - rightJamb - thkPlasterAtSillRight) * cos(60)
	SilltangArcy = openingHeight - ArchHeight + (radArch - rightJamb - thkPlasterAtSillRight) * sin(60)
	centSillArcoffs = openingHeight - (rightJamb + thkPlasterAtSillRight) / cos(30)

	BoardtangArcx = openingWidth / 2 - radArch + (radArch - CustRevealRightJamb - thkPlasterAtBoardRight) * cos(60)
	BoardtangArcy = openingHeight - ArchHeight + (radArch - CustRevealRightJamb - thkPlasterAtBoardRight) * sin(60)
	centBoardArcoffs = openingHeight - (CustRevealRightJamb + thkPlasterAtBoardRight) / cos(30)

endif


! ]=== Window Shape related definitions ===

pen WALL_VIEW_PEN
if nArchResolution > 3 then resol nArchResolution

if AC_HoleSideMaterial then
	if WIDO_REVEAL_SIDE then
		matRevealSide	= WALL_MAT_A
		matOppositeSide = WALL_MAT_B
	else
		matRevealSide	= WALL_MAT_B
		matOppositeSide = WALL_MAT_A
	endif
else
	matRevealSide	= WALL_MAT_EDGE
	matOppositeSide = WALL_MAT_EDGE
endif


leftDx	= 0
rightDx	= 0
if bSlantedInnerSide then
	if curvedWall then

			if gs_stack_left  then
			gs_reveal_left_angle  = alfaLeftOs
!			rightDx = WIDO_FRAME_THICKNESS * tan(alfaLeftOs)
			endif
			if gs_stack_right then
			gs_reveal_right_angle  = alfaRightOs
!			leftDx = WIDO_FRAME_THICKNESS * tan(alfaRightOs)
		endif

		if not(wallIsLeft) then
			leftDx	= 0
			rightDx	= 0
		endif
	endif
endif


if iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC then
	offsetInsideDepth	= WIDO_FRAME_THICKNESS
	offsetInsideLeft	= revealInnerLeft
	offsetInsideRight	= revealInnerRight
	offsetInsideTop		= gs_reveal_splayed_innerTop
	offsetInsideBott	= gs_reveal_splayed_innerBottom
else
	offsetInsideDepth	= 0
	offsetInsideRight	= 0
	offsetInsideLeft	= 0
	offsetInsideTop		= 0
	offsetInsideBott	= 0
endif
if iRevealType = REVEAL_DOUBLE_SPLAYED then
	offsetInsideDepth	= WIDO_FRAME_THICKNESS
	offsetOutsideDepth	= 0
endif

bSillIsHorizontal	= ( iWindowShape = SHAPE_RECTANGULAR			| \
						iWindowShape = SHAPE_ARCHED					| \
						iWindowShape = SHAPE_HALFARCH				| \
						iWindowShape = SHAPE_ELLIPSEARCH			| \
						iWindowShape = SHAPE_EYEBROWS				| \
						iWindowShape = SHAPE_PENTAGON				| \
						iWindowShape = SHAPE_TRAPEZOID				| \
						iWindowShape = SHAPE_TRIANGLE				| \
						iWindowShape = SHAPE_CORNER_TRIANGLE		| \
						iWindowShape = SHAPE_PARALLELOGRAM			| \
						iWindowShape = SHAPE_GOTHICARCH				| \
						iWindowShape = SHAPE_HALFCIRCLE				| \
						iWindowShape = SHAPE_QUARTERROUND			| \
						iWindowShape = SHAPE_QUARTERROUND_NOFRAME )


! ==============================================================================
! Wallhole Hotspots
! ==============================================================================

gs_wallhole_width_half = 0
gs_reveal_width_half = 0

if WIDO_REVEAL_SIDE then
	addz WIDO_FRAME_THICKNESS
	mulz -1
endif

unID = 11100

! Board side offsets
dxBL = leftRevealPnts[idxBoardEndRevealLeft][1]
dxBR = rightRevealPnts[idxBoardEndRevealRight][1]

! Reveal side offsets
dxSL = leftRevealPnts[idxSillStartRevealLeft][1]
dxSR = rightRevealPnts[idxSillStartRevealRight][1]

! Slanted and Splayed reveal offsets - at the Top
if bSlantedInnerSide & not(gs_stack_top) then
	dyBLT =  ((leftRevealPnts[idxBoardEndRevealLeft][2]  - (iRevealType <> REVEAL_SLANTED) * WIDO_FRAME_THICKNESS) * tan(gs_reveal_top_angle) - (iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_SPLAYED) * gs_reveal_splayed_InnerTop)	! Top Left
	dyBRT = ((rightRevealPnts[idxBoardEndRevealRight][2] - (iRevealType <> REVEAL_SLANTED) * WIDO_FRAME_THICKNESS) * tan(gs_reveal_top_angle) - (iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_SPLAYED) * gs_reveal_splayed_InnerTop)	! Top Right
else
	dyBLT = 0
	dyBRT = 0
endif

! Slanted and Splayed reveal offsets - at the Bottom
if bSlantedInnerSide & not(gs_stack_bottom) & isWindow then
	dyBLB =  ((leftRevealPnts[idxBoardEndRevealLeft][2]  - (iRevealType <> REVEAL_SLANTED) * WIDO_FRAME_THICKNESS) * tan(gs_reveal_bottom_angle) - (iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_SPLAYED) * gs_reveal_splayed_InnerBottom)	! Bottom Left
	dyBRB = ((rightRevealPnts[idxBoardEndRevealRight][2] - (iRevealType <> REVEAL_SLANTED) * WIDO_FRAME_THICKNESS) * tan(gs_reveal_bottom_angle) - (iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_SPLAYED) * gs_reveal_splayed_InnerBottom)	! Bottom Right
else
	dyBLB = 0
	dyBRB = 0
endif

if	iWindowShape = SHAPE_RECTANGULAR			| \
	iWindowShape = SHAPE_ARCHED					| \
	iWindowShape = SHAPE_ELLIPSEARCH			| \
	iWindowShape = SHAPE_EYEBROWS				| \
	iWindowShape = SHAPE_HALFCIRCLE				| \
	iWindowShape = SHAPE_HALFARCH				| \
	iWindowShape = SHAPE_PENTAGON				| \
	iWindowShape = SHAPE_QUARTERROUND			| \
	iWindowShape = SHAPE_QUARTERROUND_NOFRAME	| \
	iWindowShape = SHAPE_TRIANGLE				| \
	iWindowShape = SHAPE_GOTHICARCH				| \
	iWindowShape = SHAPE_CORNER_TRIANGLE		| \
	iWindowShape = SHAPE_TRAPEZOID then

! Board Side Hotspots ----------------------------------------------------------

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0,-dyBLB,						0, unID
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0,-dyBRB,						0, unID
	del 1
	unID = unID + 2

! Sill Side Hotspots -----------------------------------------------------------

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO | ((iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) & gs_mountingFrame) then
		if (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) then
			hptsYL = -elevationOffset - (bSlantedOuterSide & not(gs_stack_bottom)) * ( -leftRevealPnts[idxSillStartRevealLeft][2]  - gs_mountingFrame_depth) * tan(gs_reveal_outerBottom_angle)
			hptsYR = -elevationOffset - (bSlantedOuterSide & not(gs_stack_bottom)) * (-rightRevealPnts[idxSillStartRevealRight][2] - gs_mountingFrame_depth) * tan(gs_reveal_outerBottom_angle)
		else
			hptsYL = -elevationOffset + gs_reveal_bottom + original_gs_reveal_bottom * not(bShowRevealSE)
			hptsYR = hptsYL
		endif

		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0,hptsYL,	0, unID
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0,hptsYR,	0, unID
		del 1
		unID = unID + 2
	else
		if (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) then
			hptsYL = -(bSlantedOuterSide & not(gs_stack_bottom)) * ( -leftRevealPnts[idxSillStartRevealLeft][2]  - gs_mountingFrame * gs_mountingFrame_depth) * tan(gs_reveal_outerBottom_angle) + gs_reveal_bottom * not(gs_stack_bottom)
			hptsYR = -(bSlantedOuterSide & not(gs_stack_bottom)) * (-rightRevealPnts[idxSillStartRevealRight][2] - gs_mountingFrame * gs_mountingFrame_depth) * tan(gs_reveal_outerBottom_angle) + gs_reveal_bottom * not(gs_stack_bottom)
		else
			hptsYL = -elevationOffset + gs_reveal_bottom * not(gs_stack_bottom)
			hptsYR = -elevationOffset + gs_reveal_bottom * not(gs_stack_bottom)
		endif

		if iWindowShape = SHAPE_TRIANGLE then
			_oleft = -(leftJamb + thkPlasterAtSillLeft) / sin(atn(tan_LeftSide))
			add -ac_wallhole_width / 2 - _oleft,			 0, leftRevealPnts[idxSillStartRevealLeft][2]
		else
			add leftRevealPnts[idxSillStartRevealLeft][1],	 0, leftRevealPnts[idxSillStartRevealLeft][2]
		endif
		hotspot 0,hptsYL,	0, unID
		del 1
		unID = unID + 2

		if iWindowShape = SHAPE_TRIANGLE then
			_oright = -(rightJamb + thkPlasterAtSillRight) / sin(atn(tan_RightSide))
			add ac_wallhole_width / 2 + _oright,			 0, rightRevealPnts[idxSillStartRevealRight][2]
		else
			add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		endif
		hotspot 0,hptsYR,	0, unID
		del 1
		unID = unID + 2

		if (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) then
			hptsYL = gs_reveal_bottom * not(gs_stack_bottom)
			hptsYR = gs_reveal_bottom * not(gs_stack_bottom)
		else
			hptsYL = -elevationOffset + gs_reveal_bottom * not(gs_stack_bottom)
			hptsYR = -elevationOffset + gs_reveal_bottom * not(gs_stack_bottom)
		endif

		add leftRevealPnts[idxSillEndRevealLeft][1], 0, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0,hptsYL,	0, unID
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], 0, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0,hptsYR,	0, unID
		del 1
		unID = unID + 2

		if (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) then
			hptsYL = 0
			hptsYR = 0
		else
			hptsYL = -elevationOffset
			hptsYR = -elevationOffset
		endif

		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot 0,hptsYL,	0, unID
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0,hptsYR,	0, unID
		del 1
		unID = unID + 2
	endif
endif

if	iWindowShape = SHAPE_ARCHED_T				| \
	iWindowShape = SHAPE_T						| \
	iWindowShape = SHAPE_ARCHED_HALF_T_LEFT		| \
	iWindowShape = SHAPE_HALF_T_LEFT			| \
	iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT	| \
	iWindowShape = SHAPE_HALF_T_RIGHT then

	gs_sidelight_WHole_width_left 	= gs_sidelight_WHole_width_left * (iWindowShape = SHAPE_ARCHED_T | iWindowShape = SHAPE_T | iWindowShape = SHAPE_ARCHED_HALF_T_LEFT | iWindowShape = SHAPE_HALF_T_LEFT)
	gs_sidelight_parapet_hgt_left 	= gs_sidelight_parapet_hgt_left * (iWindowShape = SHAPE_ARCHED_T | iWindowShape = SHAPE_T | iWindowShape = SHAPE_ARCHED_HALF_T_LEFT | iWindowShape = SHAPE_HALF_T_LEFT)
	gs_sidelight_WHole_width_right 	= gs_sidelight_WHole_width_right * (iWindowShape = SHAPE_ARCHED_T | iWindowShape = SHAPE_T | iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT | iWindowShape = SHAPE_HALF_T_RIGHT)
	gs_sidelight_parapet_hgt_right 	= gs_sidelight_parapet_hgt_right * (iWindowShape = SHAPE_ARCHED_T | iWindowShape = SHAPE_T | iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT | iWindowShape = SHAPE_HALF_T_RIGHT)

	revealDiffLeft	= (gs_reveal_double_innerLeft_sL  - gs_reveal_double_innerLeft)
	revealDiffRight	= (gs_reveal_double_innerRight_sR - gs_reveal_double_innerRight)

! Board Side Hotspots ----------------------------------------------------------

	if	iWindowShape = SHAPE_ARCHED_T				| \
		iWindowShape = SHAPE_T						| \
		iWindowShape = SHAPE_ARCHED_HALF_T_LEFT		| \
		iWindowShape = SHAPE_HALF_T_LEFT then

		hptsYM = -dyBLB + (isWindow | gs_reveal_double_innerBottom > EPS) * gs_reveal_double_innerBottom
		hptsYL = -dyBLB + gs_sidelight_parapet_hgt_left  + gs_reveal_double_innerBottom_sL

		px = -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_double_innerLeft_sL
		if curvedWall then
			pz = WOD - signWallIsLeft * sqr(radBoard^2 - px^2)
		else
			pz = leftRevealPnts[idxBoardEndRevealLeft][2] + incX * px
		endif
		hotspot px, hptsYM, pz, unID
		unID = unID + 2
		if gs_sidelight_WHole_width_left > EPS & gs_sidelight_parapet_hgt_left > EPS then
			hotspot px, hptsYL, pz, unID
			unID = unID + 2
			hotspot leftRevealPnts[idxBoardEndRevealLeft][1], hptsYL, leftRevealPnts[idxBoardEndRevealLeft][2], unID
			unID = unID + 2
		else
			unID = unID + 4
		endif
	else
		unID = unID + 6
	endif

	if	iWindowShape = SHAPE_ARCHED_T				| \
		iWindowShape = SHAPE_T						| \
		iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT	| \
		iWindowShape = SHAPE_HALF_T_RIGHT then

		hptsYM = -dyBRB + (isWindow | gs_reveal_double_innerBottom > EPS) * gs_reveal_double_innerBottom
		hptsYR = -dyBRB + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR

		px = rightWidth - gs_sidelight_WHole_width_right - gs_reveal_double_innerRight_sR
		if curvedWall then
			pz = WOD - signWallIsLeft * sqr(radBoard^2 - px^2)
		else
			pz = leftRevealPnts[idxBoardEndRevealRight][2] + incX * px
		endif
		hotspot px, hptsYM, pz, unID
		unID = unID + 2
		if gs_sidelight_WHole_width_right > EPS & gs_sidelight_parapet_hgt_right > EPS then
			hotspot px, hptsYR, pz, unID
			unID = unID + 2
			hotspot rightRevealPnts[idxBoardEndRevealRight][1], hptsYR, rightRevealPnts[idxBoardEndRevealRight][2], unID
			unID = unID + 2
		else
			unID = unID + 4
		endif
	else
		unID = unID + 6
	endif

! Sill Side Hotspots -----------------------------------------------------------

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		hptsYM = -elevationOffset
		hptsYL = -elevationOffset
		hptsYR = -elevationOffset

		if	iWindowShape = SHAPE_ARCHED_T				| \
			iWindowShape = SHAPE_T						| \
			iWindowShape = SHAPE_ARCHED_HALF_T_LEFT		| \
			iWindowShape = SHAPE_HALF_T_LEFT then

			px = -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_double_innerLeft_sL
			if curvedWall then
				pz = WOD - signWallIsLeft * sqr(radSill^2 - px^2)
			else
				pz = leftRevealPnts[idxSillStartRevealLeft][2] + incX * px
			endif
			hotspot px, hptsYM, pz, unID
			unID = unID + 2
			if gs_sidelight_WHole_width_left > EPS & gs_sidelight_parapet_hgt_left > EPS then
				hotspot px, hptsYL + gs_sidelight_parapet_hgt_left, pz, unID
				unID = unID + 2
				hotspot leftRevealPnts[idxSillStartRevealLeft][1], hptsYL + gs_sidelight_parapet_hgt_left, leftRevealPnts[idxSillStartRevealLeft][2], unID
				unID = unID + 2
			else
				unID = unID + 4
			endif
		else
			unID = unID + 6
		endif

		if	iWindowShape = SHAPE_ARCHED_T				| \
			iWindowShape = SHAPE_T						| \
			iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT	| \
			iWindowShape = SHAPE_HALF_T_RIGHT then

			px = rightWidth - gs_sidelight_WHole_width_right - gs_reveal_double_innerRight_sR
			if curvedWall then
				pz = WOD - signWallIsLeft * sqr(radSill^2 - px^2)
			else
				pz = leftRevealPnts[idxSillStartRevealRight][2] + incX * px
			endif
			hotspot px, hptsYM, pz, unID
			unID = unID + 2
			if gs_sidelight_WHole_width_right > EPS & gs_sidelight_parapet_hgt_right > EPS then
				hotspot px, hptsYR + gs_sidelight_parapet_hgt_right, pz, unID
				unID = unID + 2
				hotspot rightRevealPnts[idxSillStartRevealRight][1], hptsYR + gs_sidelight_parapet_hgt_right, rightRevealPnts[idxSillStartRevealRight][2], unID
				unID = unID + 2
			else
				unID = unID + 4
			endif
		else
			unID = unID + 6
		endif
	else
		bNegativeReveal = (iRevealType = REVEAL_NEGATIVE | (iRevealType = REVEAL_DOUBLE & iSillRevealType = REVEAL_NEGATIVE))

		hptsYM = -elevationOffset + (isWindow | gs_reveal_bottom > EPS) * gs_reveal_bottom
		hptsYL = -elevationOffset + gs_reveal_bottom_sL
		hptsYR = -elevationOffset + gs_reveal_bottom_sL

		revealDiffLeft	= (gs_reveal_left_sL  - gs_reveal_left)
		revealDiffRight	= (gs_reveal_right_sR - gs_reveal_right)

		px = -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_left_sL
		if curvedWall then
			pz = WOD - signWallIsLeft * sqr(radSill^2 - px^2)
		else
			pz = leftRevealPnts[idxSillStartRevealLeft][2] + incX * px
		endif
		hotspot px, hptsYM, pz, unID
		unID = unID + 2
		if gs_sidelight_WHole_width_left > EPS & gs_sidelight_parapet_hgt_left > EPS then
			hotspot px, hptsYL + gs_sidelight_parapet_hgt_left, pz, unID
			unID = unID + 2
			hotspot leftRevealPnts[idxSillStartRevealLeft][1], hptsYL + gs_sidelight_parapet_hgt_left, leftRevealPnts[idxSillStartRevealLeft][2], 	unID
			unID = unID + 2
		else
			unID = unID + 4
		endif

		hptsYL = -elevationOffset + gs_reveal_bottom_sR
		hptsYR = -elevationOffset + gs_reveal_bottom_sR

		px = rightWidth - gs_sidelight_WHole_width_right - gs_reveal_right_sR
		if curvedWall then
			pz = WOD - signWallIsLeft * sqr(radSill^2 - px^2)
		else
			pz = leftRevealPnts[idxSillStartRevealRight][2] + incX * px
		endif
		hotspot px, hptsYM, pz, unID
		unID = unID + 2
		if gs_sidelight_WHole_width_right > EPS & gs_sidelight_parapet_hgt_right > EPS then
			hotspot px, hptsYR + gs_sidelight_parapet_hgt_right, pz, unID
			unID = unID + 2
			hotspot rightRevealPnts[idxSillStartRevealRight][1], hptsYR + gs_sidelight_parapet_hgt_right, rightRevealPnts[idxSillStartRevealRight][2], unID
			unID = unID + 2
		else
			unID = unID + 4
		endif

		hptsYL = -elevationOffset + gs_reveal_bottom_sL
		hptsYR = -elevationOffset + gs_reveal_bottom_sL

		add leftRevealPnts[idxSillEndRevealLeft][1], 0, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot gs_sidelight_WHole_width_left + not(bNegativeReveal) * revealDiffLeft, hptsYM, 0, 	unID
		unID = unID + 2
		if gs_sidelight_WHole_width_left > EPS & gs_sidelight_parapet_hgt_left > EPS then
			hotspot gs_sidelight_WHole_width_left + not(bNegativeReveal) * revealDiffLeft,	hptsYL + gs_sidelight_parapet_hgt_left - bNegativeReveal * gs_reveal_bottom_sL,	0, 	unID
			unID = unID + 2
			hotspot 0, hptsYL + gs_sidelight_parapet_hgt_left - bNegativeReveal * gs_reveal_bottom_sL,	0, 	unID
			unID = unID + 2
		else
			unID = unID + 4
		endif
		del 1

		hptsYL = -elevationOffset + gs_reveal_bottom_sR
		hptsYR = -elevationOffset + gs_reveal_bottom_sR

		add rightRevealPnts[idxSillEndRevealRight][1], 0, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot -gs_sidelight_WHole_width_right - not(bNegativeReveal) * revealDiffRight, hptsYM,										0, unID
		unID = unID + 2
		if gs_sidelight_WHole_width_right > EPS & gs_sidelight_parapet_hgt_right > EPS then
			hotspot -gs_sidelight_WHole_width_right - not(bNegativeReveal) * revealDiffRight, hptsYR + gs_sidelight_parapet_hgt_right - bNegativeReveal * gs_reveal_bottom_sR,	0, unID
			unID = unID + 2
			hotspot 0, hptsYR + gs_sidelight_parapet_hgt_right - bNegativeReveal * gs_reveal_bottom_sR,	0, unID
			unID = unID + 2
		else
			unID = unID + 4
		endif
		del 1

		hptsYL = -elevationOffset
		hptsYR = -elevationOffset

		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot gs_sidelight_WHole_width_left, 	hptsYL,									0, 	unID
		unID = unID + 2
		if gs_sidelight_WHole_width_left > EPS & gs_sidelight_parapet_hgt_left > EPS then
			hotspot gs_sidelight_WHole_width_left,	hptsYL + gs_sidelight_parapet_hgt_left,	0, 	unID
			unID = unID + 2
			hotspot 0,								hptsYL + gs_sidelight_parapet_hgt_left,	0, 	unID
			unID = unID + 2
		else
			unID = unID + 4
		endif
		del 1

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot -gs_sidelight_WHole_width_right, hptsYR,										0, unID
		unID = unID + 2
		if gs_sidelight_WHole_width_right > EPS & gs_sidelight_parapet_hgt_right > EPS then
			hotspot -gs_sidelight_WHole_width_right,	hptsYR + gs_sidelight_parapet_hgt_right,	0, unID
			unID = unID + 2
			hotspot 0, 									hptsYR + gs_sidelight_parapet_hgt_right,	0, unID
			unID = unID + 2
		else
			unID = unID + 4
		endif
		del 1

	endif
endif

if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_T | iWindowShape = SHAPE_HALF_T_LEFT | iWindowShape = SHAPE_HALF_T_RIGHT then

! Board Side Hotspots ----------------------------------------------------------

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, B + dyBLT - gs_reveal_double_innerTop * (iRevealType = REVEAL_DOUBLE) - overSizeLower + overSizeUpper,	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, B + dyBRT - gs_reveal_double_innerTop * (iRevealType = REVEAL_DOUBLE) - overSizeLower + overSizeUpper,	0, unID+1
	del 1
	unID = unID + 2

! Sill Side Hotspots -----------------------------------------------------------

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO | ((iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) & gs_mountingFrame) then
		if (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) then
			hptsYL = B + overSizeUpper + (bSlantedOuterSide & not(gs_stack_top)) * ( -leftRevealPnts[idxSillStartRevealLeft][2]  - gs_reveal_outer_jamb_depth) * tan(gs_reveal_outerTop_angle)
			hptsYR = B + overSizeUpper + (bSlantedOuterSide & not(gs_stack_top)) * (-rightRevealPnts[idxSillStartRevealRight][2] - gs_reveal_outer_jamb_depth) * tan(gs_reveal_outerTop_angle)
		else
			hptsYL = gs_reveal_bottom + ac_reveal_height + overSizeLowerOriginal - elevationOffset + original_gs_reveal_bottom * not(bShowRevealSE)
			hptsYR = hptsYL
		endif

		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0,hptsYL,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0,hptsYR,	0, unID+1
		del 1
		unID = unID + 2

![#COMPATIBILITY] - START
!		unID = unID + 8
![#COMPATIBILITY] - END
	else
		if (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) then
			hptsY = B + overSizeUpper - gs_reveal_top
		else
			hptsY = gs_reveal_bottom + ac_reveal_height + overSizeLowerOriginal - elevationOffset
		endif

		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0,hptsY,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0,hptsY,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxSillEndRevealLeft][1], 0, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0,hptsY,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], 0, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0,hptsY,	0, unID+1
		del 1
		unID = unID + 2

		if (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) then
			hptsY = B + overSizeUpper
		else
			if ac_wallhole_height_original > EPS then
				hptsY = ac_wallhole_height_original + overSizeLowerOriginal - elevationOffset
			else
				hptsY = ac_wallhole_height + overSizeLowerOriginal - elevationOffset
			endif
		endif

		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot 0,hptsY,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0,hptsY,	0, unID+1
		del 1
		unID = unID + 2
	endif
endif

if iWindowShape = SHAPE_ARCHED | iWindowShape = SHAPE_ARCHED_T | iWindowShape = SHAPE_ARCHED_HALF_T_LEFT | iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT then

! Board Side Hotspots ----------------------------------------------------------

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, openingHeight - archHeight + dyBLT,	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, openingHeight - archHeight + dyBRT,	0, unID+1
	del 1
	unID = unID + 2

! Sill Side Hotspots -----------------------------------------------------------

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2
	else

		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2


		add leftRevealPnts[idxSillEndRevealLeft][1], 0, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], 0, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2
	endif

	add 0, gs_reveal_bottom, leftRevealPnts[idxSillStartRevealLeft][2]
	hotspot 0,ac_reveal_height + overSizeLowerOriginal - elevationOffset,	0, unID+1
	del 1
	unID = unID + 2

	add 0, gs_reveal_bottom, leftRevealPnts[idxSillEndRevealLeft][2]
	hotspot 0,ac_reveal_height + overSizeLowerOriginal - elevationOffset,	0, unID+1
	del 1
	unID = unID + 2

	if bShowAddHotspotsForIS then

		add 0, gs_reveal_bottom, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2

		add 0, gs_reveal_bottom, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2
	endif

endif

if iWindowShape = SHAPE_EYEBROWS | iWindowShape = SHAPE_ELLIPSEARCH then

! Board Side Hotspots ----------------------------------------------------------

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, openingHeight - archHeight + dyBLT,	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, openingHeight - archHeight + dyBRT,	0, unID+1
	del 1
	unID = unID + 2

! Sill Side Hotspots -----------------------------------------------------------

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

![#COMPATIBILITY] - START
!		unID = unID + 8
![#COMPATIBILITY] - END
	else
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxSillEndRevealLeft][1], 0, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], 0, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2
	endif

	add 0, 0, leftRevealPnts[idxSillStartRevealLeft][2]
	hotspot 0,ac_reveal_height + overSizeLowerOriginal - elevationOffset,	0, unID+1
	del 1
	unID = unID + 2

	add 0, 0, leftRevealPnts[idxSillEndRevealLeft][2]
	hotspot 0,ac_reveal_height + overSizeLowerOriginal - elevationOffset,	0, unID+1
	del 1
	unID = unID + 2

	if bShowAddHotspotsForIS then

		add 0, 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2
	else
![#COMPATIBILITY] - START
!		unID = unID + 4
![#COMPATIBILITY] - END
	endif

endif

if iWindowShape = SHAPE_TRIANGLE then
	_oleft = -leftJamb / sin(atn(tan_LeftSide))
	_oright = -rightJamb / sin(atn(tan_RightSide))
	_xTop = (ac_wallhole_width + _oleft + _oright) / (tan_LeftSide / tan_RightSide + 1)
	_yTop = _xTop * tan_LeftSide
	addx -ac_wallhole_width / 2 - _oleft + _xTop

	add 0, 0, leftRevealPnts[idxSillStartRevealLeft][2]
	hotspot 0, _yTop,	0, unID+1
	del 1
	unID = unID + 2

	add 0, 0, leftRevealPnts[idxSillEndRevealLeft][2]
	hotspot 0, _yTop,	0, unID+1
	del 1
	unID = unID + 2

	if bShowAddHotspotsForIS then

		add 0, 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2
	endif

	del 1
endif

if iWindowShape = SHAPE_HALFCIRCLE then

	add 0, 0, leftRevealPnts[idxSillStartRevealLeft][2]
	hotspot 0, ac_reveal_height + overSizeLowerOriginal - elevationOffset,	0, unID+1
	del 1
	unID = unID + 2

	add 0, 0, leftRevealPnts[idxSillEndRevealLeft][2]
	hotspot 0, ac_reveal_height + overSizeLowerOriginal - elevationOffset,	0, unID+1
	del 1
	unID = unID + 2

	if bShowAddHotspotsForIS then

		add 0, 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2
	endif

endif

if iWindowShape = SHAPE_HALFARCH then

! Board Side Hotspots ----------------------------------------------------------

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, openingHeight - archHeight + CustRevealRightJamb + dyBLT,	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, openingHeight + CustRevealRightJamb + dyBRT,	0, unID+1
	del 1
	unID = unID + 2

! Sill Side Hotspots -----------------------------------------------------------

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight,	0, unID+1
		del 1
		unID = unID + 2

		unID = unID + 8
	else
		add leftRevealPnts[idxSillStartRevealLeft][1], gs_reveal_bottom, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, SillShouldy - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, SillTopy - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxSillEndRevealLeft][1], gs_reveal_bottom, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0, SillShouldy - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, SillTopy - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight,	0, unID+1
		del 1
		unID = unID + 2
	endif

endif

if iWindowShape = SHAPE_PENTAGON then

! Board Side Hotspots ----------------------------------------------------------

	_hCenter = B + overSizeUpper - (CustRevealTopJamb + thkPlasterAtBoardTop) / cos(atn(tan_topAngle))

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, _hCenter + leftRevealPnts[idxBoardEndRevealLeft][1] * tan_topAngle,	0, unID+1

	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, _hCenter - rightRevealPnts[idxBoardEndRevealRight][1] * tan_topAngle,	0, unID+1
	del 1
	unID = unID + 2

! Sill Side Hotspots -----------------------------------------------------------

	_hCenter = B + overSizeUpper - (upperJamb + thkPlasterAtSillTop) / cos(atn(tan_topAngle))

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, _hCenter + leftRevealPnts[idxSillStartRevealLeft][1] * tan_topAngle,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, _hCenter - rightRevealPnts[idxSillStartRevealRight][1] * tan_topAngle,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, _hCenter,	0, unID+1
		del 1
		unID = unID + 2

	else
		add leftRevealPnts[idxSillStartRevealLeft][1], gs_reveal_bottom, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, _hCenter + leftRevealPnts[idxSillStartRevealLeft][1] * tan_topAngle,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, _hCenter - rightRevealPnts[idxSillStartRevealRight][1] * tan_topAngle, 0, unID+1
		del 1
		unID = unID + 2

		add 0, gs_reveal_bottom, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, _hCenter, 0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxSillEndRevealLeft][1], gs_reveal_bottom, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0, _hCenter + leftRevealPnts[idxSillEndRevealLeft][1] * tan_topAngle, 0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, _hCenter - rightRevealPnts[idxSillEndRevealRight][1] * tan_topAngle,	0, unID+1
		del 1
		unID = unID + 2

		add 0, gs_reveal_bottom, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, _hCenter, 0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight,	0, unID+1
		del 1
		unID = unID + 2
	endif

	add 0, 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, openingHeight + CustRevealRightJamb + dyBRT,	0, unID+1
	del 1
	unID = unID + 2

	if bShowAddHotspotsForIS then

		add 0, gs_reveal_bottom, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2

		add 0, gs_reveal_bottom, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2
	endif

endif

if iWindowShape = SHAPE_HALFROUND then

! Board Side Hotspots ----------------------------------------------------------

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, openingHeight/2 + CustRevealRightJamb + dyBLT,	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, openingHeight/2 + CustRevealRightJamb + dyBRT,	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, openingHeight + CustRevealRightJamb + dyBRT,	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, CustRevealRightJamb + dyBRT,	0, unID+1
	del 1
	unID = unID + 2

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight/2,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight/2,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, 0,	0, unID+1
		del 1
		unID = unID + 2

		unID = unID + 16
	else
		add leftRevealPnts[idxSillStartRevealLeft][1], gs_reveal_bottom, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight/2 - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight/2 - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight - sillArcoffs - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, sillArcoffs - lowerJamb, 0, unID+1
		del 1
		unID = unID + 2


		add leftRevealPnts[idxSillEndRevealLeft][1], gs_reveal_bottom, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0, openingHeight/2 - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, openingHeight/2 - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, openingHeight - sillArcoffs - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, sillArcoffs - lowerJamb, 0, unID+1
		del 1
		unID = unID + 2


		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot 0, openingHeight/2,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight/2,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, 0,	0, unID+1
		del 1
		unID = unID + 2
	endif

endif

if iWindowShape = SHAPE_TRAPEZOID then

! Board Side Hotspots ----------------------------------------------------------

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, B + dyBLT + not(bMirroredOpening) * (-archHeight + CustRevealRightJamb),	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, B + dyBRT + bMirroredOpening * (-archHeight + CustRevealRightJamb),	0, unID+1
	del 1
	unID = unID + 2

! Sill Side Hotspots -----------------------------------------------------------

	_hCenter = B + overSizeUpper - overSizeLower - archHeight / 2 - (upperJamb + thkPlasterAtSillTop) / cos(atn(tan_topAngle))
	_dirWin = not(bMirroredOpening) * 2 - 1		!mirrored: -1  nonmirrored: 1

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight - not(bMirroredOpening) * archHeighT_Reveal,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, _hCenter + _dirWin * rightRevealPnts[idxSillStartRevealRight][1] * tan_topAngle, 0, unID+1
		del 1
		unID = unID + 2
	else

		add leftRevealPnts[idxSillStartRevealLeft][1], overSizeLower, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, _hCenter + _dirWin * leftRevealPnts[idxSillStartRevealLeft][1] * tan_topAngle,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], overSizeLower, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, _hCenter + _dirWin * rightRevealPnts[idxSillStartRevealRight][1] * tan_topAngle,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxSillEndRevealLeft][1], overSizeLower , leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0, _hCenter + _dirWin * leftRevealPnts[idxSillEndRevealLeft][1] * tan_topAngle,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], overSizeLower , rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, _hCenter + _dirWin * rightRevealPnts[idxSillEndRevealRight][1] * tan_topAngle,	0, unID+1
		del 1
		unID = unID + 2

		_hCenter = B + overSizeUpper - overSizeLower - archHeight / 2 - thkPlasterAtSillTop / cos(atn(tan_topAngle))

		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot 0, _hCenter + _dirWin * leftRevealPnts[idxFrameStartRevealLeft][1] * tan_topAngle,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight - bMirroredOpening * archHeight,	0, unID+1
		del 1
		unID = unID + 2
	endif
endif

if iWindowShape = SHAPE_GOTHICARCH then

! Board Side Hotspots ----------------------------------------------------------

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, openingHeight - archHeight + CustRevealRightJamb + dyBLT,	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, openingHeight - archHeight + CustRevealRightJamb + dyBRT,	0, unID+1
	del 1
	unID = unID + 2

	add 0, 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, openingHeight + CustRevealRightJamb + dyBRT,	0, unID+1
	del 1
	unID = unID + 2

! Sill Side Hotspots -----------------------------------------------------------

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight,	0, unID+1
		del 1
		unID = unID + 2

		unID = unID + 12
	else
		add leftRevealPnts[idxSillStartRevealLeft][1], gs_reveal_bottom, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight- archHeight - lowerJamb ,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight - archHeight - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add 0, gs_reveal_bottom, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight - centSillArcoffs - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxSillEndRevealLeft][1], gs_reveal_bottom, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0, openingHeight - archHeight - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, openingHeight - archHeight - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add 0, gs_reveal_bottom, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, openingHeight - centSillArcoffs - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight,	0, unID+1
		del 1
		unID = unID + 2
	endif

	if bShowAddHotspotsForIS then

		add 0, gs_reveal_bottom, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2

		add 0, gs_reveal_bottom, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2
	else
		unID = unID + 4
	endif

endif

if iWindowShape = SHAPE_ROMBUS then

! Board Side Hotspots ----------------------------------------------------------

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, openingHeight / 2,	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, openingHeight / 2,	0, unID+1
	del 1
	unID = unID + 2

	add 0, 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, - overSizeLower + CustRevealBottJamb,	0, unID+1
	del 1
	unID = unID + 2

	add 0, 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, openingHeight + oversizeUpper + CustRevealTopJamb,	0, unID+1
	del 1
	unID = unID + 2

! Sill Side Hotspots -----------------------------------------------------------

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight / 2,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight / 2,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, - overSizeLower,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight + oversizeUpper,	0, unID+1
		del 1
		unID = unID + 2

![#COMPATIBILITY] - START
!		unID = unID + 16
![#COMPATIBILITY] - END
	else
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight / 2,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight / 2,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, lowerJamb - overSizeLower,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight - upperJamb + oversizeUpper,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxSillEndRevealLeft][1], 0, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0, openingHeight / 2,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], 0, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, openingHeight / 2,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, lowerJamb - overSizeLower,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, openingHeight - upperJamb + oversizeUpper,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot 0, openingHeight / 2,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight / 2,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, - overSizeLower,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight + oversizeUpper,	0, unID+1
		del 1
		unID = unID + 2
	endif
endif

if iWindowShape = SHAPE_PARALLELOGRAM then

! Board Side Hotspots ----------------------------------------------------------

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, archHeight - dyBLB,	0, unID
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, - dyBRB, 	0, unID
	del 1
	unID = unID + 2

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, B + dyBLT,	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, B - archHeight + dyBRT,	0, unID+1
	del 1
	unID = unID + 2

! Sill Side Hotspots -----------------------------------------------------------

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, archHeighT_Reveal - elevationOffset,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, - elevationOffset,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, B - elevationOffset,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, B - archHeighT_Reveal - elevationOffset,	0, unID+1
		del 1
		unID = unID + 2
	else
![#COMPATIBILITY] - START
!		unID = unID + 8
![#COMPATIBILITY] - END
	endif
endif

if iWindowShape = SHAPE_OCTAGONAL then
	addy openingHeight/2
	mulx openingWidth / openingHeight

	alpha_rotation = 22.5

	! Reveal Hotspots --------------------------------------------------------------
	for i = 1 to 8
		gosub 3000

		alpha_rotation = alpha_rotation + 45
	next i


	! Wallhole Hotspots ------------------------------------------------------------
	unID=11000

	for i = 1 to 8
		gosub 4000

		alpha_rotation = alpha_rotation + 45
	next i

	del 2
endif

if iWindowShape = SHAPE_MULTISIDE then
	addy normalRadius * cos (180 / gs_numOfSides)

	! Reveal Hotspots --------------------------------------------------------------
	alpha_rotation = 0
	if (gs_numOfSides mod 2) = 0 then
		alpha_rotation = 180 / gs_numOfSides
	endif

	unID = unID + 1

	for i = 1 to gs_numOfSides

		if (gs_numOfSides mod 2) <> 0 then

			if	i = 1 then
				gosub 3000
			endif
			if	i = int(gs_numOfSides / 2) + 1 or\
				i = int(gs_numOfSides / 2) + 2 then
				gosub 3000
			endif
			if i = int(gs_numOfSides / 2) + 1 then
				if bShowAddHotspotsForIS then
					gosub 3000
				endif
			endif

			if ((gs_numOfSides + 1) mod 4) <> 0 then
				if	i = (gs_numOfSides + 3) / 4 or\
					i = (gs_numOfSides + 3) / 4 + ((gs_numOfSides + 1) / 2) then
					gosub 3000
				endif
			else
				if	i = (gs_numOfSides + 5) / 4 or\
					i = (gs_numOfSides + 5) / 4 + ((gs_numOfSides - 1) / 2) then
					gosub 3000
				endif
			endif

		else

			if	i = 1 or\
				i = gs_numOfSides or\
				i = gs_numOfSides / 2 or\
				i = gs_numOfSides / 2 + 1 then
				gosub 3000
			endif

			if (gs_numOfSides mod 4) <> 0 then
				if	i = (gs_numOfSides + 2) / 4 or\
					i = (gs_numOfSides + 2) / 4 + gs_numOfSides / 2 then
					gosub 3000
				endif
			else
				if	i = gs_numOfSides / 4 or\
					i = gs_numOfSides / 4 + 1 or\
					i = gs_numOfSides / 4 + gs_numOfSides / 2 or\
					i = gs_numOfSides / 4 + gs_numOfSides / 2 + 1 then
					gosub 3000
				endif
			endif

		endif

		alpha_rotation = alpha_rotation + 360 / gs_numOfSides
	next i


	! Wallhole Hotspots ------------------------------------------------------------
	unID = 11000

	alpha_rotation = 0
	if (gs_numOfSides mod 2) = 0 then
		alpha_rotation = 180 / gs_numOfSides
	endif

	for i = 1 to gs_numOfSides

		if (gs_numOfSides mod 2) <> 0 then

			if	i = 1 then
				gosub 4000
			endif
			if	i = int(gs_numOfSides / 2) + 1 or\
				i = int(gs_numOfSides / 2) + 2 then
				gosub 4000
			endif
			if i = int(gs_numOfSides / 2) + 1 then
				if bShowAddHotspotsForIS then
					gosub 4000
				endif
			endif

			if ((gs_numOfSides + 1) mod 4) <> 0 then
				if	i = (gs_numOfSides + 3) / 4 or\
					i = (gs_numOfSides + 3) / 4 + ((gs_numOfSides + 1) / 2) then
					gosub 4000
				endif
			else
				if	i = (gs_numOfSides + 5) / 4 or\
					i = (gs_numOfSides + 5) / 4 + ((gs_numOfSides - 1) / 2) then
					gosub 4000
				endif
			endif

		else

			if	i = 1 or\
				i = gs_numOfSides or\
				i = gs_numOfSides / 2 or\
				i = gs_numOfSides / 2 + 1 then
				gosub 4000
			endif

			if (gs_numOfSides mod 4) <> 0 then
				if	i = (gs_numOfSides + 2) / 4 or\
					i = (gs_numOfSides + 2) / 4 + gs_numOfSides / 2 then
					gosub 4000
				endif
			else
				if	i = gs_numOfSides / 4 or\
					i = gs_numOfSides / 4 + 1 or\
					i = gs_numOfSides / 4 + gs_numOfSides / 2 or\
					i = gs_numOfSides / 4 + gs_numOfSides / 2 + 1 then
					gosub 4000
				endif
			endif

		endif

		alpha_rotation = alpha_rotation + 360 / gs_numOfSides
	next i

	del 1
endif

if iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then

	addy openingHeight / 2
	muly openingHeight / openingWidth

	! Reveal Hotspots --------------------------------------------------------------
	if iRevealType > REVEAL_NO then
		hotspot 0,  openingWidth/2 - rightJamb, leftRevealPnts[idxSillStartRevealLeft][2],	unID + 1
		hotspot 0, -openingWidth/2 + rightJamb, leftRevealPnts[idxSillStartRevealLeft][2],	unID + 2
		hotspot  openingWidth/2 - rightJamb, 0, leftRevealPnts[idxSillStartRevealLeft][2],	unID + 3
		hotspot -openingWidth/2 + rightJamb, 0, leftRevealPnts[idxSillStartRevealLeft][2],	unID + 4
		unID = unID + 4

		hotspot 0,  openingWidth/2 - rightJamb, leftRevealPnts[idxSillEndRevealLeft][2],	unID + 1
		hotspot 0, -openingWidth/2 + rightJamb, leftRevealPnts[idxSillEndRevealLeft][2],	unID + 2
		hotspot  openingWidth/2 - rightJamb, 0, leftRevealPnts[idxSillEndRevealLeft][2],	unID + 3
		hotspot -openingWidth/2 + rightJamb, 0, leftRevealPnts[idxSillEndRevealLeft][2],	unID + 4
		unID = unID + 4
	endif


	! Wallhole Hotspots ------------------------------------------------------------
	unID=11000

	! Board Side Hotspots ----------------------------------------------------------
	hotspot 0,  openingWidth/2, leftRevealPnts[idxBoardEndRevealLeft][2],	unID + 1
	hotspot 0, -openingWidth/2, leftRevealPnts[idxBoardEndRevealLeft][2],	unID + 2
	hotspot  openingWidth/2, 0, leftRevealPnts[idxBoardEndRevealLeft][2],	unID + 3
	hotspot -openingWidth/2, 0, leftRevealPnts[idxBoardEndRevealLeft][2],	unID + 4
	unID = unID + 4

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		hotspot 0,  openingWidth/2, leftRevealPnts[idxSillStartRevealLeft][2],	unID + 1
		hotspot 0, -openingWidth/2, leftRevealPnts[idxSillStartRevealLeft][2],	unID + 2
		hotspot  openingWidth/2, 0, leftRevealPnts[idxSillStartRevealLeft][2],	unID + 3
		hotspot -openingWidth/2, 0, leftRevealPnts[idxSillStartRevealLeft][2],	unID + 4
		unID = unID + 4
	else
		hotspot 0,  openingWidth/2, leftRevealPnts[idxFrameStartRevealLeft][2],	unID + 1
		hotspot 0, -openingWidth/2, leftRevealPnts[idxFrameStartRevealLeft][2],	unID + 2
		hotspot  openingWidth/2, 0, leftRevealPnts[idxFrameStartRevealLeft][2],	unID + 3
		hotspot -openingWidth/2, 0, leftRevealPnts[idxFrameStartRevealLeft][2],	unID + 4
		unID = unID + 4
	endif

	del 2
endif


if bSillIsHorizontal & \
	( iRevealType = REVEAL_SLANTED	| \
	  iRevealType = REVEAL_SPLAYED	| \
	  iRevealType = REVEAL_HISTORIC	| \
	 (iRevealType = REVEAL_DOUBLE & abs(gs_reveal_double_innerBottom) > EPS) ) then

! Board Side Hotspots ----------------------------------------------------------

	if bSlantedInnerSide & not(gs_stack_bottom) & isWindow then
		dyBLB =  ((leftRevealPnts[idxBoardEndRevealLeft - 1][2]  - (iRevealType <> REVEAL_SLANTED) * WIDO_FRAME_THICKNESS) * tan(gs_reveal_bottom_angle)) - (iRevealType <> REVEAL_SLANTED) * gs_reveal_splayed_innerBottom	! Bottom Left
		dyBRB = ((rightRevealPnts[idxBoardEndRevealRight - 1][2] - (iRevealType <> REVEAL_SLANTED) * WIDO_FRAME_THICKNESS) * tan(gs_reveal_bottom_angle)) - (iRevealType <> REVEAL_SLANTED) * gs_reveal_splayed_innerBottom	! Bottom Right
	else
		dyBLB = -(iRevealType = REVEAL_DOUBLE) * gs_reveal_double_innerBottom
		dyBRB = -(iRevealType = REVEAL_DOUBLE) * gs_reveal_double_innerBottom
	endif

	add leftRevealPnts[idxBoardEndRevealLeft - 1][1], 0, leftRevealPnts[idxBoardEndRevealLeft - 1][2]
	hotspot 0,-dyBLB,						0, unID
	del 1
	unID = unID + 1

	add rightRevealPnts[idxBoardEndRevealRight - 1][1], 0, rightRevealPnts[idxBoardEndRevealRight - 1][2]
	hotspot 0,-dyBRB,						0, unID
	del 1
	unID = unID + 1
endif

if iWindowShape = SHAPE_RECTANGULAR & \
	( iRevealType = REVEAL_SLANTED	| \
	  iRevealType = REVEAL_SPLAYED	| \
	  iRevealType = REVEAL_HISTORIC	| \
	 (iRevealType = REVEAL_DOUBLE & abs(gs_reveal_double_innerTop) > EPS) ) then

	if bSlantedInnerSide & not(gs_stack_top) then
		dyBLT =  ((leftRevealPnts[idxBoardEndRevealLeft - 1][2]  - (iRevealType <> REVEAL_SLANTED) * WIDO_FRAME_THICKNESS) * tan(gs_reveal_top_angle) - (iRevealType <> REVEAL_SLANTED) * gs_reveal_splayed_InnerTop)	! Top Left
		dyBRT = ((rightRevealPnts[idxBoardEndRevealRight - 1][2] - (iRevealType <> REVEAL_SLANTED) * WIDO_FRAME_THICKNESS) * tan(gs_reveal_top_angle) - (iRevealType <> REVEAL_SLANTED) * gs_reveal_splayed_InnerTop)	! Top Right
	else
		dyBLT = -(iRevealType = REVEAL_DOUBLE) * gs_reveal_double_innerTop
		dyBRT = -(iRevealType = REVEAL_DOUBLE) * gs_reveal_double_innerTop
	endif

	add leftRevealPnts[idxBoardEndRevealLeft - 1][1], 0, leftRevealPnts[idxBoardEndRevealLeft - 1][2]
	hotspot 0, B + dyBLT - overSizeLower + overSizeUpper,	0, unID
	del 1
	unID = unID + 1

	add rightRevealPnts[idxBoardEndRevealRight - 1][1], 0, rightRevealPnts[idxBoardEndRevealRight - 1][2]
	hotspot 0, B + dyBRT - overSizeLower + overSizeUpper,	0, unID
	del 1
	unID = unID + 1
endif


!! Horizontal editing -----------------------------------------------------------
!
!		add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
!		hotspot  0,0,					0, unID,   ac_wallhole_width, 1+256, ac_wallhole_width	! Base
!		hotspot -ac_wallhole_width,0,	0, unID+1, ac_wallhole_width, 2,		ac_wallhole_width	! Moving
!		hotspot  1,0,					0, unID+2, ac_wallhole_width, 3,		ac_wallhole_width	! Reference
!		del 1
!		unID = unID + 3
!
!		if abs(gs_wallhole_width_half) > EPS then
!			add dxBR, 0, rightRevealPnts[idxBoardEndRevealRight][2]
!			hotspot  0,0,						0, unID,   gs_wallhole_width_half, 1+128, ac_wallhole_width	! Base
!			hotspot  gs_wallhole_width_half,0,	0, unID+1, gs_wallhole_width_half, 2,		ac_wallhole_width	! Moving
!			hotspot -1,0,						0, unID+2, gs_wallhole_width_half, 3,		ac_wallhole_width	! Reference
!			del 1
!		endif
!		unID = unID + 3
!
!		if abs(gs_wallhole_width_half) > EPS then
!			add dxBL, 0, leftRevealPnts[idxBoardEndRevealLeft][2]
!			hotspot  0,0,						0, unID,   gs_wallhole_width_half, 1+128,	ac_wallhole_width	! Base
!			hotspot -gs_wallhole_width_half,0,	0, unID+1, gs_wallhole_width_half, 2,		ac_wallhole_width	! Moving
!			hotspot  1,0,						0, unID+2, gs_wallhole_width_half, 3,		ac_wallhole_width	! Reference
!			del 1
!		endif
!		unID = unID + 3
!
!		if abs(gs_wallhole_width_half) > EPS then
!			add dxBR, openingHeight, rightRevealPnts[idxBoardEndRevealRight][2]
!			hotspot  0,0,						0, unID,   gs_wallhole_width_half, 1+128, ac_wallhole_width	! Base
!			hotspot  gs_wallhole_width_half,0,	0, unID+1, gs_wallhole_width_half, 2,		ac_wallhole_width	! Moving
!			hotspot -1,0,						0, unID+2, gs_wallhole_width_half, 3,		ac_wallhole_width	! Reference
!			del 1
!		endif
!		unID = unID + 3
!
!		if abs(gs_wallhole_width_half) > EPS then
!			add dxBL, openingHeight, leftRevealPnts[idxBoardEndRevealLeft][2]
!			hotspot  0,0,						0, unID,   gs_wallhole_width_half, 1+128,	ac_wallhole_width	! Base
!			hotspot -gs_wallhole_width_half,0,	0, unID+1, gs_wallhole_width_half, 2,		ac_wallhole_width	! Moving
!			hotspot  1,0,						0, unID+2, gs_wallhole_width_half, 3,		ac_wallhole_width	! Reference
!			del 1
!		endif
!		unID = unID + 3
!
!		if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
!		else
!			if abs(gs_reveal_width_half) > EPS then
!				add dxSR, gs_reveal_bottom, rightRevealPnts[idxSillStartRevealRight][2]
!				hotspot  0,0,					0, unID,   gs_reveal_width_half, 1+128, ac_reveal_width	! Base
!				hotspot  gs_reveal_width_half,0,0, unID+1, gs_reveal_width_half, 2,	  ac_reveal_width	! Moving
!				hotspot -1,0,					0, unID+2, gs_reveal_width_half, 3,	  ac_reveal_width	! Reference
!				del 1
!			endif
!			unID = unID + 3
!
!			if abs(gs_reveal_width_half) > EPS then
!				add dxSL, gs_reveal_bottom, leftRevealPnts[idxSillStartRevealLeft][2]
!				hotspot  0,0,					0, unID,   gs_reveal_width_half, 1+128, ac_reveal_width	! Base
!				hotspot -gs_reveal_width_half,0,0, unID+1, gs_reveal_width_half, 2,	  ac_reveal_width	! Moving
!				hotspot  1,0,					0, unID+2, gs_reveal_width_half, 3,	  ac_reveal_width	! Reference
!				del 1
!			endif
!			unID = unID + 3
!
!			if abs(gs_reveal_width_half) > EPS then
!				add dxSR, openingHeight - gs_reveal_top, rightRevealPnts[idxSillStartRevealRight][2]
!				hotspot  0,0,					0, unID,   gs_reveal_width_half, 1+128, ac_reveal_width	! Base
!				hotspot  gs_reveal_width_half,0,0, unID+1, gs_reveal_width_half, 2,	  ac_reveal_width	! Moving
!				hotspot -1,0,					0, unID+2, gs_reveal_width_half, 3,	  ac_reveal_width	! Reference
!				del 1
!			endif
!			unID = unID + 3
!
!			if abs(gs_reveal_width_half) > EPS then
!				add dxSL, openingHeight - gs_reveal_top, leftRevealPnts[idxSillStartRevealLeft][2]
!				hotspot  0,0,					0, unID,   gs_reveal_width_half, 1+128, ac_reveal_width	! Base
!				hotspot -gs_reveal_width_half,0,0, unID+1, gs_reveal_width_half, 2,	  ac_reveal_width	! Moving
!				hotspot  1,0,					0, unID+2, gs_reveal_width_half, 3,	  ac_reveal_width	! Reference
!				del 1
!			endif
!			unID = unID + 3
!		endif
!
!! Vertical editing -------------------------------------------------------------
!
!		add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
!		hotspot 0,0,					0, unID,   ac_wallhole_height, 1	! Base
!		hotspot 0,ac_wallhole_height,	0, unID+1, ac_wallhole_height, 2	! Moving
!		hotspot 0,-1,					0, unID+2, ac_wallhole_height, 3	! Reference
!		del 1
!		unID = unID + 3
!
!		add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
!		hotspot 0,0,					0, unID,   ac_wallhole_height, 1	! Base
!		hotspot 0,ac_wallhole_height,	0, unID+1, ac_wallhole_height, 2	! Moving
!		hotspot 0,-1,					0, unID+2, ac_wallhole_height, 3	! Reference
!		del 1
!		unID = unID + 3
!
!		if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
!			add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
!			hotspot 0,0,				0, unID,   ac_wallhole_height, 1	! Base
!			hotspot 0,ac_reveal_height,	0, unID+1, ac_wallhole_height, 2	! Moving
!			hotspot 0,-1,				0, unID+2, ac_wallhole_height, 3	! Reference
!			del 1
!			unID = unID + 3
!
!			add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
!			hotspot 0,0,				0, unID,   ac_wallhole_height, 1	! Base
!			hotspot 0,ac_reveal_height,	0, unID+1, ac_wallhole_height, 2	! Moving
!			hotspot 0,-1,				0, unID+2, ac_wallhole_height, 3	! Reference
!			del 1
!			unID = unID + 3
!		else
!			add leftRevealPnts[idxSillStartRevealLeft][1], gs_reveal_bottom, leftRevealPnts[idxSillStartRevealLeft][2]
!			hotspot 0,0,				0, unID,   ac_reveal_height, 1	! Base
!			hotspot 0,ac_reveal_height,	0, unID+1, ac_reveal_height, 2	! Moving
!			hotspot 0,-1,				0, unID+2, ac_reveal_height, 3	! Reference
!			del 1
!			unID = unID + 3
!
!			add rightRevealPnts[idxSillStartRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillStartRevealRight][2]
!			hotspot 0,0,				0, unID,   ac_reveal_height, 1	! Base
!			hotspot 0,ac_reveal_height,	0, unID+1, ac_reveal_height, 2	! Moving
!			hotspot 0,-1,				0, unID+2, ac_reveal_height, 3	! Reference
!			del 1
!			unID = unID + 3
!		endif
!	endif

if WIDO_REVEAL_SIDE then
	del 2
endif

! ==============================================================================
! Cut Default Wallhole
! ==============================================================================

if not(curvedWall) | (curvedWall & bParalellInCurvedWalls) then

	if WIDO_REVEAL_SIDE then
		addz WIDO_SILL - WALL_THICKNESS + WIDO_FRAME_THICKNESS    ! Flip
	else
		addz -WIDO_SILL
	endif

	if WIDO_REVEAL_SIDE then
		mulz -1
		addz -WALL_THICKNESS
	endif

	if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
		MulRat = 1
	endif

! =============================================================================
! Outer Side Cut - Straight Wall
! =============================================================================

	if WIDO_SILL > EPS then
		material matRevealSide

		_bCustomMatNicheTop			= bCustomMatNicheTop
		_wallNicheSurfaceLeft		= matRevealSide
		_wallNicheSurfaceRight		= matRevealSide
		_wallNicheSurfaceBottom		= matRevealSide
		_wallNicheSurfaceTop		= matNicheTop

		cutMethod	= 1
		if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then
			cutStatus	= 2 + 16 + 256 * _bCustomMatNicheTop
		else
			cutStatus	= 2 + 16
		endif
		cutVectX	= 0
		cutVectY	= 0
		cutVectZ	= 1
		cutDepth	= WIDO_SILL

		sideRight	= rightWidth + overSizeRight
		sideLeft	= leftWidth  + overSizeLeft
		sideBottom	= overSizeLower
		sideTop		= B + overSizeUpper

		offLeft		= leftJamb  + thkPlasterAtSillLeft
		offRight	= rightJamb + thkPlasterAtSillRight
		offTop		= upperJamb + thkPlasterAtSillTop
		offBottom	= lowerJamb + thkPlasterAtSillBottom

		if iWindowShape = SHAPE_ELLIPSEARCH then
			smallRadiusEllips_offset	= smallRadiusEllips_reveal
			middleRadiusEllips_offset	= middleRadiusEllips_reveal
		endif

		if iWindowShape = SHAPE_GOTHICARCH then
			centArcoffs		= centSillArcoffs
		endif

		if iWindowShape = SHAPE_OGEECENTERED then
			centArcoffs		= centSillArcoffs
		endif

		if iWindowShape = SHAPE_SARACENIC then
			tangArcx		= SilltangArcx
			tangArcy		= SilltangArcy
			centArcoffs		= centSillArcoffs
		endif

		if iWindowShape = SHAPE_HORSESHOE then
			LowArcoffsy		= SillLowArcoffsy
			LowArcoffsx		= SillLowArcoffsx
			HighArcoffs		= SillHighArcoffs
		endif

		if iWindowShape = SHAPE_HALFARCH then
			Topx	= SillTopx
			Topy	= SillTopy
			Shouldx	= SillShouldx
			Shouldy	= SillShouldy
		endif

		if bTShapedOpening then
			offSlLeft			= gs_reveal_left_sL   + thkPlasterAtSillSLLeft
			offSlRight			= gs_reveal_right_sR  + thkPlasterAtSillSLRight
			offSlLeftBottom		= gs_reveal_bottom_sL + thkPlasterAtSillSlLeftBottom
			offSlRightBottom	= gs_reveal_bottom_sR + thkPlasterAtSillSlRightBottom
		endif

		addz -SillPlasterAtFrame
		gosub 2000
		del 1

	endif


! =============================================================================
! Plaster Layer Outer Side Cut - Straight Wall
! =============================================================================

	if WIDO_SILL > EPS & SillPlasterAtFrame > EPS then
		cutMethod	= 1
		cutStatus	= 2 + 16
		cutVectX	= 0
		cutVectY	= 0
		cutVectZ	= 1
		cutDepth	= WIDO_SILL

		sideRight	= rightWidth + overSizeRight
		sideLeft	= leftWidth  + overSizeLeft
		sideBottom	= overSizeLower - bSillIsHorizontal * bBoardElevUsa
		sideTop		= B + overSizeUpper

		offLeft		= thkPlasterAtSillLeft
		offRight	= thkPlasterAtSillRight
		offTop		= thkPlasterAtSillTop	 + (thkPlasterAtSillTop		< EPS) * gs_reveal_top
		offBottom	= thkPlasterAtSillBottom + (thkPlasterAtSillBottom	< EPS) * gs_reveal_bottom

		if iWindowShape = SHAPE_ELLIPSEARCH then
			smallRadiusEllips_offset	= smallRadiusEllips - offLeft
			middleRadiusEllips_offset	= middleRadiusEllips - offLeft
		endif

		if bTShapedOpening then
			offSlLeft			= thkPlasterAtSillSlLeft
			offSlRight			= thkPlasterAtSillSlRight
			offSlLeftBottom		= thkPlasterAtSillSlLeftBottom  + (thkPlasterAtSillSlLeftBottom	 < EPS) * gs_reveal_bottom
			offSlRightBottom	= thkPlasterAtSillSlRightBottom + (thkPlasterAtSillSlRightBottom < EPS) * gs_reveal_bottom
		endif

		gosub 2000
	endif


! =============================================================================
! Inner Side Cut - Straight Wall
! =============================================================================

	material matOppositeSide

	addz WALL_THICKNESS

	isParIns = 0

	if not(bSlantedInnerSide) then
		cutMethod	= 1
		cutStatus	= 2 + 8 * (WIDO_SILL < EPS) + 16
		cutVectX	= 0
		cutVectY	= 0
		cutVectZ	= -1
		cutDepth	= WALL_THICKNESS - WIDO_SILL - CustRevealOffsetDepth - BoardPlasterAtFrame

		sideRight	= rightWidth + overSizeRight
		sideLeft	= leftWidth  + overSizeLeft
		sideBottom	= overSizeLower
		sideTop		= B + overSizeUpper

		offLeft		= CustRevealLeftJamb  + thkPlasterAtBoardLeft
		offRight	= CustRevealRightJamb + thkPlasterAtBoardRight
		offTop		= CustRevealTopJamb   + thkPlasterAtBoardTop
		offBottom	= CustRevealBottJamb  + thkPlasterAtBoardBottom + bSillIsHorizontal * bBoardElevUsa

		if iWindowShape = SHAPE_ELLIPSEARCH then
			smallRadiusEllips_offset	= smallRadiusEllips_Innreveal
			middleRadiusEllips_offset	= middleRadiusEllips_Innreveal
		endif

		if iWindowShape = SHAPE_GOTHICARCH then
			centArcoffs		= centBoardArcoffs
		endif

		if iWindowShape = SHAPE_OGEECENTERED then
			centArcoffs		= centBoardArcoffs
		endif

		if iWindowShape = SHAPE_SARACENIC then
			tangArcx		= BoardtangArcx
			tangArcy		= BoardtangArcy
			centArcoffs		= centBoardArcoffs
		endif

		if iWindowShape = SHAPE_HORSESHOE then
			LowArcoffsy		= BoardLowArcoffsy
			LowArcoffsx		= BoardLowArcoffsx
			HighArcoffs		= BoardHighArcoffs
		endif

		if iWindowShape = SHAPE_HALFARCH then
			Topx	= BoardTopx
			Topy	= BoardTopy
			Shouldx	= BoardShouldx
			Shouldy	= BoardShouldy
		endif

		if bTShapedOpening then
			offSlLeft			= gs_reveal_double_innerLeft_sL   + thkPlasterAtBoardSlLeft
			offSlRight			= gs_reveal_double_innerRight_sR  + thkPlasterAtBoardSlRight
			offSlLeftBottom		= gs_reveal_double_innerBottom_sL + thkPlasterAtBoardSlLeftBottom
			offSlRightBottom	= gs_reveal_double_innerBottom_sR + thkPlasterAtBoardSlRightBottom
		endif

		gosub 2000
	endif


! =============================================================================
! Plaster Layer Inner Side Cut - Straight Wall
! =============================================================================

	if not(bSlantedInnerSide) & BoardPlasterAtFrame > EPS then
		cutMethod	= 1
		cutStatus	= 2 + 16
		cutVectX	= 0
		cutVectY	= 0
		cutVectZ	= -1
		cutDepth	= WALL_THICKNESS - WIDO_SILL - CustRevealOffsetDepth

		sideRight	= rightWidth + overSizeRight
		sideLeft	= leftWidth  + overSizeLeft
		sideBottom	= overSizeLower - bSillIsHorizontal * bBoardElevUsa
		sideTop		= B + overSizeUpper

		offLeft		= thkPlasterAtBoardLeft
		offRight	= thkPlasterAtBoardRight
		offTop		= thkPlasterAtBoardTop	  + (thkPlasterAtBoardTop	 < EPS) * (CustRevealTopJamb  + offsetInsideTop)
		offBottom	= thkPlasterAtBoardBottom + (thkPlasterAtBoardBottom < EPS) * (CustRevealBottJamb + offsetInsideBott)

		if iWindowShape = SHAPE_ELLIPSEARCH then
			smallRadiusEllips_offset	= smallRadiusEllips - offLeft
			middleRadiusEllips_offset	= middleRadiusEllips - offLeft
		endif

		if bTShapedOpening then
			offSlLeft			= thkPlasterAtBoardSlLeft
			offSlRight			= thkPlasterAtBoardSlRight
			offSlLeftBottom		= thkPlasterAtBoardSlLeftBottom  + (thkPlasterAtBoardSlLeftBottom  < EPS) * (CustRevealBottJamb + offsetInsideBott)
			offSlRightBottom	= thkPlasterAtBoardSlRightBottom + (thkPlasterAtBoardSlRightBottom < EPS) * (CustRevealBottJamb + offsetInsideBott)
		endif

		gosub 2000
	endif


! =============================================================================
! Slanted Inner Side Cut - Straight Wall
! =============================================================================

	if bSlantedInnerSide then
		if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then
			gs_slanted_left_angle		= gs_reveal_left_angle
			gs_slanted_right_angle		= gs_reveal_right_angle
			gs_slanted_bottom_angle		= gs_reveal_bottom_angle
			gs_slanted_top_angle		= gs_reveal_top_angle
			thkPlasterAtSlantedLeft		= thkPlasterAtBoardLeft
			thkPlasterAtSlantedRight	= thkPlasterAtBoardRight
			thkPlasterAtSlantedBottom	= thkPlasterAtBoardBottom
			thkPlasterAtSlantedTop		= thkPlasterAtBoardTop
			thkPlasterAtSlanted			= thkPlasterAtBoard
			HalfInfiniteCut				= 1
			slantedDepth		= (WALL_THICKNESS - WIDO_SILL - offsetInsideDepth - not(iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) * thkPlasterAtBoard)
			slantedDepthBottom	= slantedDepth
			slantedCutDepth		= slantedDepth
			offsetDepth		= offsetInsideDepth
			offsetRight		= offsetInsideRight
			offsetLeft		= offsetInsideLeft
			offsetTop		= offsetInsideTop
			offsetBott		= offsetInsideBott + bSillIsHorizontal * bBoardElevUsa
			bWallInsetCut	= 1

			gosub 1000	! Slanted Reveal cutting body
		endif
	endif


! =============================================================================
! Slanted Outer Side Cut - Straight Wall
! =============================================================================

	if bSlantedOuterSide then
		if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then

			gs_slanted_left_angle		= gs_reveal_outerLeft_angle
			gs_slanted_right_angle		= gs_reveal_outerRight_angle
			gs_slanted_bottom_angle		= gs_reveal_outerBottom_angle
			gs_slanted_top_angle		= gs_reveal_outerTop_angle
			thkPlasterAtSlantedLeft		= thkPlasterAtSillLeft
			thkPlasterAtSlantedRight	= thkPlasterAtSillRight
			thkPlasterAtSlantedBottom	= thkPlasterAtSillBottom
			thkPlasterAtSlantedTop		= thkPlasterAtSillTop
			thkPlasterAtSlanted			= 0
			HalfInfiniteCut				= 1
			slantedDepth		= WIDO_SILL - gs_reveal_outer_jamb_depth
			slantedDepthBottom	= WIDO_SILL - bHaveMountingFrame * (gs_mountingFrame_depth)
			slantedCutDepth		= slantedDepth
			offsetDepth		= offsetOutsideDepth
			offsetRight		= gs_reveal_right
			offsetLeft		= gs_reveal_left
			offsetTop		= gs_reveal_top
			offsetBott		= gs_reveal_bottom - (not(bHaveMountingFrame) * gs_reveal_outer_jamb_depth + bHaveMountingFrame * (gs_reveal_outer_jamb_depth - gs_mountingFrame_depth)) * tan(gs_reveal_outerBottom_angle)
			bWallInsetCut	= 0

			mulz -1
			addz WALL_THICKNESS
			gosub 1000	! Slanted Reveal cutting body
			del 2
		endif
	endif


! =============================================================================
! Middle cut at window range - Straight Wall
! =============================================================================

	if WIDO_FRAME_THICKNESS > EPS & bNeedMiddleCut then

		cutMethod	= 1
		cutStatus	= 2
		cutVectX	= 0
		cutVectY	= 0
		cutVectZ	= 1
		cutDepth	= WIDO_FRAME_THICKNESS

		sideRight	= rightWidth + overSizeRight
		sideLeft	= leftWidth  + overSizeLeft
		sideBottom	= overSizeLower
		sideTop		= B + overSizeUpper

		offLeft		= 0
		offRight	= 0
		offTop		= 0
		offBottom	= 0

		if iWindowShape = SHAPE_ELLIPSEARCH then
			smallRadiusEllips_offset	= smallRadiusEllips
			middleRadiusEllips_offset	= middleRadiusEllips
		endif

		if iWindowShape = SHAPE_GOTHICARCH then
			centArcoffs		= 0
		endif

		if iWindowShape = SHAPE_OGEECENTERED then
			centArcoffs		= sideTop
		endif

		if iWindowShape = SHAPE_SARACENIC then
			tangArcx		= FrametangArcx
			tangArcy		= FrametangArcy
			centArcoffs		= sideTop
		endif

		if iWindowShape = SHAPE_HORSESHOE then
			LowArcoffsy		= FrameLowArcoffsy
			LowArcoffsx		= FrameLowArcoffsx
			HighArcoffs		= FrameHighArcoffs
		endif

		if iWindowShape = SHAPE_HALFARCH then
			Topx	= FrameTopx
			Topy	= FrameTopy
			Shouldx	= FrameShouldx
			Shouldy	= FrameShouldy
		endif

		if bTShapedOpening then
			offSlLeft			= 0
			offSlRight			= 0
			offSlLeftBottom		= 0
			offSlRightBottom	= 0
		endif

		addz WIDO_SILL - WALL_THICKNESS

		if iRevealType = REVEAL_SLANTED then
			gs_slanted_left_angle		= gs_reveal_left_angle
			gs_slanted_right_angle		= gs_reveal_right_angle
			gs_slanted_bottom_angle		= gs_reveal_bottom_angle
			gs_slanted_top_angle		= gs_reveal_top_angle
			thkPlasterAtSlantedLeft		= 0
			thkPlasterAtSlantedRight	= 0
			thkPlasterAtSlantedBottom	= 0
			thkPlasterAtSlantedTop		= 0
			thkPlasterAtSlanted			= 0
			HalfInfiniteCut				= 0
			slantedDepth		= WIDO_FRAME_THICKNESS
			slantedDepthBottom	= slantedDepth
			slantedCutDepth		= slantedDepth
			offsetDepth		= offsetInsideDepth
			offsetRight		= offsetInsideRight
			offsetLeft		= offsetInsideLeft
			offsetTop		= offsetInsideTop
			offsetBott		= offsetInsideBott
			bWallInsetCut	= 0

			addz WIDO_FRAME_THICKNESS
			gosub 1000
			del 1
		else
			gosub 2000
		endif
		del 1

	endif

	if WIDO_FRAME_THICKNESS > EPS & abs(bBoardElevUsa) > EPS then
		addz WIDO_SILL - WALL_THICKNESS
		if	iWindowShape = SHAPE_RECTANGULAR | \
			iWindowShape = SHAPE_ELLIPSEARCH |\
			iWindowShape = SHAPE_HALFCIRCLE |\
			iWindowShape = SHAPE_PENTAGON |\
			iWindowShape = SHAPE_QUARTERROUND |\
			iWindowShape = SHAPE_TRAPEZOID |\
			iWindowShape = SHAPE_ARCHED then

			wallniche 4, 1, 2,
				0,0,1,	WIDO_FRAME_THICKNESS,
				 rightWidth + overSizeRight,	-overSizeLower + bBoardElevUsa,	31,
				 rightWidth + overSizeRight,	-overSizeLower,					31,
				-leftWidth  - overSizeLeft,		-overSizeLower,					31,
				-leftWidth  - overSizeLeft,		-overSizeLower + bBoardElevUsa,	31
		endif
		del 1
	endif

	del 2 + WIDO_REVEAL_SIDE * 2


! =============================================================================
! Cut Wall Inset - Straight Wall
! =============================================================================

	if bParapetWallInset & SYMB_POS_Y > overSizeLower & not(isParIns) & parapet_height > EPS & (SYMB_POS_Y - act_st_pos) > EPS then
		if not(curvedWall) then

			if WIDO_REVEAL_SIDE then
				addz WIDO_SILL - WALL_THICKNESS + WIDO_FRAME_THICKNESS    ! Flip
			else
				addz -WIDO_SILL
			endif
			if WIDO_REVEAL_SIDE then
				mulz -1
				addz -WALL_THICKNESS
			endif
			addz WALL_THICKNESS

			rotx 90
			addz SYMB_POS_Y - act_st_pos

			dx = parapetWallInsetDepth * sin(WALL_INCL)
			dy = parapetWallInsetDepth * cos(WALL_INCL)

			if gs_parapet_autodim then
				revSlantYRight	= revSlantYRight + gs_parapet_autodim * thkPlasterAtBoardRight * incV
				revSlantYLeft	= revSlantYLeft  - gs_parapet_autodim * thkPlasterAtBoardLeft  * incV
				wallniche 4, 1, 2,
					0,0,-1,	parapet_height + gs_parapet_autodim * thkPlasterAtBoardBottom,
					 rightWidth + overSizeRight + revYR - gs_parapet_autodim * thkPlasterAtBoardRight + parapetExtendRight * cos(WALL_INCL) + revSlantXRight,	-py1p - revSlantYRight,	31,
					 rightWidth + overSizeRight + revYR - gs_parapet_autodim * thkPlasterAtBoardRight + parapetExtendRight * cos(WALL_INCL),					-py1p + 1.0,			31,
					-leftWidth  - overSizeLeft  - revYL + gs_parapet_autodim * thkPlasterAtBoardLeft  - parapetExtendLeft  * cos(WALL_INCL),					-py2p + 1.0,			31,
					-leftWidth  - overSizeLeft  - revYL + gs_parapet_autodim * thkPlasterAtBoardLeft  - parapetExtendLeft  * cos(WALL_INCL) + revSlantXLeft,	-py2p - revSlantYLeft,	31
			else
				wallniche 4, 1, 2,
					0,0,-1,	parapet_height + gs_parapet_autodim * thkPlasterAtBoardBottom,
					 rightWidth + overSizeRight + revYR - gs_parapet_autodim * thkPlasterAtBoardRight + parapetExtendRight * cos(WALL_INCL) + dx*incFactor,	-py1p - dy,		31,
					 rightWidth + overSizeRight + revYR - gs_parapet_autodim * thkPlasterAtBoardRight + parapetExtendRight * cos(WALL_INCL),					-py1p + 1.0,	31,
					-leftWidth  - overSizeLeft  - revYL + gs_parapet_autodim * thkPlasterAtBoardLeft  - parapetExtendLeft  * cos(WALL_INCL),					-py2p + 1.0,	31,
					-leftWidth  - overSizeLeft  - revYL + gs_parapet_autodim * thkPlasterAtBoardLeft  - parapetExtendLeft  * cos(WALL_INCL) + dx*incFactor,	-py2p - dy,		31
			endif

			del 2
			del 2 + WIDO_REVEAL_SIDE * 2

		else			! if bParalellInCurvedWalls, curved walls

			if parapet_height > EPS & (SYMB_POS_Y - act_st_pos) > EPS then
				if wallIsLeft then

					dy = WOD - radBoard - parapetWallInsetDepth

					angd = asn( (parapet_width/2) / radBoard )
					dx2 = (radBoard + parapetWallInsetDepth) * tan(angd)

					dyrad = radBoard - sqr(radBoard^2 - (parapet_width/2)^2)
					dy2 = dyrad + parapetWallInsetDepth

					vyLeftIn =  dy
					vyRightIn =  dy

					vxLeft =  -parapet_width/2
					vyLeft =  dy + dy2
					vxRight =  parapet_width/2
					vyRight =  dy + dy2

					rotx 90
					addz SYMB_POS_Y - act_st_pos - parapet_height

					wallniche 6, 1, 2,
						0,0, 1,	parapet_height,
						 vxRight, vyRightIn,	31,
						 vxRight, vyLeft,	31,
						 vxRight, 1,	31,
						 vxLeft, 1,	31,
						 vxLeft, vyRight,	31,
						 vxLeft, vyLeftIn,	31

					del 2
				else

					angd = atn( (parapet_width/2) / radBoard )
					dy = radBoard + WOD

					vyLeftIn =  dy - parapetWallInsetDepth * cos(angd)
					vyRightIn =  dy - parapetWallInsetDepth * cos(angd)

					vxLeft = -parapet_width/2
					vyLeft =  dy
					vxRight =  parapet_width/2
					vyRight =  dy

					rotx 90
					addz SYMB_POS_Y - act_st_pos - parapet_height

					wallniche 6, 1, 2,
						0,0, 1,	parapet_height,
						 vxRight, vyRightIn,	31,
						 vxRight, vyLeft,	31,
						 vxRight, 1,	31,
						 vxLeft, 1,	31,
						 vxLeft, vyRight,	31,
						 vxLeft,	vyLeftIn,	31

					del 2
				endif
			endif
		endif
	endif
endif


! =============================================================================
! Curved Wall
! =============================================================================

if curvedWall & not(bParalellInCurvedWalls) then

	isParIns = 0

	bReveal = WIDO_REVEAL_ON | WIDO_SILL > EPS | not(gs_IsCurved)
	bUniformSideMats	= (matRevealSide = matOppositeSide)
	bOneCut				= (bUniformSideMats & WIDO_SILL < 0.005 & thkPlasterAtSill < EPS & thkPlasterAtBoard < EPS)	! Cut the hole with only one wallniche

	if iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC then
		bOneCut = 0
	endif

	if SYMB_ROTANGLE > EPS then addz WIDO_FRAME_THICKNESS
	if WIDO_REVEAL_SIDE then mulz -1

	if wallIsLeft then

		material matRevealSide

		addz -WIDO_FRAME_THICKNESS

! =============================================================================
! Outer Side Cut - Curved Left Wall
! =============================================================================

		if (WIDO_SILL > EPS | not(gs_IsCurved)) & not(bOneCut) then

			leftJamb	= leftWidth  + WOD * tan(alfaLeftOs - alfaLeftJamb) + gs_left_oversize
			rightJamb	= rightWidth + WOD * tan(alfaRightOs - alfaRightJamb) + gs_right_oversize

			thkPlasterAtSillLeft_distx = thkPlasterAtSillLeft / cos(alfaLeftOs - alfaLeftJamb)
			thkPlasterAtSillRight_distx = thkPlasterAtSillRight / cos(alfaRightOs - alfaRightJamb)

			px1 =  leftWidth  - leftJamb  + overSizeLeft + thkPlasterAtSillLeft_distx - SillPlasterAtFrame * tan(alfaLeftOs - alfaLeftJamb)
			px2 = -rightWidth + rightJamb - overSizeRight - thkPlasterAtSillRight_distx + SillPlasterAtFrame * tan(alfaRightOs - alfaRightJamb)

			! Searching for new plaster offset centerpoint
			x11 = px1
			y11 = WOD + SillPlasterAtFrame
			x12 = thkPlasterAtSillLeft_distx
			y12 = 0

			x21 = px2
			y21 = WOD + SillPlasterAtFrame
			x22 = -thkPlasterAtSillRight_distx
			y22 = 0

			gosub 100			! Line - Line intersection

			_bCustomMatNicheTop			= bCustomMatNicheTop
			_wallNicheSurfaceLeft		= matRevealSide
			_wallNicheSurfaceRight		= matRevealSide
			_wallNicheSurfaceBottom		= matRevealSide
			_wallNicheSurfaceTop		= matNicheTop

			cutMethod	= 3
			if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then
				cutStatus	= 2 + 16 + 256 * _bCustomMatNicheTop
			else
				cutStatus	= 2 + 16
			endif
			cutVectX	= cx
			cutVectY	= 0
			cutVectZ	= WOD - cy + SillPlasterAtFrame
			cutDepth	= 0

			sideRight	= rightWidth + overSizeRight
			sideLeft	= leftWidth  + overSizeLeft
			sideBottom	= overSizeLower
			sideTop		= B + overSizeUpper

			offLeft		= leftWidth  - WOD * tan(alfaLeftOs  - alfaLeftJamb)  + gs_left_oversize  + thkPlasterAtSillLeft_distx  - SillPlasterAtFrame * tan(alfaLeftOs - alfaLeftJamb)
			offRight	= rightWidth - WOD * tan(alfaRightOs - alfaRightJamb) + gs_right_oversize + thkPlasterAtSillRight_distx - SillPlasterAtFrame * tan(alfaRightOs - alfaRightJamb)
			offTop		= upperJamb + thkPlasterAtSillTop
			offBottom	= lowerJamb + thkPlasterAtSillBottom

			if iWindowShape = SHAPE_ELLIPSEARCH then
				smallRadiusEllips_offset	= smallRadiusEllips - offLeft
				middleRadiusEllips_offset	= middleRadiusEllips - offLeft
			endif

			if iWindowShape = SHAPE_GOTHICARCH then
				centArcoffs		= centSillArcoffs
			endif

			if iWindowShape = SHAPE_OGEECENTERED then
				centArcoffs		= centSillArcoffs
			endif

			if iWindowShape = SHAPE_SARACENIC then
				tangArcx		= SilltangArcx
				tangArcy		= SilltangArcy
				centArcoffs		= centSillArcoffs
			endif

			if iWindowShape = SHAPE_HORSESHOE then
				LowArcoffsy		= SillLowArcoffsy
				LowArcoffsx		= SillLowArcoffsx
				HighArcoffs		= SillHighArcoffs
			endif

			if iWindowShape = SHAPE_HALFARCH then
				Topx	= SillTopx
				Topy	= SillTopy
				Shouldx	= SillShouldx
				Shouldy	= SillShouldy
			endif

			if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
				MulRat = 1
			endif

			if bTShapedOpening then
				offSlLeft			= gs_reveal_left_sL   + thkPlasterAtSillSLLeft
				offSlRight			= gs_reveal_right_sR  + thkPlasterAtSillSLRight
				offSlLeftBottom		= gs_reveal_bottom_sL + thkPlasterAtSillSlLeftBottom
				offSlRightBottom	= gs_reveal_bottom_sR + thkPlasterAtSillSlRightBottom
			endif

			addz -SillPlasterAtFrame
			gosub 2000
			del 1
		endif


! =============================================================================
! Plaster Layer Outer Side Cut - Curved Left Wall
! =============================================================================

		if SillPlasterAtFrame > EPS then
			cutMethod	= 1
			cutStatus	= 2 + 16
			cutVectX	= 0
			cutVectY	= 0
			cutVectZ	= 1
			cutDepth	= 0

			sideRight	= rightWidth + overSizeRight
			sideLeft	= leftWidth  + overSizeLeft
			sideBottom	= overSizeLower !- bSillIsHorizontal * bBoardElevUsa
			sideTop		= B + overSizeUpper

			offLeft		= thkPlasterAtSillLeft  - (WIDO_FRAME_THICKNESS + (gs_stack_left  | bLeftCornerFunction)  * SillPlasterAtFrame) * tan(alfaLeftOs)
			offRight	= thkPlasterAtSillRight - (WIDO_FRAME_THICKNESS + (gs_stack_right | bRightCornerFunction) * SillPlasterAtFrame) * tan(alfaRightOs)
			offTop		= thkPlasterAtSillTop	  + (thkPlasterAtSillTop    < EPS) * gs_reveal_top
			offBottom	= thkPlasterAtSillBottom  + (thkPlasterAtSillBottom < EPS) * gs_reveal_bottom

			if iWindowShape = SHAPE_ELLIPSEARCH then
				smallRadiusEllips_offset	= smallRadiusEllips - offLeft
				middleRadiusEllips_offset	= middleRadiusEllips - offLeft
			endif

			if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
				MulRat = 1
			endif

			if bTShapedOpening then
				offSlLeft			= thkPlasterAtSillSlLeft
				offSlRight			= thkPlasterAtSillSlRight
				offSlLeftBottom		= thkPlasterAtSillSlLeftBottom  + (thkPlasterAtSillSlLeftBottom	 < EPS) * gs_reveal_bottom
				offSlRightBottom	= thkPlasterAtSillSlRightBottom + (thkPlasterAtSillSlRightBottom < EPS) * gs_reveal_bottom
			endif

			gosub 2000
		endif


! =============================================================================
! Inner Side Cut - Curved Left Wall
! =============================================================================

		material matOppositeSide

		thkPlasterAtBoardLeft_distx	 = thkPlasterAtBoardLeft  / cos(alfaLeftInnJamb)
		thkPlasterAtBoardRight_distx = thkPlasterAtBoardRight / cos(alfaRightInnJamb)

		if not(bSlantedInnerSide) then
			if iRevealType = REVEAL_DOUBLE then
				dxL = 0
				dxR = 0
			else
				dxL = WIDO_FRAME_THICKNESS * tan(alfaLeftOs)
				dxR = WIDO_FRAME_THICKNESS * tan(alfaRightOs)
			endif

			px1 =  rightWidth + overSizeRight - CustRevealRightJamb - thkPlasterAtBoardRight_distx - BoardPlasterAtFrame * tan(alfaRightInnJamb) + dxR
			px2 = -leftWidth  - overSizeLeft  + CustRevealLeftJamb  + thkPlasterAtBoardLeft_distx  + BoardPlasterAtFrame * tan(alfaLeftInnJamb)  - dxL

			! Searching for new plaster offset centerpoint
			x11 = px1
			y11 = tempWOD - BoardPlasterAtFrame + (WIDO_FRAME_THICKNESS * (iRevealType <> REVEAL_DOUBLE))
			x12 = -thkPlasterAtBoardRight_distx
			y12 = 0

			x21 = px2
			y21 = tempWOD - BoardPlasterAtFrame + (WIDO_FRAME_THICKNESS * (iRevealType <> REVEAL_DOUBLE))
			x22 = thkPlasterAtBoardLeft_distx
			y22 = 0

			gosub 100			! Line - Line intersection

			cutZ = WOD - (iRevealType = REVEAL_DOUBLE) * WIDO_FRAME_THICKNESS - cy - BoardPlasterAtFrame

			cutMethod	= 3
			cutStatus	= 2 + (8 + 16) * (not(bReveal) | bOneCut)
			cutVectX	= cx
			cutVectY	= 0
			cutVectZ	= cutZ
			cutDepth	= cutZ

			sideRight	= rightWidth + overSizeRight
			sideLeft	= leftWidth  + overSizeLeft
			sideBottom	= overSizeLower - bSillIsHorizontal * bBoardElevUsa
			sideTop		= B + overSizeUpper

			offLeft		= CustRevealLeftJamb  + thkPlasterAtBoardLeft_distx  + BoardPlasterAtFrame * tan(alfaLeftInnJamb)  - dxL
			offRight	= CustRevealRightJamb + thkPlasterAtBoardRight_distx + BoardPlasterAtFrame * tan(alfaRightInnJamb) - dxR
			offTop		= CustRevealTopJamb   + thkPlasterAtBoardTop
			offBottom	= CustRevealBottJamb  + thkPlasterAtBoardBottom

			if iWindowShape = SHAPE_ELLIPSEARCH then
				smallRadiusEllips_offset	= smallRadiusEllips - offLeft
				middleRadiusEllips_offset	= middleRadiusEllips - offLeft
			endif

			if iWindowShape = SHAPE_GOTHICARCH then
				centArcoffs		= centBoardArcoffs
			endif

			if iWindowShape = SHAPE_OGEECENTERED then
				centArcoffs		= centBoardArcoffs
			endif

			if iWindowShape = SHAPE_SARACENIC then
				tangArcx		= BoardtangArcx
				tangArcy		= BoardtangArcy
				centArcoffs		= centBoardArcoffs
			endif

			if iWindowShape = SHAPE_HORSESHOE then
				LowArcoffsy		= BoardLowArcoffsy
				LowArcoffsx		= BoardLowArcoffsx
				HighArcoffs		= BoardHighArcoffs
			endif

			if iWindowShape = SHAPE_HALFARCH then
				Topx	= BoardTopx
				Topy	= BoardTopy
				Shouldx	= BoardShouldx
				Shouldy	= BoardShouldy
			endif

			if bTShapedOpening then
				offSlLeft			= gs_reveal_double_innerLeft_sL   + thkPlasterAtBoardSlLeft
				offSlRight			= gs_reveal_double_innerRight_sR  + thkPlasterAtBoardSlRight
				offSlLeftBottom		= gs_reveal_double_innerBottom_sL + thkPlasterAtBoardSlLeftBottom
				offSlRightBottom	= gs_reveal_double_innerBottom_sR + thkPlasterAtBoardSlRightBottom
			endif

			if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
				MulRat = openingHeight / (openingHeight + (2 * WIDO_FRAME_THICKNESS * tan(alfaRightOs)))
			endif

			addz (iRevealType = REVEAL_DOUBLE) * WIDO_FRAME_THICKNESS + BoardPlasterAtFrame
			gosub 2000
			del 1
		endif


! =============================================================================
! Plaster Layer Inner Side Cut - Curved Left Wall
! =============================================================================

		if not(bSlantedInnerSide) & BoardPlasterAtFrame > EPS then
			cutMethod	= 1
			cutStatus	= 2	! Finite cut
			cutVectX	= 0
			cutVectY	= 0
			cutVectZ	= -1
			cutDepth	= -BoardPlasterAtFrame - EPS

			sideRight	= rightWidth + overSizeRight
			sideLeft	= leftWidth  + overSizeLeft
			sideBottom	= overSizeLower - bSillIsHorizontal * bBoardElevUsa
			sideTop		= B + overSizeUpper

			offLeft		= thkPlasterAtBoardLeft
			offRight	= thkPlasterAtBoardRight
			offTop		= thkPlasterAtBoardTop	  + (thkPlasterAtBoardTop    < EPS) * (CustRevealTopJamb  + offsetInsideTop)
			offBottom	= thkPlasterAtBoardBottom + (thkPlasterAtBoardBottom < EPS) * (CustRevealBottJamb + offsetInsideBott)

			if iWindowShape = SHAPE_ELLIPSEARCH then
				smallRadiusEllips_offset	= smallRadiusEllips - offLeft
				middleRadiusEllips_offset	= middleRadiusEllips - offLeft
			endif

			if bTShapedOpening then
				offSlLeft			= thkPlasterAtBoardSlLeft
				offSlRight			= thkPlasterAtBoardSlRight
				offSlLeftBottom		= thkPlasterAtBoardSlLeftBottom  + (thkPlasterAtBoardSlLeftBottom  < EPS) * (CustRevealBottJamb + offsetInsideBott)
				offSlRightBottom	= thkPlasterAtBoardSlRightBottom + (thkPlasterAtBoardSlRightBottom < EPS) * (CustRevealBottJamb + offsetInsideBott)
			endif

			if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
				MulRat = openingHeight / (openingHeight + (2 * WIDO_FRAME_THICKNESS * tan(alfaRightOs)))
			endif

			addz WIDO_FRAME_THICKNESS
			gosub 2000
			del 1
		endif


! =============================================================================
! Slanted Inner Side Cut - Curved Left Wall
! =============================================================================


		if bSlantedInnerSide then
			addz WALL_THICKNESS - WIDO_SILL

			if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then
				gs_slanted_left_angle		= gs_reveal_left_angle
				gs_slanted_right_angle		= gs_reveal_right_angle
				gs_slanted_bottom_angle		= gs_reveal_bottom_angle
				gs_slanted_top_angle		= gs_reveal_top_angle
				thkPlasterAtSlantedLeft		= thkPlasterAtBoardLeft
				thkPlasterAtSlantedRight	= thkPlasterAtBoardRight
				thkPlasterAtSlantedBottom	= thkPlasterAtBoardBottom
				thkPlasterAtSlantedTop		= thkPlasterAtBoardTop
				thkPlasterAtSlanted			= thkPlasterAtBoard
				HalfInfiniteCut				= 1
				slantedDepth		= (WALL_THICKNESS - WIDO_SILL - offsetInsideDepth - not(iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) * thkPlasterAtBoard)
				slantedDepthBottom	= slantedDepth
				slantedCutDepth		= slantedDepth
				offsetDepth	= offsetInsideDepth
				offsetRight	= offsetInsideRight
				offsetLeft	= offsetInsideLeft
				offsetTop	= offsetInsideTop
				offsetBott	= offsetInsideBott + bSillIsHorizontal * bBoardElevUsa
				bWallInsetCut	= 1

				gosub 1000	! Slanted Reveal cutting body
			endif

			del 1
		endif


! =============================================================================
! Slanted Outer Side Cut - Curved Left Wall
! =============================================================================

		if bSlantedOuterSide then
			if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then

				gs_slanted_left_angle		= gs_reveal_outerLeft_angle	 + alfaLeftOs  - alfaLeftJamb
				gs_slanted_right_angle		= gs_reveal_outerRight_angle + alfaRightOs - alfaRightJamb
				gs_slanted_bottom_angle		= gs_reveal_outerBottom_angle
				gs_slanted_top_angle		= gs_reveal_outerTop_angle
				thkPlasterAtSlantedLeft		= thkPlasterAtSillLeft
				thkPlasterAtSlantedRight	= thkPlasterAtSillRight
				thkPlasterAtSlantedBottom	= thkPlasterAtSillBottom
				thkPlasterAtSlantedTop		= thkPlasterAtSillTop
				thkPlasterAtSlanted			= 0
				HalfInfiniteCut				= 1
				slantedDepth		= WIDO_SILL - gs_reveal_outer_jamb_depth
				slantedDepthBottom	= WIDO_SILL - bHaveMountingFrame * (gs_mountingFrame_depth)
				slantedCutDepth		= slantedDepth
				offsetDepth		= offsetOutsideDepth
				offsetRight		= rightWidth - (abs(WOD) + gs_reveal_outer_jamb_depth) * tan(alfaRightOs - alfaRightJamb)
				offsetLeft		= leftWidth  - (abs(WOD) + gs_reveal_outer_jamb_depth) * tan(alfaLeftOs  - alfaLeftJamb)
				offsetTop		= gs_reveal_top
				offsetBott		= gs_reveal_bottom - (not(bHaveMountingFrame) * gs_reveal_outer_jamb_depth + bHaveMountingFrame * (gs_reveal_outer_jamb_depth - gs_mountingFrame_depth)) * tan(gs_reveal_outerBottom_angle)
				bWallInsetCut	= 0

				mulz -1
				addz WIDO_SILL
				gosub 1000	! Slanted Reveal cutting body
				del 2
			endif
		endif


! =============================================================================
! Middle cut at window range - Curved Left Wall
! =============================================================================

		if WIDO_FRAME_THICKNESS > EPS & bNeedMiddleCut then
			cutMethod	= 3
			cutStatus	= 2
			cutVectX	= 0
			cutVectY	= 0
			cutVectZ	= WOD
			cutDepth	= WIDO_FRAME_THICKNESS

			sideRight	= rightWidth + overSizeRight
			sideLeft	= leftWidth  + overSizeLeft
			sideBottom	= overSizeLower
			sideTop		= B + overSizeUpper

			offLeft		= -WIDO_FRAME_THICKNESS * tan(alfaLeftOs)
			offRight	= -WIDO_FRAME_THICKNESS * tan(alfaRightOs)
			offTop		= 0
			offBottom	= 0

			if iWindowShape = SHAPE_ELLIPSEARCH then
				smallRadiusEllips_offset	= smallRadiusEllips - offLeft
				middleRadiusEllips_offset	= middleRadiusEllips - offLeft
			endif

			if iWindowShape = SHAPE_HALFARCH then
				Topx	= FrameTopx
				Topy	= FrameTopy
				Shouldx	= FrameShouldx
				Shouldy	= FrameShouldy
			endif

			if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
				MulRat = openingHeight / (openingHeight + (2 * WIDO_FRAME_THICKNESS * tan(alfaRightOs)))
			endif

			if iWindowShape = SHAPE_HORSESHOE then
				LowArcoffsy		= FrameLowArcoffsy
				LowArcoffsx		= FrameLowArcoffsx
				HighArcoffs		= FrameHighArcoffs
			endif

			if bTShapedOpening then
				offSlLeft			= 0
				offSlRight			= 0
				offSlLeftBottom		= 0
				offSlRightBottom	= 0
			endif

			if iRevealType = REVEAL_SLANTED then
				gs_slanted_left_angle		= gs_reveal_left_angle
				gs_slanted_right_angle		= gs_reveal_right_angle
				gs_slanted_bottom_angle		= gs_reveal_bottom_angle
				gs_slanted_top_angle		= gs_reveal_top_angle
				thkPlasterAtSlantedLeft		= 0
				thkPlasterAtSlantedRight	= 0
				thkPlasterAtSlantedBottom	= 0
				thkPlasterAtSlantedTop		= 0
				thkPlasterAtSlanted			= 0
				HalfInfiniteCut				= 0
				slantedDepth		= WIDO_FRAME_THICKNESS
				slantedDepthBottom	= slantedDepth
				slantedCutDepth		= slantedDepth
				offsetDepth		= offsetInsideDepth
				offsetRight		= offsetInsideRight
				offsetLeft		= offsetInsideLeft
				offsetTop		= offsetInsideTop
				offsetBott		= offsetInsideBott
				bWallInsetCut	= 0

				addz WIDO_FRAME_THICKNESS
				gosub 1000	! Slanted Reveal cutting body
				del 1
			else
				gosub 2000
			endif
		endif


! =============================================================================
! Cut Wall Inset - Curved Left Wall
! =============================================================================

		if bParapetWallInset & SYMB_POS_Y > overSizeLower & not(isParIns) & parapet_height > EPS & (SYMB_POS_Y - act_st_pos) > EPS then

			insetY = WOD - signWallIsLeft * radBoard - parapetWallInsetDepth

			if gs_parapet_autodim & thkPlasterAtBoardLeft > EPS then
				x1 = cx - opInner / 2 - parapetExtendLeft
				y1 = WOD - signWallIsLeft * sqr(radBoard^2 - x1^2) - thkPlasterAtBoardLeft * sin(alfaLeftInnJamb)
				x1 = x1 + thkPlasterAtBoardLeft * cos(alfaLeftInnJamb)
				x2 = x1 - thkPlasterAtBoardLeft * sin(alfaLeftInnJamb)
				y2 = y1 - thkPlasterAtBoardLeft * cos(alfaLeftInnJamb)
				xo = 0
				yo = WOD
				ro = radBoard

				gosub 101	! Circle - Line intersection

				if ya > yb then
					pxL1 = xa
					pyL1 = ya
				else
					pxL1 = xb
					pyL1 = yb
				endif

				alpha = alfaLeftInnJamb
			else
				pxL1 = cx - opInner / 2 - parapetExtendLeft
				pyL1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxL1^2)

				alpha = abs(asn(pxL1 / radBoard))
			endif
			pxL2 = pxL1 - signWallIsLeft * tan(alpha) * abs(pyL1 - insetY)
			pyL2 = insetY

			if gs_parapet_autodim & thkPlasterAtBoardRight > EPS then
				x1 = cx + opInner / 2 + parapetExtendRight
				y1 = WOD - signWallIsLeft * sqr(radBoard^2 - x1^2) - thkPlasterAtBoardRight * sin(alfaRightInnJamb)
				x1 = x1 - thkPlasterAtBoardRight * cos(alfaRightInnJamb)
				x2 = x1 + thkPlasterAtBoardRight * sin(alfaRightInnJamb)
				y2 = y1 - thkPlasterAtBoardRight * cos(alfaRightInnJamb)
				xo = 0
				yo = WOD
				ro = radBoard

				gosub 101	! Circle - Line intersection

				if ya > yb then
					pxR1 = xa
					pyR1 = ya
				else
					pxR1 = xb
					pyR1 = yb
				endif

				alpha = alfaRightInnJamb
			else
				pxR1 = cx + opInner / 2 + parapetExtendRight
				pyR1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxR1^2)

				alpha = abs(asn(pxR1 / radBoard))
			endif
			pxR2 = pxR1 + signWallIsLeft * tan(alpha) * abs(pyR1 - insetY)
			pyR2 = insetY

			rotx 90
			addz SYMB_POS_Y - act_st_pos - parapet_height - thkPlasterAtBoardBottom * gs_parapet_autodim

			wallniche 6, 1, 2,
				0,0, 1,	parapet_height + thkPlasterAtBoardBottom * gs_parapet_autodim,
				 pxR2, pyR2,	31,
				 pxR1, pyR1,	31,
				 pxR1, 1,		31,
				 pxL1, 1,		31,
				 pxL1, pyL1,	31,
				 pxL2, pyL2,	31
			del 2
		endif

		del 1
	endif

	if not(wallIsLeft) then

		material matRevealSide

! =============================================================================
! Outer Side Cut - Curved NonLeft Wall
! =============================================================================

		if (WIDO_SILL > EPS | not(gs_IsCurved)) & not(bOneCut) then

			leftJamb	= leftWidth  + WOD * tan(alfaLeftOs  - alfaLeftJamb)  + gs_left_oversize
			rightJamb	= rightWidth + WOD * tan(alfaRightOs - alfaRightJamb) + gs_right_oversize

			if gs_stack_left	then leftJamb	= 0
			if gs_stack_right	then rightJamb	= 0

			thkPlasterAtSillLeft_distx	= thkPlasterAtSillLeft  / cos(alfaLeftOs  - alfaLeftJamb)
			thkPlasterAtSillRight_distx	= thkPlasterAtSillRight / cos(alfaRightOs - alfaRightJamb)

			px1 =  leftWidth  - leftJamb  + overSizeLeft  + thkPlasterAtSillLeft_distx  - SillPlasterAtFrame * tan(alfaLeftOs  - alfaLeftJamb)
			px2 = -rightWidth + rightJamb - overSizeRight - thkPlasterAtSillRight_distx + SillPlasterAtFrame * tan(alfaRightOs - alfaRightJamb)

			! Searching for new plaster offset centerpoint
			x11 = px1
			y11 = WOD + SillPlasterAtFrame
			x12 = thkPlasterAtSillLeft_distx
			y12 = 0

			x21 = px2
			y21 = WOD + SillPlasterAtFrame
			x22 = -thkPlasterAtSillRight_distx
			y22 = 0

			gosub 100			! Line - Line intersection

			cutMethod	= 3

			_bCustomMatNicheTop			= bCustomMatNicheTop
			_wallNicheSurfaceLeft		= matRevealSide
			_wallNicheSurfaceRight		= matRevealSide
			_wallNicheSurfaceBottom		= matRevealSide
			_wallNicheSurfaceTop		= matNicheTop

			if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then
				cutStatus	= 2 + 256 * _bCustomMatNicheTop
			else
				cutStatus	= 2
			endif

			cutVectX	= cx
			cutVectY	= 0
			cutVectZ	= WOD + cy + SillPlasterAtFrame
			cutDepth	= abs(WOD)

			sideRight	= rightWidth + overSizeRight
			sideLeft	= leftWidth  + overSizeLeft
			sideBottom	= overSizeLower
			sideTop		= B + overSizeUpper

			offLeft		= leftWidth  - abs(WOD) * tan(alfaLeftOs  - alfaLeftJamb)  + gs_left_oversize  + thkPlasterAtSillLeft_distx  + SillPlasterAtFrame * tan(alfaLeftOs  - alfaLeftJamb)
			offRight	= rightWidth - abs(WOD) * tan(alfaRightOs - alfaRightJamb) + gs_right_oversize + thkPlasterAtSillRight_distx + SillPlasterAtFrame * tan(alfaRightOs - alfaRightJamb)
			offTop		= upperJamb + thkPlasterAtSillTop
			offBottom	= lowerJamb + thkPlasterAtSillBottom

			if iWindowShape = SHAPE_ELLIPSEARCH then
				smallRadiusEllips_offset	= smallRadiusEllips - offLeft
				middleRadiusEllips_offset	= middleRadiusEllips - offLeft
			endif

			if iWindowShape = SHAPE_GOTHICARCH then
				centArcoffs		= centSillArcoffs
			endif

			if iWindowShape = SHAPE_OGEECENTERED then
				centArcoffs		= centSillArcoffs
			endif

			if iWindowShape = SHAPE_SARACENIC then
				tangArcx		= SilltangArcx
				tangArcy		= SilltangArcy
				centArcoffs		= centSillArcoffs
			endif

			if iWindowShape = SHAPE_HORSESHOE then
				LowArcoffsy		= SillLowArcoffsy
				LowArcoffsx		= SillLowArcoffsx
				HighArcoffs		= SillHighArcoffs
			endif

			if iWindowShape = SHAPE_HALFARCH then
				Topx	= SillTopx
				Topy	= SillTopy
				Shouldx	= SillShouldx
				Shouldy	= SillShouldy
			endif

			if bTShapedOpening then
				offSlLeft			= gs_reveal_left_sL   + thkPlasterAtSillSLLeft
				offSlRight			= gs_reveal_right_sR  + thkPlasterAtSillSLRight
				offSlLeftBottom		= gs_reveal_bottom_sL + thkPlasterAtSillSlLeftBottom
				offSlRightBottom	= gs_reveal_bottom_sR + thkPlasterAtSillSlRightBottom
			endif

			if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
				MulRat = 1
			endif

			addz -SillPlasterAtFrame
			gosub 2000
			del 1
		endif


! =============================================================================
! Plaster Layer Outer Side Cut - Curved NonLeft Wall
! =============================================================================

		if SillPlasterAtFrame > EPS then
			cutMethod	= 1
			cutStatus	= 2	! Finite cut
			cutVectX	= 0
			cutVectY	= 0
			cutVectZ	= -1
			cutDepth	= SillPlasterAtFrame

			sideRight	= rightWidth + overSizeRight
			sideLeft	= leftWidth  + overSizeLeft
			sideBottom	= overSizeLower						 !- bSillIsHorizontal * bBoardElevUsa
			sideTop		= B + overSizeUpper

			offLeft		= thkPlasterAtSillLeft  - ((gs_stack_left  | bLeftCornerFunction)  * SillPlasterAtFrame) * tan(alfaLeftOs)
			offRight	= thkPlasterAtSillRight - ((gs_stack_right | bRightCornerFunction) * SillPlasterAtFrame) * tan(alfaRightOs)
			offTop		= thkPlasterAtSillTop	  + (thkPlasterAtSillTop    < EPS) * gs_reveal_top
			offBottom	= thkPlasterAtSillBottom  + (thkPlasterAtSillBottom < EPS) * gs_reveal_bottom

			if iWindowShape = SHAPE_ELLIPSEARCH then
				smallRadiusEllips_offset	= smallRadiusEllips - offLeft
				middleRadiusEllips_offset	= middleRadiusEllips - offLeft
			endif

			if bTShapedOpening then
				offSlLeft			= thkPlasterAtSillSlLeft
				offSlRight			= thkPlasterAtSillSlRight
				offSlLeftBottom		= thkPlasterAtSillSlLeftBottom  + (thkPlasterAtSillSlLeftBottom  < EPS) * gs_reveal_bottom
				offSlRightBottom	= thkPlasterAtSillSlRightBottom + (thkPlasterAtSillSlRightBottom < EPS) * gs_reveal_bottom
			endif

			if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
				MulRat = 1
			endif

			gosub 2000
		endif


! =============================================================================
! Inner Side Cut - Curved NonLeft Wall
! =============================================================================

		material matOppositeSide

		if not(bSlantedInnerSide) then
			thkPlasterAtBoardLeft_distx	 = thkPlasterAtBoardLeft  / cos(alfaLeftInnJamb)
			thkPlasterAtBoardRight_distx = thkPlasterAtBoardRight / cos(alfaRightInnJamb)

			if iRevealType = REVEAL_DOUBLE then
				dxL = WIDO_FRAME_THICKNESS * tan(alfaLeftOs)
				dxR = WIDO_FRAME_THICKNESS * tan(alfaRightOs)
			else
				dxL = 0
				dxR = 0
			endif

			px1 =  rightWidth + overSizeRight - CustRevealRightJamb - thkPlasterAtBoardRight_distx - BoardPlasterAtFrame * tan(alfaRightInnJamb) + dxR
			px2 = -leftWidth  - overSizeLeft  + CustRevealLeftJamb  + thkPlasterAtBoardLeft_distx  + BoardPlasterAtFrame * tan(alfaLeftInnJamb)  - dxL

			! Searching for new plaster offset centerpoint
			x11 = px1
			y11 = tempWOD + BoardPlasterAtFrame + (WIDO_FRAME_THICKNESS * (iRevealType = REVEAL_DOUBLE))
			x12 = -thkPlasterAtBoardRight_distx
			y12 = 0

			x21 = px2
			y21 = tempWOD + BoardPlasterAtFrame + (WIDO_FRAME_THICKNESS * (iRevealType = REVEAL_DOUBLE))
			x22 = thkPlasterAtBoardLeft_distx
			y22 = 0

			gosub 100			! Line - Line intersection

			cutZ = WOD - (iRevealType = REVEAL_DOUBLE) * WIDO_FRAME_THICKNESS + cy - BoardPlasterAtFrame

			cutMethod	= 3
			cutStatus	= 2 + 8 * (not(bReveal) | bOneCut) + 16
			cutVectX	= cx
			cutVectY	= 0
			cutVectZ	= cutZ
			cutDepth	= 0

			sideRight	= rightWidth + overSizeRight
			sideLeft	= leftWidth  + overSizeLeft
			sideBottom	= overSizeLower - bSillIsHorizontal * bBoardElevUsa
			sideTop		= B + overSizeUpper

			offLeft		= CustRevealLeftJamb  + thkPlasterAtBoardLeft_distx  - BoardPlasterAtFrame * tan(alfaLeftInnJamb)  - dxL
			offRight	= CustRevealRightJamb + thkPlasterAtBoardRight_distx - BoardPlasterAtFrame * tan(alfaRightInnJamb) - dxR
			offTop		= CustRevealTopJamb   + thkPlasterAtBoardTop
			offBottom	= CustRevealBottJamb  + thkPlasterAtBoardBottom

			if iWindowShape = SHAPE_ELLIPSEARCH then
				smallRadiusEllips_offset	= smallRadiusEllips - offLeft
				middleRadiusEllips_offset	= middleRadiusEllips - offLeft
			endif

			if iWindowShape = SHAPE_GOTHICARCH then
				centArcoffs		= centBoardArcoffs
			endif

			if iWindowShape = SHAPE_OGEECENTERED then
				centArcoffs		= centBoardArcoffs
			endif

			if iWindowShape = SHAPE_SARACENIC then
				tangArcx		= BoardtangArcx
				tangArcy		= BoardtangArcy
				centArcoffs		= centBoardArcoffs
			endif

			if iWindowShape = SHAPE_HORSESHOE then
				LowArcoffsy		= BoardLowArcoffsy
				LowArcoffsx		= BoardLowArcoffsx
				HighArcoffs		= BoardHighArcoffs
			endif

			if iWindowShape = SHAPE_HALFARCH then
				Topx	= BoardTopx
				Topy	= BoardTopy
				Shouldx	= BoardShouldx
				Shouldy	= BoardShouldy
			endif

			if bTShapedOpening then
				offSlLeft			= gs_reveal_double_innerLeft_sL   + thkPlasterAtBoardSlLeft
				offSlRight			= gs_reveal_double_innerRight_sR  + thkPlasterAtBoardSlRight
				offSlLeftBottom		= gs_reveal_double_innerBottom_sL + thkPlasterAtBoardSlLeftBottom
				offSlRightBottom	= gs_reveal_double_innerBottom_sR + thkPlasterAtBoardSlRightBottom
			endif

			if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
				MulRat = openingHeight / (openingHeight + (2 * WIDO_FRAME_THICKNESS * tan(alfaRightOs)))
			endif

			addz (iRevealType = REVEAL_DOUBLE) * WIDO_FRAME_THICKNESS + BoardPlasterAtFrame
			gosub 2000
			del 1
		endif


! =============================================================================
! Plaster Layer Inner Side Cut - Curved NonLeft Wall
! =============================================================================

		if not(bSlantedInnerSide) & BoardPlasterAtFrame > EPS then

			if iRevealType = REVEAL_DOUBLE then
				dxL = WIDO_FRAME_THICKNESS * tan(alfaLeftOs)
				dxR = WIDO_FRAME_THICKNESS * tan(alfaRightOs)
			else
				dxL = 0
				dxR = 0
			endif

			cutMethod	= 1
			cutStatus	= 2 + 16
			cutVectX	= 0
			cutVectY	= 0
			cutVectZ	= -1
			cutDepth	= -WIDO_FRAME_THICKNESS

			sideRight	= rightWidth + overSizeRight
			sideLeft	= leftWidth  + overSizeLeft
			sideBottom	= overSizeLower - bSillIsHorizontal * bBoardElevUsa
			sideTop		= B + overSizeUpper

			offLeft		= thkPlasterAtBoardLeft  - dxL
			offRight	= thkPlasterAtBoardRight - dxR
			offTop		= thkPlasterAtBoardTop	  + (thkPlasterAtBoardTop    < EPS) * (CustRevealTopJamb  + offsetInsideTop)
			offBottom	= thkPlasterAtBoardBottom + (thkPlasterAtBoardBottom < EPS) * (CustRevealBottJamb + offsetInsideBott)

			if iWindowShape = SHAPE_ELLIPSEARCH then
				smallRadiusEllips_offset	= smallRadiusEllips - offLeft
				middleRadiusEllips_offset	= middleRadiusEllips - offLeft
			endif

			if bTShapedOpening then
				offSlLeft			= thkPlasterAtBoardSlLeft
				offSlRight			= thkPlasterAtBoardSlRight
				offSlLeftBottom		= thkPlasterAtBoardSlLeftBottom  + (thkPlasterAtBoardSlLeftBottom  < EPS) * (CustRevealBottJamb + offsetInsideBott)
				offSlRightBottom	= thkPlasterAtBoardSlRightBottom + (thkPlasterAtBoardSlRightBottom < EPS) * (CustRevealBottJamb + offsetInsideBott)
			endif

			if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
				MulRat = openingHeight / (openingHeight + (2 * WIDO_FRAME_THICKNESS * tan(alfaRightOs)))
			endif

			gosub 2000
		endif


! =============================================================================
! Slanted Inner Side Cut - Curved NonLeft Wall
! =============================================================================

		if bSlantedInnerSide then
			addz WALL_THICKNESS - WIDO_SILL

			if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then
				gs_slanted_left_angle		= gs_reveal_left_angle
				gs_slanted_right_angle		= gs_reveal_right_angle
				gs_slanted_bottom_angle		= gs_reveal_bottom_angle
				gs_slanted_top_angle		= gs_reveal_top_angle
				thkPlasterAtSlantedLeft		= thkPlasterAtBoardLeft
				thkPlasterAtSlantedRight	= thkPlasterAtBoardRight
				thkPlasterAtSlantedBottom	= thkPlasterAtBoardBottom
				thkPlasterAtSlantedTop		= thkPlasterAtBoardTop
				thkPlasterAtSlanted			= thkPlasterAtBoard
				HalfInfiniteCut				= 1
				slantedDepth		= (WALL_THICKNESS - WIDO_SILL - offsetInsideDepth - not(iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) * thkPlasterAtBoard)
				slantedDepthBottom	= slantedDepth
				slantedCutDepth		= slantedDepth
				offsetDepth		= offsetInsideDepth
				offsetRight		= offsetInsideRight - (iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC) * WIDO_FRAME_THICKNESS * tan(alfaRightOs)
				offsetLeft		= offsetInsideLeft  - (iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC) * WIDO_FRAME_THICKNESS * tan(alfaLeftOs)
				offsetTop		= offsetInsideTop
				offsetBott		= offsetInsideBott + bSillIsHorizontal * bBoardElevUsa
				bWallInsetCut	= 1

				gosub 1000	! Slanted Reveal cutting body
			endif

			del 1
		endif


! =============================================================================
! Slanted Outer Side Cut - Straight Wall
! =============================================================================

		if bSlantedOuterSide then
			if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then

				gs_slanted_left_angle		= gs_reveal_outerLeft_angle  - (alfaLeftOs  - alfaLeftJamb)
				gs_slanted_right_angle		= gs_reveal_outerRight_angle - (alfaRightOs - alfaRightJamb)
				gs_slanted_bottom_angle		= gs_reveal_outerBottom_angle
				gs_slanted_top_angle		= gs_reveal_outerTop_angle
				thkPlasterAtSlantedLeft		= thkPlasterAtSillLeft
				thkPlasterAtSlantedRight	= thkPlasterAtSillRight
				thkPlasterAtSlantedBottom	= thkPlasterAtSillBottom
				thkPlasterAtSlantedTop		= thkPlasterAtSillTop
				thkPlasterAtSlanted			= 0
				HalfInfiniteCut				= 1
				slantedDepth		= WIDO_SILL - gs_reveal_outer_jamb_depth
				slantedDepthBottom	= WIDO_SILL - bHaveMountingFrame * (gs_mountingFrame_depth)
				slantedCutDepth		= WIDO_SILL
				offsetDepth		= offsetOutsideDepth
				offsetRight		= rightWidth - (abs(WOD) - gs_reveal_outer_jamb_depth) * tan(alfaRightOs - alfaRightJamb)
				offsetLeft		= leftWidth  - (abs(WOD) - gs_reveal_outer_jamb_depth) * tan(alfaLeftOs  - alfaLeftJamb)
				offsetTop		= gs_reveal_top
				offsetBott		= gs_reveal_bottom - (not(bHaveMountingFrame) * gs_reveal_outer_jamb_depth + bHaveMountingFrame * (gs_reveal_outer_jamb_depth - gs_mountingFrame_depth)) * tan(gs_reveal_outerBottom_angle)
				bWallInsetCut	= 0

				mulz -1
				addz WIDO_SILL
				gosub 1000	! Slanted Reveal cutting body
				del 2
			endif
		endif


! =============================================================================
! Middle cut at window range - Curved NonLeft Wall
! =============================================================================

		if WIDO_FRAME_THICKNESS > EPS & bNeedMiddleCut then

			cutMethod	= 3
			cutStatus	= 2
			cutVectX	= 0
			cutVectY	= 0
			cutVectZ	= WOD - (iRevealType = REVEAL_SLANTED) * WIDO_FRAME_THICKNESS
			if iRevealType = REVEAL_SLANTED then
				cutDepth	= WIDO_FRAME_THICKNESS
			else
				cutDepth	= -WIDO_FRAME_THICKNESS
			endif

			sideRight	= rightWidth + overSizeRight
			sideLeft	= leftWidth  + overSizeLeft
			sideBottom	= overSizeLower
			sideTop		= B + overSizeUpper

			offLeft		= -WIDO_FRAME_THICKNESS * tan(alfaLeftOs)  * (iRevealType = REVEAL_SLANTED)
			offRight	= -WIDO_FRAME_THICKNESS * tan(alfaRightOs) * (iRevealType = REVEAL_SLANTED)
			offTop		= 0
			offBottom	= 0

			if iWindowShape = SHAPE_ELLIPSEARCH then
				smallRadiusEllips_offset	= smallRadiusEllips - offLeft
				middleRadiusEllips_offset	= middleRadiusEllips - offLeft
			endif

			if iWindowShape = SHAPE_HALFARCH then
				Topx	= FrameTopx
				Topy	= FrameTopy
				Shouldx	= FrameShouldx
				Shouldy	= FrameShouldy
			endif

			if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
				MulRat = openingHeight / (openingHeight + (2 * WIDO_FRAME_THICKNESS * tan(alfaRightOs)))
			endif

			if iWindowShape = SHAPE_HORSESHOE then
				LowArcoffsy		= FrameLowArcoffsy
				LowArcoffsx		= FrameLowArcoffsx
				HighArcoffs		= FrameHighArcoffs
			endif

			if bTShapedOpening then
				offSlLeft			= 0
				offSlRight			= 0
				offSlLeftBottom		= 0
				offSlRightBottom	= 0
			endif

			if iRevealType = REVEAL_SLANTED then
				gs_slanted_left_angle		= gs_reveal_left_angle
				gs_slanted_right_angle		= gs_reveal_right_angle
				gs_slanted_bottom_angle		= gs_reveal_bottom_angle
				gs_slanted_top_angle		= gs_reveal_top_angle
				thkPlasterAtSlantedLeft		= 0
				thkPlasterAtSlantedRight	= 0
				thkPlasterAtSlantedBottom	= 0
				thkPlasterAtSlantedTop		= 0
				thkPlasterAtSlanted			= 0
				HalfInfiniteCut				= 0
				slantedDepth		= WIDO_FRAME_THICKNESS
				slantedDepthBottom	= slantedDepth
				slantedCutDepth		= slantedDepth
				offsetDepth		= offsetInsideDepth
				offsetRight		= offsetInsideRight
				offsetLeft		= offsetInsideLeft
				offsetTop		= offsetInsideTop
				offsetBott		= offsetInsideBott
				bWallInsetCut	= 0

				addz WIDO_FRAME_THICKNESS
				gosub 1000	! Slanted Reveal cutting body
				del 1
			else
				gosub 2000
			endif
		endif


! =============================================================================
! Cut Wall Inset - Curved NonLeft Wall
! =============================================================================

		if bParapetWallInset & SYMB_POS_Y > overSizeLower & not(isParIns) & parapet_height > EPS & (SYMB_POS_Y - act_st_pos) > EPS then

			insetY = WOD - signWallIsLeft * radBoard - parapetWallInsetDepth

			if gs_parapet_autodim & thkPlasterAtBoardLeft > EPS then
				x1 = cx - opInner / 2 - parapetExtendLeft
				y1 = WOD - signWallIsLeft * sqr(radBoard^2 - x1^2) + thkPlasterAtBoardLeft * sin(alfaLeftInnJamb)
				x1 = x1 + thkPlasterAtBoardLeft * cos(alfaLeftInnJamb)
				x2 = x1 + thkPlasterAtBoardLeft * sin(alfaLeftInnJamb)
				y2 = y1 - thkPlasterAtBoardLeft * cos(alfaLeftInnJamb)
				xo = 0
				yo = WOD
				ro = radBoard

				gosub 101	! Circle - Line intersection

				if ya > yb then
					pxL1 = xa
					pyL1 = ya
				else
					pxL1 = xb
					pyL1 = yb
				endif

				alpha = alfaLeftInnJamb
			else
				pxL1 = cx - opInner / 2 - parapetExtendLeft
				pyL1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxL1^2)

				alpha = abs(asn(pxL1 / radBoard))
			endif
			pxL2 = pxL1 - signWallIsLeft * tan(alpha) * abs(pyL1 - insetY)
			pyL2 = insetY
			pxL1 = pxL1 - sin(alfaLeftInnJamb)
			pyL1 = pyL1 + cos(alfaLeftInnJamb)

			if gs_parapet_autodim & thkPlasterAtBoardRight > EPS then
				x1 = cx + opInner / 2 + parapetExtendRight
				y1 = WOD - signWallIsLeft * sqr(radBoard^2 - x1^2) + thkPlasterAtBoardRight * sin(alfaRightInnJamb)
				x1 = x1 - thkPlasterAtBoardRight * cos(alfaRightInnJamb)
				x2 = x1 - thkPlasterAtBoardRight * sin(alfaRightInnJamb)
				y2 = y1 - thkPlasterAtBoardRight * cos(alfaRightInnJamb)
				xo = 0
				yo = WOD
				ro = radBoard

				gosub 101	! Circle - Line intersection

				if ya > yb then
					pxR1 = xa
					pyR1 = ya
				else
					pxR1 = xb
					pyR1 = yb
				endif

				alpha = alfaRightInnJamb
			else
				pxR1 = cx + opInner / 2 + parapetExtendRight
				pyR1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxR1^2)

				alpha = abs(asn(pxR1 / radBoard))
			endif
			pxR2 = pxR1 + signWallIsLeft * tan(alpha) * abs(pyR1 - insetY)
			pyR2 = insetY
			pxR1 = pxR1 + sin(alfaRightInnJamb)
			pyR1 = pyR1 + cos(alfaRightInnJamb)

			rotx 90
			addz SYMB_POS_Y - act_st_pos - parapet_height - gs_parapet_autodim * thkPlasterAtBoardRight

			wallniche 6, 1, 2,
				0,0, 1,	parapet_height + gs_parapet_autodim * thkPlasterAtBoardRight,
				 pxR2, pyR2,	31,
				 pxR1, pyR1,	31,
				 pxR1, 1,		31,
				 pxL1, 1,		31,
				 pxL1, pyL1,	31,
				 pxL2, pyL2,	31
			del 2

		endif

	endif

	del (SYMB_ROTANGLE > EPS) + WIDO_REVEAL_SIDE
endif

del 1	! addz -SymbolMid_shiftDy


! ==============================================================================
! Mounting Frame
! ==============================================================================

if bHaveMountingFrame & lod3D_MountingFrame > 0 then
	if iWindowShape = SHAPE_ARCHED then
		gs_stack_left 	= 0
		gs_stack_right 	= 0
		gs_stack_bottom = 0
		gs_stack_top	= 0
	endif

	material gs_mountingFrame_mat
	pen gs_mountingFrame_pen_view
	sect_fill gs_mountingFrame_fill, gs_mountingFrame_pen_bg, gs_mountingFrame_pen_fg, gs_mountingFrame_pen_cont

	pxL1 = -leftWidth - (bLeftCornerFunction | gs_stack_left) * (lx * gs_mountingFrame_depth + 1.0)
	pxL2 = pxL1 + gs_mountingFrame_width_left
	pxR1 = rightWidth + (bRightCornerFunction | gs_stack_right) * (rx * gs_mountingFrame_depth + 1.0)
	pxR2 = pxR1- gs_mountingFrame_width_right

	pyB1 = -overSizeLower - (gs_stack_bottom * 1.0) + (ac_wallhole_height - ac_wallhole_height_original)*(ac_wallhole_height_original > EPS)
	pyB2 = pyB1 + gs_mountingFrame_width_bottom
	pyT1 = openingHeight + overSizeUpper + (gs_stack_top * 1.0)
	pyT2 = pyT1 - gs_mountingFrame_width_top

	if WIDO_REVEAL_SIDE then
		addz WIDO_FRAME_THICKNESS
	else
		mulz -1
	endif

	numCuts = 0

	if bRightCornerFunction then
		add rightRevealPnts[idxSillStartRevealRight][1], 0, -rightRevealPnts[idxSillStartRevealRight][2]
		roty -rightCornerAngle / 2
		cutplane 180
		numCuts = 1
		del 2
	endif

	if bLeftCornerFunction then
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, -leftRevealPnts[idxSillStartRevealLeft][2]
		roty leftCornerAngle / 2
		cutplane 180
		numCuts = numCuts + 1
		del 2
	endif

	if gs_stack_left then
		cutpolya 4, 2, 0,
			-leftWidth, pyB1-0.01,	13,
			pxL1-0.01,  pyB1-0.01,	15,
			pxL1-0.01,	pyT1+0.01,	15,
			-leftWidth,	pyT1+0.01,	8
		numCuts = numCuts + 1
	endif

	if gs_stack_right then
		cutpolya 4, 2, 0,
			rightWidth, pyB1-0.01,	13,
			pxR1+0.01,  pyB1-0.01,	15,
			pxR1+0.01,	pyT1+0.01,	15,
			rightWidth,	pyT1+0.01,	8
		numCuts = numCuts + 1
	endif

	if gs_stack_bottom then
		cutpolya 4, 2, 0,
			pxL1-0.01,	-overSizeLower,	8,
			pxR1+0.01,  -overSizeLower,	13,
			pxR1+0.01,	pyB1-0.01,		15,
			pxL1-0.01,	pyB1-0.01,		15
		numCuts = numCuts + 1
	endif

	if gs_stack_top then
		cutpolya 4, 2, 0,
			pxL1-0.01,	openingHeight + overSizeUpper, 8,
			pxR1+0.01,	openingHeight + overSizeUpper, 13,
			pxR1+0.01,	pyT1+0.01,		15,
			pxL1-0.01,	pyT1+0.01,		15
		numCuts = numCuts + 1
	endif

	if iWindowShape = SHAPE_ARCHED then
		hs = openingHeight - archHeight
		rr = (archHeight^2 + (leftWidth)^2) / 2 / archHeight

		! Cut space for mounting frame in the turned plaster layer
		if thkPlasterAtSill > EPS | (curvedWall & not(wallIsLeft)) then
			wallniche 5, 1, 2,
				0,0, 1,	gs_mountingFrame_depth,
				 -leftWidth, 	0,					31,
				 -leftWidth, 	hs, 				31,
				 0, 			openingHeight-rr, 	931,
				 rightWidth,	hs, 				3031,
				 rightWidth,	0,					31
		endif

		archHeight2 = rr-(rr-gs_mountingFrame_width_left) * sin( acs( (leftWidth-gs_mountingFrame_width_left)/(rr-gs_mountingFrame_width_left)))

		if not(gs_stack_bottom) then
			hotspot pxL2, pyB2, 0, 11050
		endif
		if not(gs_stack_bottom) then
			hotspot pxR2, pyB2, 0, 11051
		endif

		hotspot pxL2, pyT1-archHeight2, 0, 11052
		hotspot pxR2, pyT1-archHeight2, 0, 11053
		hotspot 0, pyT2, 0, 11054

		if GLOB_CONTEXT = 4 then
			poly_ 13,
				pxL1,	pyB1, 1,
				pxL1,	pyT1-archHeight, 1,
				0, 	openingHeight-rr, 901,
				pxR1,	pyT1-archHeight, 3001,
				pxR1,	pyB1, 1,
				pxL1,	pyB1, -1,

				pxL2,	pyB2, 1,
				pxL2,	pyT1-archHeight2-EPS, 1,
				pxL2,	pyT1-archHeight2, 1,
				0, 	openingHeight-rr, 901,
				pxR2,	pyT1-archHeight2, 3001,
				pxR2,	pyB2, 1,
				pxL2,	pyB2, -1
		endif
		prism_ 13, gs_mountingFrame_depth,
			 pxL1,	pyB1, 15,
			 pxL1,	pyT1-archHeight, 79,
			 0, 	openingHeight-rr, 915,
			 pxR1,	pyT1-archHeight, 3015,
			 pxR1,	pyB1, 15,
			 pxL1,	pyB1, -1,

			 pxL2,	pyB2, 15,
			 pxL2,	pyT1-archHeight2-EPS, 13,
			 pxL2,	pyT1-archHeight2, 79,
			 0, 	openingHeight-rr, 915,
			 pxR2,	pyT1-archHeight2, 3015,
			 pxR2,	pyB2, 15,
			 pxL2,	pyB2, -1
	else
		! Cut space for mounting frame in the turned plaster layer
		if thkPlasterAtSill > EPS | (curvedWall & not(wallIsLeft)) then
			wallniche 4, 1, 2,
				0,0, 1,	gs_mountingFrame_depth,
				 -leftWidth, -overSizeLower,				 31,
				 -leftWidth,  openingHeight + overSizeUpper, 31,
				 rightWidth,  openingHeight + overSizeUpper, 31,
				 rightWidth, -overSizeLower,				 31
		endif

		if not(gs_stack_left | bLeftCornerFunction | gs_stack_bottom) then
			hotspot pxL2, pyB2, 0, 11050
		endif
		if not(gs_stack_right | bRightCornerFunction | gs_stack_bottom) then
			hotspot pxR2, pyB2, 0, 11051
		endif

		if not(gs_stack_left | bLeftCornerFunction | gs_stack_top) then
			hotspot pxL2, pyT2, 0, 11052
		endif
		if not(gs_stack_right | bRightCornerFunction | gs_stack_top) then
			hotspot pxR2, pyT2, 0, 11053
		endif

		if GLOB_CONTEXT = 4 then
			plane_ 10,
				 pxL1,	pyB1, 0, 1,
				 pxL1,	pyT1, 0, 1,
				 pxR1,	pyT1, 0, 1,
				 pxR1,	pyB1, 0, 1,
				 pxL1,	pyB1, 0, -1,

				 pxL2,	pyB2, 0, 1,
				 pxL2,	pyT2, 0, 1,
				 pxR2,	pyT2, 0, 1,
				 pxR2,	pyB2, 0, 1,
				 pxL2,	pyB2, 0, -1
		endif

		prism_ 10,gs_mountingFrame_depth,
			 pxL1,	pyB1, 15,
			 pxL1,	pyT1, 15,
			 pxR1,	pyT1, 15,
			 pxR1,	pyB1, 15,
			 pxL1,	pyB1, -1,

			 pxL2,	pyB2, 15,
			 pxL2,	pyT2, 15,
			 pxR2,	pyT2, 15,
			 pxR2,	pyB2, 15,
			 pxL2,	pyB2, -1
	endif

	del 1

	for i=1 to numCuts
		cutend
	next i
endif


! ==============================================================================
 end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
! ==============================================================================



1000:
! ==============================================================================
! Slanted Reveal cutting body
! ==============================================================================

! Similar as in MasonryArch macro

	if gs_stack_top		then gs_slanted_top_angle	 = 0
	if gs_stack_bottom	then gs_slanted_bottom_angle = 0

	! 3D turn plaster offsets
	if iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED then
		offsetSlantedLeft	= offsetLeft  + not(bLeftCornerFunction  | gs_stack_left)  * (thkPlasterAtSlantedLeft  / cos(gs_slanted_left_angle))
		offsetSlantedRight	= offsetRight + not(bRightCornerFunction | gs_stack_right) * (thkPlasterAtSlantedRight / cos(gs_slanted_right_angle))
		offsetSlantedBott	= offsetBott  + not(gs_stack_bottom) * (thkPlasterAtSlantedBottom / cos(gs_slanted_bottom_angle))
		offsetSlantedTop	= offsetTop   + not(gs_stack_top)    * (thkPlasterAtSlantedTop    / cos(gs_slanted_top_angle))
	else
		offsetSlantedLeft	= offsetLeft  - not(bLeftCornerFunction  | gs_stack_left)  * (thkPlasterAtSlanted * tan(gs_slanted_left_angle)  - thkPlasterAtSlantedLeft  / cos(gs_slanted_left_angle))
		offsetSlantedRight	= offsetRight - not(bRightCornerFunction | gs_stack_right) * (thkPlasterAtSlanted * tan(gs_slanted_right_angle) - thkPlasterAtSlantedRight / cos(gs_slanted_right_angle))
		offsetSlantedBott	= offsetBott  - not(gs_stack_bottom) * (thkPlasterAtSlanted * tan(gs_slanted_bottom_angle) - thkPlasterAtSlantedBottom / cos(gs_slanted_bottom_angle))
		offsetSlantedTop	= offsetTop   - not(gs_stack_top)    * (thkPlasterAtSlanted * tan(gs_slanted_top_angle)    - thkPlasterAtSlantedTop    / cos(gs_slanted_top_angle))
	endif

	if abs(SYMB_POS_Y) < EPS then
		offsetSlantedBott = offsetSlantedBott - EPS
	endif

	dxl = (not(bLeftCornerFunction  | gs_stack_left)  | curvedWall) * slantedDepth * tan(gs_slanted_left_angle)		! --- Left
	dxr = (not(bRightCornerFunction | gs_stack_right) | curvedWall) * slantedDepth * tan(gs_slanted_right_angle)	! --- Right
	dxt = not(gs_stack_top)    * slantedDepth * tan(gs_slanted_top_angle)											! --- Top
	dxb = not(gs_stack_bottom) * slantedDepth * tan(gs_slanted_bottom_angle)										! --- Bottom

	if bLeftCornerFunction	then gs_slanted_left_angle	= 0
	if bRightCornerFunction	then gs_slanted_right_angle	= 0

	if iWindowShape = SHAPE_ARCHED then
		if bHalfCircle then
			arcRComponentY = 0
		else
			arcRComponentY = sqr(arcR^2 - rightWidth^2)
		endif
		if arcR + dxr - offsetSlantedRight > rightWidth + dxl - offsetSlantedRight then
			shm = sqr((arcR + dxr - offsetSlantedRight)^2 - (rightWidth + dxl - offsetSlantedRight)^2) - arcRComponentY
		else
			shm = 0
		endif
	endif

! Plaster Layer Cut ------------------------------------------------------------

	if not(iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) & thkPlasterAtSlanted > EPS then
		if iWindowShape = SHAPE_RECTANGULAR then
			if bLeftCornerFunction  then
				pxL = -leftWidth  - 10
			else
				pxL = -leftWidth  + thkPlasterAtSlantedLeft
			endif
			if bRightCornerFunction  then
				pxR = rightWidth + 10
			else
				pxR = rightWidth - thkPlasterAtSlantedRight
			endif
			wallniche 4, 1, 2 + 16,
				0,0,-slantedDepth-thkPlasterAtSlanted, slantedDepth + thkPlasterAtSlanted,
				pxR,	thkPlasterAtSlantedBottom + (thkPlasterAtSlantedBottom < EPS) * (CustRevealBottJamb + offsetInsideBott),	31,
				pxL,	thkPlasterAtSlantedBottom + (thkPlasterAtSlantedBottom < EPS) * (CustRevealBottJamb + offsetInsideBott),	31,
				pxL,	B - thkPlasterAtSlantedTop,	31,
				pxR,	B - thkPlasterAtSlantedTop,	31
		endif
		if iWindowShape = SHAPE_ARCHED then
			if bHalfCircle then
				wallniche 5, 1, 2 + 16,
					0,0,-slantedDepth-thkPlasterAtSlanted, slantedDepth + thkPlasterAtSlanted,
					 rightWidth - thkPlasterAtSlantedRight,	thkPlasterAtSlantedBottom,	31,
					 rightWidth - thkPlasterAtSlantedRight,	B - archHeight,				95,
					 0,								 		1,							895,
					-leftWidth  + thkPlasterAtSlantedLeft,	B - archHeight,				1095,
					-leftWidth  + thkPlasterAtSlantedLeft,	thkPlasterAtSlantedBottom,	31
			else
				wallniche 5, 1, 2 + 16,
					0,0,-slantedDepth-thkPlasterAtSlanted, slantedDepth + thkPlasterAtSlanted,
					(rightWidth - leftWidth) / 2,			B - arcR,					900,
					 rightWidth - thkPlasterAtSlantedRight,	thkPlasterAtSlantedBottom,	31,
					 rightWidth - thkPlasterAtSlantedRight,	B - archHeight,				95,
					-leftWidth  + thkPlasterAtSlantedLeft,	B - archHeight,				3095,
					-leftWidth  + thkPlasterAtSlantedLeft,	thkPlasterAtSlantedBottom,	31
			endif
		endif
	endif

! Cut type selection -----------------------------------------------------------

	slantedOpeningWidth	 = openingWidth  - offsetSlantedRight - offsetSlantedLeft	! Width at frame
	slantedOpeningHeight = openingHeight - offsetSlantedBott  - offsetSlantedTop	! Height at frame

	slantedOpeningWidthSide	 = slantedOpeningWidth  + dxr + dxl	! Width at wall side
	slantedOpeningHeightSide = slantedOpeningHeight + dxb + dxt	! Height at wall side

	magicRatioH = 0.95
	magicRatioV = 0.95

	wallBodyThkHorizontal = slantedDepth * (tan(gs_slanted_left_angle) + tan(gs_slanted_right_angle)) - slantedOpeningWidth
	wallBodyThkVertical   = slantedDepth * (tan(gs_slanted_top_angle) + tan(gs_slanted_bottom_angle)) - slantedOpeningHeight
	bCutEdgesOnly = ((wallBodyThkHorizontal < EPS & wallBodyThkVertical < EPS) & not(curvedWall))

! Horizontal Cutting Body ------------------------------------------------------

	if gs_slanted_left_angle > EPS | gs_slanted_right_angle > EPS then
		if gs_slanted_left_angle > EPS & gs_slanted_right_angle > EPS then
			m = ((tan(gs_slanted_right_angle) / tan(gs_slanted_left_angle)) * ((rightWidth + leftWidth) + dxr  + dxl - (offsetSlantedRight + offsetSlantedLeft))) / (1 + (tan(gs_slanted_right_angle) / tan(gs_slanted_left_angle)))
		else
			m = (rightWidth + leftWidth)/2 + dxr - offsetSlantedRight
		endif

		rxh = m - (rightWidth + leftWidth)/2 - dxr + offsetSlantedRight
		ryh = 0
		if gs_slanted_right_angle > EPS then
			rzh = -m / tan(gs_slanted_right_angle)
		else
			rzh = -m / tan(gs_slanted_left_angle)
		endif

!!!		dh = -sqr(rxh^2 + rzh^2) * slantedCutDepth / rzh	! for method = 2
		dh = slantedCutDepth								! for method = 3
		method = 3
	else
		rxh = 0
		ryh = 0
		rzh = -slantedDepth
		dh	=  slantedCutDepth

		method = 1
	endif

	if abs(rxh^2 + ryh^2 + rzh^2) > EPS then
		if iWindowShape = SHAPE_RECTANGULAR & not(bCutEdgesOnly) then
			addy B/2
			wallniche 4, method, 2 + HalfInfiniteCut * 16,
				-rxh,ryh,rzh, dh,
				 rightWidth + dxr - offsetSlantedRight,	-B/2 + offsetSlantedBott,	24,
				-leftWidth  - dxl + offsetSlantedLeft,	-B/2 + offsetSlantedBott,	31-2,
				-leftWidth  - dxl + offsetSlantedLeft,	 B/2 - offsetSlantedTop,	24,
				 rightWidth + dxr - offsetSlantedRight,	 B/2 - offsetSlantedTop,	31-2
			del 1
		endif
		if iWindowShape = SHAPE_ARCHED & slantedDepth > EPS then

			if gs_slanted_right_angle > EPS then
				method = 2
				shm2 = sqr((arcR - offsetSlantedRight)^2 - (rightWidth - offsetSlantedRight)^2) - arcRComponentY
				rxh = 0
				rzh = -(rightWidth + dxr - offsetSlantedRight) / tan(gs_slanted_right_angle)
				ryh = (shm - shm2) * (rzh / slantedDepth)

				dh	=  slantedCutDepth * ((sqr(ryh^2 + rzh^2))/abs(rzh))
			else
				method = 1
				rxh = 0
				ryh = 0
				rzh = -1
				dh	=  slantedCutDepth
			endif

			py = max(EPS, (B - archHeight - offsetSlantedBott) + XXshm)
			addy (B - archHeight)+shm
			wallniche 4, method, 2 + HalfInfiniteCut * 16,
				-rxh,ryh,rzh, dh,
				 rightWidth + dxr - offsetSlantedRight,	 -py,		31,
				-leftWidth  - dxl + offsetSlantedLeft,	 -py,		31,
				-leftWidth  - dxl + offsetSlantedLeft,	 0,	31,
				 rightWidth + dxr - offsetSlantedRight,	 0,	31
			del 1
		endif
	endif

! Vertical Cutting Body --------------------------------------------------------

	if gs_slanted_top_angle > EPS | gs_slanted_bottom_angle > EPS then
		if iWindowShape = SHAPE_RECTANGULAR then
			if gs_slanted_bottom_angle > EPS & gs_slanted_top_angle > EPS then
				m = ((tan(gs_slanted_top_angle) / tan(gs_slanted_bottom_angle)) * (B + dxt + dxb - (offsetSlantedTop + offsetSlantedBott))) / (1 + (tan(gs_slanted_top_angle) / tan(gs_slanted_bottom_angle)))
			else
				m = B/2 + dxt - offsetSlantedTop
			endif
			method = 1

			rxv = m - B/2 - dxt + offsetSlantedTop
			ryv = 0
			if gs_slanted_top_angle > EPS then
				rzv = -m / tan(gs_slanted_top_angle)
			else
				rzv = -m / tan(gs_slanted_bottom_angle)
			endif

			dv = -sqr(rxv^2 + rzv^2) * slantedCutDepth / rzv
		endif
		if iWindowShape = SHAPE_ARCHED then
			if gs_slanted_bottom_angle > EPS then m = (B - archHeight + dxb - offsetSlantedBott) / tan(gs_slanted_bottom_angle)

			rxv = (B - archHeight)
			ryv = 0
			rzv = -m
			dv = slantedCutDepth
		endif

		method = 2
	else
		rxv = 0
		ryv = 0
		rzv = -slantedDepth
		dv	=  slantedCutDepth

		method = 1
	endif

	if abs(rxh^2 + ryh^2 + rzh^2) > EPS then
		if iWindowShape = SHAPE_RECTANGULAR then
			addy B/2
			rotz 90
			xL =  leftWidth  - not(bLeftCornerFunction  | gs_stack_left)  * (offsetLeft  + thkPlasterAtSlantedLeft)  + bLeftCornerFunction  * overSizeLeft
			xR = -rightWidth + not(bRightCornerFunction | gs_stack_right) * (offsetRight + thkPlasterAtSlantedRight) - bRightCornerFunction * overSizeRight
			if slantedDepthBottom > slantedDepth & gs_slanted_bottom_angle > EPS then
				wallniche 4, method, 2 + HalfInfiniteCut * 16,
					-rxv,ryv,rzv, dv,
					 B/2+dxt - offsetSlantedTop,	xR,	24,
					 0,								xR,	31-2,
					 0,								xL,	24,
					 B/2+dxt - offsetSlantedTop,	xL,	31-2
				if not(curvedWall) | bParalellInCurvedWalls then
!					add -rxv,ryv,rzv
!					roty atn((B/2 + dxb - offsetSlantedBott - rxv) / rzv) + 180
!					wallniche 4, 1, 2 + HalfInfiniteCut * 16,
!						0,0,1, 0,
!						0,		xR,	31,
!						-0.1,	xR,	31,
!						-0.1,	xL,	31,
!						0,		xL,	31
!					del 2

					add -B/2-dxb + offsetSlantedBott, 0, 0
					wallniche 4, 1, 2 + 16,
						sin(gs_slanted_bottom_angle),0,-cos(gs_slanted_bottom_angle), slantedDepthBottom / cos(gs_slanted_bottom_angle),
						0,		xR,	31,
						gs_reveal_outer_jamb_depth * tan(gs_slanted_bottom_angle),	xR,	31,
						gs_reveal_outer_jamb_depth * tan(gs_slanted_bottom_angle),	xL,	31,
						0,		xL,	31
					del 1

!					wallniche 4, 3, 2 + HalfInfiniteCut * 16,
!						-rxv,ryv,rzv, slantedDepthBottom,
!						 0,								xR,	31,
!						-B/2-dxb + offsetSlantedBott,	xR,	31,
!						-B/2-dxb + offsetSlantedBott,	xL,	31,
!						 0,								xL,	31
				endif
			else
				if not(bCutEdgesOnly) & abs(xR - xL) > EPS  then
					wallniche 4, method, 2 + HalfInfiniteCut * 16,
						-rxv,ryv,rzv, dv,
						 B/2+dxt - offsetSlantedTop,	xR,	24,
						-B/2-dxb + offsetSlantedBott,	xR,	31-2,
						-B/2-dxb + offsetSlantedBott,	xL,	24,
						 B/2+dxt - offsetSlantedTop,	xL,	31-2
				endif
			endif
			del 2
		endif
		if iWindowShape = SHAPE_ARCHED & gs_slanted_bottom_angle > EPS then
			rotz 90
			method = 3
			xL =  leftWidth  - (offsetLeft  + thkPlasterAtSlantedLeft)
			xR = -rightWidth + (offsetRight + thkPlasterAtSlantedRight)
!			wallniche 4, method, 2 + HalfInfiniteCut * 16,
!				 rxv, ryv, rzv, dv,
!				 (B - archHeight),			 xL,		24,
!				 -dxb + offsetSlantedBott,	 xL,		31-2,
!				 -dxb + offsetSlantedBott,	 xR,	24,
!				 (B - archHeight),			 xR,	31-2

			if slantedDepthBottom > slantedDepth & gs_slanted_bottom_angle > EPS then
				add -dxb + offsetSlantedBott, 0, 0
				wallniche 4, 1, 2 + 16,
					sin(gs_slanted_bottom_angle),0,-cos(gs_slanted_bottom_angle), slantedDepthBottom / cos(gs_slanted_bottom_angle),
					0,		xR,	31,
					gs_reveal_outer_jamb_depth * tan(gs_slanted_bottom_angle),	xR,	31,
					gs_reveal_outer_jamb_depth * tan(gs_slanted_bottom_angle),	xL,	31,
					0,		xL,	31
				del 1
			endif
			del 1
		endif
	endif

! Top - Right Corner Cutting Body ----------------------------------------------

	if iWindowShape = SHAPE_RECTANGULAR then
		if abs(gs_slanted_top_angle) > EPS then
			ratioTL = tan(gs_slanted_right_angle) / tan(gs_slanted_top_angle)
			if openingWidth > B * ratioTL then
				rytl = 2 * B / 3
				rxtl = rytl * ratioTL
			else
				rxtl = 2 * openingWidth / 3
				rytl = rxtl / ratioTL
			endif

			if abs(gs_slanted_right_angle) > EPS then
				rztl = rxtl / tan(gs_slanted_right_angle)
			else
				rztl = rytl / tan(gs_slanted_top_angle)
			endif
		else
			if abs(gs_slanted_right_angle) > EPS then
				rxtl = 3 * openingWidth / 4
				rytl = 0
				rztl = rxtl / tan(gs_slanted_right_angle)
			else
				rxtl = 0
				rytl = 0
				rztl = 1
			endif
		endif

		vx = (slantedDepth) * tan(gs_slanted_right_angle)
		vy = (slantedDepth) * tan(gs_slanted_top_angle)
		vz = (slantedCutDepth)
		dtl = sqr(vx*vx + vy*vy + vz*vz)

		ratioV = max(1, dtl / sqr(rxtl^2 + rytl^2 + rztl^2) * 2)
		rxtl = rxtl * ratioV
		rytl = rytl * ratioV
		rztl = rztl * ratioV

		if bCutEdgesOnly then
			add rightWidth + gs_right_oversize - offsetSlantedRight, B + gs_upper_oversize - offsetSlantedTop, -slantedDepth
			if bRightCornerFunction then
				pxR = 10
			else
				pxR = 0
			endif
			wallniche 4, 1, 2 + HalfInfiniteCut * 16,
				-rxtl,-rytl,-rztl, -not(HalfInfiniteCut) * dtl,
				 pxR,					 0,						31,
				-slantedOpeningWidth,	 0,						31,
				-slantedOpeningWidth,	-slantedOpeningHeight,	31,
				 pxR,					-slantedOpeningHeight,	31
			del 1
		else
			add rightWidth + gs_right_oversize + dxr - offsetSlantedRight, B + gs_upper_oversize + dxt - offsetSlantedTop, 0
			wallniche 4, 2, 2 + HalfInfiniteCut * 16 + 128,
				-rxtl,-rytl,-rztl, dtl,
				leftDx,											 0,				31,
				magicRatioH * (-slantedOpeningWidthSide + dxl),	 0,				31,
				magicRatioH * (-slantedOpeningWidthSide + dxl),	magicRatioV * (-slantedOpeningHeightSide + dxb),	31,
				leftDx,											magicRatioV * (-slantedOpeningHeightSide + dxb),	31
			del 1
		endif

! Top - Left Corner Cutting Body -----------------------------------------------

		if abs(gs_slanted_top_angle) > EPS then
			ratioTR = tan(gs_slanted_left_angle) / tan(gs_slanted_top_angle)
			if openingWidth > B * ratioTR then
				rytr = 2 * B / 3
				rxtr = rytr * ratioTR
			else
				rxtr = 2 * openingWidth / 3
				rytr = rxtr / ratioTR
			endif

			if abs(gs_slanted_left_angle) > EPS then
				rztr = rxtr / tan(gs_slanted_left_angle)
			else
				rztr = rytr / tan(gs_slanted_top_angle)
			endif
		else
			if abs(gs_slanted_left_angle) > EPS then
				rxtr = 3 * openingWidth / 4
				rytr = 0
				rztr = rxtr / tan(gs_slanted_left_angle)
			else
				rxtr = 0
				rytr = 0
				rztr = 1
			endif
		endif

		vx = (slantedDepth) * tan(gs_slanted_left_angle)
		vy = (slantedDepth) * tan(gs_slanted_top_angle)
		vz = (slantedCutDepth)
		dtr = sqr(vx*vx + vy*vy + vz*vz)

		ratioV = max(1, dtr / sqr(rxtr^2 + rytr^2 + rztr^2) * 2)
		rxtr = rxtr * ratioV
		rytr = rytr * ratioV
		rztr = rztr * ratioV

		if bCutEdgesOnly then
			add -leftWidth - gs_left_oversize + offsetSlantedLeft, B + gs_upper_oversize - offsetSlantedTop, -slantedDepth
			if bLeftCornerFunction then
				pxL = -10
			else
				pxL = 0
			endif
			wallniche 4, 1, 2 + HalfInfiniteCut * 16,
				rxtr,-rytr,-rztr, -not(HalfInfiniteCut) * dtr,
				pxL,				 0,						31,
				slantedOpeningWidth, 0,						31,
				slantedOpeningWidth, -slantedOpeningHeight,	31,
				pxL,				 -slantedOpeningHeight,	31
			del 1
		else
			add -leftWidth - gs_left_oversize - dxl + offsetSlantedLeft, B + gs_upper_oversize + dxt - offsetSlantedTop, 0
			if bRightCornerFunction then
				wallniche 4, 2, 2 + HalfInfiniteCut * 16 + 128,
					rxtr,-rytr,-rztr, dtr,
					rightDx,			 0,				31,
					openingWidth + 10,	 0,				31,
					openingWidth + 10,	-3*B/4 - dxt,	31,
					rightDx,			-3*B/4 - dxt,	31
			else
				wallniche 4, 2, 2 + HalfInfiniteCut * 16 + 128,
					rxtr,-rytr,-rztr, dtr,
					rightDx,										 0,				31,
					magicRatioH * (slantedOpeningWidthSide - dxr),	 0,				31,
					magicRatioH * (slantedOpeningWidthSide - dxr),	magicRatioV * (-slantedOpeningHeightSide + dxb),	31,
					rightDx,										magicRatioV * (-slantedOpeningHeightSide + dxb),	31
			endif
			del 1
		endif
	endif

	if iWindowShape = SHAPE_ARCHED & slantedDepth > EPS then
		! --- Top Arched Cut ---

		if gs_slanted_right_angle > EPS then
			shm2 = sqr((arcR - offsetSlantedRight)^2 - (rightWidth - offsetSlantedRight)^2) - arcRComponentY
			rxh = 0
			rzh = -(rightWidth + dxr - offsetSlantedRight) / tan(gs_slanted_right_angle)
			ryh = (shm - shm2) * (rzh / slantedDepth)

			dh	=  slantedCutDepth * ((sqr(ryh^2 + rzh^2))/abs(rzh))

			x11 = 0
			y11 = 0
			x12 = rzh
			y12 = ryh
			x21 = 0
			y21 = archHeight - offsetSlantedTop + dxt - shm
			x22 = -cos(gs_slanted_right_angle)
			y22 = -sin(gs_slanted_right_angle) + y21
			gosub 100	! Line - Line intersection

!addy (B - archHeight) + shm
!roty -90
!lin_ x11,y11,0, x12,y12,0
!lin_ x21,y21,0, x22,y22,0
!del 2

			rxh2 = 0
			rzh2 = cx
			ryh2 = cy

			dh	=  slantedCutDepth * ((sqr(ryh2^2 + rzh2^2))/abs(rzh2))
			cutMethod = 2	! Pyramidal
		else
			rxh2 = 0
			ryh2 = 0
			rzh2 = -1

			dh	=  slantedCutDepth
			cutMethod = 1	! Prism shaped
		endif

		addy (B - archHeight) + shm
		wallniche 3, cutMethod, 2 + HalfInfiniteCut * 16,
			rxh2, ryh2, rzh2, dh,
			(-leftWidth - dxr + offsetSlantedLeft),		openingHeight - B,								95,
			0, 											openingHeight - arcR - ((B - archHeight) + shm),995,
			(rightWidth + dxl - offsetSlantedRight),	openingHeight - B,								3095
		del 1
	endif

	if abs(gs_slanted_bottom_angle) < EPS then	! Space for Board
		dxb = dxb + overSizeLower
	endif

! Bottom - Right Corner Cutting Body -------------------------------------------

	if abs(gs_slanted_bottom_angle) > EPS then
		ratioBL = tan(gs_slanted_right_angle) / tan(gs_slanted_bottom_angle)
		if openingWidth > B * ratioBL then
			rybl = 2 * B / 3
			rxbl = rybl * ratioBL
		else
			rxbl = 2 * openingWidth / 3
			rybl = rxbl / ratioBL
		endif

		if abs(gs_slanted_right_angle) > EPS then
			rzbl = rxbl / tan(gs_slanted_right_angle)
		else
			rzbl = rybl / tan(gs_slanted_bottom_angle)
		endif
	else
		if abs(gs_slanted_right_angle) > EPS then
			rxbl = 3 * openingWidth / 4
			rybl = 0
			rzbl = rxbl / tan(gs_slanted_right_angle)
		else
			rxbl = 0
			rybl = 0
			rzbl = 1
		endif
	endif

	vx = (slantedDepth) * tan(gs_slanted_right_angle)
	vy = (slantedDepth) * tan(gs_slanted_bottom_angle)
	vz = (slantedCutDepth)
	dbl = sqr(vx*vx + vy*vy + vz*vz)

	ratioV = max(1, dbl / sqr(rxbl^2 + rybl^2 + rzbl^2) * 2)
	rxbl = rxbl * ratioV
	rybl = rybl * ratioV
	rzbl = rzbl * ratioV

	if bCutEdgesOnly then
		add rightWidth + gs_right_oversize - offsetSlantedRight, -gs_lower_oversize + offsetSlantedBott, -slantedDepth
		if bRightCornerFunction then
			pxR = 10
		else
			pxR = 0
		endif
		py = max(EPS, slantedOpeningHeight - (iWindowShape = SHAPE_ARCHED) * (archHeight - offsetSlantedTop) - not(bWallInsetCut) * gs_reveal_outer_jamb_depth)	! not(bWallInsetCut) -> Outside
		wallniche 4, 1, 2 + HalfInfiniteCut * 16,
			-rxbl, rybl,-rzbl, -not(HalfInfiniteCut) * dbl,
			 pxR,				  0,	31,
			-slantedOpeningWidth, 0,	31,
			-slantedOpeningWidth, py,	31,
			 pxR,				  py,	31
		del 1
	else
		add rightWidth + gs_right_oversize + dxr - offsetSlantedRight, -dxb - gs_lower_oversize + offsetSlantedBott, 0
		wallniche 4, 2, 2 + HalfInfiniteCut * 16 + 128,
				-rxbl, rybl,-rzbl, dbl,
				leftDx,											0,																31,
				magicRatioH * (-slantedOpeningWidthSide + dxl), 0,																31,
				magicRatioH * (-slantedOpeningWidthSide + dxl), magicRatioV * (slantedOpeningHeightSide - dxt) - archHeight,	31,
				leftDx,											magicRatioV * (slantedOpeningHeightSide - dxt) - archHeight,	31
		del 1
	endif

! Wall Inset cutting body for Slanted Reveal - Right Side --------------

	if bWallInsetCut & bParapetWallInset & SYMB_POS_Y > overSizeLower & not(WALL_INCL > EPS) & gs_parapet_autodim & parapet_height > EPS then

		if curvedWall & wallIsLeft then
			dy = WOD - radBoard
		else
			dy = radBoard + WOD
		endif
		dd = (dy - (WALL_THICKNESS - WIDO_SILL)) * curvedWall
		vx = (parapetWallInsetDepth - dd) * tan(gs_slanted_right_angle)
		vy = (parapetWallInsetDepth - dd) * tan(gs_slanted_bottom_angle)
		vz = (parapetWallInsetDepth - dd)
		dbl = sqr(vx*vx + vy*vy + vz*vz)

		if abs(gs_slanted_right_angle) > EPS then
			rxbl = 3 * openingWidth / 4
			rzbl = rxbl / tan(gs_slanted_right_angle)
		else
			rxbl = 0
			rzbl = 1
		endif
		rybl = rzbl * tan(gs_slanted_bottom_angle)

		add rightWidth + gs_right_oversize + dxr - offsetSlantedRight, -dxb - gs_lower_oversize + offsetSlantedBott, 0
		wallniche 4, 2, 2 + HalfInfiniteCut * 16 + 128,
			-rxbl, rybl,-rzbl, dbl,
			 leftDx,					-parapet_height*3/4,	31,
			-3 * openingWidth/4 - dxl,	-parapet_height*3/4,	31,
			-3 * openingWidth/4 - dxl,	 0,						31,
			 leftDx,					 0,						31
		del 1

		db2 = sqr(vx*vx + vz*vz)

		add rightWidth + gs_right_oversize + dxr - offsetSlantedRight, -parapet_height, 0
		wallniche 4, 2, 2 + HalfInfiniteCut * 16 + 128,
			-rxbl, 0,-rzbl, db2,
			 leftDx,					 parapet_height*3/4,	31,
			-3 * openingWidth/4 - dxl,	 parapet_height*3/4,	31,
			-3 * openingWidth/4 - dxl,	 0,						31,
			 leftDx,					 0,						31
		del 1

		isParIns = 1

	endif

! Bottom - Left Corner Cutting Body --------------------------------------------

	if abs(gs_slanted_bottom_angle) > EPS then
		ratioBR = tan(gs_slanted_left_angle) / tan(gs_slanted_bottom_angle)
		if openingWidth > B * ratioBR then
			rybr = 2 * B / 3
			rxbr = rybr * ratioBR
		else
			rxbr = 2 * openingWidth / 3
			rybr = rxbr / ratioBR
		endif

		if abs(gs_slanted_left_angle) > EPS then
			rzbr = rxbr / tan(gs_slanted_left_angle)
		else
			rzbr = rybr / tan(gs_slanted_bottom_angle)
		endif
	else
		if abs(gs_slanted_left_angle) > EPS then
			rxbr = 3 * openingWidth / 4
			rybr = 0
			rzbr = rxbr / tan(gs_slanted_left_angle)
		else
			rxbr = 0
			rybr = 0
			rzbr = 1
		endif
	endif

	vx = (slantedDepth) * tan(gs_slanted_left_angle)
	vy = (slantedDepth) * tan(gs_slanted_bottom_angle)
	vz = (slantedCutDepth)
	dbr = sqr(vx*vx + vy*vy + vz*vz)

	ratioV = max(1, dbr / sqr(rxbr^2 + rybr^2 + rzbr^2) * 2)
	rxbr = rxbr * ratioV
	rybr = rybr * ratioV
	rzbr = rzbr * ratioV

	if bCutEdgesOnly then
		add -leftWidth - gs_left_oversize + offsetSlantedLeft, -gs_lower_oversize + offsetSlantedBott, -slantedDepth
		if bLeftCornerFunction then
			pxL = -10
		else
			pxL = 0
		endif
		py = max(EPS, slantedOpeningHeight - (iWindowShape = SHAPE_ARCHED) * (archHeight - offsetSlantedTop) - not(bWallInsetCut) * gs_reveal_outer_jamb_depth)	! not(bWallInsetCut) -> Outside
		wallniche 4, 1, 2 + HalfInfiniteCut * 16,
			rxbr, rybr,-rzbr, -not(HalfInfiniteCut) * dbr,
			pxL,				 0,		31,
			slantedOpeningWidth, 0,		31,
			slantedOpeningWidth, py,	31,
			pxL,				 py,	31
		del 1
	else
		add -leftWidth - gs_left_oversize - dxl + offsetSlantedLeft, -dxb - gs_lower_oversize + offsetSlantedBott, 0
		if bRightCornerFunction then
			wallniche 4, 2, 2 + HalfInfiniteCut * 16 + 128,
				 rxbr, rybr,-rzbr, dbr,
				 rightDx,			 0,								31,
				 openingWidth + 10,	 0,								31,
				 openingWidth + 10,	 3/4*(B - archHeight) + dxt,	31,
				 rightDx,			 3/4*(B - archHeight) + dxt,	31
		else
			wallniche 4, 2, 2 + HalfInfiniteCut * 16 + 128,
				 rxbr, rybr,-rzbr, dbr,
				 rightDx,										0,																31,
				 magicRatioH * (slantedOpeningWidthSide - dxr), 0,																31,
				 magicRatioH * (slantedOpeningWidthSide - dxr), magicRatioV * (slantedOpeningHeightSide - dxt) - archHeight,	31,
				 rightDx,										magicRatioV * (slantedOpeningHeightSide - dxt) - archHeight,	31
		endif
		del 1
	endif

! Wall Inset cutting body for Slanted Reveal - Left Side ---------------

	if bWallInsetCut & bParapetWallInset & SYMB_POS_Y > overSizeLower & not(WALL_INCL > EPS) & gs_parapet_autodim & parapet_height > EPS then

		if curvedWall & wallIsLeft then
			dy = WOD - radBoard
		else
			dy = radBoard + WOD
		endif
		dd = (dy - (WALL_THICKNESS - WIDO_SILL)) * curvedWall
		vx = (parapetWallInsetDepth - dd) * tan(gs_slanted_left_angle)
		vy = (parapetWallInsetDepth - dd) * tan(gs_slanted_bottom_angle)
		vz = (parapetWallInsetDepth - dd)
		dbl = sqr(vx*vx + vy*vy + vz*vz)

		if abs(gs_slanted_left_angle) > EPS then
			rxbr = 3 * openingWidth / 4
			rzbr = rxbr / tan(gs_slanted_left_angle)
		else
			rxtr = 0
			rztr = 1
		endif
		rybr = rzbr * tan(gs_slanted_bottom_angle)

		add -leftWidth - gs_left_oversize - dxl + offsetSlantedLeft, -dxb - gs_lower_oversize + offsetSlantedBott, 0
		wallniche 4, 2, 2 + HalfInfiniteCut * 16 + 128,
			 rxbr, rybr, -rzbr, dbl,
			 rightDx,					-parapet_height*3/4,	31,
			 3 * openingWidth/4 + dxl,	-parapet_height*3/4,	31,
			 3 * openingWidth/4 + dxl,	 0,						31,
			 rightDx,					 0,						31
		del 1

		db2 = sqr(vx*vx + vz*vz)

		add -leftWidth - gs_left_oversize - dxl + offsetSlantedLeft, -parapet_height, 0
		wallniche 4, 2, 2 + HalfInfiniteCut * 16 + 128,
			 rxbr, 0, -rzbr, db2,
			 rightDx,					 parapet_height*3/4,	31,
			 3 * openingWidth/4 + dxl,	 parapet_height*3/4,	31,
			 3 * openingWidth/4 + dxl,	 0,						31,
			 rightDx,					 0,						31
		del 1

	endif

return


2000:
! ==============================================================================
! Shape cut body with offset
! ------------------------------------------------------------------------------
! Input variables:
! Offsets:
!	offLeft:			offset left
!	offRight:			offset right
!	offTop:				offset top
!	offBottom:			offset bottom
! Cutting body parameters:
!	cutMethod:			method parameters of the wallniche
!	cutStatus:			status parameters of the wallniche
!	cutVectX:			x component of the cutting direction vector
!	cutVectY:			y component of the cutting direction vector
!	cutVectZ:			z component of the cutting direction vector
!	cutDepth:			depth of cut
! Shape geometrty:
!	sideRight:			right side
!	sideLeft:			left side
!	sideBottom:			bottom side
!	sideTop:			top side
!	archHeight:
!	arcR:
!	tan_topAngle:		SHAPE_TRAPEZOID upper side tan(angle)
! ==============================================================================

	if iWindowShape = SHAPE_RECTANGULAR then
		if _bCustomMatNicheTop then
			wallniche 4, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				 sideRight - offRight,	-sideBottom + offBottom,	31, _wallNicheSurfaceRight,
				 sideRight - offRight,	 sideTop    - offTop,		31, _wallNicheSurfaceTop,
				-sideLeft  + offLeft,	 sideTop    - offTop,		31, _wallNicheSurfaceLeft,
				-sideLeft  + offLeft,	-sideBottom + offBottom,	31, _wallNicheSurfaceBottom
		else
			wallniche 4, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				 sideRight - offRight,	-sideBottom + offBottom,	31,
				 sideRight - offRight,	 sideTop    - offTop,		31,
				-sideLeft  + offLeft,	 sideTop    - offTop,		31,
				-sideLeft  + offLeft,	-sideBottom + offBottom,	31
		endif
	endif

	if iWindowShape = SHAPE_ARCHED then
		if bHalfCircle then
			archDistortion = (archHeight - offTop) / ((sideRight - offRight + sideLeft - offLeft) / 2)

			addy sideTop - archHeight
			muly archDistortion
			if _bCustomMatNicheTop then
				wallniche 6, cutMethod, cutStatus,
					cutVectX,cutVectY,cutVectZ, cutDepth,
					 sideRight - offRight,	(-sideBottom + offBottom - sideTop + archHeight) / archDistortion,	31, _wallNicheSurfaceRight,
					 sideRight - offRight,	 0,		95, _wallNicheSurfaceTop,
					 0,							1,			 				895, _wallNicheSurfaceTop,
					 0,		(archHeight - offTop) / archDistortion,		1095, _wallNicheSurfaceTop,
					-sideLeft  + offLeft,	 0,		1095, _wallNicheSurfaceLeft,
					-sideLeft  + offLeft,	(-sideBottom + offBottom - sideTop + archHeight) / archDistortion,	31, _wallNicheSurfaceBottom
			else
				wallniche 6, cutMethod, cutStatus,
					cutVectX,cutVectY,cutVectZ, cutDepth,
					 sideRight - offRight,	(-sideBottom + offBottom - sideTop + archHeight) / archDistortion,	31,
					 sideRight - offRight,	 0,		95,
					 0,							1,			 				895,
					 0,		(archHeight - offTop) / archDistortion,		1095,
					-sideLeft  + offLeft,	 0,		1095,
					-sideLeft  + offLeft,	(-sideBottom + offBottom - sideTop + archHeight) / archDistortion,	31
			endif
			del 2
		else
			midOffset = (sideRight - offRight - sideLeft + offLeft) / 2
			if arcR - offTop > sideRight - offRight then
				shoulder_offset = sqr((arcR - offTop)^2 - (sideRight - offRight)^2)
			else
				shoulder_offset = 0
			endif

			if _bCustomMatNicheTop then
				wallniche 6, cutMethod, cutStatus,
					cutVectX,cutVectY,cutVectZ, cutDepth,
					 midOffset,				 sideTop - arcR,					900, _wallNicheSurfaceRight,
					 sideRight - offRight,	-sideBottom + offBottom,			31, _wallNicheSurfaceRight,
					 sideRight - offRight,	 sideTop - arcR + shoulder_offset,	95, _wallNicheSurfaceTop,
					0,	 sideTop - offTop,										3095, _wallNicheSurfaceTop,
					-sideLeft  + offLeft,	 sideTop - arcR + shoulder_offset,	1095, _wallNicheSurfaceLeft,
					-sideLeft  + offLeft,	-sideBottom + offBottom,			31, _wallNicheSurfaceBottom
			else
				wallniche 6, cutMethod, cutStatus,
					cutVectX,cutVectY,cutVectZ, cutDepth,
					 midOffset,				 sideTop - arcR,					900,
					 sideRight - offRight,	-sideBottom + offBottom,			31,
					 sideRight - offRight,	 sideTop - arcR + shoulder_offset,	95,
					0,	 sideTop - offTop,										3095,
					-sideLeft  + offLeft,	 sideTop - arcR + shoulder_offset,	1095,
					-sideLeft  + offLeft,	-sideBottom + offBottom,			31
			endif
		endif
	endif

	if iWindowShape = SHAPE_HALFARCH then

		if bRightCornerFunction then
			put -sideLeft + offLeft,-sideBottom + offBottom,			31,
				sideRight,		-sideBottom + offBottom,	31,
				sideRight,		Topy,	31,
				Topx,						Topy,						95,

				sideRight - overSizeRight, 		sideTop - Arcr,		900,
				Shouldx,		Shouldy,			3031 + bFullArc * 64
		else
			put -sideLeft + offLeft,-sideBottom + offBottom,			31,
				sideRight - offRight,		-sideBottom + offBottom,	31,
				Topx,						 Topy,						95,

				sideRight,		sideTop - Arcr,		900,
				Shouldx,		Shouldy,			3031 + bFullArc * 64
		endif

		wallniche nsp/3, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			get(nsp)
	endif

	if iWindowShape = SHAPE_ELLIPSEARCH then

		if curvedWall then
			ratio = (archHeight - offTop) / (archHeight - offLeft)
		else
			ratio = 1
		endif
		addy sideTop - archHeight
		muly ratio
		wallniche 7, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			 sideRight - offRight,			-sideBottom + offBottom + (archHeight - sideTop) / ratio,	31,
			 sideRight - offRight,			 0,		95,
			 smallRadiusEllips_offset,		 alphaSide,					2095,
			 middleRadiusEllips_offset,		 alphaMiddle/2,				2095,
			 middleRadiusEllips_offset,		 alphaMiddle/2,				2095,
			 smallRadiusEllips_offset,		 alphaSide,					2095,
			-sideLeft  + offLeft,			-sideBottom + offBottom + (archHeight - sideTop) / ratio,	31
		del 2
	endif

	if iWindowShape = SHAPE_PENTAGON then
		_hCenter = sideTop - offTop / cos(atn(tan_topAngle))
		wallniche 5, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			 sideRight - offRight,	-sideBottom + offBottom,	  							31,
			 sideRight - offRight,	 _hCenter - (sideRight - offRight) * tan_topAngle,		31,
			 0,						 _hCenter,												31,
			-sideLeft  + offLeft,	 _hCenter - (sideLeft - offLeft) * tan_topAngle,		31,
			-sideLeft  + offLeft,	-sideBottom + offBottom,	  							31
	endif

	if iWindowShape = SHAPE_TRAPEZOID then
		_dirWin = not(bMirroredOpening) * 2 - 1		!mirrored: -1  nonmirrored: 1
		_hCenter = sideTop - archHeight / 2 - offTop / cos(atn(tan_topAngle))
		py1 = _hCenter + _dirWin * (sideRight - offRight) * tan_topAngle
		py2 = _hCenter - _dirWin * (sideLeft - offLeft) * tan_topAngle

		wallniche 4, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
				 sideRight - offRight,	-sideBottom + offBottom,	31,
				 sideRight - offRight,	py1,	31,
				-sideLeft  + offLeft,	py2,	31,
				-sideLeft  + offLeft,	-sideBottom + offBottom,	31
	endif

	if iWindowShape = SHAPE_TRIANGLE then
		_oleft = -offLeft / sin(atn(tan_LeftSide))
		_oright = -offRight / sin(atn(tan_RightSide))
		_xTop = (sideLeft + sideRight + _oleft + _oright) / (tan_LeftSide / tan_RightSide + 1)
		_yTop = _xTop * tan_LeftSide
		px1 = (sideLeft + sideRight) / 2 + _oright - (offBottom / tan_RightSide) * not(gs_stack_bottom)
		px2 = -(sideLeft + sideRight) / 2 - _oleft + (offBottom / tan_LeftSide) * not(gs_stack_bottom)

		wallniche 3, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			px1,	-sideBottom + offBottom,	31,
			-(sideLeft + sideRight) / 2 - _oleft + _xTop,						_yTop,						31,
			px2,	-sideBottom + offBottom,	31
	endif

	if iWindowShape = SHAPE_CORNER_TRIANGLE then
		if bRightCornerFunction then
			angleLeft	= atn((sideTop + sideBottom) / 2 / (sideLeft - (leftWidth - rightWidth) / 2))
			px2 = -sideLeft  + offBottom / tan(angleLeft)  + offLeft  / sin(angleLeft)
			CornerHeight = (sideRight - offRight - px2) * tan(angleLeft)

			wallniche 3, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				sideRight - offRight,	-sideBottom + offBottom,	31,
				sideRight - offRight,	 CornerHeight,				31,
				px2,					-sideBottom + offBottom,	31
		else
			angleLeft	= atn((sideTop + sideBottom) / 2 / sideLeft)
			px2 = -sideLeft  + offBottom / tan(angleLeft)  + offLeft  / sin(angleLeft)
			upperJambModify = 1 / tan((90-angleLeft)/2)

			wallniche 3, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				sideRight - offRight,	-sideBottom + offBottom,				31,
				sideRight - offRight,	 sideTop    - offTop * upperJambModify,	31,
				px2,					-sideBottom + offBottom,				31
		endif
	endif

	if iWindowShape = SHAPE_PARALLELOGRAM then
		if bMirroredOpening then
			wallniche 4, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				 sideRight - offRight,	-sideBottom + offBottom * upperJambModify + offRight * tan_topAngle,				31,
				 sideRight - offRight, 	 sideTop    - offTop * upperJambModify + offRight * tan_topAngle - archHeight,		31,
				-sideLeft  + offLeft,	 sideTop    - offTop * upperJambModify - offLeft  * tan_topAngle,							31,
				-sideLeft  + offLeft,	-sideBottom + offBottom * upperJambModify - offLeft * tan_topAngle + archHeight,	31
		else
			wallniche 4, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				 sideRight - offRight,	-sideBottom + offBottom * upperJambModify + offRight * tan_topAngle + archHeight,	31,
				 sideRight - offRight, 	 sideTop   - offTop * upperJambModify + offRight * tan_topAngle - archHeight,							31,
				-sideLeft  + offLeft,	 sideTop    - offTop * upperJambModify + offRight * tan_topAngle,		31,
				-sideLeft  + offLeft,	-sideBottom + offBottom * upperJambModify + offRight * tan_topAngle,				31
		endif
	endif


	if iWindowShape = SHAPE_GOTHICARCH then

		wallniche 7, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			 sideRight - offRight,					-sideBottom + offBottom,	  		31,
			 sideRight - offRight,					sideTop - archHeight,				95,
			 sideRight - arcR,						sideTop - archHeight,				900,
			(sideRight - sideLeft) / 2,				sideTop - centArcoffs,				3095,
			-sideLeft + arcR,						sideTop - archHeight,				900,
			-sideLeft  + offLeft,					sideTop - archHeight,				3095,
			-sideLeft  + offLeft,					-sideBottom + offBottom,	  		31

	endif

	if iWindowShape = SHAPE_HORSESHOE then

		wallniche 12, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
				sideRight - offRight,		-sideBottom,     		31,
				sideRight - offRight,		LowArcoffsy,			31,
				LowArcoffsx+EPS,			LowArcoffsy,			31,
				LowArcoffsx,				LowArcoffsy,			95,
				sideRight - RadArch,		sideTop - (ArchHeight - gs_lowerArchHeight), 900, 
				0,							HighArcoffs,			3000 +63,
				-EPS/2,						HighArcoffs,			95,
				-sideLeft + RadArch,		sideTop - (ArchHeight - gs_lowerArchHeight), 900,
				-LowArcoffsx,				LowArcoffsy,			3000 +31,
				-LowArcoffsx-EPS,			LowArcoffsy,			31,
				-sideLeft  + offLeft,		LowArcoffsy,			31,
				-sideLeft  + offLeft,		-sideBottom,			31
	endif

	if iWindowShape = SHAPE_OGEECENTERED then

		wallniche 11, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			sideRight - offRight,	-sideBottom,			31,
			sideRight - offRight,	sideTop - archHeight,	95,
			sideRight - RadArc,		sideTop - archHeight,	995,
			sideRight/2,			sideTop - archHeight/2,	3095,
			0 + RadArc,				sideTop,				995,
			0,						centArcoffs,			3095,
			0 - RadArc,				sideTop,				995,
			-sideLeft/2,			sideTop - archHeight/2,	3095,
			-sideLeft + RadArc,		sideTop - archHeight,	995,
			-sideLeft  + offLeft,	sideTop - archHeight,	3095,
			-sideLeft  + offLeft,	-sideBottom,			31
	endif


	if iWindowShape = SHAPE_SARACENIC then

		wallniche 10, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			sideRight - offRight,	-sideBottom,			31,
			sideRight - offRight,	sideTop - ArchHeight,	31+64,
			sideRight - RadArch,	sideTop - ArchHeight,	931+64,
			0,						60,						4031+64,
			0,						centArcoffs,			31,
			-tangArcx,				tangArcy,				31+64,
			-sideLeft + RadArch,	sideTop - ArchHeight,	931+64,
			0,						60,						4031+64,
			-sideLeft  + offLeft,	-sideBottom,			31,
			sideRight - offRight,	-sideBottom,			-1

	endif

	if iWindowShape = SHAPE_ROMBUS then
		addy openingHeight / 2
		wallniche 4, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			-openingWidth / 2 + offRight, 	 0, 							31,
			 0,								 openingHeight / 2 - offRight,	31,
			 openingWidth / 2 - offRight,	 0, 							31,
			 0,								-openingHeight / 2 + offRight,	31
!		wallniche 4, cutMethod, cutStatus,
!			cutVectX,cutVectY,cutVectZ, cutDepth,
!			-openingWidth / 2 + offRight * sideJambModify, 	 0, 												31,
!			 0,												 openingHeight / 2 - offRight * upperJambModify,	31,
!			 openingWidth / 2 - offRight * sideJambModify,	 0, 												31,
!			 0,												-openingHeight / 2 + offRight * upperJambModify,	31
		del 1
	endif

	if iWindowShape = SHAPE_OCTAGONAL then
		alpha_rotation	= 22.5
		offEdge			= (2 * offRight) / (2 * cos(22.5))
		cornerRadius	= openingHeight / (2 * cos(22.5))

		for i = 1 to 8
!!!			put (cornerRadius - offEdge / mulRatio) * sin(alpha_rotation), (cornerRadius - offEdge) * cos(alpha_rotation) * MulRat, 31
			put (cornerRadius - offEdge) * sin(alpha_rotation), (cornerRadius - offEdge) * cos(alpha_rotation) * MulRat, 31
			alpha_rotation = alpha_rotation + 45
		next i

		addy openingHeight/2
		wallniche nsp/3, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			get (nsp)
		del 1
	endif

	if iWindowShape = SHAPE_MULTISIDE then
		addy normalRadius * cos (180 / gs_numOfSides)

		alpha_rotation = 0
		if (gs_numOfSides mod 2) = 0 then
			alpha_rotation = 180 / gs_numOfSides
		endif

		cornerRadius = normalRadius - offRight / cos (180 / gs_numOfSides)

		for i = 1 to gs_numOfSides
			put cornerRadius * sin (alpha_rotation), cornerRadius * cos (alpha_rotation) * MulRat, 31 + (nArchResolution = 0) * 64
			alpha_rotation = alpha_rotation + 360 / gs_numOfSides
		next i

		wallniche nsp/3, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			get (nsp)
		del 1
	endif

	if iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
		addy openingHeight / 2
		muly openingHeight / openingWidth * MulRat
		wallniche 2, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			0, 0, 995,
			openingWidth/2 - offRight,	360, 4095
		del 2
	endif

	if iWindowShape = SHAPE_HALFCIRCLE then
		if sideTop - archHeight > -sideBottom + offBottom then
			archDistortion = (archHeight - offTop) / ((sideRight - offRight + sideLeft - offLeft) / 2)
			addy sideTop - archHeight
			muly archDistortion
			wallniche 6, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				 sideRight - offRight,	(-sideBottom + offBottom - sideTop + archHeight) / archDistortion,	31,
				 sideRight - offRight,	0,																	95,
				 0,						1, 																	895,
				 0,	 					(sideTop - offTop - sideTop + archHeight) / archDistortion,			1095,
				-sideLeft  + offLeft,	0,																	1095,
				-sideLeft  + offLeft,	(-sideBottom + offBottom - sideTop + archHeight) / archDistortion,	31
			del 2
		else
			pxR = sqr((sideRight - offRight)^2 - (-sideBottom + offBottom - (sideTop - archHeight))^2)
			pxL = sqr((sideLeft  - offLeft)^2  - (-sideBottom + offBottom - (sideTop - archHeight))^2)
			alpha = atn((-sideBottom + offBottom - (sideTop - archHeight)) / pxR)
			wallniche 5, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				 pxR,			-sideBottom + offBottom,	95,
				 -sin(alpha),	 cos(alpha), 				895,
				 0,				 sideTop - offTop,			1031,
				-pxL,			-sideBottom + offBottom,	1031,
				 pxR,			-sideBottom + offBottom,	31
		endif
	endif

	if iWindowShape = SHAPE_HALFROUND then

		mulx -1
		add - openingWidth / 2, openingHeight / 2, 0

		diffx = (leftWidth - rightWidth) / 2
		ang_segm = 360 / nArchResolution
		kezd_veg = 0

		for kk= 0 to nArchResolution/2

			xa = openingWidth * cos(-90 + (kk) * ang_segm)
			ya = openingHeight / 2 * sin(-90 + (kk) * ang_segm)
			if ABS(ya) < EPS then
				ang_cent = -90
			else
				ang_cent = ATN(xa/ya)
			endif

			xa_el = openingWidth * cos(-90 + (kk-1) * ang_segm)
			ya_el = openingHeight / 2 * sin(-90 + (kk-1) * ang_segm)
			if ABS(ya_el) < EPS then
				ang_cent_el = -90
			else
				ang_cent_el = ATN(xa_el/ya_el)
			endif

			xa_ut = openingWidth * cos(-90 + (kk+1) * ang_segm)
			ya_ut = openingHeight / 2 * sin(-90 + (kk+1) * ang_segm)
			if ABS(ya_ut) < EPS then
				ang_cent_ut = -90
			else
				ang_cent_ut = ATN(xa_ut/ya_ut)
			endif

			bFirstPoint	= (kk = 0)
			bLastPoint	= (kk = nArchResolution / 2)

			if bFirstPoint & not(bRightCornerFunction) & offLeft < -EPS then
				put diffx + offLeft, -openingHeight / 2 + offLeft, 31
			endif

			if xa - abs(offLeft * sin(ang_cent)) >= offLeft then
				! between points
				if (bFirstPoint | bLastPoint) & not(bRightCornerFunction) & offLeft > -EPS then
					mask = 31
				else
					mask = 95
				endif
				if kk>nArchResolution/4 then
					put diffx + xa - (offLeft * sin(ang_cent)), ya - (offLeft * cos(ang_cent)), mask
				else
					put diffx + xa + (offLeft * sin(ang_cent)), ya + (offLeft * cos(ang_cent)), mask
				endif
			else
				if not(bRightCornerFunction) then
					mask = 31
				else
					mask = 95
				endif

				! first point
				if kezd_veg = 0 & xa_ut - ABS( offLeft * sin(ang_cent_ut)) > offLeft then
					x11 = offLeft
					y11 = -openingHeight
					x12 = offLeft
					y12 = openingHeight
					x21 = xa 	- ABS( offLeft * sin(ang_cent))
					y21 = ya 	+ ( offLeft * cos(ang_cent))
					x22 = xa_ut - ABS( offLeft * sin(ang_cent_ut))
					y22 = ya_ut + ( offLeft * cos(ang_cent_ut))
					GOSUB 100

					put diffx + cx, cy, mask

					kezd_veg = 1
				endif

				! last point
				if kezd_veg = 1  & xa_el - ABS( offLeft * sin(ang_cent_el)) > offLeft then
					x11 = offLeft
					y11 = -openingHeight
					x12 = offLeft
					y12 = openingHeight
					x21 = xa 	- ABS( offLeft * sin(ang_cent))
					y21 = ya 	- ( offLeft * cos(ang_cent))
					x22 = xa_el - ABS( offLeft * sin(ang_cent_el))
					y22 = ya_el - ( offLeft * cos(ang_cent_el))
					GOSUB 100

					put diffx + cx, cy, mask

					kezd_veg = 2
				endif
			endif

			if bLastPoint & not(bRightCornerFunction) & offLeft < -EPS then
				put diffx + offLeft, openingHeight / 2 - offLeft, 31
			endif


		next kk

		if bRightCornerFunction then
			wallniche 2+nsp/3, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				-1,		-openingHeight/2 + offLeft,	95,
				get(nsp),
				-1,		openingHeight/2 - offLeft,	95
		else
			wallniche nsp/3, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				get(nsp)
		endif

		del 2
	endif

	if iWindowShape = SHAPE_T then
		if curvedWall then
			midleLine = (-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left + sideRight - offSlRight - gs_sidelight_WHole_width_right) / 2
			wallniche 6, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				 sideRight - offRight,	-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
				 sideRight - offRight,	 sideTop    - offTop,												31,
				-sideLeft  + offLeft,	 sideTop    - offTop,												31,
				-sideLeft  + offLeft,	-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,		31,
				 midleLine,				-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,		31,
				 midleLine,				-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31
			cutHeight = (sideTop - offTop) + (-sideBottom + max(gs_sidelight_parapet_hgt_left + offSlLeftBottom, gs_sidelight_parapet_hgt_right + offSlRightBottom) - sideTop + offTop) / 2
			wallniche 4, 1, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	 cutHeight,					31,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	-sideBottom + offBottom,	31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	-sideBottom + offBottom,	31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	 cutHeight,					31
		else
			wallniche 9, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				 sideRight - offRight,										-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
				 sideRight - offRight,										 sideTop    - offTop,												31,
				-sideLeft  + offLeft,										 sideTop    - offTop,												31,
				-sideLeft  + offLeft,										-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,		31,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,		31,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	-sideBottom + offBottom,											31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	-sideBottom + offBottom,											31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
				 sideRight - offRight,										-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	-1
		endif
	endif

	if iWindowShape = SHAPE_HALF_T_LEFT then
		if curvedWall then
			midleLine = (-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left + sideRight - offRight) / 2
			cutHeight = (sideTop - offTop) + (-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left - sideTop + offTop) / 2
			wallniche 4, 1, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	 cutHeight,					31,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	-sideBottom + offBottom,	31,
				 midleLine + 0.1,											-sideBottom + offBottom,	31,
				 midleLine + 0.1,											 cutHeight,					31
		else
			midleLine = -sideLeft  + offSlLeft + gs_sidelight_WHole_width_left
		endif
		wallniche 7, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			 sideRight - offRight,	-sideBottom + offBottom,										31,
			 sideRight - offRight,	 sideTop    - offTop,											31,
			-sideLeft  + offLeft,	 sideTop    - offTop,											31,
			-sideLeft  + offLeft,	-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,	31,
			 midleLine,				-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,	31,
			 midleLine,				-sideBottom + offBottom,										31,
			sideRight - offRight,	-sideBottom + offBottom,										-1
	endif

	if iWindowShape = SHAPE_HALF_T_RIGHT then
		if curvedWall then
			midleLine = (-sideLeft  + offLeft + sideRight - offSlRight - gs_sidelight_WHole_width_right) / 2
			cutHeight = (sideTop - offTop) + (-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right - sideTop + offTop) / 2
			wallniche 4, 1, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				 midleLine - 0.1,											 cutHeight,					31,
				 midleLine - 0.1,											-sideBottom + offBottom,	31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	-sideBottom + offBottom,	31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	 cutHeight,					31
		else
			midleLine = sideRight - offSlRight - gs_sidelight_WHole_width_right
		endif
		wallniche 7, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			 sideRight - offRight,	-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
			 sideRight - offRight,	 sideTop    - offTop,												31,
			-sideLeft  + offLeft,	 sideTop    - offTop,												31,
			-sideLeft  + offLeft,	-sideBottom + offBottom,											31,
			 midleLine,				-sideBottom + offBottom,											31,
			 midleLine,				-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
			 sideRight - offRight,	-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	-1
	endif

	if iWindowShape = SHAPE_ARCHED_T then
		if arcR - offTop > sideRight - offRight then
			shoulder_offset = sqr((arcR - offTop)^2 - (sideRight - offRight)^2)
			mask = 0
		else
			shoulder_offset = 0
			mask = 64
		endif

		if curvedWall then
			midleLine = (-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left + sideRight - offSlRight - gs_sidelight_WHole_width_right) / 2
			wallniche 11, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				(sideRight - offRight - sideLeft + offLeft) / 2,	 sideTop - arcR,						900,
				 sideRight - offRight,	-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
				 sideRight - offRight,	 sideTop    - arcR + shoulder_offset - EPS,							31+mask,
				 sideRight - offRight,	 sideTop    - arcR + shoulder_offset,								95,
				 0,	 					 sideTop - offTop,													3031+mask,
				-sideLeft  + offLeft,	 sideTop    - arcR + shoulder_offset,								3031+mask,
				-sideLeft  + offLeft,	 sideTop    - arcR + shoulder_offset - EPS,							31+mask,
				-sideLeft  + offLeft,	-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,		31,
				midleLine,				-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,		31,
				midleLine,				-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
				 sideRight - offRight,	-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	-1
			cutHeight = (sideTop - offTop) + (-sideBottom + max(gs_sidelight_parapet_hgt_left + offSlLeftBottom, gs_sidelight_parapet_hgt_right + offSlRightBottom) - sideTop + offTop) / 2
			wallniche 4, 1, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	 cutHeight,					31,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	-sideBottom + offBottom,	31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	-sideBottom + offBottom,	31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	 cutHeight,					31
		else
			wallniche 13, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				(sideRight - offRight - sideLeft + offLeft) / 2,			 sideTop 	- arcR,				 									900,
				 sideRight - offRight,										-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
				 sideRight - offRight,										 sideTop    - arcR + shoulder_offset - EPS,							31+mask,
				 sideRight - offRight,										 sideTop    - arcR + shoulder_offset,								95,
				 0,															 sideTop - offTop,													3031+mask,
				-sideLeft  + offLeft,										 sideTop    - arcR + shoulder_offset,								3031+mask,
				-sideLeft  + offLeft,										 sideTop    - arcR + shoulder_offset - EPS,							31+mask,
				-sideLeft  + offLeft,										-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,		31,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,		31,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	-sideBottom + offBottom,											31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	-sideBottom + offBottom,											31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
				 sideRight - offRight,										-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	-1
		endif
	endif

	if iWindowShape = SHAPE_ARCHED_HALF_T_LEFT then
		if arcR - offTop > sideRight - offRight then
			shoulder_offset = sqr((arcR - offTop)^2 - (sideRight - offRight)^2)
			mask = 0
		else
			shoulder_offset = 0
			mask = 64
		endif

		if curvedWall then
			midleLine = (-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left + sideRight - offRight) / 2
			cutHeight = (sideTop - offTop) + (-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left - sideTop + offTop) / 2
			wallniche 4, 1, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	 cutHeight,					31,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	-sideBottom + offBottom,	31,
				 midleLine + 0.1,											-sideBottom + offBottom,	31,
				 midleLine + 0.1,											 cutHeight,					31
		else
			midleLine = -sideLeft  + offSlLeft + gs_sidelight_WHole_width_left
		endif
		wallniche 11, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			(sideRight - offRight - sideLeft + offLeft) / 2,	sideTop - arcR,						900,
			 sideRight - offRight,	-sideBottom + offBottom,										31,
			 sideRight - offRight,	 sideTop    - arcR + shoulder_offset - EPS,						31+mask,
			 sideRight - offRight,	 sideTop    - arcR + shoulder_offset,							95,
			 0,						 sideTop - offTop,												3031+mask,
			-sideLeft  + offLeft,	 sideTop    - arcR + shoulder_offset,							3031+mask,
			-sideLeft  + offLeft,	 sideTop    - arcR + shoulder_offset - EPS,						31+mask,
			-sideLeft  + offLeft,	-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,	31,
			 midleLine,				-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,	31,
			 midleLine,				-sideBottom + offBottom,										31,
			 sideRight - offRight,	-sideBottom + offBottom,										-1
	endif

	if iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT then
		if arcR - offTop > sideRight - offRight then
			shoulder_offset = sqr((arcR - offTop)^2 - (sideRight - offRight)^2)
			mask = 0
		else
			shoulder_offset = 0
			mask = 64
		endif

		if curvedWall then
			midleLine = (-sideLeft  + offLeft + sideRight - offSlRight - gs_sidelight_WHole_width_right) / 2
			cutHeight = (sideTop - offTop) + (-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right - sideTop + offTop) / 2
			wallniche 4, 1, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				 midleLine - 0.1,											 cutHeight,					31,
				 midleLine - 0.1,											-sideBottom + offBottom,	31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	-sideBottom + offBottom,	31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	 cutHeight,					31
		else
			midleLine = sideRight - offSlRight - gs_sidelight_WHole_width_right
		endif
		wallniche 11, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			(sideRight - offRight - sideLeft + offLeft) / 2,	sideTop - arcR,							900,
			 sideRight - offRight,	-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
			 sideRight - offRight,	 sideTop    - arcR + shoulder_offset - EPS,							31+mask,
			 sideRight - offRight,	 sideTop    - arcR + shoulder_offset,								95,
			 0,						 sideTop - offTop,													3031+mask,
			-sideLeft  + offLeft,	 sideTop    - arcR + shoulder_offset,								3031+mask,
			-sideLeft  + offLeft,	 sideTop    - arcR + shoulder_offset - EPS,							31+mask,
			-sideLeft  + offLeft,	-sideBottom + offBottom,											31,
			 midleLine,				-sideBottom + offBottom,											31,
			 midleLine,				-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
			 sideRight - offRight,	-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	-1
	endif

	if iWindowShape = SHAPE_QUARTERROUND then
		if offLeft > holeSideOffset | offBottom > holeBottomOffset then
			px = sqr((openingWidth - offRight)^2 - (offBottom - holeBottomOffset)^2)
			py = sqr((openingHeight - offTop)^2 - (offLeft - holeSideOffset)^2)
			wallniche 6, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				-openingWidth / 2 + offLeft,		offBottom,					31,
				-openingWidth / 2 + px,				offBottom,					95,
				-openingWidth / 2 + holeSideOffset,	holeBottomOffset,			900,
				-openingWidth / 2 + offLeft,		py,							3031,
				-openingWidth / 2 + offLeft,		py - EPS,					31,
				-openingWidth / 2 + offLeft,		offBottom,					-1
		else
			wallniche 7, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				-openingWidth / 2 + offLeft,		offBottom,					31,
				 openingWidth / 2 - offRight,		offBottom,					95,
				 openingWidth / 2 - offRight,		holeBottomOffset,			95,
				 0,									1,							800,
				-openingWidth / 2 + holeSideOffset,	openingHeight - offTop,		1031,
				-openingWidth / 2 + offLeft,		openingHeight - offTop,		31,
				-openingWidth / 2 + offLeft,		offBottom,					-1
		endif
	endif

	if iWindowShape = SHAPE_QUARTERROUND_NOFRAME then
		if bMirroredOpening then
			openingHeight = openingWidth
			px = sqr((openingWidth - offLeft)^2 - offBottom^2)
			py = sqr((openingHeight - offTop)^2 - offLeft^2)

			if bRightCornerFunction then
				diffx = -(leftWidth - rightWidth) / 2
				wallniche 6, cutMethod, cutStatus,
					cutVectX,cutVectY,cutVectZ, cutDepth,
					 diffx + openingWidth / 2 + 1.0,	offBottom,				31,
					 diffx + openingWidth / 2 - px,		offBottom,				95,
					 diffx + openingWidth / 2,			0,						900,
					 diffx + openingWidth / 2,			openingHeight - offTop,	3095,
					 diffx + openingWidth / 2 + 1.0,	openingHeight - offTop, 31,
					 diffx + openingWidth / 2 + 1.0,	offBottom,				-1
			else
				if px > py then
					wallniche 6, cutMethod, cutStatus,
						cutVectX,cutVectY,cutVectZ, cutDepth,
						 openingWidth / 2 - offRight,	offBottom,	31,
						 openingWidth / 2 - px,			offBottom,	95,
						 openingWidth / 2,				0,			900,
						 openingWidth / 2 - offRight,	py,			3031,
						 openingWidth / 2 - offRight,	py - EPS,	31,
						 openingWidth / 2 - offRight,	offBottom,	-1
				else
					wallniche 6, cutMethod, cutStatus,
						cutVectX,cutVectY,cutVectZ, cutDepth,
						 openingWidth / 2 - offRight,	offBottom,	31,
						 openingWidth / 2 - px,			offBottom,	95,
						 openingWidth / 2,				0,			900,
						 openingWidth / 2,				px,			3095,
						 openingWidth / 2 - offRight,	px - EPS,	31,
						 openingWidth / 2 - offRight,	offBottom,	-1
				endif
			endif
		else
			px = sqr((openingWidth - offRight)^2 - offBottom^2)
			py = sqr((openingHeight - offTop)^2 - offLeft^2)

			wallniche 6, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				-openingWidth / 2 + offLeft,	offBottom,	31,
				-openingWidth / 2 + px,			offBottom,	95,
				-openingWidth / 2,				0,			900,
				-openingWidth / 2 + offLeft,	py,			3031,
				-openingWidth / 2 + offLeft,	py - EPS,	31,
				-openingWidth / 2 + offLeft,	offBottom,	-1
		endif
	endif

	_bCustomMatNicheTop		= 0
return


! ==============================================================================
! Line - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	x11,y11, x12,y12	line #1
!	x21,y21, x22,y22	line #2
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = valid intersection point
!	cx, cy:				intersection point
! ==============================================================================

100:
	lliDiv = (x11-x12) * (y21-y22) - (y11-y12) * (x21-x22)

	if abs(lliDiv) > EPS then
		! Intersection

		temp1 = x11 * y12 - y11 * x12
		temp2 = x21 * y22 - y21 * x22

		tempx = temp1 * (x21-x22) - (x11-x12) * temp2
		tempy = temp1 * (y21-y22) - (y11-y12) * temp2

		state = 1
		cx = (tempx / lliDiv)
		cy = (tempy / lliDiv)
	else
		! No Intersection
		state = 0
		cx = 0
		cy = 0
	endif
return



! ==============================================================================
! Circle - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	xo,yo,ro:			circle
!	x1,y1, x2,y2		line
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = one intersection point (tangential line)
!						2 = two intersection points
!	xa, ya:				intersection point #1
!	xb, yb:				intersection point #2
! ==============================================================================

101:
	tempX1 = x1 - xo: tempY1 = y1 - yo
	tempX2 = x2 - xo: tempY2 = y2 - yo

	if abs(tempX2 - tempX1) < EPS then
		if abs(ro - abs(tempX1)) < EPS then
			state = 1
			xa = tempX1
			ya = 0
			xb = tempX1
			yb = 0
		else
			if abs(ro) - abs(tempX1) < 0 then
				state = 0: xa = 0: ya = 0: xb = 0: yb = 0
			else
				state = 2
				xa = tempX1
				ya = sqr(ro^2 - tempX1^2)
				xb = tempX1
				yb = -ya
			endif
		endif
	else
		kf = (tempY2 - tempY1) / (tempX2 - tempX1)
		ad = 1 + kf^2
		bd = 2 * tempY1 * kf - 2 * tempX1 * kf^2
		cd = tempY1^2 - 2 * tempX1 * tempY1 * kf + tempX1^2 * kf^2 - ro^2

		if bd^2 - 4 * ad * cd < 0 then
			state = 0: xa = 0: ya = 0: xb = 0: yb = 0
		else
			xa = (-bd + sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			ya = tempY1 + (xa - tempX1) * kf
			xb = (-bd - sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			yb = tempY1 + (xb - tempX1) * kf

			if abs(xa - xb) < EPS then state = 1 else state = 2
		endif
	endif

	if state = 2 then
		da = sqr((tempX1 - xa)^2 + (tempY1 - ya)^2)
		db = sqr((tempX1 - xb)^2 + (tempY1 - yb)^2)

		if db < da then
			xxo = xa: yyo = ya
			xa = xb:  ya = yb
			xb = xxo: yb = yyo
		endif
	endif

	xa = xa + xo: ya = ya + yo
	xb = xb + xo: yb = yb + yo
return

205:

!!! ***** Direction Angle of Vector


IF vx=0 AND vy=0 THEN PRINT "Error: Null Vector !"

IF vx=0 THEN
	IF vy>0 THEN
		anglex = 90
	ELSE
		anglex = 270
	ENDIF
ELSE

	anglex = ATN (vy/vx)

	IF vx>=0 THEN
		IF anglex>=0 THEN
			anglex = anglex
		ELSE
			anglex = 360 + anglex
		ENDIF

	ELSE

		IF anglex>0 THEN
			anglex = 180 + anglex
		ELSE
			anglex = 180 + anglex
		ENDIF
	ENDIF
ENDIF

RETURN


209:

!!! ***** Circle - Circle Intersection

vx =	x2-x1
vy =	y2-y1
GOSUB 205

angle = anglex


d = SQR( (vx)^2+(vy)^2 )

IF d>(r1+r2) OR ABS(d)<EPS THEN ! No Intersection
	state = 0
	RETURN
ENDIF

IF ABS(d-(r1+r2))<EPS THEN ! One Intersection

	state =  1
	ccx1 = x1 + ((x2-x1)*r1)/(r1+r2)
	ccy1 = y1 + ((y2-y1)*r1)/(r1+r2)

	ccx2 = ccx1
	ccy2 = ccy1
	RETURN
ENDIF


! Check if one circle inside the another !!!!!!!!!!!!!!!!!!!!!!!!!!!

x = (d^2 - r2^2 + r1^2) / (2*d)
y = SQR(4*d^2*r1^2-(d^2-r2^2+r1^2)^2)/(d*2)
ccx1 = x1 + y*SIN(-angle) + x*COS(-angle)
ccy1 = y1 + y*COS(-angle) - x*SIN(-angle)
ccx2 = x1 - y*SIN(-angle) + x*COS(-angle)
ccy2 = y1 - y*COS(-angle) - x*SIN(-angle)

state =	2


RETURN



3000:
! ==============================================================================
! --- Reveal Hotspots ---
! ==============================================================================
if iRevealType > REVEAL_NO then
	hotspot revealRadius * sin (alpha_rotation), revealRadius * cos (alpha_rotation), leftRevealPnts[idxSillStartRevealLeft][2],	unID : unID = unID + 1
	hotspot revealRadius * sin (alpha_rotation), revealRadius * cos (alpha_rotation), leftRevealPnts[idxSillEndRevealLeft][2],	unID : unID = unID + 1
endif
return



4000:
! ==============================================================================
! --- Wallhole Hotspots ---
! ==============================================================================

! Board Side Hotspots ----------------------------------------------------------
hotspot normalRadius * sin (alpha_rotation), normalRadius * cos (alpha_rotation), leftRevealPnts[idxBoardEndRevealLeft][2],	unID : unID = unID + 1

! Sill Side Hotspots ----------------------------------------------------------
if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
	hotspot normalRadius * sin (alpha_rotation), normalRadius * cos (alpha_rotation), leftRevealPnts[idxSillStartRevealLeft][2],	unID : unID = unID + 1
else
	hotspot normalRadius * sin (alpha_rotation), normalRadius * cos (alpha_rotation), leftRevealPnts[idxFrameStartRevealLeft][2],	unID : unID = unID + 1
endif

return




]]>
</Script_3D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_2D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[

! Contact person: <NJ>

_bValidPoly = 1

! ==============================================================================
! This macro cuts the wallhole
! ------------------------------------------------------------------------------
! Input parameters:
!
! Hotspot IDs:
!	11040:			Wall Inset left edge (at the inset depth)
!	11041:			Wall Inset right edge (at the inset depth)
!	11042:			Wall Inset left edge (at the wall side)
!	11043:			Wall Inset right edge (at the wall side)
!	11000:			Frame start left
!	11001:			Frame start right
!	11002:			Frame end left
!	11003:			Frame end right
!	11100-11199:	Reveal hotspots
!	11200-:			Polygonal wall corner points
! ==============================================================================


LINE_BEG_X		= 1
LINE_BEG_Y		= 2
LINE_END_X		= 3
LINE_END_Y		= 4
LINE_ATTRIBUTES	= 5	! bitfield, look at LINE_ATTRIBUTES_xxx for available values
LINE_PEN_IDX	= 6
LINE_LTYPE_IDX	= 7

LINE_ATTRIBUTES_GDLLINE		= 0			! Draw GDL Line in the section
LINE_ATTRIBUTES_WALLLINE	= 1			! Draw WallLine in the section
LINE_ATTRIBUTES_WALLSIDE	= 2			! The section is on the wall side (it is an arc in curved wall)
LINE_ATTRIBUTES_DRAWCC		= 3			! The section is drawn by CavityClosure macro (otherwise the WallHoleCut macro)
LINE_ATTRIBUTES_CONTOUR		= 4			! The section is contour or inner line
!!!	LINE_ATTRIBUTES_WALLEDGE	= 0			! The section is on the wall edge (always a line)


! ==============================================================================

if WIDO_REVEAL_SIDE then
	add2 0,-WIDO_FRAME_THICKNESS
else
	mul2 1,-1
endif


! ==============================================================================
! Wallhole (Frame) Hotspots
! ==============================================================================

!if gs_wallhole_hotspots then
!	hotspot2 leftRevealPnts[idxFrameStartRevealLeft][1],	leftRevealPnts[idxFrameStartRevealLeft][2],	 11000
!	hotspot2 rightRevealPnts[idxFrameStartRevealRight][1],	rightRevealPnts[idxFrameStartRevealRight][2],11001
!
!	if iRevealType <> REVEAL_SLANTED then
!		hotspot2 leftRevealPnts[idxFrameEndRevealLeft][1],	leftRevealPnts[idxFrameEndRevealLeft][2],	11002
!		hotspot2 rightRevealPnts[idxFrameEndRevealRight][1],rightRevealPnts[idxFrameEndRevealRight][2],	11003
!	endif
!endif

if iRevealType > REVEAL_NO then
	hotspot2 leftRevealPnts[idxFrameStartRevealLeft][1],	leftRevealPnts[idxFrameStartRevealLeft][2],	 11000
	hotspot2 rightRevealPnts[idxFrameStartRevealRight][1],	rightRevealPnts[idxFrameStartRevealRight][2],11001
endif



! ==============================================================================
! Reveal Hotspots
! ------------------------------------------------------------------------------
! It skips hotspots on wall contour in case of polygonal walls (AC_WallType = 2).
! Skipped points will be drawn in the polygon operations section
! ==============================================================================

if gs_reveal_hotspots & AC_WallType <> 2 then

	unID = 11100
	for ii = idxSillStartRevealLeft - (AC_WallType = 2) to idxFrameStartRevealLeft - 1
		hotspot2 leftRevealPnts[ii][1], leftRevealPnts[ii][2], unID : unID = unID + 2
	next ii

	unID = 11101
	for ii = idxSillStartRevealRight - (AC_WallType = 2) to idxFrameStartRevealRight - 1
		hotspot2 rightRevealPnts[ii][1], rightRevealPnts[ii][2], unID : unID = unID + 2
	next ii

	! Show hotspot at frame
	bShowLastHpts = not(iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO | iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_NEGATIVE | iRevealType = REVEAL_SLANTED)

	unID = 11150
	for ii = idxFrameEndRevealLeft + 1 to idxBoardEndRevealLeft - (AC_WallType = 2)
		hotspot2 leftRevealPnts[ii][1], leftRevealPnts[ii][2], unID : unID = unID + 2
	next ii
![#COMPATIBILITY] - START
!	for ii = idxFrameEndRevealLeft + not(bShowLastHpts) to idxBoardEndRevealLeft - (AC_WallType = 2)
!		hotspot2 leftRevealPnts[ii][1], leftRevealPnts[ii][2], unID : unID = unID + 2
!	next ii
	if bShowLastHpts then
		ii = idxFrameEndRevealLeft
		hotspot2 leftRevealPnts[ii][1], leftRevealPnts[ii][2], unID : unID = unID + 2
	endif
![#COMPATIBILITY] - END

	unID = 11151
	for ii = idxFrameEndRevealRight + 1 to idxBoardEndRevealRight - (AC_WallType = 2)
		hotspot2 rightRevealPnts[ii][1], rightRevealPnts[ii][2], unID : unID = unID + 2
	next ii
![#COMPATIBILITY] - START
!	for ii = idxFrameEndRevealRight + not(bShowLastHpts) to idxBoardEndRevealRight - (AC_WallType = 2)
!		hotspot2 rightRevealPnts[ii][1], rightRevealPnts[ii][2], unID : unID = unID + 2
!	next ii
	if bShowLastHpts then
		ii = idxFrameEndRevealRight
		hotspot2 rightRevealPnts[ii][1], rightRevealPnts[ii][2], unID : unID = unID + 2
	endif
![#COMPATIBILITY] - END

	! Show hotspot at corner of turned last plaster skin

	if gs_turn_plaster_dim_2D then

		unID = 11201
		if ((abs(leftRevealPnts[idxSillStartPlasterLeft][1] - leftRevealPnts[idxSillStartRevealLeft][1]) > EPS) |\
			(abs(leftRevealPnts[idxSillStartPlasterLeft][2] - leftRevealPnts[idxSillStartRevealLeft][2]) > EPS)) then

			hotspot2 leftRevealPnts[idxSillStartPlasterLeft][1], leftRevealPnts[idxSillStartPlasterLeft][2], unID : unID = unID + 2
!!!			circle2 leftRevealPnts[idxSillStartPlasterLeft][1], leftRevealPnts[idxSillStartPlasterLeft][2], 0.02
		else
			unID = unID + 2
		endif

		if ((abs(leftRevealPnts[idxBoardEndPlasterLeft][1] - leftRevealPnts[idxBoardEndRevealLeft][1]) > EPS) |\
			(abs(leftRevealPnts[idxBoardEndPlasterLeft][2] - leftRevealPnts[idxBoardEndRevealLeft][2]) > EPS)) then

			hotspot2 leftRevealPnts[idxBoardEndPlasterLeft][1], leftRevealPnts[idxBoardEndPlasterLeft][2], unID : unID = unID + 2
!!!			circle2 leftRevealPnts[idxBoardEndPlasterLeft][1], leftRevealPnts[idxBoardEndPlasterLeft][2], 0.02
		else
			unID = unID + 2
		endif

		unID = 11251
		if ((abs(rightRevealPnts[idxSillStartPlasterRight][1] - rightRevealPnts[idxSillStartRevealRight][1]) > EPS) |\
			(abs(rightRevealPnts[idxSillStartPlasterRight][2] - rightRevealPnts[idxSillStartRevealRight][2]) > EPS)) then

			hotspot2 rightRevealPnts[idxSillStartPlasterRight][1], rightRevealPnts[idxSillStartPlasterRight][2], unID : unID = unID + 2
!!!			circle2 rightRevealPnts[idxSillStartPlasterRight][1], rightRevealPnts[idxSillStartPlasterRight][2], 0.02
		else
			unID = unID + 2
		endif

		if ((abs(rightRevealPnts[idxBoardEndPlasterRight][1] - rightRevealPnts[idxBoardEndRevealRight][1]) > EPS) |\
			(abs(rightRevealPnts[idxBoardEndPlasterRight][2] - rightRevealPnts[idxBoardEndRevealRight][2]) > EPS)) then

			hotspot2 rightRevealPnts[idxBoardEndPlasterRight][1], rightRevealPnts[idxBoardEndPlasterRight][2], unID : unID = unID + 2
!!!			circle2 rightRevealPnts[idxBoardEndPlasterRight][1], rightRevealPnts[idxBoardEndPlasterRight][2], 0.02
		else
			unID = unID + 2
		endif

	endif
endif

polyUnID = 11200	! Hotspot unID for polygonal wall corner points


! ==============================================================================



bNeedToOffsetSkins		= (offsetSill > EPS | offsetBoard > EPS)

if isWindow then
	drawindex 30	! Draw parapet contour lines at the bottom
else
	drawindex 20	! Draw parapet contour lines at the bottom
endif


! ==============================================================================
! Cut corners in case of corner window function
! ==============================================================================

if not(curvedWall) & not(bInclinedWall) & AC_WallType <> 2 & not(gs_transom_display) then	! Not drawn when Display as Transom is ON
	if bLeftCornerFunction then
		fill 0
		if GLOB_CONTEXT = 5 then
			poly2_b 4, 2+4+64, 0, -1,
				leftRevealPnts[idxBoardEndPlasterLeft][1],  leftRevealPnts[idxBoardEndPlasterLeft][2],  0,
				leftRevealPnts[idxSillStartPlasterLeft][1], leftRevealPnts[idxSillStartPlasterLeft][2], 0,
				0, leftRevealPnts[idxSillStartPlasterLeft][2], 0,
				0, leftRevealPnts[idxBoardEndPlasterLeft][2],  0
		else
			wallhole2 4, 2 + 64, 0, -1,
				0, 0, 0,
				leftRevealPnts[idxBoardEndPlasterLeft][1],  leftRevealPnts[idxBoardEndPlasterLeft][2],  0,
				leftRevealPnts[idxSillStartPlasterLeft][1], leftRevealPnts[idxSillStartPlasterLeft][2], 0,
				0, leftRevealPnts[idxSillStartPlasterLeft][2], 0,
				0, leftRevealPnts[idxBoardEndPlasterLeft][2],  0
		endif
	endif
	if bRightCornerFunction then
		fill 0
		if GLOB_CONTEXT = 5 then
			poly2_b 4, 2+4+64, 0, -1,
				rightRevealPnts[idxBoardEndPlasterRight][1],  rightRevealPnts[idxBoardEndPlasterRight][2],  0,
				rightRevealPnts[idxSillStartPlasterRight][1], rightRevealPnts[idxSillStartPlasterRight][2], 0,
				0, rightRevealPnts[idxSillStartPlasterRight][2], 0,
				0, rightRevealPnts[idxBoardEndPlasterRight][2],  0
		else
			wallhole2 4, 2 + 64, 0, -1,
				0, 0, 0,
				rightRevealPnts[idxBoardEndPlasterRight][1],  rightRevealPnts[idxBoardEndPlasterRight][2],  0,
				rightRevealPnts[idxSillStartPlasterRight][1], rightRevealPnts[idxSillStartPlasterRight][2], 0,
				0, rightRevealPnts[idxSillStartPlasterRight][2], 0,
				0, rightRevealPnts[idxBoardEndPlasterRight][2],  0
		endif
	endif
endif


! =============================================================================
! Change visible contour line to hidden contour line
! =============================================================================

if bEnableWallContourHiddenLine then
	if bWallContHiddenLineIn then
		gs_wcont_line_in	= gs_wcont_hidden_line_in
	endif
	if bWallContHiddenLineOut then
		gs_wcont_line_out	= gs_wcont_hidden_line_out
	endif

	if bWallContHiddenLineInLeftSl then
		_wcont_line_left_sl_in	= gs_wcont_hidden_line_sl_in
	else
		_wcont_line_left_sl_in	= gs_wcont_line_sl_in
	endif
	if bWallContHiddenLineOutLeftSl then
		_wcont_line_left_sl_out	= gs_wcont_hidden_line_sl_out
	else
		_wcont_line_left_sl_out	= gs_wcont_line_sl_out
	endif

	if bWallContHiddenLineInRightSl then
		_wcont_line_right_sl_in		= gs_wcont_hidden_line_sl_in
	else
		_wcont_line_right_sl_in		= gs_wcont_line_sl_in
	endif
	if bWallContHiddenLineOutRightSl then
		_wcont_line_right_sl_out	= gs_wcont_hidden_line_sl_out
	else
		_wcont_line_right_sl_out	= gs_wcont_line_sl_out
	endif
endif


! ==============================================================================
! Cut 2D Wallhole and Draw Background Fills
! ==============================================================================

bUseOneBackgroundFill		= (bDrawSillFill = bDrawBoardFill)	! 1 - 1 or 0 - 0
bVisibleWallInsetIn2D		= (bParapetWallInset & ((bParapetWallInsetFullHeight & (bDrawBoardFill | gs_parapet_2D)) | (not(bParapetWallInsetFullHeight) & gs_parapet_2D)))
bHiddenParapetWallInsetIn2D	= (bParapetWallInset & (not(bParapetWallInsetFullHeight) | not(bDrawBoardFill)))

bSkipSillFill = (abs(WIDO_SILL) < EPS & AC_WallType <> 2 & (not(curvedWall) | (curvedWall & gs_IsCurved)))

if vardim1(leftRevealPnts) > 1 & not(gs_transom_display) then	! Not drawn when Display as Transom is ON

	if bHasSidelightLeft | bHasSidelightRight then
		wallholeFill	= gs_wallhole_fill_sl
		wallholePen_fg	= gs_wallhole_pen_sl_fg
		wallholePen_bg	= gs_wallhole_pen_sl_bg

		if bHasSidelightLeft then
			wcontLineIn			= _wcont_line_left_sl_in  * (iWallContourLineSl = 2 | iWallContourLineSl = 4)
			wcontLineOut		= _wcont_line_left_sl_out * (iWallContourLineSl = 3 | iWallContourLineSl = 4)
			sidelightCutLeft	= 0
			sidelightCutRight	= 1
			sidelightCutPosSillRight	= -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_left_sL + thkPlasterAtSillSlLeft
			sidelightCutPosMiddleRight	= -leftWidth + gs_sidelight_WHole_width_left
			sidelightCutPosBoardRight	= -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_double_innerLeft_sL + thkPlasterAtBoardSlLeft
			gosub "DrawWallholeFill"
		endif

		if bHasSidelightRight then
			wcontLineIn			= _wcont_line_right_sl_in  * (iWallContourLineSl = 2 | iWallContourLineSl = 4)
			wcontLineOut		= _wcont_line_right_sl_out * (iWallContourLineSl = 3 | iWallContourLineSl = 4)
			sidelightCutLeft 	= 1
			sidelightCutRight 	= 0
			sidelightCutPosSillLeft		= rightWidth - gs_sidelight_WHole_width_right - gs_reveal_right_sR - thkPlasterAtSillSlRight
			sidelightCutPosMiddleLeft	= rightWidth - gs_sidelight_WHole_width_right
			sidelightCutPosBoardLeft	= rightWidth - gs_sidelight_WHole_width_right - gs_reveal_double_innerRight_sR - thkPlasterAtBoardSlRight
			gosub "DrawWallholeFill"
		endif

		wallholeFill	= gs_wallhole_fill
		wallholePen_fg	= gs_wallhole_pen_fg
		wallholePen_bg	= gs_wallhole_pen_bg
		wcontLineIn		= gs_wcont_line_in  * (iWallContourLine = 2 | iWallContourLine = 4)
		wcontLineOut	= gs_wcont_line_out * (iWallContourLine = 3 | iWallContourLine = 4)

		sidelightCutLeft  = 2 * bHasSidelightLeft
		sidelightCutRight = 2 * bHasSidelightRight
		sidelightCutPosSillLeft		= -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_left_sL + thkPlasterAtSillSlLeft
		sidelightCutPosMiddleLeft	= -leftWidth + gs_sidelight_WHole_width_left
		sidelightCutPosBoardLeft	= -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_double_innerLeft_sL + thkPlasterAtBoardSlLeft
		sidelightCutPosSillRight	= rightWidth - gs_sidelight_WHole_width_right - gs_reveal_right_sR - thkPlasterAtSillSlRight
		sidelightCutPosMiddleRight	= rightWidth - gs_sidelight_WHole_width_right
		sidelightCutPosBoardRight	= rightWidth - gs_sidelight_WHole_width_right - gs_reveal_double_innerRight_sR - thkPlasterAtBoardSlRight
		gosub "DrawWallholeFill"
	else
		wallholeFill	= gs_wallhole_fill
		wallholePen_fg	= gs_wallhole_pen_fg
		wallholePen_bg	= gs_wallhole_pen_bg
		wcontLineIn		= gs_wcont_line_in  * (iWallContourLine = 2 | iWallContourLine = 4)
		wcontLineOut	= gs_wcont_line_out * (iWallContourLine = 3 | iWallContourLine = 4)

		sidelightCutLeft  = 0
		sidelightCutRight = 0
		gosub "DrawWallholeFill"
	endif
endif


! Draw Parapet Contours Outside ------------------------------------------------

bWallContourLine	= (iWallContourLine = 3 | iWallContourLine = 4)							! Outside, Both Sides
bWallContourLineSl	= ((iWallContourLineSl = 3 | iWallContourLineSl = 4) & bTShapedOpening)	! Outside, Both Sides

if AC_WallType <> 2 & (bWallContourLine | bWallContourLineSl) & not(gs_transom_display) then
	gosub "DrawContourLinesOutside"
endif


! Draw Parapet Contour Inside --------------------------------------------------

bWallContourLine	= (iWallContourLine = 2 | iWallContourLine = 4)							! Inside, Both Sides
bWallContourLineSl	= ((iWallContourLineSl = 2 | iWallContourLineSl = 4) & bTShapedOpening)	! Inside, Both Sides

if not(bVisibleWallInsetIn2D) & AC_WallType <> 2 & (bWallContourLine | bWallContourLineSl) & not(gs_transom_display) then
	gosub "DrawContourLinesInside"
endif


! Head / Threshold Plan Symbol -------------------------------------------------

if iRevealType > REVEAL_NO & gs_head_symbol & (abs(gs_reveal_top) > EPS | abs(gs_reveal_bottom) > EPS) & not(gs_transom_display) then
	gosub "DrawHeadThresholdPlanSymbol"
endif


! Drawing the wall contour lines -----------------------------------------------

drawindex 50	! Draw wall contour lines at the top
bListView = (GLOB_CONTEXT = 6 | GLOB_CONTEXT = 46)
if not(bListView) then
	gosub "DrawWallContourLines"
endif


! Draw New Wallhole Symbol (SWE symbol) -----------------------------------------

if gs_bShowNewOnCC & (iTypeDemolitionFill = RENOVATION_FILL_NEW | iTypeDemolitionFill = RENOVATION_FILL_NEW_FULL) then
	gosub "DrawSWENewWallholeSymbol"
endif


! Drawing Mounting Frame -------------------------------------------------------

if bHaveMountingFrame & lod2D_MountingFrame > 0 then
	gosub "DrawMountingFrame"
endif


! ==============================================================================
end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
! ==============================================================================


"DrawWallholeFill":

! Cut 2D Wallhole - Straight, Trapezoid and Arched Walls ----------------------

	if (bUseOneBackgroundFill | bVisibleWallInsetIn2D | bNeedToOffsetSkins) then
		gosub "DrawWallholeFillBothSides"
	endif


! Draw Sill Side Background Fill and Parapet Contours -------------------------

	bUsePolygonOperations	= 0
	bCutWallInsetWithPolyOp	= 0
	bAutoParapetInset		= 0

	if (not(bUseOneBackgroundFill) | bVisibleWallInsetIn2D | bNeedToOffsetSkins) & not(bSkipSillFill) then
		gosub "DrawWallholeFillOutside"
	endif


! Draw Board Side Background Fill and Parapet Contours ------------------------

	gosub "DrawWallholeFillInside"
return



! ==============================================================================
! Cut wallhole - both sides
! ==============================================================================

"DrawWallholeFillBothSides":

	if AC_WallType <> 2 then

		bDrawFill = ((bDrawSillFill & bDrawBoardFill) & not(bVisibleWallInsetIn2D | bNeedToOffsetSkins))

		if curvedWall then put 0,WOD,900

		if sidelightCutLeft then
			if curvedWall then
				put sidelightCutPosSillLeft, WOD - signWallIsLeft * sqr(radSill^2 - sidelightCutPosSillLeft^2), 0
			else
				put sidelightCutPosSillLeft, leftRevealPnts[idxSillStartPlasterLeft][2], 0
			endif
			if abs(sidelightCutPosSillLeft - sidelightCutPosMiddleLeft) > EPS then
				put sidelightCutPosSillLeft,	0, 0,
					sidelightCutPosMiddleLeft,	0, 0
			endif
			if abs(sidelightCutPosMiddleLeft - sidelightCutPosBoardLeft) > EPS then
				put sidelightCutPosMiddleLeft,	WIDO_FRAME_THICKNESS, 0,
					sidelightCutPosBoardLeft,	WIDO_FRAME_THICKNESS, 0
			endif
			if curvedWall then
				put sidelightCutPosBoardLeft, WOD - signWallIsLeft * sqr(radBoard^2 - sidelightCutPosBoardLeft^2), 0
			else
				if bInclinedWall then
					put sidelightCutPosBoardLeft,
						leftRevealPnts[idxBoardEndPlasterLeft][2] + (leftRevealPnts[idxBoardEndPlasterLeft][1] - sidelightCutPosBoardLeft) * \
						(leftRevealPnts[idxBoardEndPlasterLeft][2] - rightRevealPnts[idxBoardEndPlasterRight][2]) / (-leftRevealPnts[idxBoardEndPlasterLeft][1] + rightRevealPnts[idxBoardEndPlasterRight][1]),
						0
				else
					put sidelightCutPosBoardLeft, leftRevealPnts[idxBoardEndPlasterLeft][2], 0
				endif
			endif
		else
			if bLeftCornerFunction then
				put leftRevealPnts[idxSillStartPlasterLeft][1],	leftRevealPnts[idxSillStartPlasterLeft][2],	0,
					leftRevealPnts[idxFrameEndRevealLeft][1],	leftRevealPnts[idxFrameEndRevealLeft][2],	0,
					leftRevealPnts[idxBoardEndPlasterLeft][1],	leftRevealPnts[idxBoardEndPlasterLeft][2],	0
			else
				if	(( (iRevealType = REVEAL_EDGE) | (iRevealType = REVEAL_NO) ) &\
					 ( abs(thkPlasterAtSillLeft) < EPS ) &\
					 ( abs(thkPlasterAtBoardLeft) < EPS )) then

					put leftRevealPnts[idxSillStartPlasterLeft][1], leftRevealPnts[idxSillStartPlasterLeft][2], 0
					put leftRevealPnts[idxBoardEndPlasterLeft][1], leftRevealPnts[idxBoardEndPlasterLeft][2], 0
				else
					for i=idxSillStartPlasterLeft to idxSillEndPlasterLeft
						put leftRevealPnts[i][1], leftRevealPnts[i][2], 0
					next i

					if	(abs(leftRevealPnts[idxFrameStartRevealLeft][1] - leftRevealPnts[idxSillEndPlasterLeft][1]) > EPS) | \
						(abs(leftRevealPnts[idxFrameStartRevealLeft][2] - leftRevealPnts[idxSillEndPlasterLeft][2]) > EPS) then
							put leftRevealPnts[idxFrameStartRevealLeft][1],	leftRevealPnts[idxFrameStartRevealLeft][2], 0
					endif
					if	(abs(leftRevealPnts[idxFrameEndRevealLeft][1] - leftRevealPnts[idxBoardStartPlasterLeft][1]) > EPS) | \
						(abs(leftRevealPnts[idxFrameEndRevealLeft][2] - leftRevealPnts[idxBoardStartPlasterLeft][2]) > EPS) then
							put leftRevealPnts[idxFrameEndRevealLeft][1],	leftRevealPnts[idxFrameEndRevealLeft][2], 0
					endif

					for i=idxBoardStartPlasterLeft to idxBoardEndPlasterLeft
						put leftRevealPnts[i][1], leftRevealPnts[i][2], 0
					next i
				endif
			endif
		endif

		if sidelightCutRight then
			if curvedWall then
				put sidelightCutPosBoardRight, WOD - signWallIsLeft * sqr(radBoard^2 - sidelightCutPosBoardRight^2), 3000 * bDrawFill
			else
				if bInclinedWall then
					put sidelightCutPosBoardRight,
						rightRevealPnts[idxBoardEndPlasterRight][2] + (rightRevealPnts[idxBoardEndPlasterRight][1] - sidelightCutPosBoardRight) * \
						(leftRevealPnts[idxBoardEndPlasterLeft][2] - rightRevealPnts[idxBoardEndPlasterRight][2]) / (-leftRevealPnts[idxBoardEndPlasterLeft][1] + rightRevealPnts[idxBoardEndPlasterRight][1]),
						0
				else
					put sidelightCutPosBoardRight, rightRevealPnts[idxBoardEndPlasterRight][2], 0
				endif
			endif
			if abs(sidelightCutPosBoardRight - sidelightCutPosMiddleRight) > EPS then
				put sidelightCutPosBoardRight,	WIDO_FRAME_THICKNESS, 0,
					sidelightCutPosMiddleRight,	WIDO_FRAME_THICKNESS, 0
			endif
			if abs(sidelightCutPosMiddleRight - sidelightCutPosSillRight) > EPS then
				put sidelightCutPosMiddleRight,	0, 0,
					sidelightCutPosSillRight,	0, 0
			endif
			if curvedWall then
				put sidelightCutPosSillRight, WOD - signWallIsLeft * sqr(radSill^2 - sidelightCutPosSillRight^2), 0
			else
				put sidelightCutPosSillRight, rightRevealPnts[idxSillStartPlasterRight][2], 0
			endif
		else
			if bRightCornerFunction then
				put rightRevealPnts[idxBoardEndPlasterRight][1],  rightRevealPnts[idxBoardEndPlasterRight][2],	0,
					rightRevealPnts[idxFrameEndRevealRight][1],   rightRevealPnts[idxFrameEndRevealRight][2],	0,
					rightRevealPnts[idxSillStartPlasterRight][1], rightRevealPnts[idxSillStartPlasterRight][2],	0
			else
				if	(( (iRevealType = REVEAL_EDGE) | (iRevealType = REVEAL_NO) ) &\
					 ( abs(thkPlasterAtSillRight) < EPS ) &\
					 ( abs(thkPlasterAtBoardRight) < EPS )) then

					put rightRevealPnts[idxBoardEndPlasterRight][1], rightRevealPnts[idxBoardEndPlasterRight][2]
					if curvedWall then
						put 3000 * (bDrawFill | not(wallIsLeft))
					else
						put 0
					endif
					put rightRevealPnts[idxSillStartPlasterRight][1], rightRevealPnts[idxSillStartPlasterRight][2], 0
				else
					for i = idxBoardEndPlasterRight to idxBoardStartPlasterRight step -1
						put rightRevealPnts[i][1], rightRevealPnts[i][2]
						if curvedWall & i = idxBoardEndPlasterRight then
							put 3000 * (bDrawFill | not(wallIsLeft))
						else
							put 0
						endif
					next i

					if	(abs(rightRevealPnts[idxFrameEndRevealLeft][1] - rightRevealPnts[idxBoardStartPlasterRight][1]) > EPS) | \
						(abs(rightRevealPnts[idxFrameEndRevealLeft][2] - rightRevealPnts[idxBoardStartPlasterRight][2]) > EPS) then
							put rightRevealPnts[idxFrameEndRevealLeft][1],	rightRevealPnts[idxFrameEndRevealLeft][2], 0
					endif
					if	(abs(rightRevealPnts[idxFrameStartRevealLeft][1] - rightRevealPnts[idxSillEndPlasterRight][1]) > EPS) | \
						(abs(rightRevealPnts[idxFrameStartRevealLeft][2] - rightRevealPnts[idxSillEndPlasterRight][2]) > EPS) then
							put rightRevealPnts[idxFrameStartRevealLeft][1],	rightRevealPnts[idxFrameStartRevealLeft][2], 0
					endif

					for i = idxSillEndPlasterRight to idxSillStartPlasterRight step -1
						put rightRevealPnts[i][1], rightRevealPnts[i][2], 0
					next i
				endif
			endif
		endif

		if curvedWall then
			if sidelightCutLeft then
				put sidelightCutPosSillLeft, leftRevealPnts[idxSillStartPlasterLeft][2], 3000 * (bDrawFill | wallIsLeft)
			else
				put leftRevealPnts[idxSillStartPlasterLeft][1], leftRevealPnts[idxSillStartPlasterLeft][2], 3000 * (bDrawFill | wallIsLeft)
			endif
		endif


		! Ignore point if location of previous point is same, contour bit is always zero
!!!		define style "text01" "arial", 0.3, 5, 0
!!!		set style "text01"
!!!		line_type 1

		_num = nsp/3
		dim temp_coord[][]
		for i = 1 to _num
			temp_x = get(1)
			temp_y = get(1)
			temp_s = get(1)

!!!			text2 temp_x, temp_y, i
!!!			circle2 temp_x, temp_y, 0.01

			temp_coord[i][1] = temp_x
			temp_coord[i][2] = temp_y
			temp_coord[i][3] = temp_s
		next i

		for i = 1 to _num
			if i > 1 then
				if not((abs(temp_coord[i-1][1] - temp_coord[i][1]) < EPS) & (abs(temp_coord[i-1][2] - temp_coord[i][2]) < EPS)) then
					put temp_coord[i][1]
					put temp_coord[i][2]
					put temp_coord[i][3]

!!!					text2 temp_coord[i][1], temp_coord[i][2], i
!!!					circle2 temp_coord[i][1], temp_coord[i][2], 0.01
				endif
			else
				put temp_coord[i][1]
				put temp_coord[i][2]
				put temp_coord[i][3]
			endif
		next i

		if nsp > 8 then
			if bDrawFill then
				fill wallholeFill
				if GLOB_CONTEXT = 5 then
					poly2_b nsp/3, 2 + 4 + 64, wallholePen_fg,wallholePen_bg,
						get(nsp)
				else
					wallhole2 nsp/3, 2 + 64, wallholePen_fg,wallholePen_bg,
						0, 0, 0, get(nsp)
				endif
			else
				fill 0
				if GLOB_CONTEXT = 5 then
					poly2_b nsp/3, 2 + 4 + 64, 0, -1,
						get(nsp)
				else
					wallhole2 nsp/3, 2 + 64, 0, -1,
						0, 0, 0, get(nsp)
				endif
			endif
		else
			for i = 1 to nsp
				temp_param = get(1)
			next i
		endif
	endif


! ==============================================================================
! Cut 2D Wallhole - Polygonal Walls
! ==============================================================================

	if AC_WallType = 2 then

		ch = initaddonscope ("PolyOperations", "", "")

		preparefunction ch, "CreateContainer", "mySourceContainer", ""
		preparefunction ch, "CreateContainer", "myDestinationContainer", ""

		preparefunction ch, "SetSourceContainer",	 	"mySourceContainer", ""
		preparefunction ch, "SetDestinationContainer",	"myDestinationContainer", ""

! Store wallhole polygon -------------------------------------------------------

		if sidelightCutLeft then
			put sidelightCutPosSillLeft, leftRevealPnts[idxSillStartPlasterLeft][2],  3 * (sidelightCutLeft = 1),
				sidelightCutPosSillLeft, 0, 0
			if abs(sidelightCutPosSillLeft - sidelightCutPosMiddleLeft) > EPS then
				put	sidelightCutPosMiddleLeft,	0, 0
			endif
			if abs(sidelightCutPosMiddleLeft - sidelightCutPosBoardLeft) > EPS then
				put sidelightCutPosMiddleLeft,	0, 0
			endif
			put	sidelightCutPosBoardLeft, 0, 2 * (sidelightCutLeft = 1),
				sidelightCutPosBoardLeft, leftRevealPnts[idxBoardEndPlasterLeft][2], -1
		else
			bHasAnySillPoint = 0
			lastSillPointX = leftRevealPnts[idxSillStartRevealLeft][1]
			lastSillPointY = leftRevealPnts[idxSillStartRevealLeft][2]
			for i=idxSillStartRevealLeft to idxSillEndRevealLeft
				if leftRevealPnts[i][2] <= 0 then
					distFromLast = abs((leftRevealPnts[i][1] - lastSillPointX)^2 + (leftRevealPnts[i][2] - lastSillPointY)^2)
					if not(bHasAnySillPoint) | distFromLast > EPS then
						put leftRevealPnts[i][1], leftRevealPnts[i][2], not(gs_stack_left)
						lastSillPointX = leftRevealPnts[i][1]
						lastSillPointY = leftRevealPnts[i][2]
						bHasAnySillPoint = 1
					endif
				endif
			next i
			if idxFrameStartRevealLeft <> idxSillEndRevealLeft | not(bHasAnySillPoint) then
				put leftRevealPnts[idxFrameStartRevealLeft][1],	leftRevealPnts[idxFrameStartRevealLeft][2],	not(gs_stack_left)
			endif
			put leftRevealPnts[idxFrameEndRevealLeft][1],	leftRevealPnts[idxFrameEndRevealLeft][2]
			bStatusSet = 0
			bHasAnyBoardPoint = 0
			lastBoardPointX = leftRevealPnts[idxBoardStartRevealLeft + (idxFrameEndRevealLeft = idxBoardStartRevealLeft)][1]
			lastBoardPointY = leftRevealPnts[idxBoardStartRevealLeft + (idxFrameEndRevealLeft = idxBoardStartRevealLeft)][2]
			for i=idxBoardStartRevealLeft + (idxFrameEndRevealLeft = idxBoardStartRevealLeft) to idxBoardEndRevealLeft
				if leftRevealPnts[i][2] >= WIDO_FRAME_THICKNESS then
					distFromLast = abs((leftRevealPnts[i][1] - lastBoardPointX)^2 + (leftRevealPnts[i][2] - lastBoardPointY)^2)
					if not(bHasAnyBoardPoint) | distFromLast > EPS then
						if not(bStatusSet) then
							put not(gs_stack_left)
							bStatusSet = 1
						endif
						put leftRevealPnts[i][1], leftRevealPnts[i][2]
						if i = idxBoardEndRevealLeft then
							put -1
						else
							put not(gs_stack_left)
						endif
						lastBoardPointX = leftRevealPnts[i][1]
						lastBoardPointY = leftRevealPnts[i][2]
						bHasAnyBoardPoint = 1
					endif
				endif
			next i
			if not(bStatusSet) then
				put -1
				bStatusSet = 1
			endif
		endif

		if sidelightCutRight then
			put sidelightCutPosBoardRight, rightRevealPnts[idxBoardEndPlasterRight][2], 2 * (sidelightCutRight = 1),
				sidelightCutPosBoardRight,	0, 0
			if abs(sidelightCutPosBoardRight - sidelightCutPosMiddleRight) > EPS then
				put	sidelightCutPosMiddleRight,	0, 0
			endif
			if abs(sidelightCutPosMiddleRight - sidelightCutPosSillRight) > EPS then
				put sidelightCutPosMiddleRight,	0, 0
			endif
			put	sidelightCutPosSillRight, 0, 3 * (sidelightCutRight = 1),
				sidelightCutPosSillRight, rightRevealPnts[idxSillStartPlasterRight][2], -1
		else
			bHasAnyBoardPoint = 0
			for i = idxBoardEndRevealRight to idxBoardStartRevealRight step -1
				if rightRevealPnts[i][2] >= WIDO_FRAME_THICKNESS then
					distFromLast = abs((rightRevealPnts[i][1] - lastBoardPointX)^2 + (rightRevealPnts[i][2] - lastBoardPointY)^2)
					if not(bHasAnyBoardPoint) | distFromLast > EPS then
						put rightRevealPnts[i][1], rightRevealPnts[i][2], not(gs_stack_right)
						lastBoardPointX = rightRevealPnts[i][1]
						lastBoardPointY = rightRevealPnts[i][2]
						bHasAnyBoardPoint = 1
					endif
				endif
			next i
			if idxFrameEndRevealRight <> idxBoardStartRevealRight | not(bHasAnyBoardPoint) then
				put rightRevealPnts[idxFrameEndRevealRight][1],	 rightRevealPnts[idxFrameEndRevealRight][2],	not(gs_stack_right)
			endif
			put rightRevealPnts[idxFrameStartRevealRight][1],rightRevealPnts[idxFrameStartRevealRight][2],	not(gs_stack_right)
			bHasAnySillPoint = 0
			lastSillPointX = rightRevealPnts[idxFrameStartRevealRight][1]
			lastSillPointY = rightRevealPnts[idxFrameStartRevealRight][2]
			for i = idxSillEndRevealRight - (idxFrameStartRevealRight = idxSillEndRevealRight) to idxSillStartRevealRight step -1
				if rightRevealPnts[i][2] <= 0 then
					distFromLast = abs((rightRevealPnts[i][1] - lastSillPointX)^2 + (rightRevealPnts[i][2] - lastSillPointY)^2)
					if distFromLast > EPS then
						put rightRevealPnts[i][1], rightRevealPnts[i][2]
						if i = idxSillStartRevealRight then
							put -1
						else
							put not(gs_stack_right)
						endif
						lastSillPointX = rightRevealPnts[i][1]
						lastSillPointY = rightRevealPnts[i][2]
						bHasAnySillPoint = 1
					endif
				endif
			next i
		endif

		nVertices1 = nsp/3
		dim vertArr1[][3]

		defaultInhEdgeInfo = 0
		dim inhEdgeInfos1[]

		for i=1 to nVertices1
			vertarr1[i][1]	 = get(1)
			vertarr1[i][2]	 = get(1)
			vertarr1[i][3]	 = 0
			inhEdgeInfos1[i] = get(1)	! Mark wallhole edges
		next i

		nContours1 = 1
		dim contArr1[]
		contArr1[1] = nVertices1 + 1

		preparefunction ch, "Store", "wallHolePoly", nVertices1, nContours1, vertArr1, contArr1, defaultInhEdgeInfo, inhEdgeInfos1

		prevSourceContainer	= ""
		lastDestContainer	= "mySourceContainer"
		preparefunction ch, "SetDestinationContainer", lastDestContainer, ""


! Offset sill side edge --------------------------------------------------------

		if prevSourceContainer <> "" then
			preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
		endif
		preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
		prevSourceContainer	= lastDestContainer
		lastDestContainer	= "myDestContainer1"
		preparefunction ch, "CreateContainer",			lastDestContainer, ""
		preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

		preparefunction ch, "OffsetParams", "", 1, 2.00

		dim srcPolyIDArr[]
		numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

		dim tempResPolyIDArr[]
		for i=1 to numPoly
			tempNumPoly = callfunction (ch, "OffsetEdge", srcPolyIDArr[i], tempResPolyIDArr)
		next i

!!!dim resPolyIDArr[]
!!!numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)
!!!
!!!for i = 1 to numPoly
!!!	polygonID = resPolyIDArr[i]
!!!	gosub 1000	! Get GDL Polygon
!!!
!!!	ccc=0
!!!	for j=1 to nsp/3
!!!		xx=get(1)
!!!		yy=get(1)
!!!		ss=get(1)
!!!		ccc=ccc+0.003
!!!		circle2 xx,yy,ccc
!!!		text2 xx,yy,j
!!!	next j
!!!next i
!!!end

! Offset board side edge -------------------------------------------------------

		dim dstPolyIDArr[]
		numPoly = callfunction (ch, "GetDestinationPolygons", "", dstPolyIDArr)

		dim edgeIds[]
		edgeIds[numPoly] = 0
		for i=1 to numPoly

			dim inhEdgeInfos[]
			numEdges = callfunction(ch, "GetInhEdgeInfos", dstPolyIDArr[i], inhEdgeInfos)

			for j=1 to numEdges
				if inhEdgeInfos[j] = -1 then edgeIds[i] = j
			next j
		next i

		if prevSourceContainer <> "" then
			preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
		endif
		preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
		prevSourceContainer	= lastDestContainer
		lastDestContainer	= "myDestContainer2"
		preparefunction ch, "CreateContainer",			lastDestContainer, ""
		preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

		dim srcPolyIDArr[]
		numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

		dim tempResPolyIDArr[]
		for i=1 to numPoly

			preparefunction ch, "OffsetParams", "", edgeIds[i], 2.00

			tempNumPoly = callfunction (ch, "OffsetEdge", srcPolyIDArr[i], tempResPolyIDArr)
		next i

!!!dim resPolyIDArr[]
!!!numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)
!!!
!!!for i = 1 to numPoly
!!!	polygonID = resPolyIDArr[i]
!!!	gosub 1000	! Get GDL Polygon
!!!
!!!	ccc=0
!!!	for j=1 to nsp/3
!!!		xx=get(1)
!!!		yy=get(1)
!!!		ss=get(1)
!!!		ccc=ccc+0.003
!!!		circle2 xx,yy,ccc
!!!		text2 xx,yy,j
!!!	next j
!!!next i
!!!end

! Store wall contour polygon in wallhole coordinate system ---------------------

		if prevSourceContainer <> "" then
			preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
		endif
		preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
		prevSourceContainer	= lastDestContainer
		lastDestContainer	= "myDestContainer3"
		preparefunction ch, "CreateContainer",			lastDestContainer, ""
		preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

		nVertices2 = vardim1(AC_WallContourPolygon)
		dim vertArr2[][3]

		dim srcPolyIDArr[]
		numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

		defaultInhEdgeInfo = 0
		dim inhEdgeInfos2[]

		for i=1 to nVertices2
			vertarr2[i][1] = AC_WallContourPolygon[i][1]
			if WIDO_REVEAL_SIDE then
				vertarr2[i][2] = AC_WallContourPolygon[i][2] + WIDO_FRAME_THICKNESS
				vertarr2[i][3] = AC_WallContourPolygon[i][3]
			else
				vertarr2[i][2] = -AC_WallContourPolygon[i][2]
				vertarr2[i][3] = -AC_WallContourPolygon[i][3]
			endif

			inhEdgeInfos2[i] = 2 + (vertarr2[i][2] < EPS)
		next i

		nContours2 = 1
		dim contArr2[]
		contArr2[1] = nVertices2 + 1

		preparefunction ch, "Store", "wallContourPoly", nVertices2, nContours2, vertArr2, contArr2, defaultInhEdgeInfo, inhEdgeInfos2

! Intersect polygons -----------------------------------------------------------

		dim tempResPolyIDArr[]
		for i = 1 to numPoly
			tempNumPoly = callfunction (ch, "wallContourPoly / " + srcPolyIDArr[i], "", tempResPolyIDArr)
		next i

! Draw polygons ----------------------------------------------------------------

		dim resPolyIDArr[]
		numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)

		if not(gs_transom_display) then 	! Not drawn when Display as Transom is ON
			for i = 1 to numPoly
				polygonID = resPolyIDArr[i]
				gosub 1000	! Get GDL Polygon

				if _bValidPoly then
					if bDrawSillFill & bDrawBoardFill & not(bVisibleWallInsetIn2D) then
						fill wallholeFill
						if GLOB_CONTEXT = 5 then
							poly2_b nsp/3, 2+4+64, wallholePen_fg,wallholePen_bg,
								get(nsp)
						else
							wallhole2 nsp/3, 2 + 64, wallholePen_fg,wallholePen_bg,
								0, 0, 0, get(nsp)
						endif
					else
						fill 0
						if GLOB_CONTEXT = 5 then
							poly2_b nsp/3, 2+4+64, 0, -1,
								get(nsp)
						else
							wallhole2 nsp/3, 2 + 64, 0, -1,
								0, 0, 0, get(nsp)
						endif
					endif
				endif
			next i
		endif

! Draw wall contour lines ------------------------------------------------------

		dim lineAttributes[3][4]
		lineAttributes[1][1] = WALL_SECT_PEN
		lineAttributes[1][2] = WALL_LINETYPE
		lineAttributes[1][3] = LINE_PROPERTY_CONTOUR
		lineAttributes[1][4] = bitset(0, LINE_ATTRIBUTES_WALLLINE)

		lineAttributes[2][1] = gs_wcont_line_pen * (wcontLineIn > 0) * not(bVisibleWallInsetIn2D)	! Inside, Both Sides
		lineAttributes[2][2] = wcontLineIn
		lineAttributes[2][3] = LINE_PROPERTY_GENERIC
		lineAttributes[2][4] = bitset(0, LINE_ATTRIBUTES_GDLLINE)

		lineAttributes[3][1] = gs_wcont_line_pen * (wcontLineOut > 0)	! Outside, Both Sides
		lineAttributes[3][2] = wcontLineOut
		lineAttributes[3][3] = LINE_PROPERTY_GENERIC
		lineAttributes[3][4] = bitset(0, LINE_ATTRIBUTES_GDLLINE)

		bPutHotsopts	= (AC_WallType = 2)

		for i = 1 to numPoly
			polygonID = resPolyIDArr[i]
			gosub 1001	! Draw one polygon contour line
		next i

! Close channel ----------------------------------------------------------------

		closeaddonscope ch
	endif	! if AC_WallType = 2 then

return


! =============================================================================
! Draw Sill side background fill and parapet contours
! =============================================================================

"DrawWallholeFillOutside":

	if AC_WallType = 2 then
		bUsePolygonOperations	= 1
	else
		bUsePolygonOperations	= (offsetSill > EPS & offsetSill > WIDO_SILL)

! Draw Sill Side Fill or Wallhole ----------------------------------------------

		if curvedWall then put 0,WOD,900

		if sidelightCutLeft then
			if curvedWall then
				startX = sidelightCutPosSillLeft
				startY = WOD - signWallIsLeft * sqr(radSill^2 - sidelightCutPosSillLeft^2)
				put sidelightCutPosSillLeft, WOD - signWallIsLeft * sqr(radSill^2 - sidelightCutPosSillLeft^2), 0
			else
				put sidelightCutPosSillLeft, leftRevealPnts[idxSillStartPlasterLeft][2], 0
			endif
			put sidelightCutPosSillLeft, 0, 0
		else
			if bLeftCornerFunction then
				put leftRevealPnts[idxSillStartPlasterLeft][1],	leftRevealPnts[idxSillStartPlasterLeft][2] + (bNeedToOffsetSkins & not(bUsePolygonOperations)) * offsetSill, 0,
					leftRevealPnts[idxSillEndPlasterLeft][1],	leftRevealPnts[idxSillEndPlasterLeft][2], 0
			else
				if bNeedToOffsetSkins & not(bUsePolygonOperations) then
					idx = idxSillStartPlasterLeft
					if curvedWall then
						if bParalellInCurvedWalls then
							R = radSill - offsetSill * signWallIsLeft
							startX = leftRevealPnts[idx][1]
							startY = -signWallIsLeft * sqr(R^2 - startX^2) + WOD
						else
							alpha = abs(asn(leftRevealPnts[idx][1] / radSill))
							startX = -(radSill - signWallIsLeft * offsetSill) * sin(alpha)
							startY = -signWallIsLeft * (radSill - signWallIsLeft * offsetSill) * cos(alpha) + WOD
						endif
					else
						startX = leftRevealPnts[idx][1]
						startY = leftRevealPnts[idx][2] + offsetSill
					endif

					put startX, startY, 0
					for i=idxSillStartPlasterLeft + 1 to idxSillEndPlasterLeft
						put leftRevealPnts[i][1], leftRevealPnts[i][2], 0
					next i
				else
					startX = leftRevealPnts[idxSillStartPlasterLeft][1]
					startY = leftRevealPnts[idxSillStartPlasterLeft][2]

					for i=idxSillStartPlasterLeft to idxSillEndPlasterLeft
						put leftRevealPnts[i][1], leftRevealPnts[i][2], 0
					next i
				endif
			endif
		endif

		if sidelightCutRight then
			put	sidelightCutPosSillRight,	0, 0
			if curvedWall then
				put sidelightCutPosSillRight, WOD - signWallIsLeft * sqr(radSill^2 - sidelightCutPosSillRight^2), 0
			else
				put sidelightCutPosSillRight, rightRevealPnts[idxSillStartPlasterRight][2], 0
			endif
		else
			if bRightCornerFunction then
				put rightRevealPnts[idxSillEndPlasterRight][1],		rightRevealPnts[idxSillEndPlasterRight][2], 0,
					rightRevealPnts[idxSillStartPlasterRight][1],	rightRevealPnts[idxSillStartPlasterRight][2] + (bNeedToOffsetSkins & not(bUsePolygonOperations)) * offsetSill, 0
			else
				if bNeedToOffsetSkins & not(bUsePolygonOperations) then
					for i = idxSillEndPlasterRight to idxSillStartPlasterRight + 1 step -1
						put rightRevealPnts[i][1], rightRevealPnts[i][2]
						if curvedWall & gs_IsCurved & i = idxSillEndPlasterRight then
							put 3000
						else
							put 0
						endif
					next i

					idx = idxSillStartPlasterRight
					if curvedWall then
						if bParalellInCurvedWalls then
							R = radSill - offsetSill * signWallIsLeft
							put rightRevealPnts[idx][1], -signWallIsLeft * sqr(R^2 - rightRevealPnts[idx][1]^2) + WOD, 0
						else
							alpha = abs(asn(rightRevealPnts[idx][1] / radSill))
							put  (radSill - signWallIsLeft * offsetSill) * sin(alpha),
								-signWallIsLeft * (radSill - signWallIsLeft * offsetSill) * cos(alpha) + WOD, 0
						endif
					else
						put rightRevealPnts[idx][1], rightRevealPnts[idx][2] + offsetSill, 0
					endif
				else
					for i = idxSillEndPlasterRight to idxSillStartPlasterRight step -1
						put rightRevealPnts[i][1], rightRevealPnts[i][2]
						if curvedWall & gs_IsCurved & i = idxSillEndPlasterRight then
							put 3000
						else
							put 0
						endif
					next i
				endif
			endif
		endif

		if curvedWall then
			put startX, startY, 3000
		endif
	endif

	if bUsePolygonOperations then

		ch = initaddonscope ("PolyOperations", "", "")

		preparefunction ch, "CreateContainer", "mySourceContainer", ""
		preparefunction ch, "CreateContainer", "myDestinationContainer", ""

		preparefunction ch, "SetSourceContainer",	 	"mySourceContainer", ""
		preparefunction ch, "SetDestinationContainer",	"myDestinationContainer", ""

! Store wallhole polygon -------------------------------------------------------

		dim vertArr1[][3]
		dim inhEdgeInfos1[]
		defaultInhEdgeInfo = 0

		if AC_WallType = 2 then

			if sidelightCutLeft then
				put sidelightCutPosSillLeft, leftRevealPnts[idxSillStartPlasterLeft][2],  2 * (sidelightCutLeft = 1),
					sidelightCutPosSillLeft, 0,	-1
			else
				bHasAnySillPoint = 0
				for i=idxSillStartRevealLeft to idxSillEndRevealLeft
					if leftRevealPnts[i][2] <= 0 then
						distFromLast = abs((leftRevealPnts[i][1] - lastSillPointX)^2 + (leftRevealPnts[i][2] - lastSillPointY)^2)
						if not(bHasAnySillPoint) | distFromLast > EPS then
							if bHasAnySillPoint then
								put not(gs_stack_left)	! status of the previous point
							endif
							put leftRevealPnts[i][1], leftRevealPnts[i][2]
							lastSillPointX = leftRevealPnts[i][1]
							lastSillPointY = leftRevealPnts[i][2]
							bHasAnySillPoint = 1
						endif
					endif
				next i
				if bHasAnySillPoint then
					put -1	! last status
				endif
			endif

			if sidelightCutRight then
				put	sidelightCutPosSillRight, 0, 2 * (sidelightCutRight = 1),
					sidelightCutPosSillRight, rightRevealPnts[idxSillStartPlasterRight][2], -1
			else
				bHasAnySillPoint = 0
				for i = idxSillEndRevealRight to idxSillStartRevealRight step -1
					if rightRevealPnts[i][2] <= 0 then
						distFromLast = abs((rightRevealPnts[i][1] - lastSillPointX)^2 + (rightRevealPnts[i][2] - lastSillPointY)^2)
						if not(bHasAnySillPoint) | distFromLast > EPS then
							if bHasAnySillPoint then
								put not(gs_stack_right)	! status of the previous point
							endif
							put rightRevealPnts[i][1], rightRevealPnts[i][2]
							lastSillPointX = rightRevealPnts[i][1]
							lastSillPointY = rightRevealPnts[i][2]
							bHasAnySillPoint = 1
						endif
					endif
				next i
				if bHasAnySillPoint then
					put -1	! last status
				endif
			endif

			nVertices1 = nsp/3
			for i=1 to nVertices1
				vertarr1[i][1]	 = get(1)
				vertarr1[i][2]	 = get(1)
				vertarr1[i][3]	 = 0
				inhEdgeInfos1[i] = get(1)	! Mark wallhole edges
			next i
		else

			idx = 1
			inhEdgeInfosLast = 0

			for i=1 to nsp/3
				px = get(1)
				py = get(1)
				ps = round_int (get(1))

				if idx > 1 then
					bSkipThisVertex = (abs(px - vertarr1[1][1]) < EPS & abs(py - vertarr1[1][2]) < EPS)	! Skip this vertex if this is a closing one
				else
					bSkipThisVertex = 0
				endif

				if ps < 900 | ps >= 1000 then	! Skip state '900'
					if not(bSkipThisVertex) then
						vertarr1[idx][1] = px
						vertarr1[idx][2] = py
					endif
					if ps >= 3000 & ps < 4000 then
						if idx > 1 then
							vx = vertarr1[idx-1][1] - 0
							vy = vertarr1[idx-1][2] - WOD
							gosub 103	! Direction Angle
							savedAngle = angle

							vx = px - 0
							vy = py - WOD
							gosub 103	! Direction Angle

							vertarr1[idx-1][3] = angle - savedAngle
							if not(bSkipThisVertex) then
								inhEdgeInfos1[idx] = bittest(ps, 0)
							endif
						endif
					else
						if not(bSkipThisVertex) then
							vertarr1[idx][3] = 0
							inhEdgeInfos1[idx] = bittest(ps, 0)
						endif
					endif
					if not(bSkipThisVertex) then
						idx = idx + 1
					endif
				endif
			next i
			nVertices1 = vardim1(vertarr1)
		endif

		nContours1 = 1
		dim contArr1[]
		contArr1[1] = nVertices1 + 1

		if nVertices1 >= 2 then
			preparefunction ch, "Store", "wallHolePoly", nVertices1, nContours1, vertArr1, contArr1, defaultInhEdgeInfo, inhEdgeInfos1
		endif

		prevSourceContainer	= ""
		lastDestContainer	= "mySourceContainer"
		preparefunction ch, "SetDestinationContainer", lastDestContainer, ""

!!!ccc = 0
!!!for i=1 to vardim1(vertarr1)
!!!	ccc = ccc + 0.002
!!!	circle2 vertarr1[i][1], vertarr1[i][2], ccc
!!!next i

! Offset sill side edge --------------------------------------------------------

		if AC_WallType = 2 then
			if prevSourceContainer <> "" then
				preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
			endif
			preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
			prevSourceContainer	= lastDestContainer
			lastDestContainer	= "myDestContainer1"
			preparefunction ch, "CreateContainer",			lastDestContainer, ""
			preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

			preparefunction ch, "OffsetParams", "", 1, 0.50

			dim srcPolyIDArr[]
			numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

			dim tempResPolyIDArr[]
			for i=1 to numPoly
				tempNumPoly = callfunction (ch, "OffsetEdge", srcPolyIDArr[i], tempResPolyIDArr)
			next i

!!!dim resPolyIDArr[]
!!!numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)
!!!
!!!for i = 1 to numPoly
!!!	polygonID = resPolyIDArr[i]
!!!	gosub 1000	! Get GDL Polygon
!!!
!!!	ccc=0
!!!	for j=1 to nsp/3
!!!		xx=get(1)
!!!		yy=get(1)
!!!		ss=get(1)
!!!		ccc=ccc+0.003
!!!		circle2 xx,yy,ccc
!!!		text2 xx,yy,j
!!!	next j
!!!next i
!!!end
		endif

! Store wall contour polygon in wallhole coordinate system ---------------------

		if AC_WallType = 2 then
			if prevSourceContainer <> "" then
				preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
			endif
			preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
			prevSourceContainer	= lastDestContainer
			lastDestContainer	= "myDestContainer3"
			preparefunction ch, "CreateContainer",			lastDestContainer, ""
			preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

			nVertices2 = vardim1(AC_WallContourPolygon)
			dim vertArr2[][3]

			dim srcPolyIDArr[]
			numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

			defaultInhEdgeInfo = 0
			dim inhEdgeInfos2[]
!!!ccc=0
			for i=1 to nVertices2
				vertarr2[i][1] = AC_WallContourPolygon[i][1]
				if WIDO_REVEAL_SIDE then
					vertarr2[i][2] = AC_WallContourPolygon[i][2] + WIDO_FRAME_THICKNESS
					vertarr2[i][3] = AC_WallContourPolygon[i][3]
				else
					vertarr2[i][2] = -AC_WallContourPolygon[i][2]
					vertarr2[i][3] = -AC_WallContourPolygon[i][3]
				endif

				inhEdgeInfos2[i] = 2
!!!ccc=ccc+0.003
!!!circle2 vertarr2[i][1], vertarr2[i][2], ccc
!!!text2 vertarr2[i][1], vertarr2[i][2], i
			next i

			nContours2 = 1
			dim contArr2[]
			contArr2[1] = nVertices2 + 1

			preparefunction ch, "Store", "wallContourPoly", nVertices2, nContours2, vertArr2, contArr2, defaultInhEdgeInfo, inhEdgeInfos2

! Intersect polygons -----------------------------------------------------------

			dim tempResPolyIDArr[]
			for i = 1 to numPoly
				tempNumPoly = callfunction (ch, "wallContourPoly / " + srcPolyIDArr[i], "", tempResPolyIDArr)
			next i
		endif

! Regularize polygon(s) --------------------------------------------------------

		if curvedWall then

			if prevSourceContainer <> "" then
				preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
			endif
			preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
			prevSourceContainer	= lastDestContainer
			lastDestContainer	= "myDestContainer1"
			preparefunction ch, "CreateContainer",			lastDestContainer, ""
			preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

			dim srcPolyIDArr[]
			numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

			dim tempResPolyIDArr[]
			for i=1 to numPoly
				tempNumPoly = callfunction (ch, "Regularize", srcPolyIDArr[i], tempResPolyIDArr)
			next i


			if prevSourceContainer <> "" then
				preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
			endif
			preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
			prevSourceContainer	= lastDestContainer
			lastDestContainer	= "myDestContainer2"
			preparefunction ch, "CreateContainer",			lastDestContainer, ""
			preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

			preparefunction ch, "HalfPlaneParams", "", 0, 1, 0

			dim srcPolyIDArr[]
			numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

			dim tempResPolyIDArr[]
			for i = 1 to numPoly
				tempNumPoly = callfunction (ch, "PolyCut", srcPolyIDArr[i], tempResPolyIDArr)
			next i
		endif

! Cut hidden wall skins polygon ------------------------------------------------

		if AC_WallType <> 2 then

			if prevSourceContainer <> "" then
				preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
			endif
			preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
			prevSourceContainer	= lastDestContainer
			lastDestContainer	= "myDestContainer3"
			preparefunction ch, "CreateContainer",			lastDestContainer, ""
			preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

			dim srcPolyIDArr[]
			numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

! Store hidden wall skins polygon ----------------------------------------------

			if curvedWall then
				pxL1 = -radSill - signWallIsLeft * 0.1
				pyL1 = WOD

				pxL2 = -radSill + signWallIsLeft * offsetSill
				pyL2 = WOD

				pxR1 = radSill + signWallIsLeft * 0.1
				pyR1 = WOD

				pxR2 = radSill - signWallIsLeft * offsetSill
				pyR2 = WOD
			else
				pxL1 = -leftWidth - 1.0
				pyL1 = -WIDO_SILL - 0.1

				pxL2 = pxL1
				pyL2 = -WIDO_SILL + offsetSill

				pxR1 = rightWidth + 1.0
				pyR1 = -WIDO_SILL - 0.1

				pxR2 = pxR1
				pyR2 = -WIDO_SILL + offsetSill
			endif

!!!text2 0,0.2, WALL_THICKNESS
!!!circle2 0,0, 0.01
!!!fill 1
!!!pen 1
!!!poly2_b 4, 1+2+4+64, 1,0,
!!!	pxL1, pyL1, 1,
!!!	pxL2, pyL2, 1,
!!!	pxR2, pyR2, 1,
!!!	pxR1, pyR1, 1
!!!fill wallholeFill
!!!end
			nVertices2 = 4
			dim vertArr2[][3]
			vertarr2[1][1] = pxL1
			vertarr2[1][2] = pyL1
			vertarr2[1][3] = 0

			vertarr2[2][1] = pxL2
			vertarr2[2][2] = pyL2
			vertarr2[2][3] = curvedWall * signWallIsLeft * (180)

			vertarr2[3][1] = pxR2
			vertarr2[3][2] = pyR2
			vertarr2[3][3] = 0

			vertarr2[4][1] = pxR1
			vertarr2[4][2] = pyR1
			vertarr2[4][3] = curvedWall * signWallIsLeft * (-180)

			nContours2 = 1
			dim contArr2[]
			contArr2[1] = nVertices2 + 1

			preparefunction ch, "Store", "wallSkinPoly", nVertices2, nContours2, vertArr2, contArr2

! Substract polygons -----------------------------------------------------------

			dim tempResPolyIDArr[]
			for i = 1 to numPoly
				tempNumPoly = callfunction(ch, srcPolyIDArr[i] + " - wallSkinPoly", "", tempResPolyIDArr)
			next i
		endif

! Draw resulting polygons ------------------------------------------------------

		dim resPolyIDArr[]
		numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)

		for i = 1 to numPoly
			polygonID = resPolyIDArr[i]
			gosub 1000	! Get GDL Polygon

			if _bValidPoly then
				if bDrawSillFill then
					fill wallholeFill
					if GLOB_CONTEXT = 5 then
						poly2_b nsp/3, 2+4+64, wallholePen_fg,wallholePen_bg,
							get(nsp)
					else
						wallhole2 nsp/3, 2 + 64, wallholePen_fg,wallholePen_bg,
							0,0,0, get(nsp)
					endif
				else
					fill 0
					if GLOB_CONTEXT = 5 then
						poly2_b nsp/3, 2+4+64, 0,-1,
							get(nsp)
					else
						wallhole2 nsp/3, 2 + 64, 0,-1,
							0,0,0, get(nsp)
					endif
				endif
			endif
		next i

! Draw wall contour lines ------------------------------------------------------

		if AC_WallType = 2 then
			dim lineAttributes[2][4]
			lineAttributes[1][1] = WALL_SECT_PEN
			lineAttributes[1][2] = WALL_LINETYPE
			lineAttributes[1][3] = LINE_PROPERTY_CONTOUR
			lineAttributes[1][4] = bitset(0, LINE_ATTRIBUTES_WALLLINE)

			lineAttributes[2][1] = gs_wcont_line_pen * (wcontLineOut > 0)	! Outside, Both Sides
			lineAttributes[2][2] = wcontLineOut
			lineAttributes[2][3] = LINE_PROPERTY_GENERIC
			lineAttributes[2][4] = bitset(0, LINE_ATTRIBUTES_GDLLINE)

			bPutHotsopts	= (AC_WallType = 2)

			for i = 1 to numPoly
				polygonID = resPolyIDArr[i]
				gosub 1001	! Draw one polygon contour line
			next i
		endif

! Close channel ----------------------------------------------------------------

		closeaddonscope ch
	endif	! if bUsePolygonOperations then

! Draw polygons without polygon operations -------------------------------------

	if not(bUsePolygonOperations) then
		if bDrawSillFill then
			fill wallholeFill
			if GLOB_CONTEXT = 5 then
				poly2_b nsp/3, 2+4+64, wallholePen_fg,wallholePen_bg,
					get(nsp)
			else
				wallhole2 nsp/3, 2 + 64, wallholePen_fg,wallholePen_bg,
					0,0,0, get(nsp)
			endif
		else
			fill 0
			if GLOB_CONTEXT = 5 then
				poly2_b nsp/3, 2+4+64, 0,-1,
					get(nsp)
			else
				wallhole2 nsp/3, 2 + 64, 0,-1,
					0,0,0, get(nsp)
			endif
		endif
	endif
return


! =============================================================================
! Draw Board side background fill and parapet contours
! =============================================================================

"DrawWallholeFillInside":

	if not(bUseOneBackgroundFill) | bVisibleWallInsetIn2D | bNeedToOffsetSkins then

! Draw Board Side Fill or Wallhole =============================================

		bAutoParapetInset = (gs_parapet_autodim)

		if AC_WallType = 2 then
			bUsePolygonOperations	= 1
			bCutWallInsetWithPolyOp	= bVisibleWallInsetIn2D
		else
			bUsePolygonOperations	= (offsetBoard > EPS)

			if curvedWall then put 0,WOD,900

			if curvedWall then
				insetY = WOD - signWallIsLeft * radBoard - parapetWallInsetDepth
			endif

			if sidelightCutLeft then
				put sidelightCutPosMiddleLeft,	0, 0
				if abs(sidelightCutPosMiddleLeft - sidelightCutPosBoardLeft) > EPS then
					put sidelightCutPosMiddleLeft,	WIDO_FRAME_THICKNESS, 0,
						sidelightCutPosBoardLeft,	WIDO_FRAME_THICKNESS, 0
				endif
				if curvedWall then
					put sidelightCutPosBoardLeft, WOD - signWallIsLeft * sqr(radBoard^2 - sidelightCutPosBoardLeft^2), 0
				else
					if bInclinedWall then
						put sidelightCutPosBoardLeft,
							leftRevealPnts[idxBoardEndPlasterLeft][2] + (leftRevealPnts[idxBoardEndPlasterLeft][1] - sidelightCutPosBoardLeft) * \
							(leftRevealPnts[idxBoardEndPlasterLeft][2] - rightRevealPnts[idxBoardEndPlasterRight][2]) / (-leftRevealPnts[idxBoardEndPlasterLeft][1] + rightRevealPnts[idxBoardEndPlasterRight][1]),
							0
					else
						put sidelightCutPosBoardLeft, leftRevealPnts[idxBoardEndPlasterLeft][2], 0
					endif
				endif
			else
				if bLeftCornerFunction then
					startPointIdx = idxFrameStartRevealLeft
					put leftRevealPnts[idxFrameStartRevealLeft][1], leftRevealPnts[idxFrameStartRevealLeft][2], 0
					if bVisibleWallInsetIn2D then
						put leftRevealPnts[idxBoardEndPlasterLeft][1] - parapetWallInsetDepth * lx, leftRevealPnts[idxBoardEndPlasterLeft][2] - parapetWallInsetDepth,  1
						if gs_reveal_hotspots then
							hotspot2 leftRevealPnts[idxBoardEndPlasterLeft][1] - parapetWallInsetDepth * lx,
									 leftRevealPnts[idxBoardEndPlasterLeft][2] - parapetWallInsetDepth,
									 11040
						endif
					else
						put leftRevealPnts[idxBoardEndPlasterLeft][1], leftRevealPnts[idxBoardEndPlasterLeft][2],  1
					endif
				else
					if bAutoParapetInset & bVisibleWallInsetIn2D then
						startPointIdx = idxFrameStartRevealLeft
						put leftRevealPnts[idxFrameStartRevealLeft][1],	leftRevealPnts[idxFrameStartRevealLeft][2], 0
						put leftRevealPnts[idxFrameEndRevealLeft][1],	leftRevealPnts[idxFrameEndRevealLeft][2], 0
						for i = idxBoardStartPlasterLeft to idxBoardEndPlasterLeft - 1
							put leftRevealPnts[i][1], leftRevealPnts[i][2], 0
						next i

						idx = idxBoardEndPlasterLeft
						if not(gs_stack_left) & (iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC) then
							if curvedWall then
								pxInsetLeft	= leftRevealPnts[idx][1] + abs(leftRevealPnts[idx][2] - insetY) * tan(gs_reveal_left_angle)
								pyInsetLeft	= insetY
							else
								pxInsetLeft	= leftRevealPnts[idx][1] + parapetWallInsetDepth * sin(gs_reveal_left_angle)
								pyInsetLeft	= leftRevealPnts[idx][2] - parapetWallInsetDepth
							endif
						else
							if curvedWall then
								if bParalellInCurvedWalls then
									pxInsetLeft	= leftRevealPnts[idx][1]
									pyInsetLeft	= insetY
								else
									alpha = abs(asn(leftRevealPnts[idx][1] / radBoard))
									pxInsetLeft	= -abs(tan(alpha) * (WOD - insetY))
									pyInsetLeft	= insetY
								endif
							else
								pxInsetLeft	= leftRevealPnts[idx][1]
								pyInsetLeft	= leftRevealPnts[idx][2] - parapetWallInsetDepth
							endif
						endif
						if curvedWall & not(wallIsLeft) & pyInsetLeft > leftRevealPnts[idx][2] then
							pxInsetLeft	= leftRevealPnts[idx][1]
							pyInsetLeft	= leftRevealPnts[idx][2]
						endif

						if not(curvedWall) | wallIsLeft then
							if gs_reveal_hotspots then
								hotspot2 pxInsetLeft, pyInsetLeft, 11040
							endif
						endif

						put pxInsetLeft, pyInsetLeft, 1

						if curvedWall then
							if not(wallIsLeft) & insetY > pyInsetLeft + EPS then
								put -sqr(radBoard^2 - (insetY - WOD)^2), insetY, 3001
								if gs_reveal_hotspots then
									hotspot2 -sqr(radBoard^2 - (insetY - WOD)^2), insetY, 11040
								endif
							endif
						endif
					else
						if WIDO_FRAME_THICKNESS > EPS then
						startPointIdx = idxFrameStartRevealLeft
							put leftRevealPnts[idxFrameStartRevealLeft][1], leftRevealPnts[idxFrameStartRevealLeft][2], 0
							put leftRevealPnts[idxFrameEndRevealLeft][1],	leftRevealPnts[idxFrameEndRevealLeft][2], 0
						else
							startPointIdx = idxBoardStartPlasterLeft
						endif
						for i = idxBoardStartPlasterLeft to idxBoardEndPlasterLeft
							put leftRevealPnts[i][1], leftRevealPnts[i][2], (i = idxBoardEndPlasterLeft & bUseOneBackgroundFill)
						next i
					endif
				endif
			endif

! Draw not full width wall inset recess -------------------------------------- [

			bCutWallInsetWithPolyOp = 0

			if not(bAutoParapetInset) & bVisibleWallInsetIn2D then
				cx = 0
				cy = WALL_THICKNESS - WIDO_SILL

				if curvedWall then
					if bParalellInCurvedWalls then
						pxL1 = cx - opInner / 2 - parapetExtendLeft
						pyL1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxL1^2)

						pxL2 = pxL1
						pyL2 = insetY

						pxR1 = cx + opInner / 2 + parapetExtendRight
						pyR1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxR1^2)

						pxR2 = pxR1
						pyR2 = insetY

						if parapet_width > leftWidth + rightWidth then
							bUsePolygonOperations	= 1	! Lets cut it with polygon operations
							bCutWallInsetWithPolyOp	= 1
						endif
					else
						pxL1 = cx - opInner / 2 - parapetExtendLeft
						pyL1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxL1^2)

						alpha = abs(asn(pxL1 / radBoard))
						pxL2 = pxL1 - signWallIsLeft * tan(alpha) * abs(pyL1 - insetY)
						pyL2 = insetY

						pxR1 = cx + opInner / 2 + parapetExtendRight
						pyR1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxR1^2)

						alpha = abs(asn(pxR1 / radBoard))
						pxR2 = pxR1 + signWallIsLeft * tan(alpha) * abs(pyR1 - insetY)
						pyR2 = insetY

						if wallIsLeft | (bParapetWallInset & not(bAutoParapetInset)) then
							bUsePolygonOperations	= 1	! Lets cut it with polygon operations
							bCutWallInsetWithPolyOp	= 1
						endif
					endif

					if gs_reveal_hotspots then	! Show wall inset hotspot
						if pyL1 > pyL2 then
							hotspot2 pxL2, pyL2, 11040
							hotspot2 pxL1, pyL1, 11042
						else
							hotspot2 -sqr(radBoard^2 - (insetY - WOD)^2), insetY, 11040
						endif

						if pyR1 > pyR2 then
							hotspot2 pxR2, pyR2, 11041
							hotspot2 pxR1, pyR1, 11043
						else
							hotspot2 sqr(radBoard^2 - (insetY - WOD)^2), insetY, 11041
						endif
					endif

					if not(bCutWallInsetWithPolyOp) then
						if pyL1 > pyL2 then
							put pxL1, pyL1, 3001,
								pxL2, pyL2, 1
						else
							put -sqr(radBoard^2 - (insetY - WOD)^2), insetY, 3001
						endif
						if pyR1 > pyR2 then
							put pxR2, pyR2, 1,
								pxR1, pyR1, 1
							if gs_reveal_hotspots then	! Show wall inset hotspot
								hotspot2 pxR2, pyR2, 11041
								hotspot2 pxR1, pyR1, 11043
							endif
						else
							put sqr(radBoard^2 - (insetY - WOD)^2), insetY, 1
							if gs_reveal_hotspots then	! Show wall inset hotspot
								hotspot2 sqr(radBoard^2 - (insetY - WOD)^2), insetY, 11041
							endif
						endif
					endif
				else
					if bInclinedWall then
						pxL1 = -leftWidth  - overSizeLeft - revYL - parapetExtendLeft * cos(WALL_INCL)
						pyL1 = WALL_THICKNESS - WIDO_SILL - py2p

						pxL2 = pxL1 + parapetWallInsetDepth * incV
						pyL2 = pyL1 - parapetWallInsetDepth * incH

						pxR1 = rightWidth + overSizeRight + revYR + parapetExtendRight * cos(WALL_INCL)
						pyR1 = WALL_THICKNESS - WIDO_SILL - py1p

						pxR2 = pxR1 + parapetWallInsetDepth * incV
						pyR2 = pyR1 - parapetWallInsetDepth * incH
					else
						pxL1 = cx - opInner / 2 - parapetExtendLeft
						pyL1 = cy

						pxL2 = pxL1
						pyL2 = pyL1 - parapetWallInsetDepth

						pxR1 = cx + opInner / 2 + parapetExtendRight
						pyR1 = cy

						pxR2 = pxR1
						pyR2 = pyR1 - parapetWallInsetDepth
					endif

					if parapet_width > leftWidth + rightWidth then
						bUsePolygonOperations	= 1	! Lets cut it with polygon operations
						bCutWallInsetWithPolyOp	= 1
					endif

					if not(bLeftCornerFunction) then
						if not(bCutWallInsetWithPolyOp) then
							put pxL1, pyL1, 1,
								pxL2, pyL2, 1
						endif
						if gs_reveal_hotspots then	! Show wall inset hotspot
							hotspot2 pxL2, pyL2, 11040
							hotspot2 pxL1, pyL1, 11042
						endif
					endif
					if not(bRightCornerFunction) then
						if not(bCutWallInsetWithPolyOp) then
							put pxR2, pyR2, 1,
								pxR1, pyR1, 1
						endif
						if gs_reveal_hotspots then	! Show wall inset hotspot
							hotspot2 pxR2, pyR2, 11041
							hotspot2 pxR1, pyR1, 11043
						endif
					endif
				endif

!!!circle2 pxL1, pyL1, 0.005
!!!circle2 pxL2, pyL2, 0.010
!!!circle2 pxR2, pyR2, 0.015
!!!circle2 pxR1, pyR1, 0.020

			endif

! ] Draw not full width wall inset recess --------------------------------------

			if sidelightCutRight then
				if curvedWall then
					put sidelightCutPosBoardRight, WOD - signWallIsLeft * sqr(radBoard^2 - sidelightCutPosBoardRight^2), 3000
				else
					if bInclinedWall then
						put sidelightCutPosBoardRight,
							rightRevealPnts[idxBoardEndPlasterRight][2] + (rightRevealPnts[idxBoardEndPlasterRight][1] - sidelightCutPosBoardRight) * \
							(leftRevealPnts[idxBoardEndPlasterLeft][2] - rightRevealPnts[idxBoardEndPlasterRight][2]) / (-leftRevealPnts[idxBoardEndPlasterLeft][1] + rightRevealPnts[idxBoardEndPlasterRight][1]),
							0
					else
						put sidelightCutPosBoardRight, rightRevealPnts[idxBoardEndPlasterRight][2], 0
					endif
				endif
				if abs(sidelightCutPosBoardRight - sidelightCutPosMiddleRight) > EPS then
					put sidelightCutPosBoardRight,	WIDO_FRAME_THICKNESS, 0,
						sidelightCutPosMiddleRight,	WIDO_FRAME_THICKNESS, 0
				endif
				put sidelightCutPosMiddleRight,	0, 0
			else
				if bRightCornerFunction then
					if bVisibleWallInsetIn2D then
						put rightRevealPnts[idxBoardEndPlasterRight][1] + parapetWallInsetDepth * rx, rightRevealPnts[idxBoardEndPlasterRight][2] - parapetWallInsetDepth,  0
						put rightRevealPnts[idxBoardEndPlasterRight][1] + parapetWallInsetDepth * rx, rightRevealPnts[idxBoardEndPlasterRight][2] - parapetWallInsetDepth,  0

						if gs_reveal_hotspots then
							hotspot2 rightRevealPnts[idxBoardEndPlasterRight][1] + parapetWallInsetDepth * rx,
									 rightRevealPnts[idxBoardEndPlasterRight][2] - parapetWallInsetDepth,
									 11041
						endif
					else
						put rightRevealPnts[idxBoardEndPlasterRight][1], rightRevealPnts[idxBoardEndPlasterRight][2],  0
					endif
					put rightRevealPnts[idxFrameStartRevealRight][1], rightRevealPnts[idxFrameStartRevealRight][2], 0
				else
					if bAutoParapetInset & bVisibleWallInsetIn2D then
						idx = idxBoardEndPlasterRight
						psInsetRight = 0

						if not(gs_stack_right) & (iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC) then
							if curvedWall then
								pxInsetRight	= rightRevealPnts[idx][1] - abs(rightRevealPnts[idx][2] - insetY) * tan(gs_reveal_right_angle)
								pyInsetRight	= insetY
							else
								pxInsetRight	= rightRevealPnts[idx][1] - parapetWallInsetDepth * sin(gs_reveal_right_angle)
								pyInsetRight	= rightRevealPnts[idx][2] - parapetWallInsetDepth
							endif
						else
							if curvedWall then
								if bParalellInCurvedWalls then
									alpha = abs(asn(rightRevealPnts[idx][1] / radBoard))
									pxInsetRight	= rightRevealPnts[idx][1]
									pyInsetRight	= insetY
								else
									alpha = abs(asn(rightRevealPnts[idx][1] / radBoard))
									pxInsetRight	= abs(tan(alpha) * (WOD - insetY))
									pyInsetRight	= insetY
								endif
							else
								pxInsetRight	= rightRevealPnts[idx][1]
								pyInsetRight	= rightRevealPnts[idx][2] - parapetWallInsetDepth
							endif
						endif
						if curvedWall & not(wallIsLeft) & pyInsetRight > rightRevealPnts[idx][2] then
							pxInsetRight	= rightRevealPnts[idx][1]
							pyInsetRight	= rightRevealPnts[idx][2]
						endif

						if not(curvedWall) | wallIsLeft then
							if gs_reveal_hotspots then
								hotspot2 pxInsetRight, pyInsetRight, 11041
							endif
						endif

						if curvedWall then
							if not(wallIsLeft) & insetY > pyInsetRight + EPS then
								put sqr(radBoard^2 - (insetY - WOD)^2), insetY, 1
								psInsetRight = 3000
								if gs_reveal_hotspots then
									hotspot2 sqr(radBoard^2 - (insetY - WOD)^2), insetY, 11041
								endif
							endif
						endif

						put pxInsetRight, pyInsetRight, psInsetRight

						for i = idxBoardEndPlasterRight - 1 to idxBoardStartPlasterRight step -1
							put rightRevealPnts[i][1], rightRevealPnts[i][2], 0
						next i
						put rightRevealPnts[idxFrameEndRevealRight][1],		rightRevealPnts[idxFrameEndRevealRight][2], 0
						put rightRevealPnts[idxFrameStartRevealRight][1],	rightRevealPnts[idxFrameStartRevealRight][2], 0
					else
						for i = idxBoardEndPlasterRight to idxBoardStartPlasterRight step -1
							put rightRevealPnts[i][1], rightRevealPnts[i][2]
							if curvedWall & i = idxBoardEndPlasterRight then
								put 3000
							else
								put 0
							endif
						next i
						if WIDO_FRAME_THICKNESS > EPS then
							put rightRevealPnts[idxFrameEndRevealRight][1],		rightRevealPnts[idxFrameEndRevealRight][2], 0
							put rightRevealPnts[idxFrameStartRevealRight][1],	rightRevealPnts[idxFrameStartRevealRight][2], 0
						endif
					endif
				endif
			endif

			if curvedWall & gs_IsCurved then
				put leftRevealPnts[startPointIdx][1], leftRevealPnts[startPointIdx][2], 3000
			endif
		endif	! if not(AC_WallType = 2) then

		if bUsePolygonOperations then
			! If there is hidden wall skins because of actual partial structure display settings
			! If we have custom size wall inset in curved wall

			ch = initaddonscope ("PolyOperations", "", "")

			preparefunction ch, "CreateContainer",	 "mySourceContainer", ""
			preparefunction ch, "SetSourceContainer", "mySourceContainer", ""

! Store original wallhole polygon ----------------------------------------------

			dim vertArr1[][3]

			defaultInhEdgeInfo = -1
			dim inhEdgeInfos1[]

			if AC_WallType = 2 then

				if sidelightCutLeft then
					put sidelightCutPosMiddleLeft,	0, 0
					if abs(sidelightCutPosSillLeft - sidelightCutPosMiddleLeft) > EPS then
						put	sidelightCutPosMiddleLeft,	0, 0
					endif
					if abs(sidelightCutPosMiddleLeft - sidelightCutPosBoardLeft) > EPS then
						put sidelightCutPosMiddleLeft,	WIDO_FRAME_THICKNESS, 0
					endif
					put	sidelightCutPosBoardLeft, WIDO_FRAME_THICKNESS, 2 * (sidelightCutLeft = 1),
						sidelightCutPosBoardLeft, leftRevealPnts[idxBoardEndPlasterLeft][2], -1
				else
					put leftRevealPnts[idxFrameStartRevealLeft][1],	leftRevealPnts[idxFrameStartRevealLeft][2],	not(gs_stack_left)
					put leftRevealPnts[idxFrameEndRevealLeft][1],	leftRevealPnts[idxFrameEndRevealLeft][2]

					lastBoardPointX = leftRevealPnts[idxFrameEndRevealLeft][1]
					lastBoardPointY = leftRevealPnts[idxFrameEndRevealLeft][2]
					for i=idxBoardStartRevealLeft to idxBoardEndRevealLeft
						if leftRevealPnts[i][2] >= WIDO_FRAME_THICKNESS then
							distFromLast = abs((leftRevealPnts[i][1] - lastBoardPointX)^2 + (leftRevealPnts[i][2] - lastBoardPointY)^2)
							if distFromLast > EPS then
								put not(gs_stack_left)	! previous pont status
								put leftRevealPnts[i][1], leftRevealPnts[i][2]
								lastBoardPointX = leftRevealPnts[i][1]
								lastBoardPointY = leftRevealPnts[i][2]
								bHasAnyBoardPoint = 1
							endif
						endif
					next i
					put -1	! last pont status
				endif

				if sidelightCutRight then
					put sidelightCutPosBoardRight, rightRevealPnts[idxBoardEndPlasterRight][2], 2 * (sidelightCutRight = 1),
						sidelightCutPosBoardRight,	WIDO_FRAME_THICKNESS, 0
					if abs(sidelightCutPosBoardRight - sidelightCutPosMiddleRight) > EPS then
						put	sidelightCutPosMiddleRight,	WIDO_FRAME_THICKNESS, 0
					endif
					if abs(sidelightCutPosMiddleRight - sidelightCutPosSillRight) > EPS then
						put sidelightCutPosMiddleRight,	0, 0
					endif
					put sidelightCutPosMiddleRight,	0, 0
				else
					bHasAnyBoardPoint = 0
					for i = idxBoardEndRevealRight to idxBoardStartRevealRight step -1
						if rightRevealPnts[i][2] >= WIDO_FRAME_THICKNESS then
							distFromLast = abs((rightRevealPnts[i][1] - lastBoardPointX)^2 + (rightRevealPnts[i][2] - lastBoardPointY)^2)
							if not(bHasAnyBoardPoint) | distFromLast > EPS then
								put rightRevealPnts[i][1], rightRevealPnts[i][2], not(gs_stack_right)
								lastBoardPointX = rightRevealPnts[i][1]
								lastBoardPointY = rightRevealPnts[i][2]
								bHasAnyBoardPoint = 1
							endif
						endif
					next i
					if idxBoardStartRevealRight <> idxFrameEndRevealRight then
						put rightRevealPnts[idxFrameEndRevealRight][1],	rightRevealPnts[idxFrameEndRevealRight][2],	not(gs_stack_right)
					endif
					put rightRevealPnts[idxFrameStartRevealRight][1],rightRevealPnts[idxFrameStartRevealRight][2],	0
				endif

				nVertices1 = nsp/3
				for i=1 to nVertices1
					vertarr1[i][1]	 = get(1)
					vertarr1[i][2]	 = get(1)
					vertarr1[i][3]	 = 0
					inhEdgeInfos1[i] = get(1)	! Mark wallhole edges
				next i
			else

				idx = 1
				inhEdgeInfosLast = 0

				for i=1 to nsp/3
					px = get(1)
					py = get(1)
					ps = round_int (get(1))

					if idx > 1 then
						bSkipThisVertex = (abs(px - vertarr1[1][1]) < EPS & abs(py - vertarr1[1][2]) < EPS)	! Skip this vertex if this is a closing one
						if not(bSkipThisVertex) then
							bSkipThisVertex = (abs(px - vertarr1[idx-1][1]) < EPS & abs(py - vertarr1[idx-1][2]) < EPS)
						endif
					else
						bSkipThisVertex = 0
					endif

					if ps < 900 | ps >= 1000 then	! Skip state '900'
						if not(bSkipThisVertex) then
							vertarr1[idx][1] = px
							vertarr1[idx][2] = py
						endif
						if ps >= 3000 & ps < 4000 then
							if idx > 1 then
								vx = vertarr1[idx-1][1] - 0
								vy = vertarr1[idx-1][2] - WOD
								gosub 103	! Direction Angle
								savedAngle = angle

								vx = px - 0
								vy = py - WOD
								gosub 103	! Direction Angle

								vertarr1[idx-1][3] = angle - savedAngle
								if not(bSkipThisVertex) then
									inhEdgeInfos1[idx] = 2 * bittest(ps, 0)
								endif
							endif
						else
							if not(bSkipThisVertex) then
								vertarr1[idx][3] = 0
								inhEdgeInfos1[idx] = 2 * bittest(ps, 0)
							endif
						endif
						if not(bSkipThisVertex) then
							idx = idx + 1
						endif
					endif
				next i
				nVertices1 = vardim1(vertarr1)
			endif	! if not(AC_WallType = 2) then

			nContours1 = 1
			dim contArr1[]
			contArr1[1] = nVertices1 + 1

			if nVertices1 >= 2 then
				preparefunction ch, "Store", "poly1", nVertices1, nContours1, vertArr1, contArr1, defaultInhEdgeInfo, inhEdgeInfos1
			endif

			prevSourceContainer	= ""
			lastDestContainer	= "mySourceContainer"
			preparefunction ch, "SetDestinationContainer", lastDestContainer, ""

! Offset board side edge -------------------------------------------------------

			if AC_WallType = 2 then
				dim dstPolyIDArr[]
				numPoly = callfunction (ch, "GetDestinationPolygons", "", dstPolyIDArr)

				dim edgeIds[]
				edgeIds[numPoly] = 0
				for i=1 to numPoly

					dim inhEdgeInfos[]
					numEdges = callfunction(ch, "GetInhEdgeInfos", dstPolyIDArr[i], inhEdgeInfos)

					for j=1 to numEdges
						if inhEdgeInfos[j] = -1 then edgeIds[i] = j
					next j
				next i

				if prevSourceContainer <> "" then
					preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
				endif
				preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
				prevSourceContainer	= lastDestContainer
				lastDestContainer	= "myDestContainer2"
				preparefunction ch, "CreateContainer",			lastDestContainer, ""
				preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

				dim srcPolyIDArr[]
				numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

				dim tempResPolyIDArr[]
				for i=1 to numPoly

					preparefunction ch, "OffsetParams", "", edgeIds[i], 0.50

					tempNumPoly = callfunction (ch, "OffsetEdge", srcPolyIDArr[i], tempResPolyIDArr)
				next i

!!!dim resPolyIDArr[]
!!!numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)
!!!
!!!for i = 1 to numPoly
!!!	polygonID = resPolyIDArr[i]
!!!	gosub 1000	! Get GDL Polygon
!!!
!!!	ccc=0
!!!	for j=1 to nsp/3
!!!		xx=get(1)
!!!		yy=get(1)
!!!		ss=get(1)
!!!		ccc=ccc+0.003
!!!		circle2 xx,yy,ccc
!!!		text2 xx,yy,j
!!!	next j
!!!next i
!!!end
			endif	! if AC_WallType = 2 then

! Regularize polygon(s) - avoid generating invalid polygons --------------------

			if curvedWall | WIDO_SILL + WIDO_FRAME_THICKNESS >= WALL_THICKNESS | bVisibleWallInsetIn2D | abs(WIDO_FRAME_THICKNESS) < EPS then

				if prevSourceContainer <> "" then
					preparefunction ch, "DeleteContainer",			prevSourceContainer, ""
				endif
				preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
				prevSourceContainer	= lastDestContainer
				lastDestContainer	= "myDestContainer1"
				preparefunction ch, "CreateContainer",			lastDestContainer, ""
				preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

				dim srcPolyIDArr[]
				numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

				dim tempResPolyIDArr[]
				for i=1 to numPoly
					tempNumPoly = callfunction (ch, "Regularize", srcPolyIDArr[i], tempResPolyIDArr)
				next i
			endif

			if curvedWall then

				if prevSourceContainer <> "" then
					preparefunction ch, "DeleteContainer",			prevSourceContainer, ""
				endif
				preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
				prevSourceContainer	= lastDestContainer
				lastDestContainer	= "myDestContainer2"
				preparefunction ch, "CreateContainer",			lastDestContainer, ""
				preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

				preparefunction ch, "HalfPlaneParams", "", 0, -1, 0

				dim srcPolyIDArr[]
				numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

				dim tempResPolyIDArr[]
				for i = 1 to numPoly
					tempNumPoly = callfunction (ch, "PolyCut", srcPolyIDArr[i], tempResPolyIDArr)
				next i
			endif

!!!	dim resPolyIDArr[]
!!!	numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)
!!!
!!!	text2 0,0, numPoly
!!!
!!!	for i = 1 to numPoly
!!!		polygonID = resPolyIDArr[i]
!!!		gosub 1000	! Get GDL Polygon
!!!
!!!		if bDrawBoardFill then
!!!			fill wallholeFill
!!!			wallhole2 nsp/3, 2 + 64, wallholePen_fg,wallholePen_bg,
!!!				0,0,0, get(nsp)
!!!		else
!!!			fill 0
!!!			wallhole2 nsp/3, 2 + 64, 0,-1,
!!!				0,0,0, get(nsp)
!!!		endif
!!!	next i
!!!end

!!!ccc = 0
!!!for i=1 to vardim1(vertarr1)
!!!	ccc = ccc + 0.002
!!!	circle2 vertarr1[i][1], vertarr1[i][2], ccc
!!!next i


! Cut hidden wall skins polygon ------------------------------------------------

			if (offsetBoard > EPS) then

				if prevSourceContainer <> "" then
					preparefunction ch, "DeleteContainer",			prevSourceContainer, ""
				endif
				preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
				prevSourceContainer	= lastDestContainer
				lastDestContainer	= "myDestContainer3"
				preparefunction ch, "CreateContainer",			lastDestContainer, ""
				preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

				dim srcPolyIDArr[]
				numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

! Store hidden wall skins polygon ----------------------------------------------

				if curvedWall then
					pxL1 = -radBoard + signWallIsLeft * 0.1
					pyL1 = WOD

					pxL2 = -radBoard - signWallIsLeft * offsetBoard
					pyL2 = WOD

					pxR1 = radBoard - signWallIsLeft * 0.1
					pyR1 = WOD

					pxR2 = radBoard + signWallIsLeft * offsetBoard
					pyR2 = WOD
				else
					if bInclinedWall then
						pxL1 = -leftWidth - 1.0
						pyL1 = WALL_THICKNESS - WIDO_SILL + pxL1 * incX + 0.1

						pxL2 = pxL1
						pyL2 = WALL_THICKNESS - WIDO_SILL - offsetBoard * incFactor * incY + pxL2 * incX

						pxR1 = rightWidth + 1.0
						pyR1 = WALL_THICKNESS - WIDO_SILL + pxR1 * incX + 0.1

						pxR2 = pxR1
						pyR2 = WALL_THICKNESS - WIDO_SILL - offsetBoard * incFactor * incY + pxR2 * incX
					else
						pxL1 = -leftWidth - 1.0
						pyL1 = WALL_THICKNESS - WIDO_SILL + 0.1

						pxL2 = pxL1
						pyL2 = WALL_THICKNESS - WIDO_SILL - offsetBoard

						pxR1 = rightWidth + 1.0
						pyR1 = WALL_THICKNESS - WIDO_SILL + 0.1

						pxR2 = pxR1
						pyR2 = WALL_THICKNESS - WIDO_SILL - offsetBoard
					endif
				endif

!!!text2 0,0.2, WALL_THICKNESS
!!!circle2 0,0, 0.01
!!!fill 1
!!!pen 1
!!!poly2_b 4, 1+2+4+64, 1,0,
!!!	pxL1, pyL1, 1,
!!!	pxL2, pyL2, 1,
!!!	pxR2, pyR2, 1,
!!!	pxR1, pyR1, 1
!!!fill wallholeFill

				nVertices2 = 4
				dim vertArr2[][3]

				defaultInhEdgeInfo = -1
				dim inhEdgeInfos2[]

				vertarr2[1][1] = pxL1
				vertarr2[1][2] = pyL1
				vertarr2[1][3] = 0
				inhEdgeInfos2[1] = 2

				vertarr2[2][1] = pxL2
				vertarr2[2][2] = pyL2
				vertarr2[2][3] = curvedWall * signWallIsLeft * 180
				inhEdgeInfos2[2] = 2

				vertarr2[3][1] = pxR2
				vertarr2[3][2] = pyR2
				vertarr2[3][3] = 0
				inhEdgeInfos2[3] = 2

				vertarr2[4][1] = pxR1
				vertarr2[4][2] = pyR1
				vertarr2[4][3] = curvedWall * signWallIsLeft * (-180)
				inhEdgeInfos2[4] = 2

				nContours2 = 1
				dim contArr2[]
				contArr2[1] = nVertices2 + 1

				preparefunction ch, "Store", "poly2", nVertices2, nContours2, vertArr2, contArr2, defaultInhEdgeInfo, inhEdgeInfos2

! Substract polygons -----------------------------------------------------------

				dim tempResPolyIDArr[]
				for i = 1 to numPoly
					tempNumPoly = callfunction(ch, srcPolyIDArr[i] + " - poly2", "", tempResPolyIDArr)
				next i
			endif


!!!	dim resPolyIDArr[]
!!!	numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)
!!!
!!!	text2 0,0, numPoly
!!!
!!!	for i = 1 to numPoly
!!!		polygonID = resPolyIDArr[i]
!!!		gosub 1000	! Get GDL Polygon
!!!
!!!		if bDrawBoardFill then
!!!			fill wallholeFill
!!!			wallhole2 nsp/3, 2 + 64, wallholePen_fg,wallholePen_bg,
!!!				0,0,0, get(nsp)
!!!		else
!!!			fill 0
!!!			wallhole2 nsp/3, 2 + 64, 0,-1,
!!!				0,0,0, get(nsp)
!!!		endif
!!!	next i
!!!end


! Store wall inset polygon -----------------------------------------------------

			if bCutWallInsetWithPolyOp then

				if prevSourceContainer <> "" then
					preparefunction ch, "DeleteContainer",			prevSourceContainer, ""
				endif
				preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
				prevSourceContainer	= lastDestContainer
				lastDestContainer	= "myDestContainer4"
				preparefunction ch, "CreateContainer",			lastDestContainer, ""
				preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

				dim srcPolyIDArr[]
				numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

				if curvedWall then
					if bParalellInCurvedWalls then
						pxL1 = cx - opInner / 2 - parapetExtendLeft
						pyL1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxL1^2)

						pxL2 = pxL1
						pyL2 = insetY

						pxR1 = cx + opInner / 2 + parapetExtendRight
						pyR1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxR1^2)

						pxR2 = pxR1
						pyR2 = insetY
					else
						pxL1 = cx - opInner / 2 - parapetExtendLeft
						pyL1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxL1^2)

						alpha = abs(asn(pxL1 / radBoard))
						pxL2 = pxL1 - signWallIsLeft * tan(alpha) * abs(pyL1 - insetY)
						pyL2 = insetY

						pxR1 = cx + opInner / 2 + parapetExtendRight
						pyR1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxR1^2)

						alpha = abs(asn(pxR1 / radBoard))
						pxR2 = pxR1 + signWallIsLeft * tan(alpha) * abs(pyR1 - insetY)
						pyR2 = insetY

						if not(wallIsLeft) then
							if pyL1 < pyL2 then
								pxL2 = -sqr(radBoard^2 - (insetY - WOD)^2)
								pyL2 = insetY

								pxL1 = pxL2
								pyL1 = pyL2
							endif
							if pyR1 < pyR2 then
								pxR2 = sqr(radBoard^2 - (insetY - WOD)^2)
								pyR2 = insetY

								pxR1 = pxR2
								pyR1 = pyR2
							endif
						endif
					endif
				else
					if bInclinedWall then
						pxL1 = -leftWidth  - overSizeLeft - revYL - parapetExtendLeft * incH
						pyL1 = WALL_THICKNESS - WIDO_SILL - py2p

						pxL2 = pxL1 + parapetWallInsetDepth * incV
						pyL2 = pyL1 - parapetWallInsetDepth * incH

						pxR1 = rightWidth + overSizeRight + revYR + parapetExtendRight * incH
						pyR1 = WALL_THICKNESS - WIDO_SILL - py1p

						pxR2 = pxR1 + parapetWallInsetDepth * incV
						pyR2 = pyR1 - parapetWallInsetDepth * incH
					else
						pxL1 = -opInner / 2 - parapetExtendLeft - 1.0 * gs_parapet_autodim
						pyL1 = WALL_THICKNESS - WIDO_SILL + 1.0 * (AC_WallType = 2)

						pxL2 = pxL1
						pyL2 = WALL_THICKNESS - WIDO_SILL - parapetWallInsetDepth

						pxR1 = opInner / 2 + parapetExtendRight + 1.0 * gs_parapet_autodim
						pyR1 = WALL_THICKNESS - WIDO_SILL + 1.0 * (AC_WallType = 2)

						pxR2 = pxR1
						pyR2 = WALL_THICKNESS - WIDO_SILL - parapetWallInsetDepth
					endif
				endif

!!!circle2 pxL1, pyL1, 0.005
!!!circle2 pxL2, pyL2, 0.010
!!!circle2 pxR2, pyR2, 0.015
!!!circle2 pxR1, pyR1, 0.020

				nVertices4 = 4 + (curvedWall & not(wallIsLeft))
				dim vertArr4[][3]

				defaultInhEdgeInfo = -1
				dim inhEdgeInfos4[]

				vertarr4[1][1] = pxL1
				vertarr4[1][2] = pyL1
				vertarr4[1][3] = 0
				inhEdgeInfos4[1] = 2

				vertarr4[2][1] = pxL2
				vertarr4[2][2] = pyL2
				vertarr4[2][3] = 0
				inhEdgeInfos4[2] = 2

				vertarr4[3][1] = pxR2
				vertarr4[3][2] = pyR2
				vertarr4[3][3] = 0
				inhEdgeInfos4[3] = 2

				vertarr4[4][1] = pxR1
				vertarr4[4][2] = pyR1
				vertarr4[4][3] = 0
				inhEdgeInfos4[4] = 2

				if curvedWall & not(wallIsLeft) then
					vertarr4[5][1] = 0
					vertarr4[5][2] = pyR1 + WALL_THICKNESS
					vertarr4[5][3] = 0
					inhEdgeInfos4[5] = -1
				endif

				nContours4 = 1
				dim contArr4[]
				contArr4[1] = nVertices4 + 1

				preparefunction ch, "Store", "WallInset", nVertices4, nContours4, vertArr4, contArr4, defaultInhEdgeInfo, inhEdgeInfos4

! Substract polygons -----------------------------------------------------------

				dim tempResPolyIDArr[]
				for i = 1 to numPoly
					tempNumPoly = callfunction(ch, srcPolyIDArr[i] + " - WallInset", "", tempResPolyIDArr)
				next i
			endif

! Store wall contour polygon in wallhole coordinate system ---------------------

			if AC_WallType = 2 then
				if prevSourceContainer <> "" then
					preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
				endif
				preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
				prevSourceContainer	= lastDestContainer
				lastDestContainer	= "myDestContainer3"
				preparefunction ch, "CreateContainer",			lastDestContainer, ""
				preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

				nVertices2 = vardim1(AC_WallContourPolygon)
				dim vertArr2[][3]

				dim srcPolyIDArr[]
				numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

				defaultInhEdgeInfo = 0
				dim inhEdgeInfos2[]
!!!ccc=0
				for i=1 to nVertices2
					vertarr2[i][1] = AC_WallContourPolygon[i][1]
					if WIDO_REVEAL_SIDE then
						vertarr2[i][2] = AC_WallContourPolygon[i][2] + WIDO_FRAME_THICKNESS
						vertarr2[i][3] = AC_WallContourPolygon[i][3]
					else
						vertarr2[i][2] = -AC_WallContourPolygon[i][2]
						vertarr2[i][3] = -AC_WallContourPolygon[i][3]
					endif

					inhEdgeInfos2[i] = 2
!!!ccc=ccc+0.003
!!!circle2 vertarr2[i][1], vertarr2[i][2], ccc
!!!text2 vertarr2[i][1], vertarr2[i][2], i
				next i

				nContours2 = 1
				dim contArr2[]
				contArr2[1] = nVertices2 + 1

				preparefunction ch, "Store", "wallContourPoly", nVertices2, nContours2, vertArr2, contArr2, defaultInhEdgeInfo, inhEdgeInfos2

! Intersect polygons -----------------------------------------------------------

				dim tempResPolyIDArr[]
				for i = 1 to numPoly
					tempNumPoly = callfunction (ch, "wallContourPoly / " + srcPolyIDArr[i], "", tempResPolyIDArr)
				next i
			endif

! Draw resulting polygons ------------------------------------------------------

			dim resPolyIDArr[]
			numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)

!!!text2 0,0, numPoly

			for i = 1 to numPoly
				polygonID = resPolyIDArr[i]
				gosub 1000	! Get GDL Polygon

				if _bValidPoly then
					if bDrawBoardFill then
						fill wallholeFill
						if GLOB_CONTEXT = 5 then
							poly2_b nsp/3, 2+64, wallholePen_fg,wallholePen_bg,
								get(nsp)
						else
							wallhole2 nsp/3, 2 + 64, wallholePen_fg,wallholePen_bg,
								0,0,0, get(nsp)
						endif
					else
						fill 0
						if GLOB_CONTEXT = 5 then
							poly2_b nsp/3, 2+64, 0,-1,
								get(nsp)
						else
							wallhole2 nsp/3, 2 + 64, 0,-1,
								0,0,0, get(nsp)
						endif
					endif
				endif
			next i

! Draw resulting contours ------------------------------------------------------

			if ( (AC_WallType = 2) & not(bNeedToOffsetSkins) ) | bVisibleWallInsetIn2D then
				dim lineAttributes[2][4]
				lineAttributes[1][1] = WALL_SECT_PEN
				lineAttributes[1][2] = WALL_LINETYPE
				lineAttributes[1][3] = LINE_PROPERTY_CONTOUR
				lineAttributes[1][4] = bitset(0, LINE_ATTRIBUTES_WALLLINE)

				lineAttributes[2][1] = gs_wcont_line_pen * (wcontLineIn > 0)	! Inside, Both Sides
				if bHiddenParapetWallInsetIn2D then
					lineAttributes[2][2] = gs_parapet_line
				else
					lineAttributes[2][2] = wcontLineIn
				endif
				lineAttributes[2][3] = LINE_PROPERTY_GENERIC
				lineAttributes[2][4] = bitset(0, LINE_ATTRIBUTES_GDLLINE)

				bPutHotsopts	= (AC_WallType = 2)

				for i = 1 to numPoly
					polygonID = resPolyIDArr[i]
					gosub 1001	! Draw one polygon contour line
				next i
			endif
		endif	! if bUsePolygonOperations then

		if not(bUsePolygonOperations) then
			if (wcontLineIn > 0) then		! Inside, Both Sides
				pen gs_wcont_line_pen
				line_property 0
				if bHiddenParapetWallInsetIn2D then
					line_type gs_parapet_line
				else
					line_type wcontLineIn
				endif

				poly2_ nsp/3, 1,use(nsp)
			endif

			if bDrawBoardFill then
				fill wallholeFill
				if GLOB_CONTEXT = 5 then
					poly2_b nsp/3, 2+4+64, wallholePen_fg,wallholePen_bg,
						get(nsp)
				else
					wallhole2 nsp/3, 2 + 64, wallholePen_fg,wallholePen_bg,
						0,0,0, get(nsp)
				endif
			else
				fill 0
				if GLOB_CONTEXT = 5 then
					poly2_b nsp/3, 2+4+64, 0, -1,
						get(nsp)
				else
					wallhole2 nsp/3, 2 + 64, 0,-1,
						0,0,0, get(nsp)
				endif
			endif

		endif

	endif

!-------------------------------------------------------------------------------
! Draw hidden parts of Wall Inset
!-------------------------------------------------------------------------------

	if gs_parapet_2D & bUsePolygonOperations & bParapetWallInset & bCutWallInsetWithPolyOp & not(bAutoParapetInset) & \
		not((gs_stack_left | bLeftCornerFunction) & (gs_stack_right | bRightCornerFunction)) then

		if prevSourceContainer <> "" then
			preparefunction ch, "DeleteContainer", prevSourceContainer, ""
		endif
		if lastDestContainer <> "" then
			preparefunction ch, "DeleteContainer", lastDestContainer, ""
		endif

		preparefunction ch, "CreateContainer",	 "mySourceContainer", ""
		preparefunction ch, "SetSourceContainer", "mySourceContainer", ""

		prevSourceContainer	= ""
		lastDestContainer	= "mySourceContainer"
		preparefunction ch, "SetDestinationContainer", lastDestContainer, ""

! Store wallhole polygon -------------------------------------------------------

		bHasAnySillPoint = 0
		for i=idxSillStartPlasterLeft to idxSillEndPlasterLeft
			if leftRevealPnts[i][2] <= 0 then
				distFromLast = abs((leftRevealPnts[i][1] - lastSillPointX)^2 + (leftRevealPnts[i][2] - lastSillPointY)^2)
				if not(bHasAnySillPoint) | distFromLast > EPS then
					put leftRevealPnts[i][1], leftRevealPnts[i][2], not(gs_stack_left)
					lastSillPointX = leftRevealPnts[i][1]
					lastSillPointY = leftRevealPnts[i][2]
					bHasAnySillPoint = 1
				endif
			endif
		next i
		if idxFrameStartRevealLeft <> idxSillEndPlasterLeft | not(bHasAnySillPoint) then
			put leftRevealPnts[idxFrameStartRevealLeft][1],	leftRevealPnts[idxFrameStartRevealLeft][2],	not(gs_stack_left)
		endif
		put leftRevealPnts[idxFrameEndRevealLeft][1],	leftRevealPnts[idxFrameEndRevealLeft][2],	not(gs_stack_left)
		bHasAnyBoardPoint = 0
		for i=idxBoardStartPlasterLeft + (idxFrameEndRevealLeft = idxBoardStartPlasterLeft) to idxBoardEndPlasterLeft
			if leftRevealPnts[i][2] >= WIDO_FRAME_THICKNESS then
				distFromLast = abs((leftRevealPnts[i][1] - lastBoardPointX)^2 + (leftRevealPnts[i][2] - lastBoardPointY)^2)
				if not(bHasAnyBoardPoint) | distFromLast > EPS then
					put leftRevealPnts[i][1], leftRevealPnts[i][2]
					if i = idxBoardEndPlasterLeft then
						put -1
					else
						put not(gs_stack_left)
					endif
					lastBoardPointX = leftRevealPnts[i][1]
					lastBoardPointY = leftRevealPnts[i][2]
					bHasAnyBoardPoint = 1
				endif
			endif
		next i

		bHasAnyBoardPoint = 0
		for i = idxBoardEndPlasterRight to idxBoardStartPlasterRight step -1
			if rightRevealPnts[i][2] >= WIDO_FRAME_THICKNESS then
				distFromLast = abs((rightRevealPnts[i][1] - lastBoardPointX)^2 + (rightRevealPnts[i][2] - lastBoardPointY)^2)
				if not(bHasAnyBoardPoint) | distFromLast > EPS then
					put rightRevealPnts[i][1], rightRevealPnts[i][2], not(gs_stack_right)
					lastBoardPointX = rightRevealPnts[i][1]
					lastBoardPointY = rightRevealPnts[i][2]
					bHasAnyBoardPoint = 1
				endif
			endif
		next i
		if idxFrameEndRevealRight <> idxBoardStartPlasterRight | not(bHasAnyBoardPoint) then
			put rightRevealPnts[idxFrameEndRevealRight][1],	 rightRevealPnts[idxFrameEndRevealRight][2],	not(gs_stack_right)
		endif
		put rightRevealPnts[idxFrameStartRevealRight][1],rightRevealPnts[idxFrameStartRevealRight][2],	not(gs_stack_right)
		bHasAnySillPoint = 0
		lastSillPointX = rightRevealPnts[idxFrameStartRevealRight][1]
		lastSillPointY = rightRevealPnts[idxFrameStartRevealRight][2]
		for i = idxSillEndPlasterRight - (idxFrameStartRevealRight = idxSillEndPlasterRight) to idxSillStartPlasterRight step -1
			if rightRevealPnts[i][2] <= 0 then
				distFromLast = abs((rightRevealPnts[i][1] - lastSillPointX)^2 + (rightRevealPnts[i][2] - lastSillPointY)^2)
				if distFromLast > EPS then
					put rightRevealPnts[i][1], rightRevealPnts[i][2]
					if i = idxSillStartPlasterRight then
						put -1
					else
						put not(gs_stack_right)
					endif
					lastSillPointX = rightRevealPnts[i][1]
					lastSillPointY = rightRevealPnts[i][2]
					bHasAnySillPoint = 1
				endif
			endif
		next i

		nVertices1 = nsp/3
		dim vertArr1[][3]

		defaultInhEdgeInfo = 0
		dim inhEdgeInfos1[]

		idx = 1
		for i=1 to nVertices1
			px = get(1)
			py = get(1)
			ps = get(1)
			if i = 1 then
				bSkipThisPoint = 0
			else
				bSkipThisPoint = (abs(px - vertarr1[idx-1][1]) < EPS & abs(py - vertarr1[idx-1][2]) < EPS)
			endif
			if not(bSkipThisPoint) then
				vertarr1[idx][1]	 = px
				vertarr1[idx][2]	 = py
				vertarr1[idx][3]	 = 0
				inhEdgeInfos1[idx] = ps	! Mark wallhole edges
				idx = idx + 1
			endif
		next i
		nVertices1 = idx - 1

		nContours1 = 1
		dim contArr1[]
		contArr1[1] = nVertices1 + 1

		preparefunction ch, "Store", "wallHolePoly", nVertices1, nContours1, vertArr1, contArr1, defaultInhEdgeInfo, inhEdgeInfos1

! Regularize polygon(s) - avoid generating invalid polygons --------------------

		if curvedWall then

			if prevSourceContainer <> "" then
				preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
			endif
			preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
			prevSourceContainer	= lastDestContainer
			lastDestContainer	= "myDestContainer1"
			preparefunction ch, "CreateContainer",			lastDestContainer, ""
			preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

			dim srcPolyIDArr[]
			numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

			dim tempResPolyIDArr[]
			for i=1 to numPoly
				tempNumPoly = callfunction (ch, "Regularize", srcPolyIDArr[i], tempResPolyIDArr)
			next i
		endif

! Offset board side edge -------------------------------------------------------

		dim srcPolyIDArr2[]
		numPoly = callfunction (ch, "GetDestinationPolygons", "", srcPolyIDArr2)

		dim edgeIds[]
		edgeIds[numPoly] = 0
		for i=1 to numPoly
			dim inhEdgeInfos[]
			numEdges = callfunction(ch, "GetInhEdgeInfos", srcPolyIDArr2[i], inhEdgeInfos)

			for j=1 to numEdges
				if inhEdgeInfos[j] = -1 then edgeIds[i] = j
			next j
		next i

		if prevSourceContainer <> "" then
			preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
		endif
		preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
		prevSourceContainer	= lastDestContainer
		lastDestContainer	= "myDestContainer2"
		preparefunction ch, "CreateContainer",			lastDestContainer, ""
		preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

		dim srcPolyIDArr[]
		numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

		dim tempResPolyIDArr[]
		for i=1 to numPoly

			preparefunction ch, "OffsetParams", "", edgeIds[i], 0.50

			tempNumPoly = callfunction (ch, "OffsetEdge", srcPolyIDArr[i], tempResPolyIDArr)
		next i

!!!dim resPolyIDArr[]
!!!numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)
!!!
!!!for i = 1 to numPoly
!!!	polygonID = resPolyIDArr[i]
!!!	gosub 1000	! Get GDL Polygon
!!!
!!!	ccc=0
!!!	for j=1 to nsp/3
!!!		xx=get(1)
!!!		yy=get(1)
!!!		ss=get(1)
!!!		ccc=ccc+0.003
!!!		circle2 xx,yy,ccc
!!!		text2 xx,yy,j
!!!	next j
!!!next i
!!!end

! Store wall inset polygon -----------------------------------------------------

		if prevSourceContainer <> "" then
			preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
		endif
		preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
		prevSourceContainer	= lastDestContainer
		lastDestContainer	= "myDestContainer3"
		preparefunction ch, "CreateContainer",			lastDestContainer, ""
		preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

		dim srcPolyIDArr[]
		numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

		nVertices4 = 4 + (curvedWall & not(wallIsLeft))
		dim vertArr4[][3]

		defaultInhEdgeInfo = -1
		dim inhEdgeInfos4[]

		vertarr4[1][1] = pxL1 * not(gs_stack_left | bLeftCornerFunction)
		vertarr4[1][2] = pyL1
		vertarr4[1][3] = 0
		inhEdgeInfos4[1] = 2

		vertarr4[2][1] = pxL2 * not(gs_stack_left | bLeftCornerFunction)
		vertarr4[2][2] = pyL2
		vertarr4[2][3] = 0
		inhEdgeInfos4[2] = 2

		vertarr4[3][1] = pxR2 * not(gs_stack_right | bRightCornerFunction)
		vertarr4[3][2] = pyR2
		vertarr4[3][3] = 0
		inhEdgeInfos4[3] = 2

		vertarr4[4][1] = pxR1 * not(gs_stack_right | bRightCornerFunction)
		vertarr4[4][2] = pyR1
		vertarr4[4][3] = 0
		inhEdgeInfos4[4] = 0

		if curvedWall & not(wallIsLeft) then
			vertarr4[5][1] = 0
			vertarr4[5][2] = pyR1 + WALL_THICKNESS
			vertarr4[5][3] = 0
			inhEdgeInfos4[5] = 0
		endif

		nContours4 = 1
		dim contArr4[]
		contArr4[1] = nVertices4 + 1

		preparefunction ch, "Store", "WallInset", nVertices4, nContours4, vertArr4, contArr4, defaultInhEdgeInfo, inhEdgeInfos4

! Substract polygons -----------------------------------------------------------

		dim tempResPolyIDArr[]
		for i = 1 to numPoly
			tempNumPoly = callfunction(ch, "WallInset - " + srcPolyIDArr[i], "", tempResPolyIDArr)
		next i

!!!! Substract polygons -----------------------------------------------------------
!!!
!!!	dim srcPolyIDArr[]
!!!	numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)
!!!
!!!	dim operandPolygonNames[]
!!!		operandPolygonNames[1] = "WallInset"
!!!	numOperandPolygonNames = 1
!!!	containerIdx = 10
!!!
!!!	while numPoly > 0 do
!!!
!!!		for i = 2 to numPoly
!!!			tempNumPoly = callfunction (ch, "CopyPolygon", srcPolyIDArr[i], tempResPolyIDArr)
!!!		next i
!!!		lastNumPoly = numPoly - 1
!!!
!!!		for i=1 to numOperandPolygonNames
!!!			tempNumPoly = callfunction (ch, operandPolygonNames[i] + " - " + srcPolyIDArr[1], "", tempResPolyIDArr)
!!!		next i
!!!
!!!		numResPoly = tempNumPoly - lastNumPoly + 1
!!!
!!!		dim resPolyIDArr[]
!!!		tempNumPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)
!!!
!!!		numOperandPolygonNames = tempNumPoly - lastNumPoly
!!!
!!!		for i=1 to numOperandPolygonNames
!!!			operandPolygonNames[i] = resPolyIDArr[lastNumPoly + i]
!!!		next i
!!!
!!!		numPoly = numPoly - 1
!!!
!!!		if numPoly > 0 then
!!!			if prevSourceContainer <> "" then
!!!				preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
!!!			endif
!!!			preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
!!!			prevSourceContainer	= lastDestContainer
!!!			lastDestContainer	= "myDestContainer" + str(containerIdx, 1, 0)
!!!			preparefunction ch, "CreateContainer",			lastDestContainer, ""
!!!			preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""
!!!			containerIdx = containerIdx + 1
!!!		endif
!!!	endwhile

! Store wall contour polygon in wallhole coordinate system ---------------------

		if AC_WallType = 2 then

			if prevSourceContainer <> "" then
				preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
			endif
			preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
			prevSourceContainer	= lastDestContainer
			lastDestContainer	= "myDestContainer4"
			preparefunction ch, "CreateContainer",			lastDestContainer, ""
			preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

			nVertices2 = vardim1(AC_WallContourPolygon)
			dim vertArr2[][3]

			dim srcPolyIDArr[]
			numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

			defaultInhEdgeInfo = 0
			dim inhEdgeInfos2[]
!!!ccc=0
			for i=1 to nVertices2
				vertarr2[i][1] = AC_WallContourPolygon[i][1]
				if WIDO_REVEAL_SIDE then
					vertarr2[i][2] = AC_WallContourPolygon[i][2] + WIDO_FRAME_THICKNESS
					vertarr2[i][3] = AC_WallContourPolygon[i][3]
				else
					vertarr2[i][2] = -AC_WallContourPolygon[i][2]
					vertarr2[i][3] = -AC_WallContourPolygon[i][3]
				endif

				inhEdgeInfos2[i] = 2
!!!ccc=ccc+0.003
!!!circle2 vertarr2[i][1], vertarr2[i][2], ccc
!!!text2 vertarr2[i][1], vertarr2[i][2], i
			next i

			nContours2 = 1
			dim contArr2[]
			contArr2[1] = nVertices2 + 1

			preparefunction ch, "Store", "wallContourPoly", nVertices2, nContours2, vertArr2, contArr2, defaultInhEdgeInfo, inhEdgeInfos2

! Intersect polygons -----------------------------------------------------------

			dim tempResPolyIDArr[]
			for i = 1 to numPoly
				tempNumPoly = callfunction (ch, "wallContourPoly / " + srcPolyIDArr[i], "", tempResPolyIDArr)
			next i
		endif

! Cut hidden wall skins polygon ------------------------------------------------

		if (offsetBoard > EPS) then

			if prevSourceContainer <> "" then
				preparefunction ch, "DeleteContainer",			prevSourceContainer, ""
			endif
			preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
			prevSourceContainer	= lastDestContainer
			lastDestContainer	= "myDestContainer5"
			preparefunction ch, "CreateContainer",			lastDestContainer, ""
			preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

			dim srcPolyIDArr[]
			numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

! Store hidden wall skins polygon ----------------------------------------------

			if curvedWall then
				pxL1 = -radBoard + signWallIsLeft * 0.1
				pyL1 = WOD

				pxL2 = -radBoard - signWallIsLeft * offsetBoard
				pyL2 = WOD

				pxR1 = radBoard - signWallIsLeft * 0.1
				pyR1 = WOD

				pxR2 = radBoard + signWallIsLeft * offsetBoard
				pyR2 = WOD
			else
				if bInclinedWall then
					pxL1 = -leftWidth - 1.0
					pyL1 = WALL_THICKNESS - WIDO_SILL + pxL1 * incX + 0.1

					pxL2 = pxL1
					pyL2 = WALL_THICKNESS - WIDO_SILL - offsetBoard * incFactor * incY + pxL2 * incX

					pxR1 = rightWidth + 1.0
					pyR1 = WALL_THICKNESS - WIDO_SILL + pxR1 * incX + 0.1

					pxR2 = pxR1
					pyR2 = WALL_THICKNESS - WIDO_SILL - offsetBoard * incFactor * incY + pxR2 * incX
				else
					pxL1 = -leftWidth - 1.0
					pyL1 = WALL_THICKNESS - WIDO_SILL + 0.1

					pxL2 = pxL1
					pyL2 = WALL_THICKNESS - WIDO_SILL - offsetBoard

					pxR1 = rightWidth + 1.0
					pyR1 = WALL_THICKNESS - WIDO_SILL + 0.1

					pxR2 = pxR1
					pyR2 = WALL_THICKNESS - WIDO_SILL - offsetBoard
				endif
			endif

!!!text2 0,0.2, WALL_THICKNESS
!!!circle2 0,0, 0.01
!!!fill 1
!!!pen 1
!!!poly2_b 4, 1+2+4+64, 1,0,
!!!	pxL1, pyL1, 1,
!!!	pxL2, pyL2, 1,
!!!	pxR2, pyR2, 1,
!!!	pxR1, pyR1, 1
!!!fill wallholeFill

			nVertices2 = 4
			dim vertArr2[][3]

			defaultInhEdgeInfo = -1
			dim inhEdgeInfos2[]

			vertarr2[1][1] = pxL1
			vertarr2[1][2] = pyL1
			vertarr2[1][3] = 0
			inhEdgeInfos2[1] = 0

			vertarr2[2][1] = pxL2
			vertarr2[2][2] = pyL2
			vertarr2[2][3] = curvedWall * signWallIsLeft * 180
			inhEdgeInfos2[2] = 0

			vertarr2[3][1] = pxR2
			vertarr2[3][2] = pyR2
			vertarr2[3][3] = 0
			inhEdgeInfos2[3] = 0

			vertarr2[4][1] = pxR1
			vertarr2[4][2] = pyR1
			vertarr2[4][3] = curvedWall * signWallIsLeft * (-180)
			inhEdgeInfos2[4] = 0

			nContours2 = 1
			dim contArr2[]
			contArr2[1] = nVertices2 + 1

			preparefunction ch, "Store", "poly2", nVertices2, nContours2, vertArr2, contArr2, defaultInhEdgeInfo, inhEdgeInfos2

! Substract polygons -----------------------------------------------------------

			dim tempResPolyIDArr[]
			for i = 1 to numPoly
				tempNumPoly = callfunction(ch, srcPolyIDArr[i] + " - poly2", "", tempResPolyIDArr)
			next i
		endif

! Draw wall contour lines ------------------------------------------------------

		dim resPolyIDArr[]
		numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)

		dim lineAttributes[2][4]
		lineAttributes[1][1] = 0
		lineAttributes[1][2] = 0
		lineAttributes[1][3] = 0
		lineAttributes[1][4] = 0

		lineAttributes[2][1] = gs_wcont_line_pen * (wcontLineIn > 0)
		lineAttributes[2][2] = gs_parapet_line
		lineAttributes[2][3] = LINE_PROPERTY_GENERIC
		lineAttributes[2][4] = bitset(0, LINE_ATTRIBUTES_GDLLINE)

		bPutHotsopts	= 0

		for i = 1 to numPoly
			polygonID = resPolyIDArr[i]
			gosub 1001	! Draw one polygon contour line
		next i

	endif

! Close channel ----------------------------------------------------------------

	if bUsePolygonOperations then
		closeaddonscope ch
	endif
return


! ==============================================================================
! Draw Wall Contour Outside
! ==============================================================================

"DrawContourLinesOutside":

	pen gs_wcont_line_pen
	line_property 0

	if curvedWall then
		R = sqr(leftRevealPnts[idxSillStartPlasterLeft][1]^2 + (leftRevealPnts[idxSillStartPlasterLeft][2] - WOD)^2) - offsetSill * signWallIsLeft

		if wallContourLineOffsetLeftOut > EPS then
			x1 = leftRevealPnts[idxSillStartPlasterLeft][1] + signWallIsLeft * wallContourLineOffsetLeftOut / cos(alpha-270)
			y1 = leftRevealPnts[idxSillStartPlasterLeft][2]
			x2 = x1 - signWallIsLeft * sin(alpha-270)
			y2 = y1 + signWallIsLeft * cos(alpha-270)
			xo = 0
			yo = WOD
			ro = R
			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			vx = cx
			vy = cy - WOD
		else
			if bNeedToOffsetSkins & bParalellInCurvedWalls then
				vx = leftRevealPnts[idxSillStartPlasterLeft][1]
				vy = -signWallIsLeft * sqr(R^2 - vx^2)
			else
				vx = leftRevealPnts[idxSillStartPlasterLeft][1]
				vy = leftRevealPnts[idxSillStartPlasterLeft][2] - WOD
			endif
		endif
		gosub 103	! Direction Angle
		alpha = angle


		if wallContourLineOffsetRightOut > EPS then
			x1 = rightRevealPnts[idxSillStartPlasterRight][1] - signWallIsLeft * wallContourLineOffsetRightOut / cos(beta-270)
			y1 = rightRevealPnts[idxSillStartPlasterRight][2]
			x2 = x1 - signWallIsLeft * sin(beta-270)
			y2 = y1 + signWallIsLeft * cos(beta-270)
			xo = 0
			yo = WOD
			ro = R
			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			vx = cx
			vy = cy - WOD
		else
			if bNeedToOffsetSkins & bParalellInCurvedWalls then
				vx = rightRevealPnts[idxSillStartPlasterRight][1]
				vy = -signWallIsLeft * sqr(R^2 - vx^2)
			else
				vx = rightRevealPnts[idxSillStartPlasterRight][1]
				vy = rightRevealPnts[idxSillStartPlasterRight][2] - WOD
			endif
		endif
		gosub 103	! Direction Angle
		beta = angle


		if bHasSidelightLeft then
			vx = -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_left_sL + thkPlasterAtSillSlLeft
			vy = -signWallIsLeft * sqr((radSill - offsetSill * signWallIsLeft)^2 - vx^2)
			gosub 103	! Direction Angle
			if bWallContourLineSl then
				line_type _wcont_line_left_sl_out
				if abs(angle - alpha) > EPS then
					arc2 0,WOD, R, min(angle,alpha), max(angle,alpha)
				endif
				if (vy + WOD) < -EPS then
					line2 vx, vy + WOD, vx, 0
					if abs(thkPlasterAtBoardSlLeft + gs_reveal_left_sL) > EPS then
						line2 vx, 0, -leftWidth + gs_sidelight_WHole_width_left, 0
					endif
				endif
			endif
			hotspot2 vx, vy + WOD, 11070
			alpha = angle
		endif
		if bHasSidelightRight then
			vx = rightWidth - gs_sidelight_WHole_width_right - gs_reveal_right_sR - thkPlasterAtSillSlRight
			vy = -signWallIsLeft * sqr((radSill - offsetSill * signWallIsLeft)^2 - vx^2)
			gosub 103	! Direction Angle
			if bWallContourLineSl then
				line_type _wcont_line_right_sl_out
				if abs(angle - beta) > EPS then
					arc2 0,WOD, R, min(angle,beta), max(angle,beta)
				endif
				if (vy + WOD) < -EPS then
					line2 vx, vy + WOD, vx, 0
					if abs(thkPlasterAtBoardSlRight + gs_reveal_right_sR) > EPS then
						line2 vx, 0, rightWidth - gs_sidelight_WHole_width_right, 0
					endif
				endif
			endif
			hotspot2 vx, vy + WOD, 11071
			beta = angle
		endif

! We have to draw this line!
!		if (gs_IsCurved & abs(R - radSill) < WIDO_SILL) | \
!			(not(gs_IsCurved) & WOD - R * signWallIsLeft < 0) | \
!			 not(isWindow) | WIDO_FRAME_THICKNESS < EPS then

			if bWallContourLine & abs(alpha - beta) > EPS then
				line_type gs_wcont_line_out
				arc2 0,WOD, R, min(alpha,beta), max(alpha,beta)
			endif
!		endif
	else
		if bNeedToOffsetSkins then
			pxL = leftRevealPnts[idxSillStartPlasterLeft][1] + bLeftCornerFunction * lx * offsetSill
			pyL = leftRevealPnts[idxSillStartPlasterLeft][2] + offsetSill

			pxR = rightRevealPnts[idxSillStartPlasterRight][1] - bRightCornerFunction * rx * offsetSill
			pyR = rightRevealPnts[idxSillStartPlasterRight][2] + offsetSill
		else
			pxL = leftRevealPnts[idxSillStartPlasterLeft][1]
			pyL = leftRevealPnts[idxSillStartPlasterLeft][2]

			pxR = rightRevealPnts[idxSillStartPlasterRight][1]
			pyR = rightRevealPnts[idxSillStartPlasterRight][2]
		endif

		if wallContourLineOffsetLeftOut > EPS then
			pxL = pxL + wallContourLineOffsetLeftOut
		endif
		if wallContourLineOffsetRightOut > EPS then
			pxR = pxR - wallContourLineOffsetRightOut
		endif

		if bHasSidelightLeft then
			px = -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_left_sL + thkPlasterAtSillSlLeft
			if bWallContourLineSl then
				line_type _wcont_line_left_sl_out
				line2 pxL,pyL, px, pyL
				if pyL < -EPS then
					line2 px, pyL, px, 0
				endif
				if abs(thkPlasterAtBoardSlLeft + gs_reveal_left_sL) > EPS then
					line2 px, 0, -leftWidth + gs_sidelight_WHole_width_left, 0
				endif
			endif
			hotspot2 px, pyL, 11070
			pxL = px
		endif
		if bHasSidelightRight then
			px = rightWidth - gs_sidelight_WHole_width_right - gs_reveal_right_sR - thkPlasterAtSillSlRight
			if bWallContourLineSl then
				line_type _wcont_line_right_sl_out
				line2 pxR,pyR, px, pyR
				if pyR < -EPS then
					line2 px, pyR, px, 0
				endif
				if abs(thkPlasterAtBoardSlRight + gs_reveal_right_sR) > EPS then
					line2 px, 0, rightWidth - gs_sidelight_WHole_width_right, 0
				endif
			endif
			hotspot2 px, pyR, 11071
			pxR = px
		endif

! We have to draw this line!
!		! We must draw this line in case of doors [not(isWindow)]
!		! and in case of window openings [where WIDO_FRAME_THICKNESS < EPS]
!		if (pyL < 0 & pyR < 0) | not(isWindow) | WIDO_FRAME_THICKNESS < EPS then
		if bWallContourLine then
			line_type gs_wcont_line_out
			line2 pxL,pyL, pxR,pyR
		endif
	endif
return


! ==============================================================================
! Draw Wall Contour Inside
! ==============================================================================

"DrawContourLinesInside":

	pen gs_wcont_line_pen
	line_property 0

	if curvedWall then
		R = sqr(leftRevealPnts[idxBoardEndPlasterLeft][1]^2 + (leftRevealPnts[idxBoardEndPlasterLeft][2] - WOD)^2) + offsetBoard * signWallIsLeft

		if wallContourLineOffsetLeftIn > EPS then
			x1 = leftRevealPnts[idxBoardEndPlasterLeft][1] + signWallIsLeft * wallContourLineOffsetLeftIn / cos(alpha-270)
			y1 = leftRevealPnts[idxBoardEndPlasterLeft][2]
			x2 = x1 - signWallIsLeft * sin(alpha-270)
			y2 = y1 + signWallIsLeft * cos(alpha-270)
			xo = 0
			yo = WOD
			ro = R
			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			vx = cx
			vy = cy - WOD
		else
			if bNeedToOffsetSkins & bParalellInCurvedWalls then
				vx = leftRevealPnts[idxBoardEndPlasterLeft][1]
				vy = -signWallIsLeft * sqr(R^2 - vx^2)
			else
				vx = leftRevealPnts[idxBoardEndPlasterLeft][1]
				vy = leftRevealPnts[idxBoardEndPlasterLeft][2] - WOD
			endif
		endif
		gosub 103	! Direction Angle
		alpha = angle

		if wallContourLineOffsetRightIn > EPS then
			x1 = rightRevealPnts[idxBoardEndPlasterRight][1] - signWallIsLeft * wallContourLineOffsetRightIn / cos(beta-270)
			y1 = rightRevealPnts[idxBoardEndPlasterRight][2]
			x2 = x1 - signWallIsLeft * sin(beta-270)
			y2 = y1 + signWallIsLeft * cos(beta-270)
			xo = 0
			yo = WOD
			ro = R
			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			vx = cx
			vy = cy - WOD
		else
			if bNeedToOffsetSkins & bParalellInCurvedWalls then
				vx = rightRevealPnts[idxBoardEndPlasterRight][1]
				vy = -signWallIsLeft * sqr(R^2 - vx^2)
			else
				vx = rightRevealPnts[idxBoardEndPlasterRight][1]
				vy = rightRevealPnts[idxBoardEndPlasterRight][2] - WOD
			endif
		endif
		gosub 103	! Direction Angle
		beta = angle

		if bHasSidelightLeft then
			vx = -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_double_innerLeft_sL + thkPlasterAtBoardSlLeft
			vy = -signWallIsLeft * sqr((radBoard + offsetBoard * signWallIsLeft)^2 - vx^2)
			gosub 103	! Direction Angle
			if bWallContourLineSl then
				line_type _wcont_line_left_sl_in
				if abs(angle - alpha) > EPS then
					arc2 0,WOD, R, min(angle,alpha), max(angle,alpha)
				endif
				if (vy + WOD) > WIDO_FRAME_THICKNESS then
					if abs(gs_reveal_double_innerLeft_sL + thkPlasterAtBoardSlLeft) > EPS then
						line2 vx, vy + WOD, vx, WIDO_FRAME_THICKNESS
						line2 vx - gs_reveal_double_innerLeft_sL - thkPlasterAtBoardSlLeft, WIDO_FRAME_THICKNESS, vx, WIDO_FRAME_THICKNESS
						line2 vx - gs_reveal_double_innerLeft_sL - thkPlasterAtBoardSlLeft, WIDO_FRAME_THICKNESS, vx - gs_reveal_double_innerLeft_sL - thkPlasterAtBoardSlLeft, 0
					else
						vy2 = max(0 - WOD, -signWallIsLeft * sqr((radSill - offsetSill * signWallIsLeft)^2 - vx^2))
						line2 vx, vy + WOD, vx, vy2 + WOD
					endif
				endif
			endif
			hotspot2 vx, vy + WOD, 11072
			alpha = angle
		endif
		if bHasSidelightRight then
			vx = rightWidth - gs_sidelight_WHole_width_right - gs_reveal_double_innerRight_sR - thkPlasterAtBoardSlRight
			vy = -signWallIsLeft * sqr((radBoard + offsetBoard * signWallIsLeft)^2 - vx^2)
			gosub 103	! Direction Angle
			if bWallContourLineSl then
				line_type _wcont_line_right_sl_in
				if abs(angle - beta) > EPS then
					arc2 0,WOD, R, min(angle,beta), max(angle,beta)
				endif
				if (vy + WOD) > WIDO_FRAME_THICKNESS then
					if abs(gs_reveal_double_innerRight_sR + thkPlasterAtBoardSlRight) > EPS then
						line2 vx, vy + WOD, vx, WIDO_FRAME_THICKNESS
						line2 vx + gs_reveal_double_innerRight_sR + thkPlasterAtBoardSlRight, WIDO_FRAME_THICKNESS, vx, WIDO_FRAME_THICKNESS
						line2 vx + gs_reveal_double_innerRight_sR + thkPlasterAtBoardSlRight, WIDO_FRAME_THICKNESS, vx + gs_reveal_double_innerRight_sR + thkPlasterAtBoardSlRight, 0
					else
						vy2 = max(0 - WOD, -signWallIsLeft * sqr((radSill - offsetSill * signWallIsLeft)^2 - vx^2))
						line2 vx, vy + WOD, vx, vy2 + WOD
					endif
				endif
			endif
			hotspot2 vx, vy + WOD, 11073
			beta = angle
		endif

!		if (gs_IsCurved & abs(R - radSill) < WIDO_SILL) | (not(gs_IsCurved) & WOD - R * signWallIsLeft < 0) then
			if bWallContourLine & abs(alpha - beta) > EPS then
				line_type gs_wcont_line_in
				arc2 0,WOD, R, min(alpha,beta), max(alpha,beta)
			endif
!		endif
	else
		if bNeedToOffsetSkins then
			pxL = leftRevealPnts[idxBoardEndPlasterLeft][1] - bLeftCornerFunction * lx * offsetBoard
			if bInclinedWall then
				pyL = leftRevealPnts[idxBoardEndPlasterLeft][2] - offsetBoard / incH
			else
				pyL = leftRevealPnts[idxBoardEndPlasterLeft][2] - offsetBoard
			endif

			pxR = rightRevealPnts[idxBoardEndPlasterRight][1] + bRightCornerFunction * rx * offsetBoard
			if bInclinedWall then
				pyR = rightRevealPnts[idxBoardEndPlasterRight][2] - offsetBoard / incH
			else
				pyR = rightRevealPnts[idxBoardEndPlasterRight][2] - offsetBoard
			endif
		else
			pxL = leftRevealPnts[idxBoardEndPlasterLeft][1]
			pyL = leftRevealPnts[idxBoardEndPlasterLeft][2]

			pxR = rightRevealPnts[idxBoardEndPlasterRight][1]
			pyR = rightRevealPnts[idxBoardEndPlasterRight][2]
		endif

		if wallContourLineOffsetLeftIn > EPS then
			pxL = pxL + wallContourLineOffsetLeftIn
			if bInclinedWall then
				pyL = pyL  + iDir * wallContourLineOffsetLeftIn * tan(WALL_INCL)
			endif
		endif
		if wallContourLineOffsetRightIn > EPS then
			pxR = pxR - wallContourLineOffsetRightIn
			if bInclinedWall then
				pyR = pyR  - iDir * wallContourLineOffsetRightIn * tan(WALL_INCL)
			endif
		endif

		if pyL > 0 & pyR > 0 then

			if bHasSidelightLeft then
				px = -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_double_innerLeft_sL + thkPlasterAtBoardSlLeft
				py = pyL + (pxL - px) * (pyL - pyR) / (-pxL + pxR)
				if bWallContourLineSl then
					line_type _wcont_line_left_sl_in
					line2 pxL,pyL, px, py
					if abs(gs_reveal_double_innerLeft_sL + thkPlasterAtBoardSlLeft) > EPS then
						line2 px, py, px, WIDO_FRAME_THICKNESS
						line2 px - gs_reveal_double_innerLeft_sL - thkPlasterAtBoardSlLeft, WIDO_FRAME_THICKNESS, px, WIDO_FRAME_THICKNESS
						line2 px - gs_reveal_double_innerLeft_sL - thkPlasterAtBoardSlLeft, WIDO_FRAME_THICKNESS, px - gs_reveal_double_innerLeft_sL - thkPlasterAtBoardSlLeft, 0
					else
						line2 px, py, px, 0
					endif
				endif
				hotspot2 px, py, 11072
				pxL = px
				pyL = py
			endif
			if bHasSidelightRight then
				px = rightWidth - gs_sidelight_WHole_width_right - gs_reveal_double_innerRight_sR - thkPlasterAtBoardSlRight
				py = pyR + (pxR - px) * (pyL - pyR) / (-pxL + pxR)
				if bWallContourLineSl then
					line_type _wcont_line_right_sl_in
					line2 pxR,pyR, px, py
					if abs(gs_reveal_double_innerRight_sR + thkPlasterAtBoardSlRight) > EPS then
						line2 px, py, px, WIDO_FRAME_THICKNESS
						line2 px + gs_reveal_double_innerRight_sR + thkPlasterAtBoardSlRight, WIDO_FRAME_THICKNESS, px, WIDO_FRAME_THICKNESS
						line2 px + gs_reveal_double_innerRight_sR + thkPlasterAtBoardSlRight, WIDO_FRAME_THICKNESS, px + gs_reveal_double_innerRight_sR + thkPlasterAtBoardSlRight, 0
					else
						line2 px, py, px, 0
					endif
				endif
				hotspot2 px, py, 11073
				pxR = px
				pyR = py
			endif

			if bWallContourLine then
				line_type gs_wcont_line_in
				line2 pxL,pyL, pxR,pyR
			endif
		endif
	endif
return


! ==============================================================================
! Head / Threshold Plan Symbol
! ==============================================================================

"DrawHeadThresholdPlanSymbol":

	line_type gs_head_symbol_line
	pen gs_head_symbol_pen

	if curvedWall & gs_IsCurved then
		if iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_NEGATIVE | iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE then
			R = sqr(leftRevealPnts[idxSillEndPlasterLeft][1]^2 + (leftRevealPnts[idxSillEndPlasterLeft][2] - WOD)^2) - thkFinishSkinCorrection * ySign

			vx = leftRevealPnts[idxSillEndPlasterLeft][1]
			vy = leftRevealPnts[idxSillEndPlasterLeft][2] - WOD
			gosub 103	! Direction Angle
			alpha = angle

			vx = rightRevealPnts[idxSillEndPlasterRight][1]
			vy = rightRevealPnts[idxSillEndPlasterRight][2] - WOD
			gosub 103	! Direction Angle
			beta = angle

			if abs(alpha - beta) > EPS then
				arc2 0,WOD, R, min(alpha,beta), max(alpha,beta)
			endif
		endif
		if iRevealType = REVEAL_SPLAYED | ((iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE) & WIDO_FRAME_THICKNESS > EPS) then
			R = sqr(leftRevealPnts[idxBoardStartRevealLeft][1]^2 + (leftRevealPnts[idxBoardStartRevealLeft][2] - WOD)^2) - thkFinishSkinCorrection * ySign

			vx = leftRevealPnts[idxBoardStartRevealLeft][1]
			vy = leftRevealPnts[idxBoardStartRevealLeft][2] - WOD
			gosub 103	! Direction Angle
			alpha = angle

			vx = rightRevealPnts[idxBoardStartRevealRight][1]
			vy = rightRevealPnts[idxBoardStartRevealRight][2] - WOD
			gosub 103	! Direction Angle
			beta = angle

			if abs(alpha - beta) > EPS then
				arc2 0,WOD, R, min(alpha,beta), max(alpha,beta)
			endif
		endif
	else
		if iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_NEGATIVE | iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE then
			line2 leftRevealPnts[idxSillEndRevealLeft][1],  leftRevealPnts[idxSillEndRevealLeft][2],
				 rightRevealPnts[idxSillEndRevealRight][1], rightRevealPnts[idxSillEndRevealRight][2]
		endif
		if iRevealType = REVEAL_SPLAYED | ((iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE) & WIDO_FRAME_THICKNESS > EPS) then
			line2 leftRevealPnts[idxBoardStartRevealLeft][1],  leftRevealPnts[idxBoardStartRevealLeft][2],
				 rightRevealPnts[idxBoardStartRevealRight][1], rightRevealPnts[idxBoardStartRevealRight][2]
		endif
	endif
return


! ==============================================================================
! Drawing the wall contour lines
! ==============================================================================

"DrawWallContourLines":

	dim tempLineSections[]

	call "WallContourDivider_WMCC" parameters AC_Wall_Direction_Type = AC_Wall_Direction_Type,
		radSill			= radSill,
		radBoard		= radBoard,
		WOD				= WOD,
		offsetSill		= offsetSill,
		offsetBoard		= offsetBoard,
		lineSections	= lineSections,
	returned_parameters tempLineSections

	numLineSections = round_int(vardim1(tempLineSections) / 7)
	dim lineSections[][7]
	idx = 0
	for i=1 to numLineSections
		for j=1 to 7
			lineSections[i][j] = tempLineSections[idx + j]
		next j
		idx = idx + 7
	next i

	nSectNum = vardim1(lineSections)

	for i = 1 to nSectNum

		iBitField = round_int(lineSections[i][LINE_ATTRIBUTES])

		if not(bittest(iBitField, LINE_ATTRIBUTES_DRAWCC)) then

			if not(gs_transom_display) then
				penIdx		= round_int(lineSections[i][LINE_PEN_IDX])
				lineTypeIdx	= round_int(lineSections[i][LINE_LTYPE_IDX])
			else
				penIdx		= gs_transom_display_pen
				lineTypeIdx	= gs_transom_display_linetype
			endif

			if penIdx > 0 then
				pen				penIdx
				line_type		lineTypeIdx
				line_property	LINE_PROPERTY_CONTOUR

				if bittest(iBitField, LINE_ATTRIBUTES_WALLSIDE) & curvedWall then

! Curved line-------------------------------------------------------------------

					R = sqr(lineSections[i][LINE_END_X]^2 + (lineSections[i][LINE_END_Y] - WOD)^2)

					vx = lineSections[i][LINE_BEG_X]
					vy = lineSections[i][LINE_BEG_Y] - WOD
					gosub 103	! Direction Angle
					alpha = angle

					vx = lineSections[i][LINE_END_X]
					vy = lineSections[i][LINE_END_Y] - WOD
					gosub 103	! Direction Angle
					beta = angle

					if abs(alpha - beta) > EPS then
						if bittest(iBitField, LINE_ATTRIBUTES_GDLLINE) then
							if not(gs_transom_display) then
								arc2 0,WOD, R, min(alpha,beta), max(alpha,beta)
							endif
						endif
						if bittest(iBitField, LINE_ATTRIBUTES_WALLLINE) then
!!							if (GLOB_PREVIEW_MODE = 0) then
!!								arc2 0,WOD, R, min(alpha,beta), max(alpha,beta)
!!							endif
							wallarc2 0,WOD, R, min(alpha,beta), max(alpha,beta)
						endif
					endif

				else

! Straight line-----------------------------------------------------------------

					if bittest(iBitField, LINE_ATTRIBUTES_GDLLINE) then
						if not(gs_transom_display) then
							line2	lineSections[i][LINE_BEG_X], lineSections[i][LINE_BEG_Y],
									lineSections[i][LINE_END_X], lineSections[i][LINE_END_Y]
						endif
					endif

					if bittest(iBitField, LINE_ATTRIBUTES_WALLLINE) & AC_WallType <> 2 then
!!						if (GLOB_PREVIEW_MODE = 0) then
!!							line2	lineSections[i][LINE_BEG_X], lineSections[i][LINE_BEG_Y],
!!									lineSections[i][LINE_END_X], lineSections[i][LINE_END_Y]
!!						endif
						wallline2	lineSections[i][LINE_BEG_X], lineSections[i][LINE_BEG_Y],
									lineSections[i][LINE_END_X], lineSections[i][LINE_END_Y]
					endif
				endif
			endif
		endif
	next i
return


! ===============================================================================
!	New Wallhole Symbol (SWE symbol)
! ===============================================================================

"DrawSWENewWallholeSymbol":

	openingWidth	= leftWidth + rightWidth

	fill gs_new_symb_fill

	if abs(WIDO_ORIG_DIST) < EPS then					!!! Straight wall

		mul2 1,-1

		if ABS(WALL_INCL) < EPS then

			WALLBLOCK2 4, 6+16+32, gs_new_symb_pen_Fg, gs_new_symb_pen_Bg,
						0, 0, 0,
						-openingWidth/2, WIDO_SILL, 32,
						-openingWidth/2 - gs_new_symb_width_r, WIDO_SILL, 32,
						-openingWidth/2 - gs_new_symb_width_r, WIDO_SILL-WALL_THICKNESS, 32,
						-openingWidth/2, WIDO_SILL-WALL_THICKNESS, 32
			WALLBLOCK2 4, 6+16+32, gs_new_symb_pen_Fg, gs_new_symb_pen_Bg,
						0, 0, 0,
						openingWidth/2, WIDO_SILL, 32,
						openingWidth/2 + gs_new_symb_width_l, WIDO_SILL, 32,
						openingWidth/2 + gs_new_symb_width_l, WIDO_SILL-WALL_THICKNESS, 32,
						openingWidth/2, WIDO_SILL-WALL_THICKNESS, 32

			if WALL_SKINS_NUMBER = 0 then
				pen WALL_SECT_PEN
				LINE_TYPE 1
			else
				if abs(SYMB_ROTANGLE-180) < EPS then
					pen WALL_SKINS_PARAMS[1][7]
					LINE_TYPE WALL_SKINS_PARAMS[1][8]
				else
					pen WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][9]
					LINE_TYPE WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][10]
				endif
			endif

			LINE_PROPERTY 2

			WALLLINE2 openingWidth/2, WIDO_SILL, openingWidth/2 + gs_new_symb_width_l, WIDO_SILL
			WALLLINE2 -openingWidth/2, WIDO_SILL, -openingWidth/2 - gs_new_symb_width_r, WIDO_SILL


			if WALL_SKINS_NUMBER <> 0 then
				if abs(SYMB_ROTANGLE-180) < EPS then
					pen WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][9]
					LINE_TYPE WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][10]
				else
					pen WALL_SKINS_PARAMS[1][7]
					LINE_TYPE WALL_SKINS_PARAMS[1][8]
				endif
			endif

			WALLLINE2 openingWidth/2, WIDO_SILL-WALL_THICKNESS, openingWidth/2 + gs_new_symb_width_l, WIDO_SILL-WALL_THICKNESS
			WALLLINE2 -openingWidth/2, WIDO_SILL-WALL_THICKNESS, -openingWidth/2 - gs_new_symb_width_r, WIDO_SILL-WALL_THICKNESS

		else								!!!inclined wall


			if SYMB_MIRRORED exor abs(SYMB_ROTANGLE) < EPS then
				incl_sign = -1
			else
				incl_sign = 1
			endif

			if WIDO_REVEAL_SIDE then
				mul2 1,-1
				add2 0, WALL_THICKNESS - 2*WIDO_SILL
			endif

			WALLBLOCK2 4, 6+16+32, gs_new_symb_pen_Fg, gs_new_symb_pen_Bg,
						0, 0, 0,
						-openingWidth/2, WIDO_SILL + WIDO_REVEAL_SIDE * incl_sign * tan(WALL_INCL) * openingWidth/2, 32,
						-openingWidth/2 - gs_new_symb_width_r, WIDO_SILL + WIDO_REVEAL_SIDE * incl_sign * tan(WALL_INCL) * (openingWidth/2 + gs_new_symb_width_r), 32,
						-openingWidth/2 - gs_new_symb_width_r, WIDO_SILL-WALL_THICKNESS - not(WIDO_REVEAL_SIDE) * incl_sign * tan(WALL_INCL) * (openingWidth/2 + gs_new_symb_width_r), 32,
						-openingWidth/2, WIDO_SILL-WALL_THICKNESS - not(WIDO_REVEAL_SIDE) * incl_sign * tan(WALL_INCL) * openingWidth/2, 32

			WALLBLOCK2 4, 6+16+32, gs_new_symb_pen_Fg, gs_new_symb_pen_Bg,
						0, 0, 0,
						openingWidth/2, WIDO_SILL - WIDO_REVEAL_SIDE * incl_sign * tan(WALL_INCL) * openingWidth/2, 32,
						openingWidth/2 + gs_new_symb_width_l, WIDO_SILL - WIDO_REVEAL_SIDE * incl_sign * tan(WALL_INCL) * (openingWidth/2 + gs_new_symb_width_l), 32,
						openingWidth/2 + gs_new_symb_width_l, WIDO_SILL-WALL_THICKNESS + not(WIDO_REVEAL_SIDE) * incl_sign * tan(WALL_INCL) * (openingWidth/2 + gs_new_symb_width_l), 32,
						openingWidth/2, WIDO_SILL-WALL_THICKNESS + not(WIDO_REVEAL_SIDE) * incl_sign * tan(WALL_INCL) * openingWidth/2, 32

			if WALL_SKINS_NUMBER = 0 then
				pen WALL_SECT_PEN
				LINE_TYPE 1
			else
				if abs(SYMB_ROTANGLE-180) < EPS then
					pen WALL_SKINS_PARAMS[1][7]
					LINE_TYPE WALL_SKINS_PARAMS[1][8]
				else
					pen WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][9]
					LINE_TYPE WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][10]
				endif
			endif

			LINE_PROPERTY 2


			WALLLINE2	-openingWidth/2, WIDO_SILL + WIDO_REVEAL_SIDE * incl_sign * tan(WALL_INCL) * openingWidth/2,
						-openingWidth/2 - gs_new_symb_width_r, WIDO_SILL + WIDO_REVEAL_SIDE * incl_sign * tan(WALL_INCL) * (openingWidth/2 + gs_new_symb_width_r)
			WALLLINE2	openingWidth/2, WIDO_SILL - WIDO_REVEAL_SIDE * incl_sign * tan(WALL_INCL) * openingWidth/2,
						openingWidth/2 + gs_new_symb_width_l, WIDO_SILL - WIDO_REVEAL_SIDE * incl_sign * tan(WALL_INCL) * (openingWidth/2 + gs_new_symb_width_l)

			if WALL_SKINS_NUMBER <> 0 then
				if abs(SYMB_ROTANGLE-180) < EPS then
					pen WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][9]
					LINE_TYPE WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][10]
				else
					pen WALL_SKINS_PARAMS[1][7]
					LINE_TYPE WALL_SKINS_PARAMS[1][8]
				endif
			endif

			WALLLINE2	-openingWidth/2 - gs_new_symb_width_r, WIDO_SILL-WALL_THICKNESS - not(WIDO_REVEAL_SIDE) * incl_sign * tan(WALL_INCL) * (openingWidth/2 + gs_new_symb_width_r),
						-openingWidth/2, WIDO_SILL-WALL_THICKNESS - not(WIDO_REVEAL_SIDE) * incl_sign * tan(WALL_INCL) * openingWidth/2
			WALLLINE2	openingWidth/2 + gs_new_symb_width_l, WIDO_SILL-WALL_THICKNESS + not(WIDO_REVEAL_SIDE) * incl_sign * tan(WALL_INCL) * (openingWidth/2 + gs_new_symb_width_l),
						openingWidth/2, WIDO_SILL-WALL_THICKNESS + not(WIDO_REVEAL_SIDE) * incl_sign * tan(WALL_INCL) * openingWidth/2

			if WIDO_REVEAL_SIDE then del 2

		endif


	else									!!!Curved wall

		if WIDO_REVEAL_SIDE exor abs(SYMB_ROTANGLE) < EPS then
			shf_sign = -1
		else
			shf_sign = 1
		endif


		if abs(SYMB_ROTANGLE-180) < EPS then
			shf_sign2 = 1
			frame_shf2 = WIDO_FRAME_THICKNESS
		else
			shf_sign2 = -1
			frame_shf2 = 0
		endif

		if WIDO_REVEAL_SIDE then
			frame_shf = WIDO_SILL + WIDO_FRAME_THICKNESS !/ COS(leftAlfa) - WIDO_FRAME_THICKNESS
		else
			frame_shf = WIDO_SILL
		endif


		leftAlfa	= ATN((openingWidth/2) / (WIDO_ORIG_DIST + frame_shf2))
		rightAlfa	= ATN((openingWidth/2) / (WIDO_ORIG_DIST + frame_shf2))

		leftnewsymbAlfa	= ATN((openingWidth/2 + gs_new_symb_width_r) / (WIDO_ORIG_DIST + frame_shf2))
		rightnewsymbAlfa= ATN((openingWidth/2 + gs_new_symb_width_l) / (WIDO_ORIG_DIST + frame_shf2))



		radOppSide = SQR( ((openingWidth/2)^2) + (WIDO_ORIG_DIST^2) ) + shf_sign * frame_shf

		if not (WIDO_REVEAL_SIDE) then
			mul2 1,-1
		else
			add2 0,WIDO_FRAME_THICKNESS
		endif

		ADD2 0, WIDO_ORIG_DIST

		WALLBLOCK2 5, 6+16+32, gs_new_symb_pen_Fg, gs_new_symb_pen_Bg,
					0, 0, 0,
					0,0, 901,
					SIN(leftAlfa) * (radOppSide - shf_sign * WALL_THICKNESS), shf_sign2 * COS(leftAlfa) * (radOppSide - shf_sign * WALL_THICKNESS), 1,
					SIN(leftnewsymbAlfa) * (radOppSide - shf_sign * WALL_THICKNESS), shf_sign2 * COS(leftnewsymbAlfa) * (radOppSide - shf_sign * WALL_THICKNESS), 3001,
					SIN(leftnewsymbAlfa) * radOppSide, shf_sign2 * COS(leftnewsymbAlfa) * radOppSide, 1,
					SIN(leftAlfa) * radOppSide, shf_sign2 * COS(leftAlfa) * radOppSide, 3001

		WALLBLOCK2 5, 6+16+32, gs_new_symb_pen_Fg, gs_new_symb_pen_Bg,
					0, 0, 0,
					0,0, 901,
					-1 * SIN(rightAlfa) * (radOppSide - shf_sign * WALL_THICKNESS), shf_sign2 * COS(rightAlfa) * (radOppSide - shf_sign * WALL_THICKNESS), 1,
					-1 * SIN(rightnewsymbAlfa) * (radOppSide - shf_sign * WALL_THICKNESS), shf_sign2 * COS(rightnewsymbAlfa) * (radOppSide - shf_sign * WALL_THICKNESS), 3001,
					-1 * SIN(rightnewsymbAlfa) * radOppSide, shf_sign2 * COS(rightnewsymbAlfa) * radOppSide, 1,
					-1 * SIN(rightAlfa) * radOppSide, shf_sign2 * COS(rightAlfa) * radOppSide, 3001


			if WALL_SKINS_NUMBER = 0 then
				pen WALL_SECT_PEN
				LINE_TYPE 1
			else
				if WIDO_REVEAL_SIDE exor abs(SYMB_ROTANGLE) < EPS then
					pen WALL_SKINS_PARAMS[1][7]
					LINE_TYPE WALL_SKINS_PARAMS[1][8]
				else
					pen WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][9]
					LINE_TYPE WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][10]
				endif
			endif

			LINE_PROPERTY 2

			if abs(SYMB_ROTANGLE-180) < EPS then
				WALLARC2 0, 0, radOppSide - shf_sign * WALL_THICKNESS, shf_sign2 * 90+leftnewsymbAlfa, shf_sign2 * 90+leftAlfa
				WALLARC2 0, 0, radOppSide - shf_sign * WALL_THICKNESS, shf_sign2 * 90-rightAlfa, shf_sign2 * 90-rightnewsymbAlfa
			else
				WALLARC2 0, 0, radOppSide - shf_sign * WALL_THICKNESS, shf_sign2 * 90+leftAlfa, shf_sign2 * 90+leftnewsymbAlfa
				WALLARC2 0, 0, radOppSide - shf_sign * WALL_THICKNESS, shf_sign2 * 90-rightnewsymbAlfa, shf_sign2 * 90-rightAlfa
			endif



			if WALL_SKINS_NUMBER <> 0 then
				if WIDO_REVEAL_SIDE exor abs(SYMB_ROTANGLE) < EPS then
					pen WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][9]
					LINE_TYPE WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][10]
				else
					pen WALL_SKINS_PARAMS[1][7]
					LINE_TYPE WALL_SKINS_PARAMS[1][8]
				endif
			endif


			if abs(SYMB_ROTANGLE-180) < EPS then
				WALLARC2 0, 0, radOppSide, shf_sign2 * 90+leftnewsymbAlfa, shf_sign2 * 90+leftAlfa
				WALLARC2 0, 0, radOppSide, shf_sign2 * 90-rightAlfa, shf_sign2 * 90-rightnewsymbAlfa
			else
				WALLARC2 0, 0, radOppSide, shf_sign2 * 90+leftAlfa, shf_sign2 * 90+leftnewsymbAlfa
				WALLARC2 0, 0, radOppSide, shf_sign2 * 90-rightnewsymbAlfa, shf_sign2 * 90-rightAlfa
			endif

			del 1

			del 1

	endif
return


! ==============================================================================
! Mounting Frame
! ==============================================================================

"DrawMountingFrame":

	pen gs_mountingFrame_pen_cont
	fill gs_mountingFrame_fill
	line_property LINE_PROPERTY_GENERIC
	line_type 1

	if not(gs_stack_left | bLeftCornerFunction) then
		if abs(gs_mountingFrame_depth) > EPS then
			poly2_b 4, 1+2+4+64, gs_mountingFrame_pen_fg, gs_mountingFrame_pen_bg,
				-leftWidth,									-gs_mountingFrame_depth,	1+32,
				-leftWidth + gs_mountingFrame_width_left,	-gs_mountingFrame_depth,	1+32,
				-leftWidth + gs_mountingFrame_width_left,	0,							1+32,
				-leftWidth,									0,							1+32

			if lod2D_MountingFrame = 2 then
				line2 -leftWidth,0,-leftWidth + gs_mountingFrame_width_left,-gs_mountingFrame_depth
				line2 -leftWidth,-gs_mountingFrame_depth,-leftWidth + gs_mountingFrame_width_left,0
			endif
		endif
		pxL = -leftWidth + gs_mountingFrame_width_left

		hotspot2 pxL, 0, 11050
	else
		pxL = -leftWidth - bLeftCornerFunction * lx * (WIDO_FRAME_THICKNESS + gs_mountingFrame_depth)
	endif

	if not(gs_stack_right | bRightCornerFunction) then
		if abs(gs_mountingFrame_depth) > EPS then
			poly2_b 4, 1+2+4+64, gs_mountingFrame_pen_fg, gs_mountingFrame_pen_bg,
				rightWidth,									-gs_mountingFrame_depth,	1+32,
				rightWidth - gs_mountingFrame_width_right,	-gs_mountingFrame_depth,	1+32,
				rightWidth - gs_mountingFrame_width_right,	0,							1+32,
				rightWidth,									0,							1+32

			if lod2D_MountingFrame = 2 then
				line2 rightWidth,0,rightWidth - gs_mountingFrame_width_right,-gs_mountingFrame_depth
				line2 rightWidth,-gs_mountingFrame_depth,rightWidth - gs_mountingFrame_width_right,0
			endif
		endif
		pxR = rightWidth - gs_mountingFrame_width_right

		hotspot2 pxR, 0, 11051
	else
		pxR = rightWidth + bRightCornerFunction * rx * (WIDO_FRAME_THICKNESS + gs_mountingFrame_depth)
	endif

	pen gs_mountingFrame_pen_view
	line_property LINE_PROPERTY_GENERIC
	line2 pxL,-gs_mountingFrame_depth, pxR,-gs_mountingFrame_depth
	if bMountingFrame_DrawInsideLine then
		line2 pxL,0, pxR,0
	endif
return


! ==============================================================================
! Line - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	x11,y11, x12,y12	line #1
!	x21,y21, x22,y22	line #2
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = valid intersection point
!	cx, cy:				intersection point
! ==============================================================================

100:
	lliDiv = (x11-x12) * (y21-y22) - (y11-y12) * (x21-x22)

	if abs(lliDiv) > EPS then
		! Intersection

		temp1 = x11 * y12 - y11 * x12
		temp2 = x21 * y22 - y21 * x22

		tempx = temp1 * (x21-x22) - (x11-x12) * temp2
		tempy = temp1 * (y21-y22) - (y11-y12) * temp2

		state = 1
		cx = (tempx / lliDiv)
		cy = (tempy / lliDiv)
	else
		! No Intersection
		state = 0
		cx = 0
		cy = 0
	endif
return


! ==============================================================================
! Circle - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	xo,yo,ro:			circle
!	x1,y1, x2,y2		line
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = one intersection point (tangential line)
!						2 = two intersection points
!	xa, ya:				intersection point #1
!	xb, yb:				intersection point #2
! ==============================================================================

101:
	tempX1 = x1 - xo: tempY1 = y1 - yo
	tempX2 = x2 - xo: tempY2 = y2 - yo

	if abs(tempX2 - tempX1) < EPS then
		if abs(ro - abs(tempX1)) < EPS then
			state = 1
			xa = tempX1
			ya = 0
			xb = tempX1
			yb = 0
		else
			if abs(ro) - abs(tempX1) < 0 then
				state = 0: xa = 0: ya = 0: xb = 0: yb = 0
			else
				state = 2
				xa = tempX1
				ya = sqr(ro^2 - tempX1^2)
				xb = tempX1
				yb = -sqr(ro^2 - tempX1^2)
			endif
		endif
	else
		kf = (tempY2 - tempY1) / (tempX2 - tempX1)
		ad = 1 + kf^2
		bd = 2 * tempY1 * kf - 2 * tempX1 * kf^2
		cd = tempY1^2 - 2 * tempX1 * tempY1 * kf + tempX1^2 * kf^2 - ro^2

		if bd^2 - 4 * ad * cd < 0 then
			state = 0: xa = 0: ya = 0: xb = 0: yb = 0
		else
			xa = (-bd + sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			ya = tempY1 + (xa - tempX1) * kf
			xb = (-bd - sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			yb = tempY1 + (xb - tempX1) * kf

			if abs(xa - xb) < EPS then state = 1 else state = 2
		endif
	endif

	if state = 2 then
		da = sqr((tempX1 - xa)^2 + (tempY1 - ya)^2)
		db = sqr((tempX1 - xb)^2 + (tempY1 - yb)^2)

		if db < da then
			xxo = xa: yyo = ya
			xa = xb:  ya = yb
			xb = xxo: yb = yyo
		endif
	endif

	xa = xa + xo: ya = ya + yo
	xb = xb + xo: yb = yb + yo
return


! ==============================================================================
! Select good intersection point after Circle - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	state:				intersection status
!	wallIsLeft:
!	xa, ya:				intersection point #1
!	xb, yb:				intersection point #2
!
! Returned variables:
!	cx, cy:				selected intersection point
! ==============================================================================

102:
	cx = 0
	cy = 0
	if state = 1 then
		cx = xa
		cy = ya
	endif
	if state = 2 then
		if wallIsLeft then
			if ya < yb then
				cx = xa
				cy = ya
			else
				cx = xb
				cy = yb
			endif
		else
			if ya > yb then
				cx = xa
				cy = ya
			else
				cx = xb
				cy = yb
			endif
		endif
	endif
return


! ==============================================================================
! Direction Angle
! ------------------------------------------------------------------------------
! Input variables:
!	vx, vy:				vector
!
! Returned variables:
!	alpha:				selected intersection point
! ==============================================================================

103:

if abs(vx) < EPS & abs(vy) < EPS then
	angle = 0
	return
endif

if abs(vx) < EPS then
	if vy > 0 then
		angle = 90
	else
		angle = 270
	endif
else
	angle = atn(vy / vx)
	if vx >= 0 then
		if angle < 0 then
			angle = angle + 360
		endif
	else
		angle = 180 + angle
	endif
endif

return




1000:
! ==============================================================================
! Get GDL Polygon
! ------------------------------------------------------------------------------
! Input variables:
!	polygonID:			Polygon index
!
! Returned variables:
!	GDL stack:			GDL polygon
! ==============================================================================

	_bValidPoly = 1

	dim resVertices[]
	numVertices = callfunction(ch, "GETVERTICES", polygonID, resVertices)
	numVertices = numVertices / 3

	dim contArr[]
	numContours = callfunction(ch, "GETCONTOURENDS", polygonID, contArr)

!!	dim inhEdgeInfos[]
!!	numEdges = callfunction(ch, "GetInhEdgeInfos", polygonID, inhEdgeInfos)

	for contIndex = 1 to numContours

		if contIndex = 1 then
			begIdx = 0
		else
			begIdx = contArr[contIndex] - 1
		endif
		if contIndex = numContours then
			endIdx = numVertices - 1
		else
			endIdx = contArr[contIndex + 1] - 2
		endif

		bClosed = 0
		bStartWithLast = 0

		index = endIdx * 3
		ac2gdl_lpx = resVertices[index + 1]
		ac2gdl_lpy = resVertices[index + 2]
		ac2gdl_lpa = resVertices[index + 3]
!!		edgeInfo	= inhEdgeInfos[endIdx + 1]

		if abs(ac2gdl_lpa) > EPS then
			if abs(ac2gdl_lpa - 360) > EPS then			!!! Valid Curved contour line (arc angle <> 360)
				put ac2gdl_lpx, ac2gdl_lpy, 1
				bStartWithLast = 1
			else										!!! Invalid Curved contour line (arc angle = 360)
				_bValidPoly = 0
			endif
		endif

		for vertIndex = begIdx to endIdx
			index = vertIndex * 3
			ac2gdl_px = resVertices[index + 1]
			ac2gdl_py = resVertices[index + 2]
			ac2gdl_pa = resVertices[index + 3]

			if vertIndex = begIdx then
				if bStartWithLast then
					ac2gdl_spx = ac2gdl_lpx
					ac2gdl_spy = ac2gdl_lpy
				else
					ac2gdl_spx = ac2gdl_px
					ac2gdl_spy = ac2gdl_py
				endif
			endif

			if abs(ac2gdl_lpa) > EPS then			!!! Curved contour line
				ac2gdl_mx = (ac2gdl_px + ac2gdl_lpx) / 2
				ac2gdl_my = (ac2gdl_py + ac2gdl_lpy) / 2
				ac2gdl_ratio = 1 / 2 / tan (ac2gdl_lpa / 2)

				ac2gdl_cx = ac2gdl_mx - ac2gdl_ratio * (ac2gdl_py - ac2gdl_lpy)	! Arc center
				ac2gdl_cy = ac2gdl_my + ac2gdl_ratio * (ac2gdl_px - ac2gdl_lpx)

				if abs(ac2gdl_lpa - 360) > EPS then
					put ac2gdl_cx,	ac2gdl_cy,	900,
						0,			ac2gdl_lpa,	4001
				endif
			endif

			if vertIndex > begIdx & bStartWithLast & abs(ac2gdl_spx - ac2gdl_px) < EPS & abs(ac2gdl_spy - ac2gdl_py) < EPS then
				put ac2gdl_px, ac2gdl_py, -1
				bClosed = 1
			else
				if vertIndex < endIdx | not(bStartWithLast) then
					put ac2gdl_px, ac2gdl_py, 1
				endif
			endif

			ac2gdl_lpx = ac2gdl_px
			ac2gdl_lpy = ac2gdl_py
			ac2gdl_lpa = ac2gdl_pa
!!			edgeInfo	= inhEdgeInfos[vertIndex + 1]
		next vertIndex

		if not(bClosed) & numContours > 1 then	! Close the polygon if it has holes
			put ac2gdl_spx, ac2gdl_spy, -1
		endif

		if not(_bValidPoly) then
			dim _invalidPoints[]
			for ii = 1 to nsp
				_invalidPoints[ii] = get(1)
			next ii

			contIndex = numContours
		endif
	next contIndex
return


1001:
! ==============================================================================
! Draw one polygon contour line
! ------------------------------------------------------------------------------
! Input variables:
!	polygonID:				Polygon ID
!	lineAttributes[][3]:	Line attribute array
!								[][1] = pen color
!								[][2] = line type
!								[][3] = line property
!								[][4] = additional line attributes
! bPutHotsopts:				Draw hotspots (boolean)
! polyUnID:					Hotspot start unID
! ==============================================================================

	dim resVertices[]
	numVertices = callfunction(ch, "GetVertices", polygonID, resVertices)
	numVertices = numVertices / 3

	dim contArr[]
	numContours = callfunction(ch, "GetContourEnds", polygonID, contArr)

	dim inhEdgeInfos[]
	numEdges = callfunction(ch, "GetInhEdgeInfos", polygonID, inhEdgeInfos)

	for contIndex = 1 to numContours

		if contIndex = 1 then
			begIdx = 0
		else
			begIdx = contArr[contIndex] - 1
		endif
		if contIndex = numContours then
			endIdx = numVertices - 1
		else
			endIdx = contArr[contIndex + 1] - 2
		endif

		bClosed = 0
		bStartWithLast = 0

		index = endIdx * 3
		lastVertX	= resVertices[index + 1]
		lastVertY	= resVertices[index + 2]
		lastVertA	= resVertices[index + 3]
		edgeInfo	= inhEdgeInfos[endIdx + 1]

		for vertIndex = begIdx to endIdx

			index = vertIndex * 3
			actVertX = resVertices[index + 1]
			actVertY = resVertices[index + 2]
			actVertA = resVertices[index + 3]

!!!text2	(lastVertX + actVertX) / 2,
!!!		(lastVertY + actVertY) / 2,
!!!		edgeInfo

!!!ccc=ccc+0.1
!!!circle2 lastVertX, lastVertY, ccc
!!!circle2 actVertX, actVertY, ccc

			if edgeInfo > 0 & edgeInfo <= vardim1(lineAttributes) then

				if lineAttributes[edgeInfo][1] > 0 then
					if not(gs_transom_display) then
						pen				lineAttributes[edgeInfo][1]
						line_type		lineAttributes[edgeInfo][2]
					else
						pen				gs_transom_display_pen
						line_type		gs_transom_display_linetype
					endif

					line_property	lineAttributes[edgeInfo][3]
					iAttributes = round_int(lineAttributes[edgeInfo][4])

					if abs(lastVertA) > EPS then
						ac2gdl_mx = (actVertX + lastVertX) / 2
						ac2gdl_my = (actVertY + lastVertY) / 2
						ac2gdl_ratio = 1 / 2 / tan (lastVertA / 2)

						ac2gdl_cx = ac2gdl_mx - ac2gdl_ratio * (actVertY - lastVertY)	! Arc center
						ac2gdl_cy = ac2gdl_my + ac2gdl_ratio * (actVertX - lastVertX)
						ac2gdl_rad = sqr((ac2gdl_cx - actVertX)^2 + (ac2gdl_cy - actVertY)^2)

						vx = actVertX - ac2gdl_cx
						vy = actVertY - ac2gdl_cy
						gosub 103	! Direction Angle
						alpha = angle

						vx = lastVertX - ac2gdl_cx
						vy = lastVertY - ac2gdl_cy
						gosub 103	! Direction Angle
						beta = angle

						if abs(alpha - beta) > EPS then
							if abs(alpha - beta) > 180 + EPS then
								angleStart	= max(alpha,beta)
								angleEnd	= min(alpha,beta)
							else
								angleStart	= min(alpha,beta)
								angleEnd	= max(alpha,beta)
							endif
							if bittest(iAttributes, LINE_ATTRIBUTES_GDLLINE) then
								if not(gs_transom_display) then 			! Not drawed when Display as Transom is ON
									arc2 ac2gdl_cx,	ac2gdl_cy, ac2gdl_rad, angleStart, angleEnd
								endif
							endif
							if bittest(iAttributes, LINE_ATTRIBUTES_WALLLINE) then
!!								if (GLOB_PREVIEW_MODE = 0) then
!!									arc2 ac2gdl_cx,	ac2gdl_cy, ac2gdl_rad, angleStart, angleEnd
!!								endif
								wallarc2 ac2gdl_cx,	ac2gdl_cy, ac2gdl_rad, angleStart, angleEnd
							endif
						endif
					else
						if bittest(iAttributes, LINE_ATTRIBUTES_GDLLINE) then
							if not(gs_transom_display) then 			! Not drawed when Display as Transom is ON
								line2 lastVertX, lastVertY, actVertX, actVertY
							endif
						endif
						if bittest(iAttributes, LINE_ATTRIBUTES_WALLLINE) then
!!							if (GLOB_PREVIEW_MODE = 0) then
!!								line2 lastVertX, lastVertY, actVertX, actVertY
!!							endif
							wallline2 lastVertX, lastVertY, actVertX, actVertY
						endif
					endif
				endif
			endif

			if bPutHotsopts & edgeInfo <> inhEdgeInfos[vertIndex + 1] then
				hotspot2 actVertX, actVertY, polyUnID: polyUnID = polyUnID + 1
!ccc=ccc+0.003
!circle2 actVertX, actVertY,ccc
			endif

			lastVertX	= actVertX
			lastVertY	= actVertY
			lastVertA	= actVertA
			edgeInfo	= inhEdgeInfos[vertIndex + 1]

		next vertIndex
	next contIndex
return


]]>
</Script_2D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_1D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[

EPS = 0.0001

! iRevealType:
REVEAL_EDGE				= 0
REVEAL_NO				= 1
REVEAL_POSITIVE			= 2
REVEAL_NEGATIVE			= 3
REVEAL_SLANTED			= 4
REVEAL_SPLAYED			= 5
REVEAL_HISTORIC			= 6
REVEAL_DOUBLE			= 7
REVEAL_DOUBLE_SPLAYED	= 8
REVEAL_OUTSIDE_SPLAYED	= 9

! gs_reveal_type_bottom_int
REVEAL_BOTTOM_UNIFORM	= 1
REVEAL_BOTTOM_NO		= 2
REVEAL_BOTTOM_POSITIVE	= 3
REVEAL_BOTTOM_NEGATIVE	= 4

! iWindowShape:
SHAPE_RECTANGULAR			= 0
SHAPE_ARCHED				= 1
SHAPE_ROUND					= 2
SHAPE_EYEBROWS				= 3
SHAPE_HALFCIRCLE			= 4 	! straight side is horizontal
SHAPE_MULTISIDE				= 5
SHAPE_OCTAGONAL				= 6
SHAPE_HALFARCH				= 7
SHAPE_PENTAGON				= 8
SHAPE_QUARTERROUND			= 9
SHAPE_HALFROUND				= 10 	! straight side is vertical
SHAPE_TRAPEZOID				= 11
SHAPE_TRIANGLE				= 12
SHAPE_GOTHICARCH			= 13
SHAPE_ELLIPSEARCH			= 14
SHAPE_ROMBUS				= 15
SHAPE_HORSESHOE				= 16
SHAPE_OGEECENTERED			= 17
SHAPE_SARACENIC				= 18
SHAPE_T						= 19
SHAPE_HALF_T_LEFT			= 20
SHAPE_ARCHED_T				= 21
SHAPE_ARCHED_HALF_T_LEFT	= 22
SHAPE_PARALLELOGRAM			= 23
SHAPE_ELLIPSE				= 24
SHAPE_CORNER_TRIANGLE		= 25
SHAPE_QUARTERROUND_NOFRAME	= 26
SHAPE_HALF_T_RIGHT			= 27
SHAPE_ARCHED_HALF_T_RIGHT	= 28

! Line Property defines:
LINE_PROPERTY_GENERIC	= 0
LINE_PROPERTY_INNER		= 1
LINE_PROPERTY_CONTOUR	= 2

! gs_reveal_set_side:
REVEAL_SET_INSIDE	= 1
REVEAL_SET_OUTSIDE	= 2

! iClosureType:
CLOSURE_NO					= 0
CLOSURE_TRADITIONAL			= 1
CLOSURE_PREFABRICATED		= 2
CLOSURE_CUSTOM				= 3
CLOSURE_SOLID_WALL			= 4
CLOSURE_STUD_WALL			= 5
CLOSURE_STUD_WALL_SIDING	= 6
CLOSURE_BRICK_VENEER		= 7
CLOSURE_VARIABLE			= 8
CLOSURE_PLASTER_REVEAL	 			= 9
CLOSURE_INSULATED_REVEAL			= 10
CLOSURE_INSULATED_FOR_RENOVATION	= 11
CLOSURE_FINISH						= 12
CLOSURE_AIR_SPACE					= 13
CLOSURE_DUTCH_VARIABLE				= 14

! Wall Inset Sizes
PARAPET_SIZE_AUTO	= 1
PARAPET_SIZE_SYMM	= 2
PARAPET_SIZE_ASYMM	= 3

! Wall Inset Bottom at
PARAPET_BOTTOM_CURRENTSTORY	= 1
PARAPET_BOTTOM_WALLBASE		= 2

! iTypeDemolitionFill
RENOVATION_FILL_EXIST		= 1
RENOVATION_FILL_DEMOLISHED	= 2
RENOVATION_FILL_NEW			= 3
RENOVATION_FILL_NEW_FULL	= 4

! =============================================================================
! Reveal Points Indexes
! =============================================================================

idxSillStartRevealLeft		= iRevealPointsIdx[1]
idxSillEndRevealLeft		= iRevealPointsIdx[2]
idxFrameStartRevealLeft		= iRevealPointsIdx[3]
idxFrameEndRevealLeft		= iRevealPointsIdx[4]
idxBoardStartRevealLeft		= iRevealPointsIdx[5]
idxBoardEndRevealLeft		= iRevealPointsIdx[6]
idxSillStartPlasterLeft		= iRevealPointsIdx[7]
idxSillEndPlasterLeft		= iRevealPointsIdx[8]
idxBoardStartPlasterLeft	= iRevealPointsIdx[9]
idxBoardEndPlasterLeft		= iRevealPointsIdx[10]
idxSillStartRevealRight		= iRevealPointsIdx[11]
idxSillEndRevealRight		= iRevealPointsIdx[12]
idxFrameStartRevealRight	= iRevealPointsIdx[13]
idxFrameEndRevealRight		= iRevealPointsIdx[14]
idxBoardStartRevealRight	= iRevealPointsIdx[15]
idxBoardEndRevealRight		= iRevealPointsIdx[16]
idxSillStartPlasterRight	= iRevealPointsIdx[17]
idxSillEndPlasterRight		= iRevealPointsIdx[18]
idxBoardStartPlasterRight	= iRevealPointsIdx[19]
idxBoardEndPlasterRight		= iRevealPointsIdx[20]


! ==============================================================================

bInclinedWall	= (abs(WALL_INCL) > EPS)
curvedWall		= (abs(WIDO_ORIG_DIST) > EPS)
wallIsLeft		= (SYMB_ROTANGLE > EPS) exor WIDO_REVEAL_SIDE
signWallIsLeft	= wallIsleft - not(wallIsleft)

bSlantedInnerSide	= (iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE_SPLAYED)
bSlantedOuterSide	= (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED)
bHaveMountingFrame	= ((iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) & gs_mountingFrame)
bTShapedOpening =  (iWindowShape = SHAPE_T |\
					iWindowShape = SHAPE_HALF_T_LEFT |\
					iWindowShape = SHAPE_HALF_T_RIGHT |\
					iWindowShape = SHAPE_ARCHED_T |\
					iWindowShape = SHAPE_ARCHED_HALF_T_LEFT |\
					iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT)

bHasSidelightLeft = ((iWindowShape = SHAPE_T | \
					  iWindowShape = SHAPE_HALF_T_LEFT | \
					  iWindowShape = SHAPE_ARCHED_T | \
					  iWindowShape = SHAPE_ARCHED_HALF_T_LEFT) & (gs_sidelight_parapet_hgt_left > EPS))

bHasSidelightRight = ((iWindowShape = SHAPE_T | \
					  iWindowShape = SHAPE_HALF_T_RIGHT | \
					  iWindowShape = SHAPE_ARCHED_T | \
					  iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT) & (gs_sidelight_parapet_hgt_right > EPS))

bShapeSameRevealAngles = (iWindowShape = SHAPE_ARCHED |\
						  iWindowShape = SHAPE_ROUND |\
						  iWindowShape = SHAPE_EYEBROWS |\
						  iWindowShape = SHAPE_HALFCIRCLE |\
						  iWindowShape = SHAPE_MULTISIDE |\
						  iWindowShape = SHAPE_OCTAGONAL |\
						  iWindowShape = SHAPE_HALFARCH |\
						  iWindowShape = SHAPE_PENTAGON |\
						  iWindowShape = SHAPE_QUARTERROUND |\
						  iWindowShape = SHAPE_HALFROUND |\
						  iWindowShape = SHAPE_TRAPEZOID |\
						  iWindowShape = SHAPE_TRIANGLE |\
						  iWindowShape = SHAPE_GOTHICARCH |\
						  iWindowShape = SHAPE_ELLIPSEARCH |\
						  iWindowShape = SHAPE_ROMBUS |\
						  iWindowShape = SHAPE_HORSESHOE |\
						  iWindowShape = SHAPE_OGEECENTERED |\
						  iWindowShape = SHAPE_SARACENIC |\
						  iWindowShape = SHAPE_PARALLELOGRAM |\
						  iWindowShape = SHAPE_ELLIPSE |\
						  iWindowShape = SHAPE_CORNER_TRIANGLE |\
						  iWindowShape = SHAPE_QUARTERROUND_NOFRAME)

! ==============================================================================
! Compatibility
! ==============================================================================

openingWidth	= leftWidth + rightWidth
openingHeight	= B


! ==============================================================================

widoLeftJamb	= gs_reveal_left
widoRightJamb	= gs_reveal_right

leftJamb	= gs_reveal_left
rightJamb	= gs_reveal_right


! =============================================================================
! Restrictions for Window Shapes
! =============================================================================

widoHeadDepth = gs_reveal_top

if iWindowShape = SHAPE_ARCHED | iWindowShape = SHAPE_HALFCIRCLE then
	widoLeftJamb	= widoRightJamb
	widoHeadDepth	= widoRightJamb
	leftJamb		= rightJamb

	gs_right_oversize	= 0
	gs_left_oversize	= 0

	thkPlasterAtSillLeft	= thkPlasterAtSillRight
	thkPlasterAtSillTop		= thkPlasterAtSillRight
	thkPlasterAtBoardLeft	= thkPlasterAtBoardRight
	thkPlasterAtBoardTop	= thkPlasterAtBoardRight
endif

if GLOB_SCRIPT_TYPE = 3 then	! Only for 3D
	if iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_MULTISIDE | \
		iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ELLIPSE  then
		thkPlasterAtSillLeft		= 0
		thkPlasterAtBoardLeft		= 0
	endif

	if iWindowShape = SHAPE_HALFROUND then
		thkPlasterAtSillRight		= 0
		thkPlasterAtBoardRight		= 0
	endif

	if iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_MULTISIDE | \
		iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ELLIPSE  then
		thkPlasterAtSillTop			= 0
		thkPlasterAtBoardTop		= 0
	endif

	if iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_MULTISIDE | \
		iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ELLIPSE  then
		thkPlasterAtSillBottom		= 0
		thkPlasterAtBoardBottom		= 0
	endif
endif


! =============================================================================
! Calculations for Corner or horizontally Stacked Window
! =============================================================================

if bRightCornerFunction & abs(rightCornerAngle) > EPS then
	beta = atn ((rightConnWallThk * sin(rightCornerAngle)) / (WALL_THICKNESS + rightConnWallThk * cos(rightCornerAngle)))
	rx = 1 / tan(rightCornerAngle / 2)

	if rightCornerAngle > 180 then
		overSizeRight = max (0, WALL_THICKNESS / tan(360 - rightCornerAngle + beta) + WIDO_SILL / tan(rightCornerAngle / 2))
	else
		overSizeRight = (WIDO_FRAME_THICKNESS + WIDO_SILL) * rx + max (0, WALL_THICKNESS * tan(rightCornerAngle - beta - 90))
	endif
else
	overSizeRight	= gs_right_oversize
endif

if bLeftCornerFunction & abs(leftCornerAngle) > EPS then
	beta = atn ((leftConnWallThk * sin(leftCornerAngle)) / (WALL_THICKNESS + leftConnWallThk * cos(leftCornerAngle)))
	lx = 1 / tan(leftCornerAngle / 2)

	if leftCornerAngle > 180 then
		overSizeLeft = max (0, WALL_THICKNESS / tan(360 - leftCornerAngle + beta) + WIDO_SILL / tan(leftCornerAngle / 2))
	else
		overSizeLeft = (WIDO_FRAME_THICKNESS + WIDO_SILL) * lx + max (0, WALL_THICKNESS * tan(leftCornerAngle - beta - 90))
	endif
else
	overSizeLeft	= gs_left_oversize
endif

if gs_stack_right | (bRightCornerFunction & abs(rightCornerAngle) > EPS) then
	rightJamb				= 0
	widoRightJamb			= 0
	thkPlasterAtSillRight	= 0
	thkPlasterAtBoardRight	= 0
	revealInnerRight		= 0
	gs_reveal_right_angle	= 0
endif

if (bCornerWindow & SYMB_MIRRORED & gs_stack_right) | gs_stack_left | (bLeftCornerFunction & abs(leftCornerAngle) > EPS) then
	leftJamb				= 0
	widoLeftJamb			= 0
	thkPlasterAtSillLeft	= 0
	thkPlasterAtBoardLeft	= 0
	revealInnerLeft			= 0
	gs_reveal_left_angle	= 0
endif

upperJamb = not(gs_stack_top)    * gs_reveal_top
lowerJamb = not(gs_stack_bottom) * gs_reveal_bottom

overSizeLowerOriginal = overSizeLower

overSizeUpper = gs_upper_oversize
overSizeLower = gs_lower_oversize


if iWindowShape = SHAPE_ARCHED then
	overSizeLeft	= 0
	overSizeRight	= 0
	overSizeUpper	= 0
endif

if not(isWindow) then
	thkPlasterAtSillBottom		= 0
	thkPlasterAtBoardBottom		= 0
endif



! ==============================================================================
! Calculations for Inclined Walls
! ==============================================================================

if bInclinedWall then
	bFactor = SYMB_MIRRORED exor WIDO_REVEAL_SIDE exor wallIsLeft
	incFactor = not(bFactor) - bFactor
	incX = incFactor * tan(WALL_INCL)
	incY = incFactor * (1 / cos(WALL_INCL))

	bDir = SYMB_MIRRORED exor (SYMB_ROTANGLE > EPS)
	iDir = not(bDir) - bDir
	incH = cos(WALL_INCL)
	incV = sin(WALL_INCL) * iDir
else
	incX = 0
	incY = 1
	incH = 0
	incV = 0
endif


! ==============================================================================
! Calculations for vertically Stacked Window
! ==============================================================================

if gs_stack_top then
	thkPlasterAtSillTop		= 0
	thkPlasterAtBoardTop	= 0
endif

if gs_stack_bottom then
	thkPlasterAtSillBottom	= 0
	thkPlasterAtBoardBottom	= 0
endif


! ==============================================================================
! Calculations for Curved Walls
! ==============================================================================

if GLOB_SCRIPT_TYPE = 2 | GLOB_SCRIPT_TYPE = 3 then
	if curvedWall & abs(radSill) > EPS then

		if GLOB_SCRIPT_TYPE <> 2 & GLOB_CONTEXT <> 22 then
			widoOrigDist = -WIDO_ORIG_DIST
		else
			widoOrigDist = WIDO_ORIG_DIST
		endif

		tempWOD = abs(widoOrigDist) - (SYMB_ROTANGLE > EPS) * WIDO_FRAME_THICKNESS

		alfaRefWidth = atn(refWidth / tempWOD)

		alfaLeftOs	= atn((leftWidth  + overSizeLeft)  / tempWOD)
		alfaRightOs	= atn((rightWidth + overSizeRight) / tempWOD)

		alfaLeftJamb	= 180 * leftJamb  / radSill / PI
		alfaRightJamb	= 180 * rightJamb / radSill / PI

		alfaLeftInnJamb = atn((leftWidth  + overSizeLeft - (revealInnerLeft * (iRevealType = REVEAL_DOUBLE))) / tempWOD)
		alfaRightInnJamb = atn((rightWidth  + overSizeRight - (revealInnerRight * (iRevealType = REVEAL_DOUBLE))) / tempWOD)

	endif	! curvedWall
endif


! =============================================================================
! Calculations for Parapet dimension
! =============================================================================

gs_parapet_autodim = (iParapetSize = PARAPET_SIZE_AUTO)

parapet_width	= gs_parapet_width
parapet_height	= gs_parapet_height

bParapetWallInset		= (gs_parapet_wall_inset & abs(gs_parapet_inset_thk) > EPS) & bEnableParapetInset
parapetWallInsetDepth	= (gs_parapet_wall_inset & bEnableParapetInset) * gs_parapet_inset_thk


! Elevation of the current story ----------------

if iParapetBottom = PARAPET_BOTTOM_CURRENTSTORY then
	act_st_pos = SYMB_POS_Y - AC_Sill_To_Curr_Story + gs_parapet_botelev - elevationOffset
else
	act_st_pos = gs_parapet_botelev - elevationOffset
endif

if gs_parapet_autodim | (gs_parapet_width < EPS) then
	if GLOB_SCRIPT_TYPE = 2 then
		if vardim1(rightRevealPnts) >= idxBoardEndPlasterRight then
			parapet_width	= sqr ((rightRevealPnts[idxBoardEndPlasterRight][1]-leftRevealPnts[idxBoardEndPlasterLeft][1])^2 + \
			 (rightRevealPnts[idxBoardEndPlasterRight][2]-leftRevealPnts[idxBoardEndPlasterLeft][2])^2)
		endif
	else
		if vardim1(rightRevealPnts) >= idxBoardEndRevealRight then
			parapet_width	= sqr ((rightRevealPnts[idxBoardEndRevealRight][1]-leftRevealPnts[idxBoardEndRevealLeft][1])^2 + \
			 (rightRevealPnts[idxBoardEndRevealRight][2]-leftRevealPnts[idxBoardEndRevealLeft][2])^2)
		endif
	endif
	maxParapetHeight = SYMB_POS_Y - act_st_pos
	parapet_height = maxParapetHeight
else
	maxParapetHeight = SYMB_POS_Y
	if parapet_height > maxParapetHeight then
		parapet_height = maxParapetHeight
	endif
endif

bParapetWallInsetFullHeight	= (bParapetWallInset & (gs_parapet_autodim | parapet_height >= maxParapetHeight - EPS))

! Calc dimensions -------------------------------

idxSL = idxFrameStartRevealLeft
idxSR = idxFrameStartRevealRight

idxEL = idxFrameEndRevealLeft
idxER = idxFrameEndRevealRight

if bInclinedWall then
	revRightX	= min(rightRevealPnts[idxSR][1], rightRevealPnts[idxER][1]) - (rightWidth + overSizeRight)
	revLeftX	= -(max(leftRevealPnts[idxSL][1], leftRevealPnts[idxEL][1]) + (leftWidth  + overSizeLeft))
	revDRight	= revRightX / incH
	revDLeft	= revLeftX  / incH

	revYL	= revDLeft	* incH
	revYR	= revDRight	* incH

	opInner = (rightWidth + overSizeRight + leftWidth + overSizeLeft) / incH + revDLeft + revDRight
else
	revDRight	= min(rightRevealPnts[idxSR][1], rightRevealPnts[idxER][1]) - (rightWidth + overSizeRight)
	revDLeft	= -(max(leftRevealPnts[idxSL][1], leftRevealPnts[idxEL][1]) + (leftWidth  + overSizeLeft))
	revYL	= revDLeft
	revYR	= revDRight

	opInner = rightWidth + overSizeRight + leftWidth + overSizeLeft + revDLeft + revDRight
endif

if iParapetSize = PARAPET_SIZE_ASYMM then
	! Assymetric
	parapetExtendRight	= gs_parapet_right
	parapetExtendLeft	= gs_parapet_left
	parapet_width = opInner + parapetExtendRight + parapetExtendLeft
else
	! Symmetric or Automatic
	parapetExtendRight 	= (parapet_width - opInner) / 2
	parapetExtendLeft	= (parapet_width - opInner) / 2
endif

py1p = -incX * (rightWidth + overSizeRight + revYR + parapetExtendRight * incH)
py2p =  incX * (leftWidth  + overSizeLeft  + revYL + parapetExtendLeft  * incH)

dx = parapetWallInsetDepth * sin(WALL_INCL)
dy = parapetWallInsetDepth * cos(WALL_INCL)

revYPLeft		= parapetWallInsetDepth * tan(gs_reveal_left_angle - WALL_INCL)
if bInclinedWall then
	revSlantXLeft	= dx + revYPLeft * incH
	revSlantYLeft	= dy - revYPLeft * sin(WALL_INCL)
else
	revSlantXLeft	= revYPLeft
	revSlantYLeft	= parapetWallInsetDepth - revYPLeft
endif

revYPRight		= parapetWallInsetDepth * tan(gs_reveal_right_angle - WALL_INCL)
if bInclinedWall then
	revSlantXRight	= -(dx + revYPright * incH)
	revSlantYRight	=   dy - revYPright * sin(WALL_INCL)
else
	revSlantXRight	= -revYPright
	revSlantYRight	=  parapetWallInsetDepth - revYPright
endif

! =============================================================================
! Different Bottom Reveal Types Enable
! =============================================================================

bEnableDifferentBottomReveal = 1

if	iRevealType = REVEAL_EDGE |\
	iRevealType = REVEAL_SPLAYED |\
	iRevealType = REVEAL_DOUBLE_SPLAYED	|\
	iRevealType = REVEAL_OUTSIDE_SPLAYED |\
	iClosureType = CLOSURE_STUD_WALL |\
	iClosureType = CLOSURE_STUD_WALL_SIDING |\
	iClosureType = CLOSURE_BRICK_VENEER  |\
	bForceUniformBottomReveal then

	bEnableDifferentBottomReveal = 0
endif

! =============================================================================
! Uniform Jamb Depth Enable (Reveal Types and USA Stud Wall Closures)
! =============================================================================
bEnableUniformJambDepths = 1
bShowUniformJambDepths = 1

if	iClosureType = CLOSURE_STUD_WALL |\
	iClosureType = CLOSURE_STUD_WALL_SIDING |\
	iClosureType = CLOSURE_BRICK_VENEER |\
	iRevealType = REVEAL_EDGE |\
	iRevealType = REVEAL_NO |\
	(iRevealType = REVEAL_DOUBLE & iSillRevealType = REVEAL_NO & iBoardRevealType = REVEAL_NO) then

	bEnableUniformJambDepths = 0
	bShowUniformJambDepths = 0
endif

if	iRevealType = REVEAL_DOUBLE_SPLAYED |\
	iRevealType = REVEAL_OUTSIDE_SPLAYED then

	bShowUniformJambDepths = 0
endif

if bShapeSameRevealAngles then
	bShowUniformJambDepths = 0
endif


]]>
</Script_1D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_PR SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[

]]>
</Script_PR>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_UI SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[

bCustomReveal = (iRevealType = REVEAL_NEGATIVE | iRevealType = REVEAL_SLANTED)

if bRevealSettingsPage then

	if gs_closure_auto_changed then
		! The previously selected wall closure type is not available for this reveal.
		! The wall closure was changed.
		ui_pict 76, 430, 40 + pageStartY, 12,12,1 ui_tooltip stRevealUI[2] + " " + stRevealUI[3]
	endif

	y0 = 64 + pageStartY
	infieldElevation = 4
	x1 = 2
	x2 = 104
	x3 = 223
	x4 = 443-108
	x5 = 443-5
	xPic = 8
	yPic = 157 + pageStartY - 25
	xPicTop = 315
	yPicTop = 100 + pageStartY - 25
	xPicBot = 315
	yPicBot = 100+58+5 + pageStartY - 25
	yRevealText = 38 + pageStartY
	infieldHeight	= 19
	outfieldHeight	= 15

	yCurr = y0

	if bEnableUniformJambDepths & gs_reveal_uniform then
		n = request("Working_length_unit", "", formatt)
		if iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_HISTORIC then
			m = request("Working_angle_unit", "", formatAngle)
		endif
	endif

	if bEnableUniformJambDepths & bShowUniformJambDepths then
		! Uniform Jamb Depth -------------------------------------------------------------

		ui_infield{3} "gs_reveal_uniform", x1, yCurr-infieldElevation - 6, x4-x1-2 - 30, 20,
			7, "",
			2,
			1, 20, 20, 20, 20,
			0, stRevealUI[4], 0,
			1, stRevealUI[4], 1

	endif

	if bEnableDifferentBottomReveal then
		! Bottom Reveal control -------------------------------------------------------------
			bottomRevTextFlag = 4*(iClosureType = CLOSURE_STUD_WALL | iClosureType = CLOSURE_STUD_WALL_SIDING |iClosureType = CLOSURE_BRICK_VENEER)
			ui_outfield		stWallholeCutUI[32],			x3,	246,					x4-x3-2,	outfieldHeight, bottomRevTextFlag
			ui_infield{3}	"gs_reveal_type_bottom_int",	x4,	246-infieldElevation,	x5-x4,		infieldHeight,
					8, "", 4, 1, 0, 0, 0, 0,
					1, stRevealTypesBottom[1], REVEAL_BOTTOM_UNIFORM,
					2, stRevealTypesBottom[2], REVEAL_BOTTOM_NO,
					3, stRevealTypesBottom[3], REVEAL_BOTTOM_POSITIVE,
					4, stRevealTypesBottom[4], REVEAL_BOTTOM_NEGATIVE

	endif


! No Reveal - Edge -------------------------------------------------------------

	if iRevealType = REVEAL_EDGE then
		ui_style 0, 1
		ui_outfield stRevealTypes[1], x1, yRevealText, x3-x1-1, 16
		ui_style 0,0

		if not(isEmptyOpening) then
			if isWindow then
				ui_pict 135, xPic, yPic, 121, 33, 1		!no_reveal_edge_win.png
			else
				ui_pict 136, xPic, yPic, 121, 33, 1		!no_reveal_edge_door.png
			endif
		else
			ui_pict 137, xPic, yPic, 121, 33, 1			!no_reveal_edge_op.png
		endif

		ui_pict 45, xPic+121, yPic-4, 13, 9, 1
		ui_infield "AC_wido_sill", xPic+121+14, yPic-2, 72, infieldHeight ui_tooltip stRevealClusureUITips[1]

		if not(isEmptyOpening) then
			if isWindow then
				ui_pict 138, xPicTop, yPicTop, 33, 58, 1	!no_reveal_edge_top_win.png
				ui_pict 139, xPicBot, yPicBot, 33, 58, 1	!no_reveal_edge_bot_win.png
			else
				ui_pict 140, xPicTop, yPicTop, 33, 58, 1	!no_reveal_edge_top_door.png
				ui_pict 141, xPicBot, yPicBot, 33, 58, 1	!no_reveal_edge_bot_door.png
			endif
		else
			ui_pict 142, xPicTop, yPicTop, 33, 58, 1		!no_reveal_edge_top_op.png
			ui_pict 143, xPicBot, yPicBot, 33, 58, 1		!no_reveal_edge_bot_op.png
		endif

	endif

! No Reveal --------------------------------------------------------------------

	if iRevealType  = REVEAL_NO then
		ui_style 0, 1
		ui_outfield stRevealTypes[2], x1, yRevealText, x3-x1-1, 16
		ui_style 0,0
		gosub "noRevealPicsHorizontal"
		gosub "revealDepthParam"
		gosub "noRevealPicsVertical"

		if gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
			gosub "bottomPositiveReveal"
		else
			if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
				gosub "bottomNegativeReveal"
			else
				gosub "bottomNoReveal"
			endif
		endif
	endif


! Reveal -----------------------------------------------------------------------

	if iRevealType  = REVEAL_POSITIVE then
		ui_style 0, 1
		ui_outfield stRevealTypes[3], x1, yRevealText, x3-x1-1, 16
		ui_style 0,0

		if bTShapedOpening then
			gosub "ui of t shape"
		else
			gosub "revealPicsHorizontal"
			gosub "horizontalPosRevealParams"
			gosub "revealDepthParam"
			gosub "revealPicsVerticalTop"

			ui_pict 21, xPicTop-11, yPicTop+24, 11, 10, 1		!ui_arrow_10_v.png
			if bEnableUniformJambDepths & gs_reveal_uniform then
				ui_outfield str(formatt, abs(gs_reveal_right)), xPicTop-88, yPicTop+23, 72, outfieldHeight, 1
			else
				ui_infield "gs_reveal_top",	xPicTop-88, yPicTop+19, 72, infieldHeight ui_tooltip stRevealClusureUITips[6]
			endif

			if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
				gosub "bottomNegativeReveal"
			else
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					gosub "bottomNoReveal"
				else
					gosub "bottomPositiveReveal"
				endif
			endif
		endif
	endif

! Negative Reveal --------------------------------------------------------------

	if iRevealType  = REVEAL_NEGATIVE then
		ui_style 0, 1
		ui_outfield stRevealTypes[4], x1, yRevealText, x3-x1-1, 16
		ui_style 0,0

		if bTShapedOpening then
			gosub "ui of t shape"
		else
			gosub "negRevealPicsHorizontal"
			gosub "horizontalNegRevealParams"
			gosub "revealDepthParam"

			gosub "negRevealPicsVerticalTop"
			ui_pict 21, xPicTop-11, yPicTop+16, 11, 10, 1		!ui_arrow_10_v.png
			if bEnableUniformJambDepths & gs_reveal_uniform then
				ui_outfield str(formatt, abs(gs_reveal_right)), xPicTop-88, yPicTop+15, 72, outfieldHeight, 1
			else
				ui_infield "gs_reveal_top",	xPicTop-88, yPicTop+11, 72, infieldHeight ui_tooltip stRevealClusureUITips[6]
			endif

			if gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
				gosub "bottomPositiveReveal"
			else
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					gosub "bottomNoReveal"
				else
					gosub "bottomNegativeReveal"
				endif
			endif
		endif
	endif

! Slanted Reveal ---------------------------------------------------------------

	if iRevealType  = REVEAL_SLANTED then
		ui_style 0, 1
		ui_outfield stRevealTypes[5], x1, yRevealText, 320, 16
		ui_style 0,0

		if not(isEmptyOpening) then
			if isWindow then
				ui_pict 111, xPic, yPic, 121, 33, 1	!slanted_reveal_win.png
			else
				ui_pict 112, xPic, yPic, 121, 33, 1	!slanted_reveal_door.png
			endif
		else
			ui_pict 113, xPic, yPic, 121, 33, 1	!slanted_reveal_op.png
		endif
		gosub "horizontalPosRevealParams"
		gosub "revealDepthParam"

		ui_pict 11, xPic,  yPic+35, 19,25, 1
		ui_pict 12, xPic+102,yPic+35, 19,25, 1

		ui_infield "gs_reveal_right_angle",	xPic+93,	yPic+63, 60,infieldHeight ui_tooltip stRevealClusureUITips[11]
		if bEnableUniformJambDepths & gs_reveal_uniform then
			ui_outfield str(formatAngle, abs(gs_reveal_right_angle)), xPic-6,	yPic+67, 60, outfieldHeight
		else
			ui_infield "gs_reveal_left_angle",	xPic-6,	yPic+63, 60, infieldHeight ui_tooltip stRevealClusureUITips[10]
		endif

		angleYPosDiff = 0
		if not(isEmptyOpening) then
			if isWindow then
				angleYPosDiff = 10
				ui_pict 114, xPicTop, yPicTop, 33, 58, 1	!slanted_reveal_top_win.png
			else
				ui_pict 115, xPicTop, yPicTop, 33, 58, 1	!slanted_reveal_top_door.png
			endif
		else
			angleYPosDiff = 10
			ui_pict 116, xPicTop, yPicTop, 33, 58, 1		!slanted_reveal_top_op.png
		endif
		ui_pict 8, xPicTop+34, yPicTop+angleYPosDiff, 25, 19, 1
		ui_pict 21, xPicTop-11, yPicTop+24, 11, 10, 1		!ui_arrow_10_v.png

		if bEnableUniformJambDepths & gs_reveal_uniform then
			ui_outfield str(formatt, abs(gs_reveal_right)), xPicTop-88, yPicTop+23, 72, outfieldHeight, 1
		else
			ui_infield "gs_reveal_top",	xPicTop-88, yPicTop+19, 72, infieldHeight ui_tooltip stRevealClusureUITips[6]
		endif

		if bEnableUniformJambDepths & gs_reveal_uniform then
			ui_outfield str(formatAngle, abs(gs_reveal_right_angle)), xPicTop+64,yPicTop+2+angleYPosDiff, 60, outfieldHeight
		else
			ui_infield "gs_reveal_top_angle",	xPicTop+64,yPicTop-2+angleYPosDiff,  60, infieldHeight ui_tooltip stRevealClusureUITips[12]
		endif

		if gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
			gosub "bottomPositiveReveal"
		else
			if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
				gosub "bottomNoReveal"
			else
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
					gosub "bottomNegativeReveal"
				else
					angleYPosDiff = 0
					if not(isEmptyOpening) then
						if isWindow then
							angleYPosDiff = 10
							ui_pict 117, xPicBot, yPicBot, 33, 58, 1	!slanted_reveal_bot_win.png
						else
							ui_pict 118, xPicBot, yPicBot, 33, 58, 1	!slanted_reveal_bot_door.png
						endif
					else
						ui_pict 119, xPicBot, yPicBot, 33, 58, 1		!slanted_reveal_bot_op.png
					endif
					ui_pict 21, xPicBot-11, yPicBot+24, 11, 10, 1		!ui_arrow_10_v.png
					ui_pict 9, xPicBot+34, yPicBot+30+angleYPosDiff, 25, 19, 1

					ui_infield "gs_reveal_bottom", xPicBot-88, yPicBot+19, 72, infieldHeight 	ui_tooltip stRevealClusureUITips[7]
					ui_infield "gs_reveal_bottom_angle",xPicBot+64,yPicBot+30+angleYPosDiff, 60,infieldHeight ui_tooltip stRevealClusureUITips[13]
				endif
			endif
		endif
	endif

! Splayed Reveal ---------------------------------------------------------------

	if iRevealType  = REVEAL_SPLAYED then
		ui_style 0, 1
		ui_outfield stRevealTypes[6], x1, yRevealText, 320, 16
		ui_style 0,0


		if not(isEmptyOpening) then
			if isWindow then
				ui_pict 120, xPic, yPic, 121, 33, 1	!splayed_reveal_win.png
			else
				ui_pict 121, xPic, yPic, 121, 33, 1	!splayed_reveal_door.png
			endif
		else
			ui_pict 122, xPic, yPic, 121, 33, 1	!splayed_reveal_op.png
		endif

		gosub "revealDepthParam"

		ui_pict 20, xPic+24, yPic-11, 10, 11, 1			!ui_arrow_10.png
		ui_pict 20, xPic+87, yPic-11, 10, 11, 1			!ui_arrow_10.png

		ui_infield "gs_reveal_splayed_innerRight", xPic+87, yPic-34, 72, infieldHeight ui_tooltip stRevealClusureUITips[5]
		if bEnableUniformJambDepths & gs_reveal_uniform then
			ui_outfield str(formatt, abs(gs_reveal_splayed_innerRight)), xPic-6,	yPic-30, 72, outfieldHeight, 2
		else
			ui_infield "gs_reveal_splayed_innerLeft", xPic-6,	yPic-34, 72, infieldHeight ui_tooltip stRevealClusureUITips[4]
		endif

		ui_pict 11, xPic,  yPic+35, 19,25, 1
		ui_pict 12, xPic+102,yPic+35, 19,25, 1

		ui_infield "gs_reveal_right_angle",	xPic+93,	yPic+63, 60,infieldHeight ui_tooltip stRevealClusureUITips[11]
		if bEnableUniformJambDepths & gs_reveal_uniform then
			ui_outfield str(formatAngle, abs(gs_reveal_right_angle)), xPic-6,	yPic+67, 60, outfieldHeight
		else
			ui_infield "gs_reveal_left_angle",	xPic-6,	yPic+63, 60, infieldHeight ui_tooltip stRevealClusureUITips[10]
		endif

		if not(isEmptyOpening) then
			if isWindow then
				ui_pict 144, xPicTop, yPicTop, 33, 58, 1	!splayed_reveal_top_win.png
				ui_pict 145, xPicBot, yPicBot, 33, 58, 1	!splayed_reveal_bot_win.png
			else
				ui_pict 146, xPicTop, yPicTop, 33, 58, 1	!splayed_reveal_top_door.png
				ui_pict 147, xPicBot, yPicBot, 33, 58, 1	!splayed_reveal_bot_door.png
			endif
		else
			ui_pict 148, xPicTop, yPicTop, 33, 58, 1		!splayed_reveal_top_op.png
			ui_pict 149, xPicBot, yPicBot, 33, 58, 1		!splayed_reveal_bot_op.png
		endif

		ui_pict 8, xPicTop+34, yPicTop+10, 25, 19, 1
		ui_pict 21, xPicTop-11, yPicTop+24, 11, 10, 1		!ui_arrow_10_v.png

		if bEnableUniformJambDepths & gs_reveal_uniform then
			ui_outfield str(formatt, abs(gs_reveal_splayed_innerRight)), xPicTop-88, yPicTop+23, 72, outfieldHeight, 1
		else
			ui_infield "gs_reveal_splayed_innerTop",	xPicTop-88, yPicTop+19, 72, infieldHeight ui_tooltip stRevealClusureUITips[8]
		endif

		if bEnableUniformJambDepths & gs_reveal_uniform then
			ui_outfield str(formatAngle, abs(gs_reveal_right_angle)), xPicTop+64,yPicTop+12, 60, outfieldHeight
		else
			ui_infield "gs_reveal_top_angle",	xPicTop+64, yPicTop+8,  60,infieldHeight ui_tooltip stRevealClusureUITips[12]
		endif

		ui_pict 21, xPicBot-11, yPicBot+24, 11, 10, 1		!ui_arrow_10_v.png
		ui_pict 9, xPicBot+34, yPicBot+30, 25, 19, 1

		ui_infield "gs_reveal_splayed_innerBottom", xPicBot-88, yPicBot+19, 72, infieldHeight 	ui_tooltip stRevealClusureUITips[9]
		ui_infield "gs_reveal_bottom_angle",xPicBot+64,yPicBot+30, 60, infieldHeight ui_tooltip stRevealClusureUITips[13]
	endif

! Historic Reveal --------------------------------------------------------------

	if iRevealType  = REVEAL_HISTORIC then
		ui_style 0, 1
		ui_outfield stRevealTypes[7], x1, yRevealText, x3-x1-1, 16
		ui_style 0,0

		if not(isEmptyOpening) then
			if isWindow then
				ui_pict 123, xPic, yPic, 121, 33, 1	!historic_reveal_win.png
			else
				ui_pict 124, xPic, yPic, 121, 33, 1	!historic_reveal_door.png
			endif
		else
			ui_pict 125, xPic, yPic, 121, 33, 1	!historic_reveal_op.png
		endif
		gosub "horizontalPosRevealParams"
		gosub "revealDepthParam"

		ui_infield "gs_reveal_splayed_innerRight", xPic+87, yPic+45, 72, infieldHeight ui_tooltip stRevealClusureUITips[5]

		if bEnableUniformJambDepths & gs_reveal_uniform then
			ui_outfield str(formatt, abs(gs_reveal_splayed_innerRight)), xPic-6,	yPic+49, 55, outfieldHeight, 2
		else
			ui_infield "gs_reveal_splayed_innerLeft", xPic-6,	yPic+45, 72, infieldHeight ui_tooltip stRevealClusureUITips[4]
		endif

		ui_pict 44, xPic+16, yPic+33, 10, 11, 1			!ui_arrow_10_m.png
		ui_pict 44, xPic+95, yPic+33, 10, 11, 1			!ui_arrow_10_m.png

		ui_pict 11, xPic,  yPic+67, 19,25, 1
		ui_pict 12, xPic+102,yPic+67, 19,25, 1

		ui_infield "gs_reveal_right_angle",	xPic+102+26,	yPic+75, 60, infieldHeight ui_tooltip stRevealClusureUITips[11]
		if bEnableUniformJambDepths & gs_reveal_uniform then
			ui_outfield str(formatAngle, abs(gs_reveal_right_angle)), xPic+26,	yPic+79, 60, outfieldHeight
		else
			ui_infield "gs_reveal_left_angle",	xPic+26,	yPic+75, 60, infieldHeight ui_tooltip stRevealClusureUITips[10]
		endif


		if not(isEmptyOpening) then
			if isWindow then
				ui_pict 150, xPicTop, yPicTop, 33, 58, 1	!historic_reveal_top_win.png
			else
				ui_pict 151, xPicTop, yPicTop, 33, 58, 1	!historic_reveal_top_door.png
			endif
		else
			ui_pict 152, xPicTop, yPicTop, 33, 58, 1		!historic_reveal_top_op.png
		endif
		ui_pict 8, xPicTop+34, yPicTop-10, 25, 19, 1
		ui_pict 21, xPicTop-11, yPicTop+24, 11, 10, 1		!ui_arrow_10_v.png
		ui_pict 77, xPicTop+33, yPicTop+16, 11, 10, 1		!ui_arrow_10_vm.png

		if bEnableUniformJambDepths & gs_reveal_uniform then
			ui_outfield str(formatt, abs(gs_reveal_right)), xPicTop-88, yPicTop+23, 72, outfieldHeight, 1
		else
			ui_infield "gs_reveal_top",	xPicTop-88, yPicTop+19, 72, infieldHeight ui_tooltip stRevealClusureUITips[6]
		endif

		if bEnableUniformJambDepths & gs_reveal_uniform then
			ui_outfield str(formatt, abs(gs_reveal_splayed_innerRight)), xPicTop+33+19,yPicTop+15, 72, outfieldHeight
		else
			ui_infield "gs_reveal_splayed_innerTop",	xPicTop+33+19,yPicTop+11, 72,infieldHeight ui_tooltip stRevealClusureUITips[8]
		endif

		if bEnableUniformJambDepths & gs_reveal_uniform then
			ui_outfield str(formatAngle, abs(gs_reveal_right_angle)), xPicTop+64,yPicTop-8, 60, outfieldHeight
		else
			ui_infield "gs_reveal_top_angle",	xPicTop+64,yPicTop-12,  60,infieldHeight ui_tooltip stRevealClusureUITips[12]
		endif

		if gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
			gosub "bottomPositiveReveal"
		else
			if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
				gosub "bottomNoReveal"
			else
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
					gosub "bottomNegativeReveal"
				else
					angleYPosDiff = 0
					if not(isEmptyOpening) then
						if isWindow then
							ui_pict 153, xPicBot, yPicBot, 33, 58, 1	!historic_reveal_bot_win.png
						else
							ui_pict 154, xPicBot, yPicBot, 33, 58, 1	!historic_reveal_bot_door.png
						endif
					else
						ui_pict 155, xPicBot, yPicBot, 33, 58, 1		!historic_reveal_bot_op.png
					endif
					ui_pict 21, xPicBot-11, yPicBot+24, 11, 10, 1		!ui_arrow_10_v.png
					ui_pict 9, xPicBot+34, yPicBot+49, 25, 19, 1
					ui_pict 77, xPicBot+33, yPicBot+32, 11, 10, 1		!ui_arrow_10_vm.png

					ui_infield "gs_reveal_bottom", xPicBot-88, yPicBot+19, 72, infieldHeight	ui_tooltip stRevealClusureUITips[7]
					ui_infield "gs_reveal_bottom_angle",xPicBot+64,yPicBot+49, 60,infieldHeight ui_tooltip stRevealClusureUITips[13]
					ui_infield "gs_reveal_splayed_innerBottom",	xPicBot+33+19, yPicBot+27, 72,infieldHeight ui_tooltip stRevealClusureUITips[9]
				endif
			endif
		endif

	endif

! Custom Reveal ----------------------------------------------------------------

	if iRevealType  = REVEAL_DOUBLE then
		ui_style 0, 1
		ui_outfield stRevealTypes[8], x1, yRevealText, x3-x1-11, 16
		ui_style 0,0

		ui_outfield		stRevealUI[5],					x1,	80 + pageStartY,	x2-x1-1, 16
		ui_infield{3}	"gs_reveal_doubleOuterTypeInt",	x2,	76  + pageStartY,	x3-x2-12, 20,
						8, "", 3, 1,
						0, 0, 0, 0,
						1, stRevealTypes[2], 2,
						2, stRevealTypes[3], 3,
						3, stRevealTypes[4], 4

		ui_outfield		stRevealUI[6],					x1,	246,	x2-x1-1, 16
		ui_infield{3}	"gs_reveal_doubleInnerTypeInt",	x2, 242,	x3-x2-12, 20,
						8, "", 3, 1,
						0, 0, 0, 0,
						1, stRevealTypes[2], 2,
						2, stRevealTypes[3], 3,
						3, stRevealTypes[4], 4

		if bTShapedOpening then
			gosub "ui of t shape"
		else
			gosub "revealDepthParam"

			if iSillRevealType = REVEAL_NO then
				if iBoardRevealType = REVEAL_NO then
					gosub "noRevealPicsHorizontal"
					gosub "noRevealPicsVertical"

					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
						gosub "bottomNoReveal"
					endif
				else
					ui_pict 7, xPic+121, yPic, 11, 11, 1			!ui_arrow_11.png
					ui_infield "gs_wido_sill", xPic+121+16, yPic-5, 72, infieldHeight ui_tooltip stRevealClusureUITips[1]
				endif

				if iBoardRevealType = REVEAL_POSITIVE then
					if not(isEmptyOpening) then
						if isWindow then
							ui_pict 38, xPic, yPic, 121, 33, 1	!custom_norev_rev_win.png
						else
							ui_pict 39, xPic, yPic, 121, 33, 1	!custom_norev_rev_door.png
						endif
					else
						ui_pict 40, xPic, yPic, 121, 33, 1	!custom_norev_rev_op.png
					endif

					ui_pict 44, xPic+24, yPic+33, 10, 11, 1			!ui_arrow_10_m.png
					ui_pict 44, xPic+87, yPic+33, 10, 11, 1			!ui_arrow_10_m.png

					gosub "customInnerPosRevealParamaters"

					if not(isEmptyOpening) then
						if isWindow then
							ui_pict 29, xPicTop, yPicTop, 33, 58, 1	!custom_norev_rev_top_win.png
						else
							ui_pict 30, xPicTop, yPicTop, 33, 58, 1	!custom_norev_rev_top_door.png
						endif
					else
						ui_pict 31, xPicTop, yPicTop, 33, 58, 1			!custom_norev_rev_top_op.png
					endif

					ui_pict 77, xPicTop+33, yPicTop+24, 11, 10, 1		!ui_arrow_10_vm.png
					if bEnableUniformJambDepths & gs_reveal_uniform then
						ui_outfield str(formatt, abs(gs_reveal_double_innerRight)), xPicTop+33+19,yPicTop+23, 72, outfieldHeight
					else
						ui_infield "gs_reveal_double_innerTop",		xPicTop+33+19,yPicTop+19, 72,infieldHeight ui_tooltip stRevealClusureUITips[8]
					endif

					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
						if not(isEmptyOpening) then
							if isWindow then
								ui_pict 156, xPicBot, yPicBot, 33, 58, 1	!custom_norev_rev_bot_win.png
							else
								ui_pict 157, xPicBot, yPicBot, 33, 58, 1	!custom_norev_rev_bot_door.png
							endif
						else
							ui_pict 158, xPicBot, yPicBot, 33, 58, 1		!custom_norev_rev_bot_op.png
						endif

						ui_pict 77, xPicBot+33, yPicBot+24, 11, 10, 1		!ui_arrow_10_vm.png
						if bForceUniformBottomReveal then
							ui_outfield str(formatt, abs(gs_reveal_double_innerRight)), xPicTop+33+19, yPicBot+23, 72, outfieldHeight, 0
						else
							ui_infield "gs_reveal_double_innerBottom",	xPicTop+33+19, yPicBot+19, 72, infieldHeight ui_tooltip stRevealClusureUITips[9]
						endif
					endif
				endif

				if iBoardRevealType = REVEAL_NEGATIVE then
					if not(isEmptyOpening) then
						if isWindow then
							ui_pict 159, xPic, yPic, 121, 33, 1	!custom_norev_negrev_win.png
						else
							ui_pict 160, xPic, yPic, 121, 33, 1	!custom_norev_negrev_door.png
						endif
					else
						ui_pict 161, xPic, yPic, 121, 33, 1	!custom_norev_negrev_op.png
					endif

					ui_pict 44, xPic+16, yPic+33, 10, 11, 1			!ui_arrow_10_m.png
					ui_pict 44, xPic+95, yPic+33, 10, 11, 1			!ui_arrow_10_m.png

					gosub "customInnerNegRevealParamaters"

					if not(isEmptyOpening) then
						if isWindow then
							ui_pict 162, xPicTop, yPicTop, 33, 58, 1	!custom_norev_negrev_top_win.png
						else
							ui_pict 163, xPicTop, yPicTop, 33, 58, 1	!custom_norev_negrev_top_door.png
						endif
					else
						ui_pict 164, xPicTop, yPicTop, 33, 58, 1			!custom_norev_negrev_top_op.png
					endif

					ui_pict 77, xPicTop+33, yPicTop+16, 11, 10, 1		!ui_arrow_10_vm.png
					if bEnableUniformJambDepths & gs_reveal_uniform then
						ui_outfield str(formatt, abs(gs_reveal_double_innerRight)), xPicTop+33+19,yPicTop+15, 72, outfieldHeight
					else
						ui_infield "gs_reveal_double_innerTop",		xPicTop+33+19,yPicTop+11, 72, infieldHeight ui_tooltip stRevealClusureUITips[8]
					endif

					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
						if not(isEmptyOpening) then
							if isWindow then
								ui_pict 165, xPicBot, yPicBot, 33, 58, 1	!custom_norev_negrev_bot_win.png
							else
								ui_pict 166, xPicBot, yPicBot, 33, 58, 1	!custom_norev_negrev_bot_door.png
							endif
						else
							ui_pict 167, xPicBot, yPicBot, 33, 58, 1		!custom_norev_negrev_bot_op.png
						endif

						ui_pict 77, xPicBot+33, yPicBot+32, 11, 10, 1		!ui_arrow_10_vm.png
						if bForceUniformBottomReveal then
							ui_outfield str(formatt, abs(gs_reveal_double_innerRight)), xPicTop+33+19, yPicBot+31, 72, outfieldHeight, 0
						else
							ui_infield "gs_reveal_double_innerBottom",	xPicTop+33+19, yPicBot+27, 72, infieldHeight ui_tooltip stRevealClusureUITips[9]
						endif
					endif
				endif
			endif

			if iSillRevealType = REVEAL_POSITIVE then
				gosub "horizontalPosRevealParams"

				ui_pict 21, xPicTop-11, yPicTop+24, 11, 10, 1		!ui_arrow_10_v.png
				if bEnableUniformJambDepths & gs_reveal_uniform then
					ui_outfield str(formatt, abs(gs_reveal_right)), xPicTop-88, yPicTop+23, 72, outfieldHeight, 1
				else
					ui_infield "gs_reveal_top",	xPicTop-88, yPicTop+19, 72, infieldHeight ui_tooltip stRevealClusureUITips[6]
				endif

!				if isWindow then
!					ui_infield "gs_reveal_bottom",	x3-65, y2+85, 60, infieldHeight ui_tooltip stRevealClusureUITips[7]
!				endif

				if iBoardRevealType = REVEAL_NO then
					gosub "revealPicsHorizontal"
					gosub "revealPicsVerticalTop"

					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
						gosub "bottomPositiveReveal"
					endif
				endif

				if iBoardRevealType = REVEAL_POSITIVE then
					if not(isEmptyOpening) then
						if isWindow then
							ui_pict 26, xPic, yPic, 121, 33, 1	!custom_rev_rev_win.png
						else
							ui_pict 27, xPic, yPic, 121, 33, 1	!custom_rev_rev_door.png
						endif
					else
						ui_pict 28, xPic, yPic, 121, 33, 1	!custom_rev_rev_op.png
					endif
					ui_pict 44, xPic+24, yPic+33, 10, 11, 1			!ui_arrow_10_m.png
					ui_pict 44, xPic+87, yPic+33, 10, 11, 1			!ui_arrow_10_m.png

					gosub "customInnerPosRevealParamaters"

					if not(isEmptyOpening) then
						if isWindow then
							ui_pict 32, xPicTop, yPicTop, 33, 58, 1	!custom_rev_rev_top_win.png
						else
							ui_pict 33, xPicTop, yPicTop, 33, 58, 1	!custom_rev_rev_top_door.png
						endif
					else
						ui_pict 34, xPicTop, yPicTop, 33, 58, 1			!custom_rev_rev_top_op.png
					endif

					ui_pict 77, xPicTop+33, yPicTop+24, 11, 10, 1		!ui_arrow_10_vm.png
					if bEnableUniformJambDepths & gs_reveal_uniform then
						ui_outfield str(formatt, abs(gs_reveal_double_innerRight)), xPicTop+33+19,yPicTop+23, 72, outfieldHeight
					else
						ui_infield "gs_reveal_double_innerTop",		xPicTop+33+19,yPicTop+19, 72,infieldHeight ui_tooltip stRevealClusureUITips[8]
					endif

					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
						if not(isEmptyOpening) then
							if isWindow then
								ui_pict 35, xPicBot, yPicBot, 33, 58, 1	!custom_rev_rev_bot_win.png
							else
								ui_pict 36, xPicBot, yPicBot, 33, 58, 1	!custom_rev_rev_bot_door.png
							endif
						else
							ui_pict 37, xPicBot, yPicBot, 33, 58, 1		!custom_rev_rev_bot_op.png
						endif

						ui_pict 77, xPicBot+33, yPicBot+24, 11, 10, 1		!ui_arrow_10_vm.png
						if bForceUniformBottomReveal then
							ui_outfield str(formatt, abs(gs_reveal_double_innerRight)), xPicTop+33+19, yPicBot+23, 72, outfieldHeight, 0
						else
							ui_infield "gs_reveal_double_innerBottom",	xPicTop+33+19, yPicBot+19, 72, infieldHeight ui_tooltip stRevealClusureUITips[9]
						endif
						ui_pict 21, xPicBot-11, yPicBot+24, 11, 10, 1		!ui_arrow_10_v.png
						if bForceUniformBottomReveal then
							ui_outfield str(formatt, abs(gs_reveal_right)), xPicTop-88, yPicBot+23, 72, outfieldHeight, 1
						else
							ui_infield "gs_reveal_bottom", xPicBot-88, yPicBot+19, 72, infieldHeight ui_tooltip stRevealClusureUITips[7]
						endif
					endif
				endif

				if iBoardRevealType = REVEAL_NEGATIVE then
					if not(isEmptyOpening) then
						if isWindow then
							ui_pict 41, xPic, yPic, 121, 33, 1	!custom_rev_negrev_win.png
						else
							ui_pict 42, xPic, yPic, 121, 33, 1	!custom_rev_negrev_door.png
						endif
					else
						ui_pict 43, xPic, yPic, 121, 33, 1	!custom_rev_negrev_op.png
					endif
					ui_pict 44, xPic+16, yPic+33, 10, 11, 1			!ui_arrow_10_m.png
					ui_pict 44, xPic+95, yPic+33, 10, 11, 1			!ui_arrow_10_m.png

					gosub "customInnerNegRevealParamaters"

					if not(isEmptyOpening) then
						if isWindow then
							ui_pict 168, xPicTop, yPicTop, 33, 58, 1	!custom_rev_negrev_top_win.png
						else
							ui_pict 169, xPicTop, yPicTop, 33, 58, 1	!custom_rev_negrev_top_door.png
						endif
					else
						ui_pict 170, xPicTop, yPicTop, 33, 58, 1			!custom_rev_negrev_top_op.png
					endif

					ui_pict 77, xPicTop+33, yPicTop+16, 11, 10, 1		!ui_arrow_10_vm.png
					if bEnableUniformJambDepths & gs_reveal_uniform then
						ui_outfield str(formatt, abs(gs_reveal_double_innerRight)), xPicTop+33+19,yPicTop+15, 72, outfieldHeight
					else
						ui_infield "gs_reveal_double_innerTop",		xPicTop+33+19,yPicTop+11, 72,infieldHeight ui_tooltip stRevealClusureUITips[8]
					endif

					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
						if not(isEmptyOpening) then
							if isWindow then
								ui_pict 171, xPicBot, yPicBot, 33, 58, 1	!custom_rev_negrev_bot_win.png
							else
								ui_pict 172, xPicBot, yPicBot, 33, 58, 1	!custom_rev_negrev_bot_door.png
							endif
						else
							ui_pict 173, xPicBot, yPicBot, 33, 58, 1		!custom_rev_negrev_bot_op.png
						endif

						ui_pict 77, xPicBot+33, yPicBot+32, 11, 10, 1		!ui_arrow_10_vm.png
						if bForceUniformBottomReveal then
							ui_outfield str(formatt, abs(gs_reveal_double_innerRight)), xPicTop+33+19, yPicBot+31, 72, outfieldHeight, 0
						else
							ui_infield "gs_reveal_double_innerBottom",	xPicTop+33+19, yPicBot+27, 72, infieldHeight ui_tooltip stRevealClusureUITips[9]
						endif
						ui_pict 21, xPicBot-11, yPicBot+24, 11, 10, 1		!ui_arrow_10_v.png
						if bForceUniformBottomReveal then
							ui_outfield str(formatt, abs(gs_reveal_right)), xPicTop-88, yPicBot+23, 72, outfieldHeight, 1
						else
							ui_infield "gs_reveal_bottom", xPicBot-88, yPicBot+19, 72, infieldHeight	ui_tooltip stRevealClusureUITips[7]
						endif
					endif
				endif
			endif

			if iSillRevealType = REVEAL_NEGATIVE then
				gosub "horizontalNegRevealParams"

				ui_pict 21, xPicTop-11, yPicTop+16, 11, 10, 1		!ui_arrow_10_v.png
				if bEnableUniformJambDepths & gs_reveal_uniform then
					ui_outfield str(formatt, abs(gs_reveal_right)), xPicTop-88, yPicTop+15, 72, outfieldHeight, 1
				else
					ui_infield "gs_reveal_top",	xPicTop-88, yPicTop+11, 72, infieldHeight ui_tooltip stRevealClusureUITips[6]
				endif

!				if isWindow then
!					ui_infield "gs_reveal_bottom",	x3-65, y2+99, 60, infieldHeight ui_tooltip stRevealClusureUITips[7]
!				endif

				if iBoardRevealType = REVEAL_NO then
					gosub "negRevealPicsHorizontal"
					gosub "negRevealPicsVerticalTop"
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
						gosub "bottomNegativeReveal"
					endif
				endif

				if iBoardRevealType = REVEAL_POSITIVE then
					if not(isEmptyOpening) then
						if isWindow then
							ui_pict 174, xPic, yPic, 121, 33, 1	!custom_negrev_rev_win.png
						else
							ui_pict 175, xPic, yPic, 121, 33, 1	!custom_negrev_rev_door.png
						endif
					else
						ui_pict 176, xPic, yPic, 121, 33, 1	!custom_negrev_rev_op.png
					endif
					ui_pict 44, xPic+24, yPic+33, 10, 11, 1			!ui_arrow_10_m.png
					ui_pict 44, xPic+87, yPic+33, 10, 11, 1			!ui_arrow_10_m.png

					gosub "customInnerPosRevealParamaters"

					if not(isEmptyOpening) then
						if isWindow then
							ui_pict 177, xPicTop, yPicTop, 33, 58, 1	!custom_negrev_rev_top_win.png
						else
							ui_pict 178, xPicTop, yPicTop, 33, 58, 1	!custom_negrev_rev_top_door.png
						endif
					else
						ui_pict 179, xPicTop, yPicTop, 33, 58, 1			!custom_negrev_rev_top_op.png
					endif

					ui_pict 77, xPicTop+33, yPicTop+24, 11, 10, 1		!ui_arrow_10_vm.png
					if bEnableUniformJambDepths & gs_reveal_uniform then
						ui_outfield str(formatt, abs(gs_reveal_double_innerRight)), xPicTop+33+19,yPicTop+23, 72, outfieldHeight
					else
						ui_infield "gs_reveal_double_innerTop",		xPicTop+33+19,yPicTop+19, 72,infieldHeight ui_tooltip stRevealClusureUITips[8]
					endif

					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
						if not(isEmptyOpening) then
							if isWindow then
								ui_pict 180, xPicBot, yPicBot, 33, 58, 1	!custom_negrev_rev_bot_win.png
							else
								ui_pict 181, xPicBot, yPicBot, 33, 58, 1	!custom_negrev_rev_bot_door.png
							endif
						else
							ui_pict 182, xPicBot, yPicBot, 33, 58, 1		!custom_negrev_rev_bot_op.png
						endif

						ui_pict 77, xPicBot+33, yPicBot+24, 11, 10, 1		!ui_arrow_10_vm.png
						if bForceUniformBottomReveal then
							ui_outfield str(formatt, abs(gs_reveal_double_innerRight)), xPicTop+33+19, yPicBot+23, 72, outfieldHeight, 0
						else
							ui_infield "gs_reveal_double_innerBottom",	xPicTop+33+19, yPicBot+19, 72, infieldHeight ui_tooltip stRevealClusureUITips[9]
						endif
						ui_pict 21, xPicBot-11, yPicBot+32, 11, 10, 1		!ui_arrow_10_v.png
						if bForceUniformBottomReveal then
							ui_outfield str(formatt, abs(gs_reveal_right)), xPicTop-88, yPicBot+31, 72, outfieldHeight, 1
						else
							ui_infield "gs_reveal_bottom", xPicBot-88, yPicBot+27, 72, infieldHeight ui_tooltip stRevealClusureUITips[7]
						endif
					endif
				endif

				if iBoardRevealType = REVEAL_NEGATIVE then
					if not(isEmptyOpening) then
						if isWindow then
							ui_pict 183, xPic, yPic, 121, 33, 1	!custom_negrev_negrev_win.png
						else
							ui_pict 184, xPic, yPic, 121, 33, 1	!custom_negrev_negrev_door.png
						endif
					else
						ui_pict 185, xPic, yPic, 121, 33, 1	!custom_negrev_negrev_op.png
					endif
					ui_pict 44, xPic+16, yPic+33, 10, 11, 1			!ui_arrow_10_m.png
					ui_pict 44, xPic+95, yPic+33, 10, 11, 1			!ui_arrow_10_m.png

					gosub "customInnerNegRevealParamaters"

					if not(isEmptyOpening) then
						if isWindow then
							ui_pict 186, xPicTop, yPicTop, 33, 58, 1	!custom_negrev_negrev_top_win.png
						else
							ui_pict 187, xPicTop, yPicTop, 33, 58, 1	!custom_negrev_negrev_top_door.png
						endif
					else
						ui_pict 188, xPicTop, yPicTop, 33, 58, 1			!custom_negrev_negrev_top_op.png
					endif

					ui_pict 77, xPicTop+33, yPicTop+16, 11, 10, 1		!ui_arrow_10_vm.png
					if bEnableUniformJambDepths & gs_reveal_uniform then
						ui_outfield str(formatt, abs(gs_reveal_double_innerRight)), xPicTop+33+19,yPicTop+15, 72, outfieldHeight
					else
						ui_infield "gs_reveal_double_innerTop",		xPicTop+33+19,yPicTop+11, 72, infieldHeight ui_tooltip stRevealClusureUITips[8]
					endif

					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
						if not(isEmptyOpening) then
							if isWindow then
								ui_pict 189, xPicBot, yPicBot, 33, 58, 1	!custom_negrev_negrev_bot_win.png
							else
								ui_pict 190, xPicBot, yPicBot, 33, 58, 1	!custom_negrev_negrev_bot_door.png
							endif
						else
							ui_pict 191, xPicBot, yPicBot, 33, 58, 1		!custom_negrev_negrev_bot_op.png
						endif

						ui_pict 77, xPicBot+33, yPicBot+32, 11, 10, 1		!ui_arrow_10_vm.png
						if bForceUniformBottomReveal then
							ui_outfield str(formatt, abs(gs_reveal_double_innerRight)), xPicTop+33+19, yPicBot+31, 72, outfieldHeight, 0
						else
							ui_infield "gs_reveal_double_innerBottom",	xPicTop+33+19, yPicBot+27, 72, infieldHeight ui_tooltip stRevealClusureUITips[9]
						endif
						ui_pict 21, xPicBot-11, yPicBot+32, 11, 10, 1		!ui_arrow_10_v.png
						if bForceUniformBottomReveal then
							ui_outfield str(formatt, abs(gs_reveal_right)), xPicTop-88, yPicBot+31, 72, outfieldHeight, 1
						else
							ui_infield "gs_reveal_bottom", xPicBot-88, yPicBot+27, 72, infieldHeight	ui_tooltip stRevealClusureUITips[7]
						endif
					endif
				endif
			endif

			if gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
				gosub "bottomPositiveReveal"
			else
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					gosub "bottomNoReveal"
				else
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
						gosub "bottomNegativeReveal"
					endif
				endif
			endif
		endif
	endif

! Double Splayed Reveal --------------------------------------------------------

	if iRevealType  = REVEAL_DOUBLE_SPLAYED then

		MFrame_flag = 0
		if not(gs_mountingFrame) then MFrame_flag = 4

			ui_style 0, 1
			ui_outfield stWallholeCutUI[17], x1, yRevealText, 320, 17

			yCurr = y0

			if bEnableMountingFrameForReveal then
				ui_infield{3} "gs_mountingFrame", x1, yCurr-infieldElevation, x3-x1-2, 20,
						7, "",
						2,
						1, 20, 20, 20, 20,
						0, stWallholeCutUI[21], 0,	! Mounting Frame
						1, stWallholeCutUI[21], 1	! Mounting Frame
			endif
			ui_style 0,0

			bDefaultElem = (GLOB_INTGUID = "" | GLOB_INTGUID = "{00000000-0000-0000-0000-000000000000}")
			flag = 4 * (not(bDefaultElem) & (bInclinedWall | AC_WallType = 2 | ac_wall_crosssection_type = 3 | ac_wall_crosssection_type = 4))

			ui_outfield stWallholeCutUI[22], x3, yCurr, x4-x3-2, 15, flag
			ui_infield{3}	"gs_reveal_angle_edit_by_int",	x4, yCurr-infieldElevation, x5-x4, 20,
					8, "", 3, 1, 0, 0, 0, 0,
					1, stWallholeCutUI[29], 1,	! Angle and Depth
					2, stWallholeCutUI[30], 2	! Width and Depth

			if gs_reveal_angle_edit_by_int = 1 then
				x_pict_w	= 15
				y_pict_w	= 142 + pageStartY
				x_pict_h	= 340
				y_pict_h	= 100 + pageStartY


				ui_pict 56, x_pict_w+2, y_pict_w-25-1, 19, 25, 1			!ui_angle_5.png
				ui_pict 57, x_pict_w+176-31, y_pict_w-25-1, 19, 25, 1		!ui_angle_6.png
				ui_pict 58, x_pict_w+24, y_pict_w-12, 12, 12, 1				!ui_arrow_h_12.png
				ui_pict 58, x_pict_w+130, y_pict_w-12, 12, 12, 1			!ui_arrow_h_12.png

				ui_pict 9, x_pict_h+42+1, y_pict_h+129-20, 25, 19, 1			!ui_angle_3.png
				ui_pict 8, x_pict_h+42+1, y_pict_h, 25, 19, 1					!ui_angle_4.png
				ui_pict 59, x_pict_h-25-1, y_pict_h+129-20, 25, 19, 1			!ui_angle_7.png
				ui_pict 60, x_pict_h-25-1, y_pict_h, 25, 19, 1					!ui_angle_8.png
				ui_pict 10, x_pict_h-17, y_pict_h+23, 17, 12, 1					!ui_arrow_v_12.png
				ui_pict 61, x_pict_h-17, y_pict_h+94, 17, 11, 1					!ui_arrow_v_11.png

				ui_infield "gs_reveal_left_angle",	x_pict_w-10,	y_pict_w+70, 60,18 ui_tooltip stRevealClusureUITips[10]
				ui_infield "gs_reveal_right_angle",	x_pict_w+144,	y_pict_w+70, 60,18 ui_tooltip stRevealClusureUITips[11]
				ui_infield "gs_reveal_outerLeft_angle",	x_pict_w-10,	y_pict_w-50, 60,18 ui_tooltip stRevealClusureUITips[14]
				ui_infield "gs_reveal_outerRight_angle",	x_pict_w+144,	y_pict_w-50, 60,18 ui_tooltip stRevealClusureUITips[15]

				ui_infield "gs_reveal_top_angle",	x_pict_h+42+3,	y_pict_h+24, 58,18 ui_tooltip stRevealClusureUITips[12]
				ui_infield "gs_reveal_bottom_angle",	x_pict_h+42+3,	y_pict_h+129-41, 58,18 ui_tooltip stRevealClusureUITips[13]
				ui_infield "gs_reveal_outerTop_angle",	x_pict_h-25-60-2,	y_pict_h, 60,18 ui_tooltip stRevealClusureUITips[16]
				ui_infield "gs_reveal_outerBottom_angle",	x_pict_h-25-60-2,	y_pict_h+129-19, 60,18 ui_tooltip stRevealClusureUITips[17]

				ui_infield "gs_wido_sill", x_pict_w+176+3, y_pict_w+2, 60, 20 ui_tooltip stRevealClusureUITips[1]
				ui_infield "gs_reveal_outer_jamb_depth", x_pict_w+176+3, y_pict_w+25, 60, 20 ui_tooltip stRevealClusureUITips[18]


				if gs_mountingFrame then
					!floor plan
					ui_pict 46, x_pict_w, y_pict_w, 176, 68, 1		!ui_reveal_doublesplayed_withBF_plan.png

					ui_infield "gs_mountingFrame_width_right",		x_pict_w+85,	y_pict_w-33, 55,20 ui_tooltip stRevealClusureUITips[20]
					ui_infield "gs_mountingFrame_width_left",		x_pict_w+25,	y_pict_w-33, 55,20 ui_tooltip stRevealClusureUITips[19]
					ui_infield "gs_mountingFrame_depth", 			x_pict_w+64, 	y_pict_w+70, 65,18 ui_tooltip stRevealClusureUITips[23]

					!section
					ui_pict 47, x_pict_h, y_pict_h, 42, 129, 1		!ui_reveal_doublesplayed_withBF_sect.png

					ui_infield "gs_mountingFrame_width_top",		x_pict_h-60-17-3, y_pict_h+19, 60, 20 ui_tooltip stRevealClusureUITips[21]
					ui_infield "gs_mountingFrame_width_bottom",		x_pict_h-60-17-3, y_pict_h+129-39, 60, 20 ui_tooltip stRevealClusureUITips[22]
				else
					!floor plan
					ui_pict 48, x_pict_w, y_pict_w, 176, 68, 1		!ui_reveal_doublesplayed_woutBF_plan.png

					ui_infield "gs_reveal_right",		x_pict_w+85,	y_pict_w-33, 55,20 ui_tooltip stRevealClusureUITips[3]
					ui_infield "gs_reveal_left",		x_pict_w+25,	y_pict_w-33, 55,20 ui_tooltip stRevealClusureUITips[2]

					!section
					ui_pict 49, x_pict_h, y_pict_h, 42, 129, 1		!ui_reveal_doublesplayed_woutBF_sect.png

					ui_infield "gs_reveal_top",		x_pict_h-60-17-3, y_pict_h+19, 60, 20 ui_tooltip stRevealClusureUITips[6]
					ui_infield "gs_reveal_bottom",	x_pict_h-60-17-3, y_pict_h+129-39, 60, 20 ui_tooltip stRevealClusureUITips[7]
				endif
			else
				x_pict_w	= 15
				y_pict_w	= 122 + pageStartY
				x_pict_h	= 314
				y_pict_h	= 100 + pageStartY

				ui_pict 86, x_pict_w+9, y_pict_w+72, 1, 20, 1			!dotted_line.png
				ui_pict 86, x_pict_w+154, y_pict_w+72, 1, 20, 1			!dotted_line.png

				ui_infield "gs_reveal_innerLeft_width",		x_pict_w-13,	y_pict_w+96, 60,18 ui_tooltip stRevealClusureUITips[24]
				ui_infield "gs_reveal_innerRight_width",	x_pict_w+135,	y_pict_w+96, 60,18 ui_tooltip stRevealClusureUITips[25]
				ui_infield "gs_reveal_outerLeft_width",		x_pict_w-13,	y_pict_w-24, 60,20 ui_tooltip stRevealClusureUITips[28]
				ui_infield "gs_reveal_outerRight_width",	x_pict_w+129,	y_pict_w-24, 60,20 ui_tooltip stRevealClusureUITips[29]

				ui_infield "gs_reveal_innerTop_width",		x_pict_h+70,	y_pict_h-6, 58,18 ui_tooltip stRevealClusureUITips[26]
				ui_infield "gs_reveal_innerBottom_width",	x_pict_h+70,	y_pict_h+116, 58,18 ui_tooltip stRevealClusureUITips[27]

				ui_infield "gs_wido_sill", 					x_pict_w+176+3, y_pict_w+14, 60, 20 ui_tooltip stRevealClusureUITips[1]
				ui_infield "gs_reveal_outer_jamb_depth", 	x_pict_w+176+3, y_pict_w+37, 60, 20 ui_tooltip stRevealClusureUITips[18]


				if gs_mountingFrame then
					!floor plan
					ui_pict 78, x_pict_w, y_pict_w, 175, 72, 1		!ui_reveal_doublesplayed_withBF_plan_width.png

					ui_infield "gs_mountingFrame_width_right",		x_pict_w+90,	y_pict_w+74, 60,20 ui_tooltip stRevealClusureUITips[20]
					ui_infield "gs_mountingFrame_width_left",		x_pict_w+20,	y_pict_w+74, 60,20 ui_tooltip stRevealClusureUITips[19]
					ui_infield "gs_mountingFrame_depth", 			x_pict_w+59, 	y_pict_w-24, 60,20 ui_tooltip stRevealClusureUITips[23]

					!section
					ui_pict 79, x_pict_h, y_pict_h, 67, 129, 1		!ui_reveal_doublesplayed_withBF_sect_width.png

					ui_infield "gs_mountingFrame_width_top",		x_pict_h+70, y_pict_h+19, 58, 20 ui_tooltip stRevealClusureUITips[21]
					ui_infield "gs_mountingFrame_width_bottom",		x_pict_h+70, y_pict_h+89, 58, 20 ui_tooltip stRevealClusureUITips[22]

					ui_infield "gs_reveal_outerTop_width",			x_pict_h-63,	y_pict_h+12, 60,18 ui_tooltip stRevealClusureUITips[30]
					ui_infield "gs_reveal_outerBottom_width",		x_pict_h-63,	y_pict_h+102, 60,18 ui_tooltip stRevealClusureUITips[31]
				else
					!floor plan
					ui_pict 80, x_pict_w, y_pict_w, 175, 72, 1		!ui_reveal_doublesplayed_woutBF_plan_width.png

					ui_infield "gs_reveal_right",					x_pict_w+90,	y_pict_w+74, 55,20 ui_tooltip stRevealClusureUITips[3]
					ui_infield "gs_reveal_left",					x_pict_w+20,	y_pict_w+74, 55,20 ui_tooltip stRevealClusureUITips[2]

					!section
					ui_pict 81, x_pict_h, y_pict_h, 67, 129, 1		!ui_reveal_doublesplayed_woutBF_sect_width.png

					ui_infield "gs_reveal_top",						x_pict_h+70, y_pict_h+19, 58, 20 ui_tooltip stRevealClusureUITips[6]
					ui_infield "gs_reveal_bottom",					x_pict_h+70, y_pict_h+89, 58, 20 ui_tooltip stRevealClusureUITips[7]

					ui_infield "gs_reveal_outerTop_width",			x_pict_h-63,	y_pict_h+17, 60,18 ui_tooltip stRevealClusureUITips[30]
					ui_infield "gs_reveal_outerBottom_width",		x_pict_h-63,	y_pict_h+97, 60,18 ui_tooltip stRevealClusureUITips[31]
				endif
			endif

	endif

! Outside Splayed Reveal -------------------------------------------------------

	if iRevealType  = REVEAL_OUTSIDE_SPLAYED then
		y = 45 + pageStartY
		x = 2

		MFrame_flag = 0
		if not(gs_mountingFrame) then MFrame_flag = 4

			ui_style 0, 1
			ui_outfield stWallholeCutUI[19], x, yRevealText, 320, 17

			yCurr = y0

			if bEnableMountingFrameForReveal then
				ui_infield{3} "gs_mountingFrame", x1, yCurr-infieldElevation, x3-x1-2, 20,
						7, "",
						2,
						1, 20, 20, 20, 20,
						0, stWallholeCutUI[21], 0,	! Mounting Frame
						1, stWallholeCutUI[21], 1	! Mounting Frame
			endif
			ui_style 0,0

			bDefaultElem = (GLOB_INTGUID = "" | GLOB_INTGUID = "{00000000-0000-0000-0000-000000000000}")
			flag = 4 * (not(bDefaultElem) & (bInclinedWall | AC_WallType = 2 | ac_wall_crosssection_type = 3 | ac_wall_crosssection_type = 4))

			ui_outfield stWallholeCutUI[22], x3, yCurr, x4-x3-2, 15, flag
			ui_infield{3}	"gs_reveal_angle_edit_by_int",	x4, yCurr-infieldElevation, x5-x4, 20,
					8, "", 3, 1, 0, 0, 0, 0,
					1, stWallholeCutUI[29], 1,	! Angle and Depth
					2, stWallholeCutUI[30], 2	! Width and Depth

			if gs_reveal_angle_edit_by_int = 1 then
				x_pict_w	= 15
				y_pict_w	= 142 + pageStartY
				x_pict_h	= 340
				y_pict_h	= 100 + pageStartY


				ui_pict 56, x_pict_w+2, y_pict_w-25-1, 19, 25, 1			!ui_angle_5.png
				ui_pict 57, x_pict_w+176-31, y_pict_w-25-1, 19, 25, 1		!ui_angle_6.png
				ui_pict 74, x_pict_w+24, y_pict_w-12, 11, 12, 1				!ui_arrow_h_11.png
				ui_pict 74, x_pict_w+129, y_pict_w-12, 11, 12, 1			!ui_arrow_h_11.png

				ui_pict 59, x_pict_h-25-1, y_pict_h+129-20, 25, 19, 1			!ui_angle_7.png
				ui_pict 60, x_pict_h-25-1, y_pict_h, 25, 19, 1					!ui_angle_8.png
				if gs_mountingFrame then
					ui_pict 61, x_pict_h-17, y_pict_h+24, 17, 11, 1					!ui_arrow_v_11.png
				else
					ui_pict 10, x_pict_h-17, y_pict_h+23, 17, 12, 1					!ui_arrow_v_12.png
				endif
				ui_pict 61, x_pict_h-17, y_pict_h+94, 17, 11, 1					!ui_arrow_v_11.png

				ui_infield "gs_reveal_outerLeft_angle",	x_pict_w-10,	y_pict_w-50, 60,18 ui_tooltip stRevealClusureUITips[14]
				ui_infield "gs_reveal_outerRight_angle",	x_pict_w+144,	y_pict_w-50, 60,18 ui_tooltip stRevealClusureUITips[15]

				ui_infield "gs_reveal_outerTop_angle",	x_pict_h-25-60-2,	y_pict_h, 60,18 ui_tooltip stRevealClusureUITips[16]
				ui_infield "gs_reveal_outerBottom_angle",	x_pict_h-25-60-2,	y_pict_h+129-19, 60,18 ui_tooltip stRevealClusureUITips[17]

				ui_infield "gs_wido_sill", x_pict_w+176+3, y_pict_w+2, 60, 20 ui_tooltip stRevealClusureUITips[1]
				ui_infield "gs_reveal_outer_jamb_depth", x_pict_w+176+3, y_pict_w+25, 60, 20 ui_tooltip stRevealClusureUITips[18]



				if gs_mountingFrame then
					!floor plan
					ui_pict 50, x_pict_w, y_pict_w, 175, 50, 1		!ui_reveal_outsidesplayed_withBF_plan.png

					ui_infield "gs_mountingFrame_width_right",		x_pict_w+85,	y_pict_w-33, 55,20 ui_tooltip stRevealClusureUITips[20]
					ui_infield "gs_mountingFrame_width_left",		x_pict_w+25,	y_pict_w-33, 55,20 ui_tooltip stRevealClusureUITips[19]
					ui_infield "gs_mountingFrame_depth", 			x_pict_w+60, 	y_pict_w+56, 65,18 ui_tooltip stRevealClusureUITips[23]

					!section
					ui_pict 51, x_pict_h, y_pict_h, 42, 129, 1		!ui_reveal_outsidesplayed_withBF_sect.png

					ui_infield "gs_mountingFrame_width_top",		x_pict_h-60-17-3, y_pict_h+19, 60, 20 ui_tooltip stRevealClusureUITips[21]
					ui_infield "gs_mountingFrame_width_bottom",		x_pict_h-60-17-3, y_pict_h+129-39, 60, 20 ui_tooltip stRevealClusureUITips[22]
				else
					!floor plan
					ui_pict 52, x_pict_w, y_pict_w, 175, 42, 1		!ui_reveal_outsidesplayed_woutBF_plan.png

					ui_infield "gs_reveal_right",		x_pict_w+85,	y_pict_w-33, 55,20 ui_tooltip stRevealClusureUITips[3]
					ui_infield "gs_reveal_left",		x_pict_w+25,	y_pict_w-33, 55,20 ui_tooltip stRevealClusureUITips[2]

					!section
					ui_pict 53, x_pict_h, y_pict_h, 42, 129, 1		!ui_reveal_outsidesplayed_woutBF_sect.png

					ui_infield "gs_reveal_top",		x_pict_h-60-17-3, y_pict_h+19, 60, 20 ui_tooltip stRevealClusureUITips[6]
					ui_infield "gs_reveal_bottom",	x_pict_h-60-17-3, y_pict_h+129-39, 60, 20 ui_tooltip stRevealClusureUITips[7]
				endif
			else
				x_pict_w	= 15
				y_pict_w	= 122 + pageStartY
				x_pict_h	= 314
				y_pict_h	= 100 + pageStartY

				ui_infield "gs_reveal_outerLeft_width",		x_pict_w-13,	y_pict_w-24, 60,20 ui_tooltip stRevealClusureUITips[28]
				ui_infield "gs_reveal_outerRight_width",	x_pict_w+129,	y_pict_w-24, 60,20 ui_tooltip stRevealClusureUITips[29]

				ui_infield "gs_wido_sill", 					x_pict_w+176+3, y_pict_w+14, 60, 20 ui_tooltip stRevealClusureUITips[1]
				ui_infield "gs_reveal_outer_jamb_depth", 	x_pict_w+176+3, y_pict_w+37, 60, 20 ui_tooltip stRevealClusureUITips[18]

				if gs_mountingFrame then
					!floor plan
					ui_pict 82, x_pict_w, y_pict_w, 175, 71, 1		!ui_reveal_outsidesplayed_withBF_plan_width.png

					ui_infield "gs_mountingFrame_width_right",		x_pict_w+116,	y_pict_w+74, 60,20 ui_tooltip stRevealClusureUITips[20]
					ui_infield "gs_mountingFrame_width_left",		x_pict_w+13,	y_pict_w+74, 60,20 ui_tooltip stRevealClusureUITips[19]
					ui_infield "gs_mountingFrame_depth", 			x_pict_w+59, 	y_pict_w-24, 60,20 ui_tooltip stRevealClusureUITips[23]

					!section
					ui_pict 83, x_pict_h, y_pict_h, 67, 129, 1		!ui_reveal_outsidesplayed_withBF_sect_width.png

					ui_infield "gs_mountingFrame_width_top",		x_pict_h+70, y_pict_h+19, 58, 20 ui_tooltip stRevealClusureUITips[21]
					ui_infield "gs_mountingFrame_width_bottom",		x_pict_h+70, y_pict_h+89, 58, 20 ui_tooltip stRevealClusureUITips[22]

					ui_infield "gs_reveal_outerTop_width",			x_pict_h-63,	y_pict_h+8, 60,18 ui_tooltip stRevealClusureUITips[30]
					ui_infield "gs_reveal_outerBottom_width",		x_pict_h-63,	y_pict_h+106, 60,18 ui_tooltip stRevealClusureUITips[31]
				else
					!floor plan
					ui_pict 84, x_pict_w, y_pict_w, 175, 71, 1		!ui_reveal_outsidesplayed_woutBF_plan_width.png

					ui_infield "gs_reveal_right",					x_pict_w+116,	y_pict_w+74, 60,20 ui_tooltip stRevealClusureUITips[3]
					ui_infield "gs_reveal_left",					x_pict_w+13,	y_pict_w+74, 60,20 ui_tooltip stRevealClusureUITips[2]

					!section
					ui_pict 85, x_pict_h, y_pict_h, 67, 129, 1		!ui_reveal_outsidesplayed_woutBF_sect_width.png

					ui_infield "gs_reveal_top",						x_pict_h+70, 	y_pict_h+19, 58, 20 ui_tooltip stRevealClusureUITips[6]
					ui_infield "gs_reveal_bottom",					x_pict_h+70, 	y_pict_h+89, 58, 20 ui_tooltip stRevealClusureUITips[7]

					ui_infield "gs_reveal_outerTop_width",			x_pict_h-63,	y_pict_h+17, 60,18 ui_tooltip stRevealClusureUITips[30]
					ui_infield "gs_reveal_outerBottom_width",		x_pict_h-63,	y_pict_h+100, 60,18 ui_tooltip stRevealClusureUITips[31]
				endif
			endif

	endif

endif


! ==============================================================================
! Wall Inset tabpage
! ==============================================================================

if bWallInsetPage & isWindow then

	pageStartY = 5 + 30

	y = pageStartY
	dy = 25
	x1 = 5
	x2 = 190
	x3 = 225
	x4 = 440

	ui_style 0,1
	ui_infield{3} "gs_parapet_wall_inset", x1, y-4, x4-x1-1, 19,
				7, "",
				2,
				1, 20, 20, 20, 20,
				0, stWallholeCutUI[3], 0,		! Wall Inset
				1, stWallholeCutUI[3], 1		! Wall Inset

	y = y + dy

	ui_style 0,0

	bFlag = not (gs_parapet_wall_inset)
	iFlag = 4 * bFlag

	ui_outfield stWallholeCutUI[14], x1, y, x2-x1-1, 15, iFlag		! Wall Inset Sizes
	ui_infield{3}	"iParapetSize", x2, y-4, 120, 19,
			8, "", 3, 1,
			0, 0, 0, 0,
			1, stParapetSize[1], PARAPET_SIZE_AUTO,
			2, stParapetSize[2], PARAPET_SIZE_SYMM,
			3, stParapetSize[3], PARAPET_SIZE_ASYMM

	bFlag = not (gs_parapet_wall_inset & gs_parapet_2D)
	iFlag = 4 * bFlag

	ui_separator 326, y-9, 326, 185


	y = pageStartY + 82 - 10

	bFlag = not (gs_parapet_wall_inset)
	iFlag = 4 * bFlag

	ui_outfield stWallholeCutUI[10], x1, y + 7, 125, 15, iFlag		! Wall Inset Bottom at:
	ui_infield{3}	"iParapetBottom", x1, y + 27, 120, 19,
			8, "", 3, 1,
			0, 0, 0, 0,
			1, stParapetBottom[1], PARAPET_BOTTOM_CURRENTSTORY,
			2, stParapetBottom[2], PARAPET_BOTTOM_WALLBASE

	if iParapetSize = PARAPET_SIZE_ASYMM then
		ui_pict 24, x1+130, y-15, 80, 70, 1		! ui_wallinset_front_asymm
		ui_infield "gs_parapet_left",	x1+89,  y+62,	90, 19	ui_tooltip stWallholeCutUI[15]		! Overhang Side 2
		ui_infield "gs_parapet_right",	x1+183, y+62,	90, 19	ui_tooltip stWallholeCutUI[16]		! Overhang Side 1
	else
		if iParapetSize = PARAPET_SIZE_SYMM then
			ui_pict 25, x1+130, y-15, 80, 70, 1		! ui_wallinset_front_sym
			ui_infield "gs_parapet_width",	x1+142, y+62,	90, 19	ui_tooltip stWallholeCutUI[11]	! Width of Wall Inset
		else
			ui_pict 22, x1+130, y-15, 80, 70, 1		! ui_wallinset_front
		endif
	endif

	y = y - 20

	if iParapetSize <> PARAPET_SIZE_AUTO then
		ui_infield "gs_parapet_height",	x1+215, y+12,	90, 19	ui_tooltip stWallholeCutUI[12]		! Height of Wall Inset
	endif

	ui_infield "gs_parapet_botelev",	x1+215, y+36,	90, 19	ui_tooltip stWallholeCutUI[13]		! Bottom Elevation

	ui_pict 23, x3+119, y-15, 61, 76, 1	! ui_wallinset_section

	ui_infield "gs_parapet_inset_thk",	x3+122, y+62,	90, 19	ui_tooltip stWallholeCutUI[4]		! Depth of Wall Inset

	y = pageStartY + 184 - 27

	ui_separator 0, y, 444, y

	y = y + 20

	ui_infield{3} "gs_parapet_2D", x1, y, 280, 15,
				7, "",
				2,
				1, 20, 20, 20, 20,
				0, stWallholeCutUI[7], 0,		! Show Hidden Parapet on 2D
				1, stWallholeCutUI[7], 1		! Show Hidden Parapet on 2D

	y = y + dy

	ui_outfield stWallholeCutUI[9], x1, y, 184, 15, iFlag		! Hidden Parapet Line Type
	ui_infield "gs_parapet_line", 190, y, x4-x3-40, 25

endif

! ==================================================================================================
end
! ==================================================================================================

"ui of t shape":
	ui_pict 95, xPic+122, yPic-10, 13, 21, 1	! ui_arrow_v_21.png
	ui_infield "gs_wido_sill", xPic+90, yPic-30, 72, infieldHeight ui_tooltip stRevealClusureUITips[1]

	bNegativeView = 0
	if iRevealType = REVEAL_POSITIVE then
		bNegativeView = 0
		gs_reveal_set_side = REVEAL_SET_OUTSIDE
		ui_pict 15, xPic, yPic, 121, 33, 1		!reveal_door.png
	endif

	if iRevealType = REVEAL_NEGATIVE then
		bNegativeView = 1
		gs_reveal_set_side = REVEAL_SET_OUTSIDE
		ui_pict 106, xPic, yPic, 121, 33, 1	!negative_reveal_door.png
	endif

	if iRevealType = REVEAL_DOUBLE then
		if iSillRevealType = REVEAL_NO then
			gs_reveal_set_side = REVEAL_SET_INSIDE
		endif
		if iBoardRevealType = REVEAL_NO then
			gs_reveal_set_side = REVEAL_SET_OUTSIDE
		endif

		bRevealSetSide = 1
		if iSillRevealType = REVEAL_NO then
			bRevealSetSide = 0
			if iBoardRevealType = REVEAL_NO then
				ui_pict 2, xPic, yPic, 121, 33, 1		!no_reveal_door.png
				gosub "noRevealPicsVertical"

				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
					gosub "bottomPositiveReveal"
				else
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
						gosub "bottomNegativeReveal"
					else
						gosub "bottomNoReveal"
					endif
				endif
				end
			endif

			if iBoardRevealType = REVEAL_POSITIVE then
				bNegativeView = 1
				ui_pict 39, xPic, yPic, 121, 33, 1	!custom_norev_rev_door.png
			endif

			if iBoardRevealType = REVEAL_NEGATIVE then
				bNegativeView = 0
				ui_pict 160, xPic, yPic, 121, 33, 1	!custom_norev_negrev_door.png
			endif
		endif

		if iSillRevealType = REVEAL_POSITIVE then
			if iBoardRevealType = REVEAL_NO then
				bRevealSetSide = 0
				bNegativeView = 0
				ui_pict 15, xPic, yPic, 121, 33, 1	!reveal_door.png
			endif

			if iBoardRevealType = REVEAL_POSITIVE then
				if gs_reveal_set_side = REVEAL_SET_OUTSIDE then
					bNegativeView = 0
				else
					bNegativeView = 1
				endif
				ui_pict 27, xPic, yPic, 121, 33, 1	!custom_rev_rev_door.png
			endif

			if iBoardRevealType = REVEAL_NEGATIVE then
				bNegativeView = 0
				ui_pict 42, xPic, yPic, 121, 33, 1	!custom_rev_negrev_door.png
			endif
		endif

		if iSillRevealType = REVEAL_NEGATIVE then
			if iBoardRevealType = REVEAL_NO then
				bRevealSetSide = 0
				bNegativeView = 1
				ui_pict 106, xPic, yPic, 121, 33, 1	!negative_reveal_door.png
			endif

			if iBoardRevealType = REVEAL_POSITIVE then
				bNegativeView = 1
				ui_pict 175, xPic, yPic, 121, 33, 1	!custom_negrev_rev_door.png
			endif

			if iBoardRevealType = REVEAL_NEGATIVE then
				if gs_reveal_set_side = REVEAL_SET_OUTSIDE then
					bNegativeView = 1
				else
					bNegativeView = 0
				endif
				ui_pict 184, xPic, yPic, 121, 33, 1	!custom_negrev_negrev_door.png
			endif
		endif

		if bRevealSetSide then
			ui_outfield stWallholeCutUI[31], x2, yRevealText, x3-x2-2, 15	! Set Jamb Depth on
			ui_infield{3} "gs_reveal_set_side", x3, yRevealText-infieldElevation, x4-x3, 20,
					8, "",
					2,
					1, 20, 20, 20, 20,
					0, stSetRevealSide[1], REVEAL_SET_INSIDE,	! Inside
					1, stSetRevealSide[2], REVEAL_SET_OUTSIDE	! Outside
		endif
	endif

	cx		= 72
	picx	= 113
	picy	= 113
	x		= 254
	y		= 103 + pageStartY

	if iWindowShape = SHAPE_T then
		if (bRevealSetSide & gs_reveal_set_side = REVEAL_SET_INSIDE & gs_reveal_type_bottom_int <> REVEAL_BOTTOM_UNIFORM) then
			if not(bNegativeView) then
				ui_pict 87, x, y, picx, picy, 1	! T_Rev_BottNoRev.png
			endif

			if bNegativeView then
				ui_pict 90, x, y, picx, picy, 1	! T_NegRev_BottNoRev.png
			endif
		else
			if not(bNegativeView) then
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					ui_pict 87, x, y, picx, picy, 1	! T_Rev_BottNoRev.png
				else
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
						ui_pict 88, x, y, picx, picy, 1	! T_Rev_BottNegRev.png
					else
						ui_pict 89, x, y, picx, picy, 1	! T_Rev.png
					endif
				endif
			endif

			if bNegativeView then
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					ui_pict 90, x, y, picx, picy, 1	! T_NegRev_BottNoRev.png
				else
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
						ui_pict 91, x, y, picx, picy, 1	! T_NegRev_BottRev.png
					else
						ui_pict 92, x, y, picx, picy, 1	! T_NegRev_BottNegRev.png
					endif
				endif
			endif
		endif

		if gs_reveal_set_side = REVEAL_SET_OUTSIDE then
			if gs_reveal_type_bottom_int <> REVEAL_BOTTOM_NO then
				ui_infield "gs_reveal_bottom", x+34, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[7]
			endif
			if bEnableUniformJambDepths & gs_reveal_uniform then
				ui_infield "gs_reveal_right", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[40]
				n = request("Working_length_unit", "", formatt)
				ui_outfield str(formatt, abs(gs_reveal_top)), x+20, y-16, cx, outfieldHeight, 2
				ui_outfield str(formatt, abs(gs_reveal_left)), x-cx-4, y+41, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_left_sL)), x-cx-4, y+83, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_right_sR)), x+picx+5, y+86, cx, outfieldHeight, 0
				ui_outfield str(formatt, abs(gs_reveal_bottom_sL)), x+25-cx, y+picy+5, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_bottom_sR)), x+40+cx, y+picy+5, cx, outfieldHeight, 0
			else
				ui_infield "gs_reveal_top", x+32, y-20, cx, infieldHeight ui_tooltip stRevealClusureUITips[6]
				ui_infield "gs_reveal_right", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[3]
				ui_infield "gs_reveal_left", x-cx-2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[2]
				ui_infield "gs_reveal_left_sL", x-cx-2, y+79, cx, infieldHeight ui_tooltip stRevealClusureUITips[32]
				ui_infield "gs_reveal_right_sR", x+picx+2, y+82, cx, infieldHeight ui_tooltip stRevealClusureUITips[33]
				ui_infield "gs_reveal_bottom_sL", x+26-cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[34]
				ui_infield "gs_reveal_bottom_sR", x+38+cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[35]
			endif
		else
			if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
				ui_infield "gs_reveal_double_innerBottom", x+34, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[9]
			endif
			if bEnableUniformJambDepths & gs_reveal_uniform then
				ui_infield "gs_reveal_double_innerRight", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[41]
				n = request("Working_length_unit", "", formatt)
				ui_outfield str(formatt, abs(gs_reveal_double_innerTop)), x+20, y-16, cx, outfieldHeight, 2
				ui_outfield str(formatt, abs(gs_reveal_double_innerLeft)), x-cx-4, y+41, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_double_innerLeft_sL)), x-cx-4, y+83, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_double_innerRight_sR)), x+picx+5, y+86, cx, outfieldHeight, 0
				ui_outfield str(formatt, abs(gs_reveal_double_innerBottom_sL)), x+25-cx, y+picy+5, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_double_innerBottom_sR)), x+40+cx, y+picy+5, cx, outfieldHeight, 0
			else
				ui_infield "gs_reveal_double_innerTop", x+32, y-22, cx, infieldHeight ui_tooltip stRevealClusureUITips[8]
				ui_infield "gs_reveal_double_innerRight", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[5]
				ui_infield "gs_reveal_double_innerLeft", x-cx-2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[4]
				ui_infield "gs_reveal_double_innerLeft_sL", x-cx-2, y+79, cx, infieldHeight ui_tooltip stRevealClusureUITips[36]
				ui_infield "gs_reveal_double_innerRight_sR", x+picx+2, y+82, cx, infieldHeight ui_tooltip stRevealClusureUITips[37]
				ui_infield "gs_reveal_double_innerBottom_sL", x+26-cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[38]
				ui_infield "gs_reveal_double_innerBottom_sR", x+38+cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[39]
			endif
		endif
	endif

	if iWindowShape = SHAPE_HALF_T_LEFT then
		if (bRevealSetSide & gs_reveal_set_side = REVEAL_SET_INSIDE & gs_reveal_type_bottom_int <> REVEAL_BOTTOM_UNIFORM) |\
			iSillRevealType = REVEAL_NO then
			if not(bNegativeView) then
				ui_pict 93, x, y, picx, picy, 1	! P_Rev_BottNoRev.png
			endif

			if bNegativeView then
				ui_pict 97, x, y, picx, picy, 1	! P_NegRev_BottNoRev.png
			endif
		else
			if not(bNegativeView) then
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					ui_pict 93, x, y, picx, picy, 1	! P_Rev_BottNoRev.png
				else
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
						ui_pict 94, x, y, picx, picy, 1	! P_Rev_BottNegRev.png
					else
						ui_pict 96, x, y, picx, picy, 1	! P_Rev.png
					endif
				endif
			endif

			if bNegativeView then
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					ui_pict 97, x, y, picx, picy, 1	! P_NegRev_BottNoRev.png
				else
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
						ui_pict 98, x, y, picx, picy, 1	! P_NegRev_BottRev.png
					else
						ui_pict 99, x, y, picx, picy, 1	! P_NegRev_BottNegRev.png
					endif
				endif
			endif
		endif

		if gs_reveal_set_side = REVEAL_SET_OUTSIDE then
			if gs_reveal_type_bottom_int <> REVEAL_BOTTOM_NO then
				ui_infield "gs_reveal_bottom", x+54, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[7]
			endif
			if bEnableUniformJambDepths & gs_reveal_uniform then
				ui_infield "gs_reveal_right", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[40]
				n = request("Working_length_unit", "", formatt)
				ui_outfield str(formatt, abs(gs_reveal_top)), x+20, y-16, cx, outfieldHeight, 2
				ui_outfield str(formatt, abs(gs_reveal_left)), x-cx-4, y+41, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_left_sL)), x-cx-4, y+83, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_bottom_sL)), x+35-cx, y+picy+5, cx, outfieldHeight, 1
			else
				ui_infield "gs_reveal_top", x+32, y-20, cx, infieldHeight ui_tooltip stRevealClusureUITips[6]
				ui_infield "gs_reveal_right", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[3]
				ui_infield "gs_reveal_left", x-cx-2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[2]
				ui_infield "gs_reveal_left_sL", x-cx-2, y+79, cx, infieldHeight ui_tooltip stRevealClusureUITips[32]
				ui_infield "gs_reveal_bottom_sL", x+50-cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[34]
			endif
		else
			if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
				ui_infield "gs_reveal_double_innerBottom", x+54, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[9]
			endif
			if bEnableUniformJambDepths & gs_reveal_uniform then
				ui_infield "gs_reveal_double_innerRight", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[41]
				n = request("Working_length_unit", "", formatt)
				ui_outfield str(formatt, abs(gs_reveal_double_innerTop)), x+20, y-16, cx, outfieldHeight, 2
				ui_outfield str(formatt, abs(gs_reveal_double_innerLeft)), x-cx-4, y+41, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_double_innerLeft_sL)), x-cx-4, y+83, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_double_innerBottom_sL)), x+35-cx, y+picy+5, cx, outfieldHeight, 1
			else
				ui_infield "gs_reveal_double_innerTop", x+32, y-22, cx, infieldHeight ui_tooltip stRevealClusureUITips[8]
				ui_infield "gs_reveal_double_innerRight", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[5]
				ui_infield "gs_reveal_double_innerLeft", x-cx-2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[4]
				ui_infield "gs_reveal_double_innerLeft_sL", x-cx-2, y+79, cx, infieldHeight ui_tooltip stRevealClusureUITips[36]
				ui_infield "gs_reveal_double_innerBottom_sL", x+50-cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[38]
			endif
		endif
	endif

	if iWindowShape = SHAPE_HALF_T_RIGHT then
		if (bRevealSetSide & gs_reveal_set_side = REVEAL_SET_INSIDE & gs_reveal_type_bottom_int <> REVEAL_BOTTOM_UNIFORM) |\
			iSillRevealType = REVEAL_NO then
			if not(bNegativeView) then
				ui_pict 199, x, y, picx, picy, 1	! P_righT_Rev_BottNoRev.png
			endif

			if bNegativeView then
				ui_pict 202, x, y, picx, picy, 1	! P_right_NegRev_BottNoRev.png
			endif
		else
			if not(bNegativeView) then
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					ui_pict 199, x, y, picx, picy, 1	! P_righT_Rev_BottNoRev.png
				else
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
						ui_pict 200, x, y, picx, picy, 1	! P_right_Rev_BottNegRev.png
					else
						ui_pict 201, x, y, picx, picy, 1	! P_righT_Rev.png
					endif
				endif
			endif

			if bNegativeView then
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					ui_pict 202, x, y, picx, picy, 1	! P_right_NegRev_BottNoRev.png
				else
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
						ui_pict 203, x, y, picx, picy, 1	! P_right_NegRev_BottRev.png
					else
						ui_pict 204, x, y, picx, picy, 1	! P_righT_NegRev_BottNegRev.png
					endif
				endif
			endif
		endif

		if gs_reveal_set_side = REVEAL_SET_OUTSIDE then
			if gs_reveal_type_bottom_int <> REVEAL_BOTTOM_NO then
				ui_infield "gs_reveal_bottom", x+71-cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[7]
			endif
			if bEnableUniformJambDepths & gs_reveal_uniform then
				ui_infield "gs_reveal_right", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[40]
				n = request("Working_length_unit", "", formatt)
				ui_outfield str(formatt, abs(gs_reveal_top)), x+20, y-16, cx, outfieldHeight, 2
				ui_outfield str(formatt, abs(gs_reveal_left)), x-cx-4, y+41, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_right_sR)), x+picx+2, y+83, cx, outfieldHeight, 0
				ui_outfield str(formatt, abs(gs_reveal_bottom_sR)), x+77, y+picy+5, cx, outfieldHeight, 0
			else
				ui_infield "gs_reveal_top", x+32, y-20, cx, infieldHeight ui_tooltip stRevealClusureUITips[6]
				ui_infield "gs_reveal_right", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[3]
				ui_infield "gs_reveal_left", x-cx-2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[2]
				ui_infield "gs_reveal_right_sR", x+picx+2, y+79, cx, infieldHeight ui_tooltip stRevealClusureUITips[33]
				ui_infield "gs_reveal_bottom_sR", x+54, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[35]
			endif
		else
			if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
				ui_infield "gs_reveal_double_innerBottom", x+71-cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[9]
			endif
			if bEnableUniformJambDepths & gs_reveal_uniform then
				ui_infield "gs_reveal_double_innerRight", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[41]
				n = request("Working_length_unit", "", formatt)
				ui_outfield str(formatt, abs(gs_reveal_double_innerTop)), x+20, y-16, cx, outfieldHeight, 2
				ui_outfield str(formatt, abs(gs_reveal_double_innerLeft)), x-cx-4, y+41, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_double_innerRight_sR)), x+picx+2, y+83, cx, outfieldHeight, 0
				ui_outfield str(formatt, abs(gs_reveal_double_innerBottom_sR)), x+8+cx, y+picy+5, cx, outfieldHeight, 0
			else
				ui_infield "gs_reveal_double_innerTop", x+32, y-22, cx, infieldHeight ui_tooltip stRevealClusureUITips[8]
				ui_infield "gs_reveal_double_innerRight", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[5]
				ui_infield "gs_reveal_double_innerLeft", x-cx-2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[4]
				ui_infield "gs_reveal_double_innerRight_sR", x+picx+2, y+79, cx, infieldHeight ui_tooltip stRevealClusureUITips[37]
				ui_infield "gs_reveal_double_innerBottom_sR", x+8+cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[39]
			endif
		endif
	endif

	if iWindowShape = SHAPE_ARCHED_T then
		if (bRevealSetSide & gs_reveal_set_side = REVEAL_SET_INSIDE & gs_reveal_type_bottom_int <> REVEAL_BOTTOM_UNIFORM) then
			if not(bNegativeView) then
				ui_pict 100, x, y, picx, picy, 1	! T_Seg_Rev_BottNoRev.png
			endif

			if bNegativeView then
				ui_pict 103, x, y, picx, picy, 1	! T_Seg_NegRev_BottNoRev.png
			endif
		else
			if not(bNegativeView) then
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					ui_pict 100, x, y, picx, picy, 1	! T_Seg_Rev_BottNoRev.png
				else
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
						ui_pict 101, x, y, picx, picy, 1	! T_Seg_Rev_BottNegRev.png
					else
						ui_pict 102, x, y, picx, picy, 1	! T_Seg_Rev.png
					endif
				endif
			endif

			if bNegativeView then
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					ui_pict 103, x, y, picx, picy, 1	! T_Seg_NegRev_BottNoRev.png
				else
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
						ui_pict 104, x, y, picx, picy, 1	! T_Seg_NegRev_BottRev.png
					else
						ui_pict 192, x, y, picx, picy, 1	! T_Seg_NegRev_BottNegRev.png
					endif
				endif
			endif
		endif

		n = request("Working_length_unit", "", formatt)
		if gs_reveal_set_side = REVEAL_SET_OUTSIDE then
			ui_outfield str(formatt, abs(gs_reveal_left)), x-cx-4, y+41, cx, outfieldHeight, 1
			ui_outfield str(formatt, abs(gs_reveal_top)), x+20, y-16, cx, outfieldHeight, 2
			ui_infield "gs_reveal_right", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[42]
			if gs_reveal_type_bottom_int <> REVEAL_BOTTOM_NO then
				ui_infield "gs_reveal_bottom", x+30, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[7]
			endif
			if bEnableUniformJambDepths & gs_reveal_uniform then
				ui_outfield str(formatt, abs(gs_reveal_left_sL)), x-cx-4, y+83, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_right_sR)), x+picx+5, y+86, cx, outfieldHeight, 0
				ui_outfield str(formatt, abs(gs_reveal_bottom_sL)), x+25-cx, y+picy+5, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_bottom_sR)), x+38+cx, y+picy+5, cx, outfieldHeight, 0
			else
				ui_infield "gs_reveal_left_sL", x-cx-2, y+79, cx, infieldHeight ui_tooltip stRevealClusureUITips[32]
				ui_infield "gs_reveal_right_sR", x+picx+2, y+82, cx, infieldHeight ui_tooltip stRevealClusureUITips[33]
				ui_infield "gs_reveal_bottom_sL", x+24-cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[34]
				ui_infield "gs_reveal_bottom_sR", x+36+cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[35]
			endif
		else
			ui_outfield str(formatt, abs(gs_reveal_double_innerLeft)), x-cx-4, y+41, cx, outfieldHeight, 1
			ui_outfield str(formatt, abs(gs_reveal_double_innerTop)), x+20, y-16, cx, outfieldHeight, 2
			ui_infield "gs_reveal_double_innerRight", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[43]
			if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
				ui_infield "gs_reveal_double_innerBottom", x+30, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[9]
			endif
			if bEnableUniformJambDepths & gs_reveal_uniform then
				ui_outfield str(formatt, abs(gs_reveal_double_innerLeft_sL)), x-cx-4, y+83, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_double_innerRight_sR)), x+picx+5, y+86, cx, outfieldHeight, 0
				ui_outfield str(formatt, abs(gs_reveal_double_innerBottom_sL)), x+25-cx, y+picy+5, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_double_innerBottom_sR)), x+38+cx, y+picy+5, cx, outfieldHeight, 0
			else
				ui_infield "gs_reveal_double_innerLeft_sL", x-cx-2, y+79, cx, infieldHeight ui_tooltip stRevealClusureUITips[36]
				ui_infield "gs_reveal_double_innerRight_sR", x+picx+2, y+82, cx, infieldHeight ui_tooltip stRevealClusureUITips[37]
				ui_infield "gs_reveal_double_innerBottom_sL", x+24-cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[38]
				ui_infield "gs_reveal_double_innerBottom_sR", x+36+cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[39]
			endif
		endif
	endif

	if iWindowShape = SHAPE_ARCHED_HALF_T_LEFT then
		if (bRevealSetSide & gs_reveal_set_side = REVEAL_SET_INSIDE & gs_reveal_type_bottom_int <> REVEAL_BOTTOM_UNIFORM) |\
			iSillRevealType = REVEAL_NO then
			if not(bNegativeView) then
				ui_pict 193, x, y, picx, picy, 1	! P_Seg_Rev_BottNoRev.png
			endif

			if bNegativeView then
				ui_pict 196, x, y, picx, picy, 1	! P_Seg_NegRev_BottNoRev.png
			endif
		else
			if not(bNegativeView) then
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					ui_pict 193, x, y, picx, picy, 1	! P_Seg_Rev_BottNoRev.png
				else
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
						ui_pict 194, x, y, picx, picy, 1	! P_Seg_Rev_BottNegRev.png
					else
						ui_pict 195, x, y, picx, picy, 1	! P_Seg_Rev.png
					endif
				endif
			endif

			if bNegativeView then
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					ui_pict 196, x, y, picx, picy, 1	! P_Seg_NegRev_BottNoRev.png
				else
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
						ui_pict 197, x, y, picx, picy, 1	! P_Seg_NegRev_BottRev.png
					else
						ui_pict 198, x, y, picx, picy, 1	! P_Seg_NegRev_BottNegRev.png
					endif
				endif
			endif
		endif

		n = request("Working_length_unit", "", formatt)
		if gs_reveal_set_side = REVEAL_SET_OUTSIDE then
			ui_outfield str(formatt, abs(gs_reveal_left)), x-cx-4, y+41, cx, outfieldHeight, 1
			ui_outfield str(formatt, abs(gs_reveal_top)), x+20, y-16, cx, outfieldHeight, 2
			ui_infield "gs_reveal_right", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[42]
			if gs_reveal_type_bottom_int <> REVEAL_BOTTOM_NO then
				ui_infield "gs_reveal_bottom", x+54, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[7]
			endif
			if bEnableUniformJambDepths & gs_reveal_uniform then
				n = request("Working_length_unit", "", formatt)
				ui_outfield str(formatt, abs(gs_reveal_left_sL)), x-cx-4, y+83, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_bottom_sL)), x+33-cx, y+picy+5, cx, outfieldHeight, 1
			else
				ui_infield "gs_reveal_left_sL", x-cx-2, y+79, cx, infieldHeight ui_tooltip stRevealClusureUITips[32]
				ui_infield "gs_reveal_bottom_sL", x+50-cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[34]
			endif
		else
			ui_outfield str(formatt, abs(gs_reveal_double_innerLeft)), x-cx-4, y+41, cx, outfieldHeight, 1
			ui_outfield str(formatt, abs(gs_reveal_double_innerTop)), x+20, y-19, cx, outfieldHeight, 2
			ui_infield "gs_reveal_double_innerRight", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[43]
			if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
				ui_infield "gs_reveal_double_innerBottom", x+54, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[9]
			endif
			if bEnableUniformJambDepths & gs_reveal_uniform then
				ui_outfield str(formatt, abs(gs_reveal_double_innerLeft_sL)), x-cx-4, y+83, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_double_innerBottom_sL)), x+33-cx, y+picy+5, cx, outfieldHeight, 1
			else
				ui_infield "gs_reveal_double_innerLeft_sL", x-cx-2, y+79, cx, infieldHeight ui_tooltip stRevealClusureUITips[36]
				ui_infield "gs_reveal_double_innerBottom_sL", x+50-cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[38]
			endif
		endif
	endif

	if iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT then
		if (bRevealSetSide & gs_reveal_set_side = REVEAL_SET_INSIDE & gs_reveal_type_bottom_int <> REVEAL_BOTTOM_UNIFORM) |\
			iSillRevealType = REVEAL_NO then
			if not(bNegativeView) then
				ui_pict 205, x, y, picx, picy, 1	! P_right_Seg_Rev_BottNoRev.png
			endif

			if bNegativeView then
				ui_pict 208, x, y, picx, picy, 1	! P_right_Seg_NegRev_BottNoRev.png
			endif
		else
			if not(bNegativeView) then
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					ui_pict 205, x, y, picx, picy, 1	! P_right_Seg_Rev_BottNoRev.png
				else
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
						ui_pict 206, x, y, picx, picy, 1	! P_right_Seg_Rev_BottNegRev.png
					else
						ui_pict 207, x, y, picx, picy, 1	! P_right_Seg_Rev.png
					endif
				endif
			endif

			if bNegativeView then
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					ui_pict 208, x, y, picx, picy, 1	! P_right_Seg_NegRev_BottNoRev.png
				else
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
						ui_pict 209, x, y, picx, picy, 1	! P_righT_Seg_NegRev_BottRev.png
					else
						ui_pict 210, x, y, picx, picy, 1	! P_right_Seg_NegRev_BottNegRev.png
					endif
				endif
			endif
		endif

		n = request("Working_length_unit", "", formatt)
		if gs_reveal_set_side = REVEAL_SET_OUTSIDE then
			ui_outfield str(formatt, abs(gs_reveal_left)), x-cx-4, y+41, cx, outfieldHeight, 1
			ui_outfield str(formatt, abs(gs_reveal_top)), x+20, y-16, cx, outfieldHeight, 2
			ui_infield "gs_reveal_right", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[42]
			if gs_reveal_type_bottom_int <> REVEAL_BOTTOM_NO then
				ui_infield "gs_reveal_bottom", x+71-cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[7]
			endif
			if bEnableUniformJambDepths & gs_reveal_uniform then
				n = request("Working_length_unit", "", formatt)
				ui_outfield str(formatt, abs(gs_reveal_right_sR)), x+picx+2, y+83, cx, outfieldHeight, 0
				ui_outfield str(formatt, abs(gs_reveal_bottom_sR)), x+77, y+picy+5, cx, outfieldHeight, 0
			else
				ui_infield "gs_reveal_right_sR", x+picx+2, y+79, cx, infieldHeight ui_tooltip stRevealClusureUITips[33]
				ui_infield "gs_reveal_bottom_sR", x+54, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[35]
			endif
		else
			ui_outfield str(formatt, abs(gs_reveal_double_innerLeft)), x-cx-4, y+41, cx, outfieldHeight, 1
			ui_outfield str(formatt, abs(gs_reveal_double_innerTop)), x+20, y-19, cx, outfieldHeight, 2
			ui_infield "gs_reveal_double_innerRight", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[43]
			if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
				ui_infield "gs_reveal_double_innerBottom", x+71-cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[9]
			endif
			if bEnableUniformJambDepths & gs_reveal_uniform then
				ui_outfield str(formatt, abs(gs_reveal_double_innerRight_sR)), x+picx+2, y+83, cx, outfieldHeight, 0
				ui_outfield str(formatt, abs(gs_reveal_double_innerBottom_sR)), x+8+cx, y+picy+5, cx, outfieldHeight, 0
			else
				ui_infield "gs_reveal_double_innerRight_sR", x+picx+2, y+79, cx, infieldHeight ui_tooltip stRevealClusureUITips[37]
				ui_infield "gs_reveal_double_innerBottom_sR", x+8+cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[39]
			endif
		endif
	endif

return


"bottomPositiveReveal":
	if not(isEmptyOpening) then
		if isWindow then
			ui_pict 126, xPicBot, yPicBot, 33, 58, 1	!reveal_bot_win.png
		else
			ui_pict 127, xPicBot, yPicBot, 33, 58, 1	!reveal_bot_door.png
		endif
	else
		ui_pict 128, xPicBot, yPicBot, 33, 58, 1		!reveal_bot_op.png
	endif
	ui_pict 21, xPicBot-11, yPicBot+24, 11, 10, 1		!ui_arrow_10_v.png

	if bForceUniformBottomReveal then
		ui_outfield str(formatt, abs(gs_reveal_right)), xPicTop-88, yPicBot+23, 72, outfieldHeight, 1
	else
		ui_infield "gs_reveal_bottom", xPicBot-88, yPicBot+19, 72, infieldHeight	ui_tooltip stRevealClusureUITips[7]
	endif
return

"bottomNegativeReveal":
	if not(isEmptyOpening) then
		if isWindow then
			ui_pict 129, xPicBot, yPicBot, 33, 58, 1	!negative_reveal_bot_win.png
		else
			ui_pict 130, xPicBot, yPicBot, 33, 58, 1	!negative_reveal_bot_door.png
		endif
	else
		ui_pict 131, xPicBot, yPicBot, 33, 58, 1		!negative_reveal_bot_op.png
	endif
	ui_pict 21, xPicBot-11, yPicBot+32, 11, 10, 1		!ui_arrow_10_v.png

	if bForceUniformBottomReveal then
		ui_outfield str(formatt, abs(gs_reveal_right)), xPicTop-88, yPicBot+31, 72, outfieldHeight, 1
	else
		ui_infield "gs_reveal_bottom", xPicBot-88, yPicBot+27, 72, infieldHeight	ui_tooltip stRevealClusureUITips[7]
	endif
return


"bottomNoReveal":
	if not(isEmptyOpening) then
		if isWindow then
			ui_pict 132, xPicBot, yPicBot, 33, 58, 1	!no_reveal_bot_win.png
		else
			ui_pict 133, xPicBot, yPicBot, 33, 58, 1	!no_reveal_bot_door.png
		endif
	else
		ui_pict 134, xPicBot, yPicBot, 33, 58, 1			!no_reveal_bot_op.png
	endif
return

"horizontalPosRevealParams":
	ui_pict 20, xPic+24, yPic-11, 10, 11, 1			!ui_arrow_10.png
	ui_pict 20, xPic+87, yPic-11, 10, 11, 1			!ui_arrow_10.png

	ui_infield "gs_reveal_right", xPic+87, yPic-34, 72, infieldHeight ui_tooltip stRevealClusureUITips[3]

	if bEnableUniformJambDepths & gs_reveal_uniform then
		ui_outfield str(formatt, abs(gs_reveal_right)), xPic-6, yPic-30, 72, outfieldHeight, 2
	else
		ui_infield "gs_reveal_left", xPic-6,	yPic-34, 72, infieldHeight ui_tooltip stRevealClusureUITips[2]
	endif
return


"noRevealPicsHorizontal":
	if not(isEmptyOpening) then
		if isWindow then
			ui_pict 1, xPic, yPic, 121, 33, 1		!no_reveal_win.png
		else
			ui_pict 2, xPic, yPic, 121, 33, 1		!no_reveal_door.png
		endif
	else
		ui_pict 3, xPic, yPic, 121, 33, 1			!no_reveal_op.png
	endif
return

"horizontalNegRevealParams":
	ui_pict 20, xPic+16, yPic-11, 10, 11, 1			!ui_arrow_10.png
	ui_pict 20, xPic+95, yPic-11, 10, 11, 1			!ui_arrow_10.png

	ui_infield "gs_reveal_right", xPic+87, yPic-34, 72, infieldHeight ui_tooltip stRevealClusureUITips[3]
	if bEnableUniformJambDepths & gs_reveal_uniform then
		ui_outfield str(formatt, abs(gs_reveal_right)), xPic-6, yPic-30, 55, outfieldHeight, 2
	else
		ui_infield "gs_reveal_left", xPic-6,	yPic-34, 72, infieldHeight ui_tooltip stRevealClusureUITips[2]
	endif
return


"revealDepthParam":
	ui_pict 7, xPic+121, yPic, 11, 11, 1			!ui_arrow_11.png
	ui_infield "gs_wido_sill", xPic+121+16, yPic-5, 72, infieldHeight ui_tooltip stRevealClusureUITips[1]
return


"negRevealPicsHorizontal":
	if not(isEmptyOpening) then
		if isWindow then
			ui_pict 105, xPic, yPic, 121, 33, 1	!negative_reveal_win.png
		else
			ui_pict 106, xPic, yPic, 121, 33, 1	!negative_reveal_door.png
		endif
	else
		ui_pict 107, xPic, yPic, 121, 33, 1	!negative_reveal_op.png
	endif
return


"negRevealPicsVerticalTop":
	if not(isEmptyOpening) then
		if isWindow then
			ui_pict 108, xPicTop, yPicTop, 33, 58, 1	!negative_reveal_top_win.png
		else
			ui_pict 109, xPicTop, yPicTop, 33, 58, 1	!negative_reveal_top_door.png
		endif
	else
		ui_pict 110, xPicTop, yPicTop, 33, 58, 1		!negative_reveal_top_op.png
	endif
return


"noRevealPicsVertical":
	if not(isEmptyOpening) then
		if isWindow then
			ui_pict 4, xPicTop, yPicTop, 33, 58, 1	!no_reveal_top_win.png
		else
			ui_pict 5, xPicTop, yPicTop, 33, 58, 1	!no_reveal_top_door.png
		endif
	else
		ui_pict 6, xPicTop, yPicTop, 33, 58, 1			!no_reveal_top_op.png
	endif
return


"revealPicsHorizontal":
	if not(isEmptyOpening) then
		if isWindow then
			ui_pict 14, xPic, yPic, 121, 33, 1	!reveal_win.png
		else
			ui_pict 15, xPic, yPic, 121, 33, 1	!reveal_door.png
		endif
	else
		ui_pict 16, xPic, yPic, 121, 33, 1	!reveal_op.png
	endif
return


"revealPicsVerticalTop":
	if not(isEmptyOpening) then
		if isWindow then
			ui_pict 17, xPicTop, yPicTop, 33, 58, 1	!reveal_top_win.png
		else
			ui_pict 18, xPicTop, yPicTop, 33, 58, 1	!reveal_top_door.png
		endif
	else
		ui_pict 19, xPicTop, yPicTop, 33, 58, 1		!reveal_top_op.png
	endif
return


"customInnerPosRevealParamaters":
	ui_infield "gs_reveal_double_innerRight", xPic+87, yPic+45, 72, 20 ui_tooltip stRevealClusureUITips[5]
	if bEnableUniformJambDepths & gs_reveal_uniform then
		ui_outfield str(formatt, abs(gs_reveal_double_innerRight)), xPic-6, yPic+49, 72, outfieldHeight, 2
	else
		ui_infield "gs_reveal_double_innerLeft", xPic-6, yPic+45, 72, 20 ui_tooltip stRevealClusureUITips[4]
	endif
return

"customInnerNegRevealParamaters":
	ui_infield "gs_reveal_double_innerRight", xPic+87, yPic+45, 72, 20 ui_tooltip stRevealClusureUITips[5]
	if bEnableUniformJambDepths & gs_reveal_uniform then
		ui_outfield str(formatt, abs(gs_reveal_double_innerRight)), xPic-6, yPic+49, 55, outfieldHeight, 2
	else
		ui_infield "gs_reveal_double_innerLeft", xPic-6, yPic+45, 72, 20 ui_tooltip stRevealClusureUITips[4]
	endif
return




]]>
</Script_UI>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_VL SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[


! =============================================================================
! Reveal Types
! =============================================================================

if bShapeSameRevealAngles then
	gs_reveal_uniform = 1
	parameters gs_reveal_uniform = gs_reveal_uniform
endif
 
if not(bEnableUniformJambDepths & bShowUniformJambDepths) then
	hideparameter	"gs_reveal_uniform"
	lock			"gs_reveal_uniform"
endif

if not(bEnableDifferentBottomReveal) then
	hideparameter	"gs_reveal_type_bottom",
					"gs_reveal_type_bottom_int"

	lock	"gs_reveal_type_bottom",
			"gs_reveal_type_bottom_int"
endif


if iClosureType = CLOSURE_STUD_WALL then
	hideparameter	"gs_reveal_bottom",
					"gs_reveal_top"

	lock	"gs_reveal_bottom",
			"gs_reveal_top"
endif

if	iClosureType = CLOSURE_STUD_WALL then
	hideparameter	"AC_wido_sill"
	lock			"AC_wido_sill"
endif

if bEnableDifferentBottomReveal then
	if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
		hideparameter	"gs_reveal_bottom"

		lock			"gs_reveal_bottom"
	endif

	if gs_reveal_type_bottom_int <> REVEAL_BOTTOM_UNIFORM then
		hideparameter	"gs_reveal_splayed_innerBottom",
						"gs_reveal_bottom_angle"
		lock			"gs_reveal_splayed_innerBottom",
						"gs_reveal_bottom_angle"
	endif
endif

if	iRevealType = REVEAL_EDGE |\
	iRevealType = REVEAL_NO |\
	iRevealType = REVEAL_SPLAYED |\
	(iRevealType = REVEAL_DOUBLE & iSillRevealType = REVEAL_NO) then

	if (gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM & bEnableDifferentBottomReveal) | not(bEnableDifferentBottomReveal) then
		hideparameter	"gs_reveal_bottom"
		lock	"gs_reveal_bottom"
	endif

	hideparameter	"gs_reveal_left",
					"gs_reveal_right",
					"gs_reveal_top"

	lock	"gs_reveal_left",
			"gs_reveal_right",
			"gs_reveal_top"

	if bTShapedOpening then
		hideparameter	"gs_reveal_left_sL",
						"gs_reveal_right_sR",
						"gs_reveal_bottom_sL",
						"gs_reveal_bottom_sR"

		lock	"gs_reveal_left_sL",
				"gs_reveal_right_sR",
				"gs_reveal_bottom_sL",
				"gs_reveal_bottom_sR"
	endif
else
	values "gs_reveal_left"		range[0,]
	values "gs_reveal_right"	range[0,]
	values "gs_reveal_top"		range[0,]
	values "gs_reveal_bottom"	range[0,]

	if bEnableUniformJambDepths & gs_reveal_uniform then
		hideparameter	"gs_reveal_left",
						"gs_reveal_top"

		lock	"gs_reveal_left",
				"gs_reveal_top"

		if	bittest(gs_RevealTypeEnable, REVEAL_HISTORIC) |\
			bittest(gs_RevealTypeEnable, REVEAL_SPLAYED) then

			hideparameter	"gs_reveal_splayed_innerLeft",
							"gs_reveal_splayed_innerTop"

			lock	"gs_reveal_splayed_innerLeft",
					"gs_reveal_splayed_innerTop"
		endif

		if	iRevealType = REVEAL_SLANTED | \
			iRevealType = REVEAL_HISTORIC then

			hideparameter	"gs_reveal_left_angle",
							"gs_reveal_top_angle"

			lock	"gs_reveal_left_angle",
					"gs_reveal_top_angle"
		endif

		if bTShapedOpening then
			hideparameter	"gs_reveal_left_sL",
							"gs_reveal_right_sR",
							"gs_reveal_bottom_sL",
							"gs_reveal_bottom_sR"

			lock	"gs_reveal_left_sL",
					"gs_reveal_right_sR",
					"gs_reveal_bottom_sL",
					"gs_reveal_bottom_sR"
		endif
	else
		if	iWindowShape = SHAPE_ARCHED_T | \
			iWindowShape = SHAPE_ARCHED_HALF_T_LEFT | \
			iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT then

			hideparameter	"gs_reveal_top",
							"gs_reveal_left"

			lock	"gs_reveal_top",
					"gs_reveal_left"
		endif

		if	iWindowShape = SHAPE_HALF_T_LEFT | \
			iWindowShape = SHAPE_ARCHED_HALF_T_LEFT then

			hideparameter	"gs_reveal_right_sR",
							"gs_reveal_bottom_sR"

			lock	"gs_reveal_right_sR",
					"gs_reveal_bottom_sR"
		endif

		if	iWindowShape = SHAPE_HALF_T_RIGHT | \
			iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT then

			hideparameter	"gs_reveal_left_sL",
							"gs_reveal_bottom_sL"

			lock	"gs_reveal_left_sL",
					"gs_reveal_bottom_sL"
		endif
	endif
endif

if iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_SPLAYED then
	values "gs_reveal_splayed_innerLeft"	range [0,]
	values "gs_reveal_splayed_innerRight"	range [0,]
	values "gs_reveal_splayed_innerTop"		range [0,]
	values "gs_reveal_splayed_innerBottom"	range [0,]
else
	if	bittest(gs_RevealTypeEnable, REVEAL_HISTORIC) |\
		bittest(gs_RevealTypeEnable, REVEAL_SPLAYED) then

		hideparameter	"gs_reveal_splayed_innerLeft",
						"gs_reveal_splayed_innerRight",
						"gs_reveal_splayed_innerTop",
						"gs_reveal_splayed_innerBottom"

		lock	"gs_reveal_splayed_innerLeft",
				"gs_reveal_splayed_innerRight",
				"gs_reveal_splayed_innerTop",
				"gs_reveal_splayed_innerBottom"
	endif
endif

if iRevealType = REVEAL_SPLAYED then
	if bEnableUniformJambDepths & gs_reveal_uniform then
			hideparameter	"gs_reveal_left_angle",
							"gs_reveal_top_angle",
							"gs_reveal_splayed_innerLeft",
							"gs_reveal_splayed_innerTop"


			lock	"gs_reveal_left_angle",
					"gs_reveal_top_angle",
					"gs_reveal_splayed_innerLeft",
					"gs_reveal_splayed_innerTop"

	endif
endif

if	iRevealType = REVEAL_DOUBLE & iBoardRevealType <> REVEAL_NO then
	values "gs_reveal_double_innerLeft"		range [0,]
	values "gs_reveal_double_innerRight"	range [0,]
	values "gs_reveal_double_innerTop"		range [0,]
	values "gs_reveal_double_innerBottom"	range [0,]

	if bEnableUniformJambDepths & gs_reveal_uniform then
		hideparameter	"gs_reveal_double_innerLeft",
						"gs_reveal_double_innerTop"
		lock	"gs_reveal_double_innerLeft",
				"gs_reveal_double_innerTop"

		if bTShapedOpening then
			hideparameter	"gs_reveal_double_innerLeft_sL",
							"gs_reveal_double_innerRight_sR",
							"gs_reveal_double_innerBottom_sL",
							"gs_reveal_double_innerBottom_sR"

			lock	"gs_reveal_double_innerLeft_sL",
					"gs_reveal_double_innerRight_sR",
					"gs_reveal_double_innerBottom_sL",
					"gs_reveal_double_innerBottom_sR"

			if	iWindowShape = SHAPE_ARCHED_T | \
				iWindowShape = SHAPE_ARCHED_HALF_T_LEFT | \
				iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT then

				hideparameter	"gs_reveal_double_innerTop"
				lock	"gs_reveal_double_innerTop"
			endif
		endif
	else
		if	iWindowShape = SHAPE_ARCHED_T | \
			iWindowShape = SHAPE_ARCHED_HALF_T_LEFT | \
			iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT then

			hideparameter	"gs_reveal_double_innerTop",
							"gs_reveal_double_innerLeft"

			lock	"gs_reveal_double_innerTop",
					"gs_reveal_double_innerLeft"
		endif

		if	iWindowShape = SHAPE_HALF_T_LEFT | \
			iWindowShape = SHAPE_ARCHED_HALF_T_LEFT then

			hideparameter	"gs_reveal_double_innerRight_sR",
							"gs_reveal_double_innerBottom_sR"

			lock	"gs_reveal_double_innerRight_sR",
					"gs_reveal_double_innerBottom_sR"
		endif

		if	iWindowShape = SHAPE_HALF_T_RIGHT | \
			iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT then

			hideparameter	"gs_reveal_double_innerLeft_sL",
							"gs_reveal_double_innerBottom_sL"

			lock	"gs_reveal_double_innerLeft_sL",
					"gs_reveal_double_innerBottom_sL"
		endif
	endif
else
	if bittest(gs_RevealTypeEnable, REVEAL_DOUBLE) then
		hideparameter	"gs_reveal_double_innerLeft",
						"gs_reveal_double_innerRight",
						"gs_reveal_double_innerTop",
						"gs_reveal_double_innerBottom"

		lock	"gs_reveal_double_innerLeft",
				"gs_reveal_double_innerRight",
				"gs_reveal_double_innerTop",
				"gs_reveal_double_innerBottom"

		if bTShapedOpening then
			hideparameter	"gs_reveal_double_innerLeft_sL",
							"gs_reveal_double_innerRight_sR",
							"gs_reveal_double_innerBottom_sL",
							"gs_reveal_double_innerBottom_sR"

			lock	"gs_reveal_double_innerLeft_sL",
					"gs_reveal_double_innerRight_sR",
					"gs_reveal_double_innerBottom_sL",
					"gs_reveal_double_innerBottom_sR"
		endif
	endif
endif

if	iRevealType = REVEAL_SLANTED | \
	iRevealType = REVEAL_SPLAYED | \
	iRevealType = REVEAL_HISTORIC | \
	iRevealType = REVEAL_DOUBLE_SPLAYED then

	values "gs_reveal_left_angle"	range [0,90)
	values "gs_reveal_right_angle"	range [0,90)
	values "gs_reveal_top_angle"	range [0,90)
	values "gs_reveal_bottom_angle"	range [0,90)
else
	if	bittest(gs_RevealTypeEnable, REVEAL_SLANTED) |\
		bittest(gs_RevealTypeEnable, REVEAL_SPLAYED) |\
		bittest(gs_RevealTypeEnable, REVEAL_HISTORIC) |\
		bittest(gs_RevealTypeEnable, REVEAL_DOUBLE_SPLAYED) then

		hideparameter	"gs_reveal_left_angle",
						"gs_reveal_right_angle",
						"gs_reveal_top_angle",
						"gs_reveal_bottom_angle"

		lock	"gs_reveal_left_angle",
				"gs_reveal_right_angle",
				"gs_reveal_top_angle",
				"gs_reveal_bottom_angle"
	endif
endif

if	iRevealType = REVEAL_DOUBLE_SPLAYED then
	values "gs_reveal_innerLeft_width"		range [0,)
	values "gs_reveal_innerRight_width"		range [0,)
	values "gs_reveal_innerTop_width"		range [0,)
	values "gs_reveal_innerBottom_width"	range [0,)

	if gs_reveal_angle_edit_by_int = 1 then
		hideparameter	"gs_reveal_innerLeft_width",
						"gs_reveal_innerRight_width",
						"gs_reveal_innerTop_width",
						"gs_reveal_innerBottom_width"

		lock	"gs_reveal_innerLeft_width",
				"gs_reveal_innerRight_width",
				"gs_reveal_innerTop_width",
				"gs_reveal_innerBottom_width"
	else
		hideparameter	"gs_reveal_left_angle",
						"gs_reveal_right_angle",
						"gs_reveal_top_angle",
						"gs_reveal_bottom_angle"

		lock	"gs_reveal_left_angle",
				"gs_reveal_right_angle",
				"gs_reveal_top_angle",
				"gs_reveal_bottom_angle"
	endif
else
	if bittest(gs_RevealTypeEnable, REVEAL_DOUBLE_SPLAYED) then
		hideparameter	"gs_reveal_innerLeft_width",
						"gs_reveal_innerRight_width",
						"gs_reveal_innerTop_width",
						"gs_reveal_innerBottom_width"

		lock	"gs_reveal_innerLeft_width",
				"gs_reveal_innerRight_width",
				"gs_reveal_innerTop_width",
				"gs_reveal_innerBottom_width"
	endif
endif

if	iRevealType = REVEAL_DOUBLE_SPLAYED | \
	iRevealType = REVEAL_OUTSIDE_SPLAYED then

	values "gs_reveal_outer_jamb_depth"		range [0,)
	values "gs_reveal_outerLeft_angle"		range [0,90)
	values "gs_reveal_outerRight_angle"		range [0,90)
	values "gs_reveal_outerTop_angle"		range [0,90)
	values "gs_reveal_outerBottom_angle"	range [0,90)

	values "gs_reveal_outerLeft_width"		range [0,)
	values "gs_reveal_outerRight_width"		range [0,)
	values "gs_reveal_outerTop_width"		range [0,)
	values "gs_reveal_outerBottom_width"	range [0,)

	if GLOB_MODPAR_NAME = "gs_reveal_angle_edit_by" then
		gs_reveal_angle_edit_by_int = 1
		if gs_reveal_angle_edit_by = stRevealAngleEditBy[2] then gs_reveal_angle_edit_by_int = 2
		parameters gs_reveal_angle_edit_by_int = gs_reveal_angle_edit_by_int
	else
		gs_reveal_angle_edit_by = stRevealAngleEditBy[1]
		if gs_reveal_angle_edit_by_int = 2 then gs_reveal_angle_edit_by = stRevealAngleEditBy[2]
		parameters gs_reveal_angle_edit_by = gs_reveal_angle_edit_by
	endif

	bDefaultElem = (GLOB_INTGUID = "" | GLOB_INTGUID = "{00000000-0000-0000-0000-000000000000}")

	if not(bDefaultElem) & (bInclinedWall | AC_WallType = 2 | ac_wall_crosssection_type = 3 | ac_wall_crosssection_type = 4) then
		values "gs_reveal_angle_edit_by" stRevealAngleEditBy[1]
		values "gs_reveal_angle_edit_by_int" 1
		lock "gs_reveal_angle_edit_by", "gs_reveal_angle_edit_by_int"
		hideparameter "gs_reveal_angle_edit_by"
	else
		values "gs_reveal_angle_edit_by" stRevealAngleEditBy[1], stRevealAngleEditBy[2]
		values "gs_reveal_angle_edit_by_int" 1, 2
	endif

	if gs_reveal_angle_edit_by_int = 1 then
		hideparameter	"gs_reveal_outerLeft_width",
						"gs_reveal_outerRight_width",
						"gs_reveal_outerTop_width",
						"gs_reveal_outerBottom_width"

		lock	"gs_reveal_outerLeft_width",
				"gs_reveal_outerRight_width",
				"gs_reveal_outerTop_width",
				"gs_reveal_outerBottom_width"
	else
		hideparameter	"gs_reveal_outerLeft_angle",
						"gs_reveal_outerRight_angle",
						"gs_reveal_outerTop_angle",
						"gs_reveal_outerBottom_angle"

		lock	"gs_reveal_outerLeft_angle",
				"gs_reveal_outerRight_angle",
				"gs_reveal_outerTop_angle",
				"gs_reveal_outerBottom_angle"
	endif
else
	if	bittest(gs_RevealTypeEnable, REVEAL_DOUBLE_SPLAYED) |\
		bittest(gs_RevealTypeEnable, REVEAL_OUTSIDE_SPLAYED) then

		hideparameter	"gs_reveal_outer_jamb_depth",
						"gs_reveal_outerLeft_angle",
						"gs_reveal_outerRight_angle",
						"gs_reveal_outerTop_angle",
						"gs_reveal_outerBottom_angle",
						"gs_reveal_outerLeft_width",
						"gs_reveal_outerRight_width",
						"gs_reveal_outerTop_width",
						"gs_reveal_outerBottom_width",
						"gs_reveal_angle_edit_by"

		lock	"gs_reveal_outer_jamb_depth",
				"gs_reveal_outerLeft_angle",
				"gs_reveal_outerRight_angle",
				"gs_reveal_outerTop_angle",
				"gs_reveal_outerBottom_angle",
				"gs_reveal_outerLeft_width",
				"gs_reveal_outerRight_width",
				"gs_reveal_outerTop_width",
				"gs_reveal_outerBottom_width",
				"gs_reveal_angle_edit_by"
	endif
endif

if bTShapedOpening then
	values "gs_reveal_left_sL"		range[0,)
	values "gs_reveal_right_sR"		range[0,)
	values "gs_reveal_bottom_sL"	range[0,)
	values "gs_reveal_bottom_sR"	range[0,)
	values "gs_reveal_double_innerLeft_sL"		range[0,)
	values "gs_reveal_double_innerRight_sR"		range[0,)
	values "gs_reveal_double_innerBottom_sL"	range[0,)
	values "gs_reveal_double_innerBottom_sR"	range[0,)

!	if gs_sidelight_parapet_hgt_left < EPS then
!		hideparameter	"gs_reveal_left_sL",
!						"gs_reveal_bottom_sL",
!						"gs_reveal_double_innerLeft_sL",
!						"gs_reveal_double_innerBottom_sL"
!
!		lock	"gs_reveal_left_sL",
!				"gs_reveal_bottom_sL",
!				"gs_reveal_double_innerLeft_sL",
!				"gs_reveal_double_innerBottom_sL"
!
!	endif
!
!	if gs_sidelight_parapet_hgt_right < EPS then
!		hideparameter	"gs_reveal_right_sR",
!						"gs_reveal_bottom_sR",
!						"gs_reveal_double_innerRight_sR",
!						"gs_reveal_double_innerBottom_sR"
!
!		lock	"gs_reveal_right_sR",
!				"gs_reveal_bottom_sR",
!				"gs_reveal_double_innerRight_sR",
!				"gs_reveal_double_innerBottom_sR"
!
!	endif
endif


! =============================================================================
! Outside Splayed Reveal
! =============================================================================

if iRevealType = REVEAL_OUTSIDE_SPLAYED & (GLOB_MODPAR_NAME = "gs_reveal_type_new" | GLOB_MODPAR_NAME = "gs_reveal_type_int") then
	AC_wido_sill = WALL_THICKNESS - WIDO_FRAME_THICKNESS
	gs_wido_sill = AC_wido_sill
	parameters AC_wido_sill = AC_wido_sill, gs_wido_sill = gs_wido_sill
endif


! =============================================================================
! Mounting Frame
! =============================================================================

if bEnableMountingFrameForReveal then
	if not(iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) then
		lock "gs_mountingFrame"
		hideparameter "gs_mountingFrame"
	endif
	if not(iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) | not(gs_mountingFrame) then
		lock	"gs_mountingFrame_depth",
				"gs_mountingFrame_width_left",
				"gs_mountingFrame_width_right",
				"gs_mountingFrame_width_top",
				"gs_mountingFrame_width_bottom",
				"gs_mountingFrame_pen_view",
				"gs_mountingFrame_pen_cont",
				"gs_mountingFrame_fill",
				"gs_mountingFrame_pen_fg",
				"gs_mountingFrame_pen_bg",
				"gs_mountingFrame_mat"
		hideparameter	"gs_mountingFrame_depth",
						"gs_mountingFrame_width_left",
						"gs_mountingFrame_width_right",
						"gs_mountingFrame_width_top",
						"gs_mountingFrame_width_bottom",
						"gs_mountingFrame_pen_view",
						"gs_mountingFrame_pen_cont",
						"gs_mountingFrame_fill",
						"gs_mountingFrame_pen_fg",
						"gs_mountingFrame_pen_bg",
						"gs_mountingFrame_mat"
	endif

	if (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) & gs_mountingFrame then
		lock	"gs_reveal_left",
				"gs_reveal_right",
				"gs_reveal_top",
				"gs_reveal_bottom"
		hideparameter	"gs_reveal_left",
						"gs_reveal_right",
						"gs_reveal_top",
						"gs_reveal_bottom"
	endif

	if iWindowShape = SHAPE_ARCHED then
		if GLOB_MODPAR_NAME = "gs_mountingFrame_width_left" then
			gs_mountingFrame_width_right 	= gs_mountingFrame_width_left
			gs_mountingFrame_width_top 		= gs_mountingFrame_width_left
			parameters gs_mountingFrame_width_right 	= gs_mountingFrame_width_right
			parameters gs_mountingFrame_width_top 		= gs_mountingFrame_width_top
		else
			if GLOB_MODPAR_NAME = "gs_mountingFrame_width_top" then
				gs_mountingFrame_width_left 	= gs_mountingFrame_width_top
				gs_mountingFrame_width_right 	= gs_mountingFrame_width_top
				parameters gs_mountingFrame_width_left 		= gs_mountingFrame_width_left
				parameters gs_mountingFrame_width_right 	= gs_mountingFrame_width_right
			else
				gs_mountingFrame_width_left 	= gs_mountingFrame_width_right
				gs_mountingFrame_width_top 		= gs_mountingFrame_width_right
				parameters gs_mountingFrame_width_left 	= gs_mountingFrame_width_left
				parameters gs_mountingFrame_width_top 	= gs_mountingFrame_width_top
			endif
		endif
	endif

	values "gs_mountingFrame_depth"			range(0, gs_reveal_outer_jamb_depth]
	values "gs_mountingFrame_width_left"	range(0,)
	values "gs_mountingFrame_width_right"	range(0,)
	values "gs_mountingFrame_width_top"		range(0,)
	values "gs_mountingFrame_width_bottom"	range(0,)
endif


! =============================================================================
! Wall Inset
! =============================================================================

if bEnableParapetInset then
	hideparameter "gs_parapet_autodim"
	values "gs_parapet_inset_thk" range [0, ]
	if not(gs_parapet_wall_inset) then
		lock	"gs_parapet_inset_thk",
				"gs_parapet_autodim",
				"gs_parapet_width",
				"gs_parapet_height",
				"gs_parapet_2D",
				"gs_parapet_line",
				"gs_parapet_bottom_st",
				"iParapetBottom",
				"gs_parapet_botelev",
				"gs_parapet_sizes_st",
				"iParapetSize",
				"gs_parapet_left",
				"gs_parapet_right"
		hideparameter	"gs_parapet_inset_thk",
						"gs_parapet_autodim",
						"gs_parapet_width",
						"gs_parapet_height",
						"gs_parapet_2D",
						"gs_parapet_line",
						"gs_parapet_bottom_st",
						"iParapetBottom",
						"gs_parapet_botelev",
						"gs_parapet_sizes_st",
						"iParapetSize",
						"gs_parapet_left",
						"gs_parapet_right"
	else
		if gs_parapet_autodim then
			lock	"gs_parapet_width",
					"gs_parapet_height"
			hideparameter	"gs_parapet_width",
							"gs_parapet_height"
		else
			values "gs_parapet_width"	range(0,]
			values "gs_parapet_height"	range(0, WIDO_SILL_HEIGHT]
		endif
	endif
endif

if isWindow & not(gs_parapet_2D) then
	hideparameter "gs_parapet_line"
	lock "gs_parapet_line"
endif


! ==============================================================================
! Head Depth on Symbol
! ==============================================================================

if isWindow | (not(isWindow) & (isEmptyOpening | bDoorCHE)) then
	if not(gs_head_symbol) then
		lock "gs_head_symbol_line", "gs_head_symbol_pen"
		hideparameter "gs_head_symbol_line", "gs_head_symbol_pen"
	endif
endif


! ==============================================================================
! Setting Reveal Side
! ==============================================================================

if bTShapedOpening then
	values "gs_reveal_set_side" REVEAL_SET_INSIDE, REVEAL_SET_OUTSIDE
endif

]]>
</Script_VL>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Comment SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Comment>

<CalledMacros SectVersion="2" SectionFlags="0" SubIdent="0">
	<Macro>
		<MName><![CDATA["WallContourDivider_WMCC"]]></MName>
		<MainGUID>F98B04A3-BB7E-4FB6-BF54-7C41A4591B35</MainGUID>
	</Macro>
</CalledMacros>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="1" path="uipicts/WallholeCut/no_reveal_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="2" path="uipicts/WallholeCut/no_reveal_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="3" path="uipicts/WallholeCut/no_reveal_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="4" path="uipicts/WallholeCut/no_reveal_top_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="5" path="uipicts/WallholeCut/no_reveal_top_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="6" path="uipicts/WallholeCut/no_reveal_top_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="7" path="uipicts/WallholeCut/ui_arrow_11.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="8" path="uipicts/WallholeCut/ui_angle_4.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="9" path="uipicts/WallholeCut/ui_angle_3.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="10" path="uipicts/WallholeCut/ui_arrow_v_12.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="11" path="uipicts/WallholeCut/ui_angle_1.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="12" path="uipicts/WallholeCut/ui_angle_2.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="13" path="uipicts/WallholeCut/ui_reveal_type.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="14" path="uipicts/WallholeCut/reveal_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="15" path="uipicts/WallholeCut/reveal_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="16" path="uipicts/WallholeCut/reveal_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="17" path="uipicts/WallholeCut/reveal_top_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="18" path="uipicts/WallholeCut/reveal_top_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="19" path="uipicts/WallholeCut/reveal_top_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="20" path="uipicts/WallholeCut/ui_arrow_10.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="21" path="uipicts/WallholeCut/ui_arrow_10_v.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="22" path="uipicts/WallholeCut/ui_wallinset_front.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="23" path="uipicts/WallholeCut/ui_wallinset_section.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="24" path="uipicts/WallholeCut/ui_wallinset_front_assym.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="25" path="uipicts/WallholeCut/ui_wallinset_front_sym.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="26" path="uipicts/WallholeCut/custom_rev_rev_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="27" path="uipicts/WallholeCut/custom_rev_rev_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="28" path="uipicts/WallholeCut/custom_rev_rev_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="29" path="uipicts/WallholeCut/custom_norev_rev_top_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="30" path="uipicts/WallholeCut/custom_norev_rev_top_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="31" path="uipicts/WallholeCut/custom_norev_rev_top_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="32" path="uipicts/WallholeCut/custom_rev_rev_top_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="33" path="uipicts/WallholeCut/custom_rev_rev_top_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="34" path="uipicts/WallholeCut/custom_rev_rev_top_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="35" path="uipicts/WallholeCut/custom_rev_rev_bot_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="36" path="uipicts/WallholeCut/custom_rev_rev_bot_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="37" path="uipicts/WallholeCut/custom_rev_rev_bot_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="38" path="uipicts/WallholeCut/custom_norev_rev_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="39" path="uipicts/WallholeCut/custom_norev_rev_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="40" path="uipicts/WallholeCut/custom_norev_rev_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="41" path="uipicts/WallholeCut/custom_rev_negrev_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="42" path="uipicts/WallholeCut/custom_rev_negrev_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="43" path="uipicts/WallholeCut/custom_rev_negrev_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="44" path="uipicts/WallholeCut/ui_arrow_10_m.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="45" path="uipicts/WallholeCut/ui_arrow_v_0.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="46" path="uipicts/WallholeCut/ui_reveal_doublesplayed_withBF_plan.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="47" path="uipicts/WallholeCut/ui_reveal_doublesplayed_withBF_sect.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="48" path="uipicts/WallholeCut/ui_reveal_doublesplayed_woutBF_plan.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="49" path="uipicts/WallholeCut/ui_reveal_doublesplayed_woutBF_sect.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="50" path="uipicts/WallholeCut/ui_reveal_outsidesplayed_withBF_plan.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="51" path="uipicts/WallholeCut/ui_reveal_outsidesplayed_withBF_sect.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="52" path="uipicts/WallholeCut/ui_reveal_outsidesplayed_woutBF_plan.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="53" path="uipicts/WallholeCut/ui_reveal_outsidesplayed_woutBF_sect.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="56" path="uipicts/WallholeCut/ui_angle_5.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="57" path="uipicts/WallholeCut/ui_angle_6.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="58" path="uipicts/WallholeCut/ui_arrow_h_12.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="59" path="uipicts/WallholeCut/ui_angle_7.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="60" path="uipicts/WallholeCut/ui_angle_8.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="61" path="uipicts/WallholeCut/ui_arrow_v_11.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="62" path="_ui_picts_/attributes/ui_mat.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="63" path="_ui_picts_/attributes/ui_mat_lock.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="64" length_in_bytes="138" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000170000
	001102030000004B1DDF2E00000009504C5445000000FFFFFF00000073C68371
	0000000174524E530040E6D866000000254944415408D763608003A6AC052452
	ABC014C3AC06646A1584E26040A3B456AD82AA0702006F300EDFB3946F770000
	000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="65" length_in_bytes="138" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000170000
	001102030000004B1DDF2E00000009504C5445000000FFFFFF9D9DA1E333CFFB
	0000000174524E530040E6D866000000254944415408D763608003A6AC052452
	ABC014C3AC06646A1584E26040A3B456AD82AA0702006F300EDFB3946F770000
	000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="66" path="uipicts/WallholeCut/ui_uncut_pen.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="67" path="uipicts/WallholeCut/ui_uncut_pen_lock.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="68" length_in_bytes="144" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000140000
	00140203000000F0E7F59E00000009504C5445000000FFFFFF00000073C68371
	0000000174524E530040E6D8660000002B4944415408D763600003AD55AB56AD
	8091D3A64D0392515151190C9A9999994072E9D2A59489239B0F0600BBC729B5
	52F540B20000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="69" length_in_bytes="144" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000140000
	00140203000000F0E7F59E00000009504C5445000000FFFFFF9D9DA1E333CFFB
	0000000174524E530040E6D8660000002B4944415408D763600003AD55AB56AD
	8091D3A64D0392515151190C9A9999994072E9D2A59489239B0F0600BBC729B5
	52F540B20000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="70" length_in_bytes="159" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000001D0000
	00100803000000DDD384E300000009504C5445000000FFFFFF00000073C68371
	0000000174524E530040E6D8660000003A4944415478DAC5CC410A00200C0341
	DDFF3F5A7A09D215042FA63D8843331EC2A452AF7DA5C6A8F073336AD6B150CA
	C9532CCCA7504ADBCC350BFF930106624DF5830000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="71" length_in_bytes="159" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000001D0000
	00100803000000DDD384E300000009504C5445000000FFFFFF9D9DA1E333CFFB
	0000000174524E530040E6D8660000003A4944415478DAC5CC410A00200C0341
	DDFF3F5A7A09D215042FA63D8843331EC2A452AF7DA5C6A8F073336AD6B150CA
	C9532CCCA7504ADBCC350BFF930106624DF5830000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="72" path="uipicts/ui_fill_bg_pen.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="73" path="uipicts/ui_fill_bg_pen_lock.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="74" path="uipicts/WallholeCut/ui_arrow_h_11.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="75" path="uipicts/WallholeCut/ui_arrow_v_16.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="76" path="uipicts/ui_warningsign.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="77" path="uipicts/WallholeCut/ui_arrow_10_vm.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="78" path="uipicts/WallholeCut/ui_reveal_doublesplayed_withBF_plan_width.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="79" path="uipicts/WallholeCut/ui_reveal_doublesplayed_withBF_sect_width.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="80" path="uipicts/WallholeCut/ui_reveal_doublesplayed_woutBF_plan_width.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="81" path="uipicts/WallholeCut/ui_reveal_doublesplayed_woutBF_sect_width.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="82" path="uipicts/WallholeCut/ui_reveal_outsidesplayed_withBF_plan_width.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="83" path="uipicts/WallholeCut/ui_reveal_outsidesplayed_withBF_sect_width.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="84" path="uipicts/WallholeCut/ui_reveal_outsidesplayed_woutBF_plan_width.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="85" path="uipicts/WallholeCut/ui_reveal_outsidesplayed_woutBF_sect_width.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="86" path="uipicts/WallholeCut/dotted_line.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="87" path="uipicts/WallholeCut/T_Rev_BottNoRev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="88" path="uipicts/WallholeCut/T_Rev_BottNegRev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="89" path="uipicts/WallholeCut/T_Rev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="90" path="uipicts/WallholeCut/T_NegRev_BottNoRev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="91" path="uipicts/WallholeCut/T_NegRev_BottRev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="92" path="uipicts/WallholeCut/T_NegRev_BottNegRev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="93" path="uipicts/WallholeCut/P_Rev_BottNoRev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="94" path="uipicts/WallholeCut/P_Rev_BottNegRev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="95" path="uipicts/WallholeCut/ui_arrow_v_21.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="96" path="uipicts/WallholeCut/P_Rev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="97" path="uipicts/WallholeCut/P_NegRev_BottNoRev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="98" path="uipicts/WallholeCut/P_NegRev_BottRev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="99" path="uipicts/WallholeCut/P_NegRev_BottNegRev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="100" path="uipicts/WallholeCut/T_Seg_Rev_BottNoRev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="101" path="uipicts/WallholeCut/T_Seg_Rev_BottNegRev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="102" path="uipicts/WallholeCut/T_Seg_Rev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="103" path="uipicts/WallholeCut/T_Seg_NegRev_BottNoRev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="104" path="uipicts/WallholeCut/T_Seg_NegRev_BottRev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="105" path="uipicts/WallholeCut/negative_reveal_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="106" path="uipicts/WallholeCut/negative_reveal_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="107" path="uipicts/WallholeCut/negative_reveal_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="108" path="uipicts/WallholeCut/negative_reveal_top_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="109" path="uipicts/WallholeCut/negative_reveal_top_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="110" path="uipicts/WallholeCut/negative_reveal_top_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="111" path="uipicts/WallholeCut/slanted_reveal_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="112" path="uipicts/WallholeCut/slanted_reveal_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="113" path="uipicts/WallholeCut/slanted_reveal_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="114" path="uipicts/WallholeCut/slanted_reveal_top_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="115" path="uipicts/WallholeCut/slanted_reveal_top_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="116" path="uipicts/WallholeCut/slanted_reveal_top_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="117" path="uipicts/WallholeCut/slanted_reveal_bot_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="118" path="uipicts/WallholeCut/slanted_reveal_bot_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="119" path="uipicts/WallholeCut/slanted_reveal_bot_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="120" path="uipicts/WallholeCut/splayed_reveal_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="121" path="uipicts/WallholeCut/splayed_reveal_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="122" path="uipicts/WallholeCut/splayed_reveal_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="123" path="uipicts/WallholeCut/historic_reveal_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="124" path="uipicts/WallholeCut/historic_reveal_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="125" path="uipicts/WallholeCut/historic_reveal_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="126" path="uipicts/WallholeCut/reveal_bot_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="127" path="uipicts/WallholeCut/reveal_bot_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="128" path="uipicts/WallholeCut/reveal_bot_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="129" path="uipicts/WallholeCut/negative_reveal_bot_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="130" path="uipicts/WallholeCut/negative_reveal_bot_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="131" path="uipicts/WallholeCut/negative_reveal_bot_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="132" path="uipicts/WallholeCut/no_reveal_bot_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="133" path="uipicts/WallholeCut/no_reveal_bot_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="134" path="uipicts/WallholeCut/no_reveal_bot_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="135" path="uipicts/WallholeCut/no_reveal_edge_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="136" path="uipicts/WallholeCut/no_reveal_edge_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="137" path="uipicts/WallholeCut/no_reveal_edge_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="138" path="uipicts/WallholeCut/no_reveal_edge_top_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="139" path="uipicts/WallholeCut/no_reveal_edge_bot_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="140" path="uipicts/WallholeCut/no_reveal_edge_top_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="141" path="uipicts/WallholeCut/no_reveal_edge_bot_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="142" path="uipicts/WallholeCut/no_reveal_edge_top_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="143" path="uipicts/WallholeCut/no_reveal_edge_bot_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="144" path="uipicts/WallholeCut/splayed_reveal_top_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="145" path="uipicts/WallholeCut/splayed_reveal_bot_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="146" path="uipicts/WallholeCut/splayed_reveal_top_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="147" path="uipicts/WallholeCut/splayed_reveal_bot_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="148" path="uipicts/WallholeCut/splayed_reveal_top_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="149" path="uipicts/WallholeCut/splayed_reveal_bot_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="150" path="uipicts/WallholeCut/historic_reveal_top_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="151" path="uipicts/WallholeCut/historic_reveal_top_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="152" path="uipicts/WallholeCut/historic_reveal_top_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="153" path="uipicts/WallholeCut/historic_reveal_bot_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="154" path="uipicts/WallholeCut/historic_reveal_bot_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="155" path="uipicts/WallholeCut/historic_reveal_bot_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="156" path="uipicts/WallholeCut/custom_norev_rev_bot_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="157" path="uipicts/WallholeCut/custom_norev_rev_bot_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="158" path="uipicts/WallholeCut/custom_norev_rev_bot_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="159" path="uipicts/WallholeCut/custom_norev_negrev_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="160" path="uipicts/WallholeCut/custom_norev_negrev_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="161" path="uipicts/WallholeCut/custom_norev_negrev_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="162" path="uipicts/WallholeCut/custom_norev_negrev_top_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="163" path="uipicts/WallholeCut/custom_norev_negrev_top_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="164" path="uipicts/WallholeCut/custom_norev_negrev_top_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="165" path="uipicts/WallholeCut/custom_norev_negrev_bot_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="166" path="uipicts/WallholeCut/custom_norev_negrev_bot_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="167" path="uipicts/WallholeCut/custom_norev_negrev_bot_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="168" path="uipicts/WallholeCut/custom_rev_negrev_top_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="169" path="uipicts/WallholeCut/custom_rev_negrev_top_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="170" path="uipicts/WallholeCut/custom_rev_negrev_top_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="171" path="uipicts/WallholeCut/custom_rev_negrev_bot_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="172" path="uipicts/WallholeCut/custom_rev_negrev_bot_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="173" path="uipicts/WallholeCut/custom_rev_negrev_bot_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="174" path="uipicts/WallholeCut/custom_negrev_rev_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="175" path="uipicts/WallholeCut/custom_negrev_rev_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="176" path="uipicts/WallholeCut/custom_negrev_rev_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="177" path="uipicts/WallholeCut/custom_negrev_rev_top_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="178" path="uipicts/WallholeCut/custom_negrev_rev_top_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="179" path="uipicts/WallholeCut/custom_negrev_rev_top_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="180" path="uipicts/WallholeCut/custom_negrev_rev_bot_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="181" path="uipicts/WallholeCut/custom_negrev_rev_bot_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="182" path="uipicts/WallholeCut/custom_negrev_rev_bot_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="183" path="uipicts/WallholeCut/custom_negrev_negrev_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="184" path="uipicts/WallholeCut/custom_negrev_negrev_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="185" path="uipicts/WallholeCut/custom_negrev_negrev_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="186" path="uipicts/WallholeCut/custom_negrev_negrev_top_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="187" path="uipicts/WallholeCut/custom_negrev_negrev_top_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="188" path="uipicts/WallholeCut/custom_negrev_negrev_top_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="189" path="uipicts/WallholeCut/custom_negrev_negrev_bot_win.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="190" path="uipicts/WallholeCut/custom_negrev_negrev_bot_door.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="191" path="uipicts/WallholeCut/custom_negrev_negrev_bot_op.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="192" path="uipicts/WallholeCut/T_Seg_NegRev_BottNegRev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="193" path="uipicts/WallholeCut/P_Seg_Rev_BottNoRev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="194" path="uipicts/WallholeCut/P_Seg_Rev_BottNegRev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="195" path="uipicts/WallholeCut/P_Seg_Rev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="196" path="uipicts/WallholeCut/P_Seg_NegRev_BottNoRev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="197" path="uipicts/WallholeCut/P_Seg_NegRev_BottRev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="198" path="uipicts/WallholeCut/P_Seg_NegRev_BottNegRev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="199" path="uipicts/WallholeCut/P_right_Rev_BottNoRev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="200" path="uipicts/WallholeCut/P_right_Rev_BottNegRev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="201" path="uipicts/WallholeCut/P_right_Rev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="202" path="uipicts/WallholeCut/P_right_NegRev_BottNoRev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="203" path="uipicts/WallholeCut/P_right_NegRev_BottRev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="204" path="uipicts/WallholeCut/P_right_NegRev_BottNegRev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="205" path="uipicts/WallholeCut/P_right_Seg_Rev_BottNoRev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="206" path="uipicts/WallholeCut/P_right_Seg_Rev_BottNegRev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="207" path="uipicts/WallholeCut/P_right_Seg_Rev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="208" path="uipicts/WallholeCut/P_right_Seg_NegRev_BottNoRev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="209" path="uipicts/WallholeCut/P_right_Seg_NegRev_BottRev.png">
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="210" path="uipicts/WallholeCut/P_right_Seg_NegRev_BottNegRev.png">
</GDLPict>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_FWM SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[

]]>
</Script_FWM>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_BWM SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[

]]>
</Script_BWM>

<Keywords SectVersion="1" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Keywords>

<Copyright SectVersion="1" SectionFlags="0" SubIdent="0">
	<Author>BIMobject</Author>
	<License>
		<Type>CC BY-ND</Type>
		<Version>3.0</Version>
	</License>
</Copyright>

<ParamSection SectVersion="22" SectionFlags="0" SubIdent="0">
	<ParamSectHeader>
		<Version>22</Version>
		<AutoHotspots>no</AutoHotspots>
		<StatBits>
			<STBit_FixSize/>
		</StatBits>
		<WDLeftFrame>0</WDLeftFrame>
		<WDRightFrame>0</WDRightFrame>
		<WDTopFrame>0</WDTopFrame>
		<WDBotFrame>0</WDBotFrame>
		<LayFlags>65535</LayFlags>
		<WDMirrorThickness>0</WDMirrorThickness>
		<WDWallInset>0</WDWallInset>
		<SymbolColor>0</SymbolColor>
	</ParamSectHeader>
	<Parameters>
		<Length Name="A">
			<Description><![CDATA["Dimension 1"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Length Name="B">
			<Description><![CDATA["Dimension 2"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Length Name="ZZYZX">
			<Description><![CDATA["Height"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Boolean Name="AC_show2DHotspotsIn3D">
			<Description><![CDATA["Show 2D Hotspots in 3D"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="ac_bottomlevel">
			<Description><![CDATA["Bottom Level"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Length Name="ac_toplevel">
			<Description><![CDATA["Top Level"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Integer Name="gs_macro_version">
			<Description><![CDATA["Macro Version"]]></Description>
			<Value>9</Value>
		</Integer>
		<Length Name="AC_Sill_To_Curr_Story">
			<Description><![CDATA["Sill Height to Current Story"]]></Description>
			<Value>0</Value>
		</Length>
		<Integer Name="AC_Hole_Hotspot_Control">
			<Description><![CDATA["Hotspots 0-None,1-2D,2-3D,3-All"]]></Description>
			<Value>3</Value>
		</Integer>
		<Integer Name="AC_Hole_Display_Option">
			<Description><![CDATA["Floor Plan Display Option"]]></Description>
			<Value>3</Value>
		</Integer>
		<Boolean Name="AC_HoleSideMaterial">
			<Description><![CDATA["Hole has Wall's Side Surface"]]></Description>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="AC_HoleMaterialCurved">
			<Description><![CDATA["Hole Surface's Split is Curved in Curved Walls"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Integer Name="AC_WallType">
			<Description><![CDATA["Wall Type"]]></Description>
			<Value>0</Value>
		</Integer>
		<Integer Name="AC_WindowInWallContour">
			<Description><![CDATA["Window in Wall Contour"]]></Description>
			<ArrayValues FirstDimension="4" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
			</ArrayValues>
		</Integer>
		<Length Name="AC_WallContourPolygon">
			<Description><![CDATA["Wall Contour Polygon"]]></Description>
			<ArrayValues FirstDimension="1" SecondDimension="3">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="AC_Wall_Direction_Type">
			<Description><![CDATA["Wall Direction Type"]]></Description>
			<Value>0</Value>
		</Integer>
		<Integer Name="ac_wall_crosssection_type">
			<Description><![CDATA["Wall Cross Section Type"]]></Description>
			<Value>0</Value>
		</Integer>

		<!-- iTypeDemolitionFill: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Integer Name="iTypeDemolitionFill">
			<Description><![CDATA["Demolition / New construction"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<FillPattern Name="gs_new_symb_fill">
			<Description><![CDATA["New Wall Fill Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4</Value>
		</FillPattern>
		<PenColor Name="gs_new_symb_pen_Fg">
			<Description><![CDATA["New Wall Fill Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</PenColor>
		<PenColor Name="gs_new_symb_pen_bg">
			<Description><![CDATA["New Wall Fill Background Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>19</Value>
		</PenColor>
		<Length Name="gs_new_symb_width_r">
			<Description><![CDATA["New Wall Fill Width Right"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.15</Value>
		</Length>
		<Length Name="gs_new_symb_width_l">
			<Description><![CDATA["New Wall Fill Width Left"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.15</Value>
		</Length>
		<Boolean Name="gs_bShowNewOnCC">
			<Description><![CDATA["Show new construction on Wall"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- gs_function_control_parameters: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_function_control_parameters">
			<Description><![CDATA["Function Control Parameters"]]></Description>
		</Title>
		<Boolean Name="bEnableParapetInset">
			<Description><![CDATA["Enable/Disable Wall Inset"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bEnableMountingFrameForReveal">
			<Description><![CDATA["Enable/Disable Mounting Frame (For Reveal)"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bCut3DWallhole">
			<Description><![CDATA["Cut 3D Wallhole"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bDWSymbolAtMiddle">
			<Description><![CDATA["Symbol at Middle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="lod2D_MountingFrame">
			<Description><![CDATA["2D Detail Level - Mounting Frame"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="lod3D_MountingFrame">
			<Description><![CDATA["3D Detail Level - Mounting Frame"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Boolean Name="bEnableWallContourHiddenLine">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bWallContHiddenLineIn">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bWallContHiddenLineOut">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bWallContHiddenLineInLeftSl">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bWallContHiddenLineOutLeftSl">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bWallContHiddenLineInRightSl">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bWallContHiddenLineOutRightSl">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="gs_RevealTypeEnable">
			<Description><![CDATA["Reveal Type Enable Mask"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>

		<!-- gs_wallhole_geometry: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_wallhole_geometry">
			<Description><![CDATA["Wallhole Geometry"]]></Description>
		</Title>
		<Boolean Name="bParalellInCurvedWalls">
			<Description><![CDATA["Parallel Opening in Curved Walls"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="refWidth">
			<Description><![CDATA["Curved Wall - Reference Width"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="leftWidth">
			<Description><![CDATA["Left Offset from the Origo"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="rightWidth">
			<Description><![CDATA["Right Offset from the Origo"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="radSill">
			<Description><![CDATA["Curved Wall - Sill Radius"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="radBoard">
			<Description><![CDATA["Curved Wall - Board Radius"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="WOD">
			<Description><![CDATA["Curved Wall - Wall Center Distance"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="elevationOffset">
			<Description><![CDATA["Elevation Offset"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="offsetSill">
			<Description><![CDATA["Thickness of Hidden Wall Skins at Sill Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="offsetBoard">
			<Description><![CDATA["Thickness of Hidden Wall Skins at Board Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="lineSections">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="7">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">0</AVal>
				<AVal Column="4" Row="1">0</AVal>
				<AVal Column="5" Row="1">0</AVal>
				<AVal Column="6" Row="1">0</AVal>
				<AVal Column="7" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="overSizeLower">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- iRevealType: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Integer Name="iRevealType">
			<Description><![CDATA["Reveal Type"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<String Name="gs_reveal_type_new">
			<Description><![CDATA["Reveal Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["No Reveal - Edge"]]></Value>
		</String>
		<Integer Name="gs_reveal_type_int">
			<Description><![CDATA["Reveal Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<String Name="gs_reveal_type_bottom">
			<Description><![CDATA["Reveal Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["No Reveal"]]></Value>
		</String>
		<Integer Name="gs_reveal_type_bottom_int">
			<Description><![CDATA["Reveal Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<Integer Name="iSillRevealType">
			<Description><![CDATA["Outer Reveal Type - Custom Reveal"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="iBoardRevealType">
			<Description><![CDATA["Inner Reveal Type - Custom Reveal"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Length Name="gs_wido_sill">
			<Description><![CDATA["Reveal Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>-9999</Value>
		</Length>
		<Length Name="AC_wido_sill">
			<Description><![CDATA["Reveal Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<String Name="gs_reveal_type">
			<Description><![CDATA["Outer Reveal Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["No Reveal"]]></Value>
		</String>
		<Integer Name="gs_reveal_doubleOuterTypeInt">
			<Description><![CDATA["Reveal Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<String Name="gs_reveal_double_innerType">
			<Description><![CDATA["Inner Reveal Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["No Reveal"]]></Value>
		</String>
		<Integer Name="gs_reveal_doubleInnerTypeInt">
			<Description><![CDATA["Reveal Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="gs_reveal_set_side">
			<Description><![CDATA["Set Jamb Depth on Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Boolean Name="gs_reveal_uniform">
			<Description><![CDATA["Uniform Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="leftRevealPnts">
			<Description><![CDATA["Left Reveal Points"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="rightRevealPnts">
			<Description><![CDATA["Right Reveal Points"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="iRevealPointsIdx">
			<Description><![CDATA["Reveal Points Index"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="20" SecondDimension="0">
				<AVal Row="1">1</AVal>
				<AVal Row="2">1</AVal>
				<AVal Row="3">1</AVal>
				<AVal Row="4">1</AVal>
				<AVal Row="5">1</AVal>
				<AVal Row="6">1</AVal>
				<AVal Row="7">1</AVal>
				<AVal Row="8">1</AVal>
				<AVal Row="9">1</AVal>
				<AVal Row="10">1</AVal>
				<AVal Row="11">1</AVal>
				<AVal Row="12">1</AVal>
				<AVal Row="13">1</AVal>
				<AVal Row="14">1</AVal>
				<AVal Row="15">1</AVal>
				<AVal Row="16">1</AVal>
				<AVal Row="17">1</AVal>
				<AVal Row="18">1</AVal>
				<AVal Row="19">1</AVal>
				<AVal Row="20">1</AVal>
			</ArrayValues>
		</Integer>
		<Length Name="gs_reveal_left">
			<Description><![CDATA["Jamb Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_reveal_right">
			<Description><![CDATA["Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_reveal_left_sL">
			<Description><![CDATA["Lower Jamb Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_reveal_right_sR">
			<Description><![CDATA["Lower Jamb Depth Side 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_reveal_splayed_innerLeft">
			<Description><![CDATA["Inner Jamb Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_splayed_innerRight">
			<Description><![CDATA["Inner Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerLeft">
			<Description><![CDATA["Inner Jamb Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerRight">
			<Description><![CDATA["Inner Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="revealInnerLeft">
			<Description><![CDATA["Inner Jamb Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="revealInnerRight">
			<Description><![CDATA["Inner Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerLeft_sL">
			<Description><![CDATA["Inner Lower Jamb Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_reveal_double_innerRight_sR">
			<Description><![CDATA["Inner Lower Jamb Depth Side 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_reveal_top">
			<Description><![CDATA["Head Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_reveal_bottom">
			<Description><![CDATA["Sill Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Boolean Name="bShowRevealSE">
			<Description><![CDATA["Show reveal on Section/Elevation"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Length Name="original_gs_reveal_bottom">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_bottom_sL">
			<Description><![CDATA["Sill Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_reveal_bottom_sR">
			<Description><![CDATA["Sill Depth Side 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_reveal_splayed_innerTop">
			<Description><![CDATA["Inner Head Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_splayed_innerBottom">
			<Description><![CDATA["Inner Sill Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerTop">
			<Description><![CDATA["Inner Head Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerBottom">
			<Description><![CDATA["Inner Sill Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerBottom_sL">
			<Description><![CDATA["Inner Sill Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerBottom_sR">
			<Description><![CDATA["Inner Sill Depth Side 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_outer_jamb_depth">
			<Description><![CDATA["Outer Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.08</Value>
		</Length>
		<String Name="gs_reveal_angle_edit_by">
			<Description><![CDATA["Edit Jamb by"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Angle and Depth"]]></Value>
		</String>
		<Integer Name="gs_reveal_angle_edit_by_int">
			<Description><![CDATA["Edit Jamb by"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Angle Name="gs_reveal_left_angle">
			<Description><![CDATA["Angle Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Angle Name="gs_reveal_right_angle">
			<Description><![CDATA["Angle Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Angle Name="gs_reveal_top_angle">
			<Description><![CDATA["Upper Side Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Angle Name="gs_reveal_bottom_angle">
			<Description><![CDATA["Bottom Side Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Length Name="gs_reveal_innerLeft_width">
			<Description><![CDATA["Splay Width Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.08</Value>
		</Length>
		<Length Name="gs_reveal_innerRight_width">
			<Description><![CDATA["Splay Width Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.08</Value>
		</Length>
		<Length Name="gs_reveal_innerTop_width">
			<Description><![CDATA["Upper Side Splay Width"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.08</Value>
		</Length>
		<Length Name="gs_reveal_innerBottom_width">
			<Description><![CDATA["Bottom Side Splay Width"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.08</Value>
		</Length>
		<Angle Name="gs_reveal_outerLeft_angle">
			<Description><![CDATA["Outer Angle Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Angle Name="gs_reveal_outerRight_angle">
			<Description><![CDATA["Outer Angle Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Angle Name="gs_reveal_outerTop_angle">
			<Description><![CDATA["Outer Angle Upper Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Angle Name="gs_reveal_outerBottom_angle">
			<Description><![CDATA["Outer Angle Bottom Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Length Name="gs_reveal_outerLeft_width">
			<Description><![CDATA["Outer Splay Width Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.08</Value>
		</Length>
		<Length Name="gs_reveal_outerRight_width">
			<Description><![CDATA["Outer Splay Width Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.08</Value>
		</Length>
		<Length Name="gs_reveal_outerTop_width">
			<Description><![CDATA["Outer Splay Width Upper Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.08</Value>
		</Length>
		<Length Name="gs_reveal_outerBottom_width">
			<Description><![CDATA["Outer Splay Width Bottom Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.08</Value>
		</Length>
		<Boolean Name="gs_mountingFrame">
			<Description><![CDATA["Mounting Frame"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="gs_mountingFrame_depth">
			<Description><![CDATA["Mounting Frame Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_mountingFrame_width_left">
			<Description><![CDATA["Mounting Frame Width Left"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_mountingFrame_width_right">
			<Description><![CDATA["Mounting Frame Width Right"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_mountingFrame_width_top">
			<Description><![CDATA["Mounting Frame Width Upper"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_mountingFrame_width_bottom">
			<Description><![CDATA["Mounting Frame Width Bottom"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<PenColor Name="gs_mountingFrame_pen_view">
			<Description><![CDATA["Mounting Frame Uncut Line Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<PenColor Name="gs_mountingFrame_pen_cont">
			<Description><![CDATA["Mounting Frame Contour Line Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<FillPattern Name="gs_mountingFrame_fill">
			<Description><![CDATA["Mounting Frame Fill Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</FillPattern>
		<PenColor Name="gs_mountingFrame_pen_fg">
			<Description><![CDATA["Mounting Frame Fill Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<PenColor Name="gs_mountingFrame_pen_bg">
			<Description><![CDATA["Mounting Frame Fill Background Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<Material Name="gs_mountingFrame_mat">
			<Description><![CDATA["Mounting Frame Surface"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Material>
		<Boolean Name="bMountingFrame_DrawInsideLine">
			<Description><![CDATA["Draw Mounting Frame INside Line"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- gs_closure: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_closure">
			<Description><![CDATA["Cavity Closure"]]></Description>
		</Title>
		<Integer Name="iClosureType">
			<Description><![CDATA["Closure Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Boolean Name="gs_closure_auto_changed">
			<Description><![CDATA["Closure Method Changed Automatically"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- PlasterGeometry: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="PlasterGeometry">
			<Description><![CDATA["Plaster Geometry"]]></Description>
		</Title>
		<Boolean Name="gs_turn_plaster_dim_2D">
			<Description><![CDATA["Dimensionable on 2D"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_turn_plaster_show_3D">
			<Description><![CDATA["Show in 3D"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="thkPlasterAtSillLeft">
			<Description><![CDATA["Plaster Thickness at Sill - Left Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtSillRight">
			<Description><![CDATA["Plaster Thickness at Sill - Right Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtSillTop">
			<Description><![CDATA["Plaster Thickness at Sill - Top Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtSillBottom">
			<Description><![CDATA["Plaster Thickness at Sill - Bottom Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtSillSlLeft">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtSillSlLeftBottom">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtSillSlRight">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtSillSlRightBottom">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtBoardLeft">
			<Description><![CDATA["Plaster Thickness at Board - Left Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtBoardRight">
			<Description><![CDATA["Plaster Thickness at Board - Right Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtBoardTop">
			<Description><![CDATA["Plaster Thickness at Board - Top Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtBoardBottom">
			<Description><![CDATA["Plaster Thickness at Board - Bottom Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtBoardSlLeft">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtBoardSlLeftBottom">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtBoardSlRight">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtBoardSlRightBottom">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- gs_macro_control_parameters: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_macro_control_parameters">
			<Description><![CDATA["Macro Control Parameters"]]></Description>
		</Title>
		<Boolean Name="isWindow">
			<Description><![CDATA["Window or Door Type Object"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="isEmptyOpening">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_IsCurved">
			<Description><![CDATA["Curved Window"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bDrawSillFill">
			<Description><![CDATA["Draw Wallhole Fill at Sill Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bDrawBoardFill">
			<Description><![CDATA["Draw Wallhole Fill at Board Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="wallContourLineOffsetLeftIn">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="wallContourLineOffsetRightIn">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="wallContourLineOffsetLeftOut">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="wallContourLineOffsetRightOut">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="bCustomMatNicheTop">
			<Description><![CDATA["Custom Niche Surface"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Material Name="matNicheTop">
			<Description><![CDATA["Custom Niche Surface at Top"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>101</Value>
		</Material>

		<!-- iWindowShape: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Integer Name="iWindowShape">
			<Description><![CDATA["Window Shape"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Length Name="archHeight">
			<Description><![CDATA["Height of the Arc"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.25</Value>
		</Length>
		<Length Name="gs_lowerArchHeight">
			<Description><![CDATA["Bottom Arch Height"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.15</Value>
		</Length>
		<Boolean Name="bMirroredOpening">
			<Description><![CDATA["Mirrored Opening"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="nArchResolution">
			<Description><![CDATA["Arch Resolution"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>3</Value>
		</Integer>
		<Length Name="smallRadiusEllips">
			<Description><![CDATA["smaller radius of ellips arch"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Integer Name="gs_numOfSides">
			<Description><![CDATA["Num of Sides in multiside openings"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Length Name="gs_posTopEdge_triangle">
			<Description><![CDATA["Top Edge from Center"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_sidelight_WHole_width_left">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_sidelight_WHole_width_right">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_sidelight_parapet_hgt_left">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_sidelight_parapet_hgt_right">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="holeBottomOffset">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="holeSideOffset">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_frame_width">
			<Description><![CDATA["Frame Width"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- ac_corner_window: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="ac_corner_window">
			<Description><![CDATA["Corner Window Function"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bLeftCornerFunction">
			<Description><![CDATA["Left Corner"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Angle Name="leftCornerAngle">
			<Description><![CDATA["Left Corner Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Length Name="leftConnWallThk">
			<Description><![CDATA["Left Connected Wall Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="bRightCornerFunction">
			<Description><![CDATA["Right Corner"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Angle Name="rightCornerAngle">
			<Description><![CDATA["Right Corner Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Length Name="rightConnWallThk">
			<Description><![CDATA["Right Connected Wall Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="bCornerWindow">
			<Description><![CDATA["Corner Window"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- gs_window_sizes: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_window_sizes">
			<Description><![CDATA["Window Sizes"]]></Description>
		</Title>
		<Length Name="ac_wallhole_width">
			<Description><![CDATA["Wallhole Width"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Length Name="ac_wallhole_height">
			<Description><![CDATA["Wallhole Height"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="ac_wallhole_height_original">
			<Description><![CDATA["Wallhole Height"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="ac_reveal_height">
			<Description><![CDATA["Reveal Height"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="gs_wallhole_hotspots">
			<Description><![CDATA["Show Wallhole Hotspots"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_reveal_hotspots">
			<Description><![CDATA["Show Reveal Hotspots"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- gs_windw_stack: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_windw_stack">
			<Description><![CDATA["Ganging"]]></Description>
		</Title>
		<Boolean Name="gs_stack_left">
			<Description><![CDATA["Connection on the Left"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_stack_right">
			<Description><![CDATA["Connection on the Right"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_stack_top">
			<Description><![CDATA["Connection on the Top"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_stack_bottom">
			<Description><![CDATA["Connection on the Bottom"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- gs_window_oversize: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_window_oversize">
			<Description><![CDATA["Oversize"]]></Description>
		</Title>
		<Length Name="gs_left_oversize">
			<Description><![CDATA["Left Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_right_oversize">
			<Description><![CDATA["Right Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_upper_oversize">
			<Description><![CDATA["Upper Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_lower_oversize">
			<Description><![CDATA["Lower Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- gs_parapet_wall_inset: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="gs_parapet_wall_inset">
			<Description><![CDATA["Wall Inset"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="gs_parapet_inset_thk">
			<Description><![CDATA["Depth of Inset"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.2</Value>
		</Length>
		<String Name="gs_parapet_sizes_st">
			<Description><![CDATA["Wall Inset Sizes"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<Integer Name="iParapetSize">
			<Description><![CDATA["Wall Inset Sizes"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Length Name="gs_parapet_width">
			<Description><![CDATA["Parapet Width"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Length Name="gs_parapet_right">
			<Description><![CDATA["Overhang Side 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_parapet_left">
			<Description><![CDATA["Overhang Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_parapet_height">
			<Description><![CDATA["Parapet Height"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="gs_parapet_2D">
			<Description><![CDATA["Show Hidden Parapet"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<String Name="gs_parapet_bottom_st">
			<Description><![CDATA["Wall Inset Bottom at"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<Integer Name="iParapetBottom">
			<Description><![CDATA["Wall Inset Bottom at"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Length Name="gs_parapet_botelev">
			<Description><![CDATA["Bottom Overhang"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<LineType Name="gs_parapet_line">
			<Description><![CDATA["Hidden Parapet Line Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</LineType>

		<!-- gs_wallhole: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_wallhole">
			<Description><![CDATA["Plan Symbol Fill"]]></Description>
		</Title>
		<FillPattern Name="gs_wallhole_fill">
			<Description><![CDATA["Plan Symbol Fill Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>65</Value>
		</FillPattern>
		<PenColor Name="gs_wallhole_pen_fg">
			<Description><![CDATA["Plan Symbol Fill Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>19</Value>
		</PenColor>
		<PenColor Name="gs_wallhole_pen_bg">
			<Description><![CDATA["Plan Symbol Fill Background Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>19</Value>
		</PenColor>
		<FillPattern Name="gs_wallhole_fill_sl">
			<Description><![CDATA["Plan Symbol Fill Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>65</Value>
		</FillPattern>
		<PenColor Name="gs_wallhole_pen_sl_fg">
			<Description><![CDATA["Plan Symbol Fill Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>19</Value>
		</PenColor>
		<PenColor Name="gs_wallhole_pen_sl_bg">
			<Description><![CDATA["Plan Symbol Fill Background Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>19</Value>
		</PenColor>
		<String Name="gs_wcont_line">
			<Description><![CDATA["Wall Contour Line"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<Integer Name="iWallContourLine">
			<Description><![CDATA["Wall Contour Line"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<LineType Name="gs_wcont_line_in">
			<Description><![CDATA["Wall Contour Line Type Inside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</LineType>
		<LineType Name="gs_wcont_line_out">
			<Description><![CDATA["Wall Contour Line Type Outside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</LineType>
		<LineType Name="gs_wcont_hidden_line_in">
			<Description><![CDATA["Hidden Wall Contour Line Type Inside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4</Value>
		</LineType>
		<LineType Name="gs_wcont_hidden_line_out">
			<Description><![CDATA["Hidden Wall Contour Line Type Outside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4</Value>
		</LineType>
		<PenColor Name="gs_wcont_line_pen">
			<Description><![CDATA["Use Fills"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>3</Value>
		</PenColor>

		<!-- iWallContourLineSl: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Integer Name="iWallContourLineSl">
			<Description><![CDATA["Wall Contour Line Sidelights"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<LineType Name="gs_wcont_line_sl_in">
			<Description><![CDATA["Wall Contour Line Type Inside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</LineType>
		<LineType Name="gs_wcont_line_sl_out">
			<Description><![CDATA["Wall Contour Line Type Outside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</LineType>
		<LineType Name="gs_wcont_hidden_line_sl_in">
			<Description><![CDATA["Hidden Wall Contour Line Type Inside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4</Value>
		</LineType>
		<LineType Name="gs_wcont_hidden_line_sl_out">
			<Description><![CDATA["Hidden Wall Contour Line Type Outside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4</Value>
		</LineType>

		<!-- gs_head_symbol: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="gs_head_symbol">
			<Description><![CDATA["Head Depth on Symbol"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<LineType Name="gs_head_symbol_line">
			<Description><![CDATA["Head Depth Symbol Line Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>21</Value>
		</LineType>
		<PenColor Name="gs_head_symbol_pen">
			<Description><![CDATA["Head Depth Symbol Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>6</Value>
		</PenColor>
		<Boolean Name="bRevealSettingsPage">
			<Description><![CDATA["Show Tabpage"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bWallInsetPage">
			<Description><![CDATA["Show Tabpage"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="gs_ui_sub_tabpage">
			<Description><![CDATA[""]]></Description>
			<Value>1</Value>
		</Integer>
		<Integer Name="pageStartY">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Integer>

		<!-- gs_string_resources: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_string_resources">
			<Description><![CDATA["String Resources"]]></Description>
		</Title>
		<String Name="stWallholeCutUI">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="32" SecondDimension="0">
				<AVal Row="1"><![CDATA["Custom Reveal"]]></AVal>
				<AVal Row="2"><![CDATA["Custom Reveal Sizes"]]></AVal>
				<AVal Row="3"><![CDATA["Wall Inset"]]></AVal>
				<AVal Row="4"><![CDATA["Depth"]]></AVal>
				<AVal Row="5"><![CDATA["Custom Reveal"]]></AVal>
				<AVal Row="6"><![CDATA["Reveal Type"]]></AVal>
				<AVal Row="7"><![CDATA["Show Hidden Parapet on 2D"]]></AVal>
				<AVal Row="8"><![CDATA["Automatic Wall Inset Sizes"]]></AVal>
				<AVal Row="9"><![CDATA["Hidden Parapet Line Type"]]></AVal>
				<AVal Row="10"><![CDATA["Wall Inset Bottom at:"]]></AVal>
				<AVal Row="11"><![CDATA["Width of Wall Inset"]]></AVal>
				<AVal Row="12"><![CDATA["Height of Wall Inset"]]></AVal>
				<AVal Row="13"><![CDATA["Bottom Elevation"]]></AVal>
				<AVal Row="14"><![CDATA["Wall Inset Sizes:"]]></AVal>
				<AVal Row="15"><![CDATA["Left Overhang"]]></AVal>
				<AVal Row="16"><![CDATA["Right Overhang"]]></AVal>
				<AVal Row="17"><![CDATA["Double Splayed Reveal - Reveal Geometry"]]></AVal>
				<AVal Row="18"><![CDATA["Double Splayed Reveal - Mounting Frame Attributes"]]></AVal>
				<AVal Row="19"><![CDATA["Outside Splayed Reveal - Reveal Geometry"]]></AVal>
				<AVal Row="20"><![CDATA["Outside Splayed Reveal - Mounting Frame Attributes"]]></AVal>
				<AVal Row="21"><![CDATA["Mounting Frame"]]></AVal>
				<AVal Row="22"><![CDATA["Frame Thickness"]]></AVal>
				<AVal Row="23"><![CDATA["Surface"]]></AVal>
				<AVal Row="24"><![CDATA["Cut Line Pen"]]></AVal>
				<AVal Row="25"><![CDATA["Uncut Line Pen"]]></AVal>
				<AVal Row="26"><![CDATA["Cut Fill Type"]]></AVal>
				<AVal Row="27"><![CDATA["Fill Pen"]]></AVal>
				<AVal Row="28"><![CDATA["Fill Background Pen"]]></AVal>
				<AVal Row="29"><![CDATA["Angle and Depth"]]></AVal>
				<AVal Row="30"><![CDATA["Width and Depth"]]></AVal>
				<AVal Row="31"><![CDATA["Set Jamb Depth on"]]></AVal>
				<AVal Row="32"><![CDATA["Bottom Reveal"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stRevealUI">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="4" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
				<AVal Row="2"><![CDATA[""]]></AVal>
				<AVal Row="3"><![CDATA[""]]></AVal>
				<AVal Row="4"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stRevealTypes">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="10" SecondDimension="0">
				<AVal Row="1"><![CDATA["No Reveal - Edge"]]></AVal>
				<AVal Row="2"><![CDATA["No Reveal"]]></AVal>
				<AVal Row="3"><![CDATA["Reveal"]]></AVal>
				<AVal Row="4"><![CDATA["Negative Reveal"]]></AVal>
				<AVal Row="5"><![CDATA["Slanted Reveal"]]></AVal>
				<AVal Row="6"><![CDATA["Splayed Reveal"]]></AVal>
				<AVal Row="7"><![CDATA["Historic Reveal"]]></AVal>
				<AVal Row="8"><![CDATA["Custom Reveal"]]></AVal>
				<AVal Row="9"><![CDATA["Double Splayed Reveal"]]></AVal>
				<AVal Row="10"><![CDATA["Outside Splayed Reveal"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stRevealTypesBottom">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="4" SecondDimension="0">
				<AVal Row="1"><![CDATA["Uniform"]]></AVal>
				<AVal Row="2"><![CDATA["No Reveal"]]></AVal>
				<AVal Row="3"><![CDATA["Reveal"]]></AVal>
				<AVal Row="4"><![CDATA["Negative Reveal"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stSetRevealSide">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="2" SecondDimension="0">
				<AVal Row="1"><![CDATA["Inside"]]></AVal>
				<AVal Row="2"><![CDATA["Outside"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stRevealAngleEditBy">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="2" SecondDimension="0">
				<AVal Row="1"><![CDATA["Angle and Depth"]]></AVal>
				<AVal Row="2"><![CDATA["Width and Depth"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stParapetSize">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="3" SecondDimension="0">
				<AVal Row="1"><![CDATA["Automatic"]]></AVal>
				<AVal Row="2"><![CDATA["Symmetric"]]></AVal>
				<AVal Row="3"><![CDATA["Asymmetric"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stParapetBottom">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="2" SecondDimension="0">
				<AVal Row="1"><![CDATA["Current Story"]]></AVal>
				<AVal Row="2"><![CDATA["Wall Base"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stRevealClusureUITips">
			<Description><![CDATA[""]]></Description>
			<ArrayValues FirstDimension="43" SecondDimension="0">
				<AVal Row="1"><![CDATA["Reveal Depth"]]></AVal>
				<AVal Row="2"><![CDATA["Jamb Depth Side 2"]]></AVal>
				<AVal Row="3"><![CDATA["Jamb Depth Side 1"]]></AVal>
				<AVal Row="4"><![CDATA["Inner Jamb Depth Side 2"]]></AVal>
				<AVal Row="5"><![CDATA["Inner Jamb Depth Side 1"]]></AVal>
				<AVal Row="6"><![CDATA["Head Depth"]]></AVal>
				<AVal Row="7"><![CDATA["Sill Depth"]]></AVal>
				<AVal Row="8"><![CDATA["Inner Head Depth"]]></AVal>
				<AVal Row="9"><![CDATA["Inner Sill Depth"]]></AVal>
				<AVal Row="10"><![CDATA["Angle Side 2"]]></AVal>
				<AVal Row="11"><![CDATA["Angle Side"]]></AVal>
				<AVal Row="12"><![CDATA["Upper Side Angle"]]></AVal>
				<AVal Row="13"><![CDATA["Bottom Side Angle"]]></AVal>
				<AVal Row="14"><![CDATA["Outer Angle Left Side"]]></AVal>
				<AVal Row="15"><![CDATA["Outer Angle Right Side"]]></AVal>
				<AVal Row="16"><![CDATA["Outer Angle Upper Side"]]></AVal>
				<AVal Row="17"><![CDATA["Outer Angle Bottom Side"]]></AVal>
				<AVal Row="18"><![CDATA["Outer Jamb Depth"]]></AVal>
				<AVal Row="19"><![CDATA["Mounting Frame Width Left"]]></AVal>
				<AVal Row="20"><![CDATA["Mounting Frame Width Right"]]></AVal>
				<AVal Row="21"><![CDATA["Mounting Frame Width Upper"]]></AVal>
				<AVal Row="22"><![CDATA["Mounting Frame Width Bottom"]]></AVal>
				<AVal Row="23"><![CDATA["Mounting Frame Thickness"]]></AVal>
				<AVal Row="24"><![CDATA["Left Side Splay Width"]]></AVal>
				<AVal Row="25"><![CDATA["Right Side Splay Width"]]></AVal>
				<AVal Row="26"><![CDATA["Upper Side Splay Width"]]></AVal>
				<AVal Row="27"><![CDATA["Bottom Side Splay Width"]]></AVal>
				<AVal Row="28"><![CDATA["Outer Splay Width Left Side"]]></AVal>
				<AVal Row="29"><![CDATA["Outer Splay Width Right Side"]]></AVal>
				<AVal Row="30"><![CDATA["Outer Splay Width Upper Side"]]></AVal>
				<AVal Row="31"><![CDATA["Outer Splay Width Bottom Side"]]></AVal>
				<AVal Row="32"><![CDATA["Lower Jamb Depth Side 2"]]></AVal>
				<AVal Row="33"><![CDATA["Lower Jamb Depth Side 1"]]></AVal>
				<AVal Row="34"><![CDATA["Sill Depth Side 2"]]></AVal>
				<AVal Row="35"><![CDATA["Sill Depth Side 1"]]></AVal>
				<AVal Row="36"><![CDATA["Inner Lower Jamb Depth Side 2"]]></AVal>
				<AVal Row="37"><![CDATA["Inner Lower Jamb Depth Side 1"]]></AVal>
				<AVal Row="38"><![CDATA["Inner Sill Depth Side 2"]]></AVal>
				<AVal Row="39"><![CDATA["Inner Sill Depth Side 1"]]></AVal>
				<AVal Row="40"><![CDATA["Jamb Depth"]]></AVal>
				<AVal Row="41"><![CDATA["Inner Jamb Depth"]]></AVal>
				<AVal Row="42"><![CDATA["Jamb / Head Depth"]]></AVal>
				<AVal Row="43"><![CDATA["Inner Jamb / Head Depth"]]></AVal>
			</ArrayValues>
		</String>
		<Length Name="bBoardElevUsa">
			<Description><![CDATA["USA board elevation"]]></Description>
			<Value>0</Value>
		</Length>

		<!-- gs_transom_display: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="gs_transom_display">
			<Description><![CDATA["Display as Transom"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<PenColor Name="gs_transom_display_pen">
			<Description><![CDATA["Wall End Line Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<LineType Name="gs_transom_display_linetype">
			<Description><![CDATA["Wall End Line Line Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</LineType>
		<Boolean Name="bShowAddHotspotsForIS">
			<Description><![CDATA["Show Additional Hotspots For IS"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Integer Name="bDoorCHE">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Integer>
		<Boolean Name="bForceUniformBottomReveal">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>
	</Parameters>
</ParamSection>

</Symbol>
